
fat_mci_demo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00009824  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000004c  40000000  00009824  00018000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006a8  4000004c  00009870  0001804c  2**2
                  ALLOC
  3 .bss.takeSnapshot 00000004  400006f4  00009f18  0001804c  2**2
                  ALLOC
  4 .bss.startRecording 00000004  400006f8  00009f1c  0001804c  2**2
                  ALLOC
  5 .bss.stopRecording 00000004  400006fc  00009f20  0001804c  2**2
                  ALLOC
  6 .bss.FatFs    00000004  40000700  00009f24  0001804c  2**2
                  ALLOC
  7 .bss.fsid     00000002  40000704  00009f28  0001804c  2**1
                  ALLOC
  8 .bss.Timer2   00000004  40000708  00009f2c  0001804c  2**2
                  ALLOC
  9 .bss.CardType 00000004  4000070c  00009f30  0001804c  2**2
                  ALLOC
 10 .bss.csd      00000010  40000710  00009f34  0001804c  2**0
                  ALLOC
 11 .bss.sd_status 00000010  40000720  00009f44  0001804c  2**0
                  ALLOC
 12 .bss.MCI_DataErrorProcess_count 00000004  40000730  00009f54  0001804c  2**2
                  ALLOC
 13 .bss.MCI_DATA_END_InterruptService_count 00000004  40000734  00009f58  0001804c  2**2
                  ALLOC
 14 .bss.MCI_FIFOInterruptService_count 00000004  40000738  00009f5c  0001804c  2**2
                  ALLOC
 15 .bss.MCI_CmdProcess_count 00000004  4000073c  00009f60  0001804c  2**2
                  ALLOC
 16 .bss.CmdCRCErrCount 00000004  40000740  00009f64  0001804c  2**2
                  ALLOC
 17 .bss.CmdTimeoutErrCount 00000004  40000744  00009f68  0001804c  2**2
                  ALLOC
 18 .bss.CmdRespEndCount 00000004  40000748  00009f6c  0001804c  2**2
                  ALLOC
 19 .bss.CmdSentCount 00000004  4000074c  00009f70  0001804c  2**2
                  ALLOC
 20 .bss.CmdActiveCount 00000004  40000750  00009f74  0001804c  2**2
                  ALLOC
 21 .bss.DataCRCErrCount 00000004  40000754  00009f78  0001804c  2**2
                  ALLOC
 22 .bss.DataTimeoutErrCount 00000004  40000758  00009f7c  0001804c  2**2
                  ALLOC
 23 .bss.DataTxUnderrunErrCount 00000004  4000075c  00009f80  0001804c  2**2
                  ALLOC
 24 .bss.DataRxOverrunErrCount 00000004  40000760  00009f84  0001804c  2**2
                  ALLOC
 25 .bss.DataStartbitErrCount 00000004  40000764  00009f88  0001804c  2**2
                  ALLOC
 26 .bss.DataEndCount 00000004  40000768  00009f8c  0001804c  2**2
                  ALLOC
 27 .bss.DataBlockEndCount 00000004  4000076c  00009f90  0001804c  2**2
                  ALLOC
 28 .bss.MCI_Block_End_Flag 00000004  40000770  00009f94  0001804c  2**2
                  ALLOC
 29 .bss.DataTxActiveCount 00000004  40000774  00009f98  0001804c  2**2
                  ALLOC
 30 .bss.DataRxActiveCount 00000004  40000778  00009f9c  0001804c  2**2
                  ALLOC
 31 .bss.DataFIFOCount 00000004  4000077c  00009fa0  0001804c  2**2
                  ALLOC
 32 .bss.SDStatRead 00000004  40000780  00009fa4  0001804c  2**2
                  ALLOC
 33 .bss.DMAErrCount.1312 00000004  40000784  00009fa8  0001804c  2**2
                  ALLOC
 34 .bss.DMATCCount.1311 00000004  40000788  00009fac  0001804c  2**2
                  ALLOC
 35 .bss.TxCounter 00000004  4000078c  00009fb0  0001804c  2**2
                  ALLOC
 36 .bss.recvI    00000004  40000790  00009fb4  0001804c  2**2
                  ALLOC
 37 .bss.AckCounter 00000001  40000794  00009fb8  0001804c  2**0
                  ALLOC
 38 .bss.global   00000004  40000798  00009fbc  0001804c  2**2
                  ALLOC
 39 .stack        00000800  40000800  0000a024  0001804c  2**0
                  ALLOC
 40 .comment      0000017a  00000000  00000000  0001804c  2**0
                  CONTENTS, READONLY
 41 .debug_aranges 000007a0  00000000  00000000  000181c8  2**3
                  CONTENTS, READONLY, DEBUGGING
 42 .debug_pubnames 00000d1e  00000000  00000000  00018968  2**0
                  CONTENTS, READONLY, DEBUGGING
 43 .debug_info   00004dc7  00000000  00000000  00019686  2**0
                  CONTENTS, READONLY, DEBUGGING
 44 .debug_abbrev 0000140b  00000000  00000000  0001e44d  2**0
                  CONTENTS, READONLY, DEBUGGING
 45 .debug_line   00002215  00000000  00000000  0001f858  2**0
                  CONTENTS, READONLY, DEBUGGING
 46 .debug_frame  0000166c  00000000  00000000  00021a70  2**2
                  CONTENTS, READONLY, DEBUGGING
 47 .debug_str    00001476  00000000  00000000  000230dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 48 .debug_loc    00001fb1  00000000  00000000  00024552  2**0
                  CONTENTS, READONLY, DEBUGGING
 49 .ARM.attributes 00000010  00000000  00000000  00026503  2**0
                  CONTENTS, READONLY
 50 .debug_ranges 00000678  00000000  00000000  00026513  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_boot>:
_boot:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
       0:	ea000012 	b	50 <_mainCRTStartup>
        ldr   pc,_undf                  // undefined - _undf
       4:	e59ff014 	ldr	pc, [pc, #20]	; 20 <_undf>
        ldr   pc,_swi                   // SWI - _swi
       8:	e59ff014 	ldr	pc, [pc, #20]	; 24 <_swi>
        ldr   pc,_pabt                  // program abort - _pabt
       c:	e59ff014 	ldr	pc, [pc, #20]	; 28 <_pabt>
        ldr   pc,_dabt                  // data abort - _dabt
      10:	e59ff014 	ldr	pc, [pc, #20]	; 2c <_dabt>
        nop                             // reserved
      14:	e1a00000 	nop			(mov r0,r0)
        ldr   pc,[pc,#-0x120]           // IRQ - read the VIC
      18:	e51ff120 	ldr	pc, [pc, #-288]	; ffffff00 <_end+0xbfffef00>
        ldr   pc,_fiq                   // FIQ - _fiq
      1c:	e59ff010 	ldr	pc, [pc, #16]	; 34 <_fiq>

00000020 <_undf>:
      20:	00000038 	.word	0x00000038

00000024 <_swi>:
      24:	0000003c 	.word	0x0000003c

00000028 <_pabt>:
      28:	00000040 	.word	0x00000040

0000002c <_dabt>:
      2c:	00000044 	.word	0x00000044

00000030 <_irq>:
      30:	00000048 	.word	0x00000048

00000034 <_fiq>:
      34:	0000004c 	.word	0x0000004c

00000038 <__undf>:
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
      38:	eafffffe 	b	38 <__undf>

0000003c <__swi>:
__swi:  b     .                         // SWI
      3c:	eafffffe 	b	3c <__swi>

00000040 <__pabt>:
__pabt: b     .                         // program abort
      40:	eafffffe 	b	40 <__pabt>

00000044 <__dabt>:
__dabt: b     .                         // data abort
      44:	eafffffe 	b	44 <__dabt>

00000048 <__irq>:
__irq:  b     .                         // IRQ
      48:	eafffffe 	b	48 <__irq>

0000004c <__fiq>:
__fiq:  b     .                         // FIQ
      4c:	eafffffe 	b	4c <__fiq>

00000050 <_mainCRTStartup>:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack
      50:	e59f00c0 	ldr	r0, [pc, #192]	; 118 <_reset+0x4>
        msr   CPSR_c,#MODE_UND|I_BIT|F_BIT // Undefined Instruction Mode
      54:	e321f0db 	msr	CPSR_c, #219	; 0xdb
        mov   sp,r0
      58:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#UND_STACK_SIZE
      5c:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_ABT|I_BIT|F_BIT // Abort Mode
      60:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
        mov   sp,r0
      64:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#ABT_STACK_SIZE
      68:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_FIQ|I_BIT|F_BIT // FIQ Mode
      6c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
        mov   sp,r0
      70:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#FIQ_STACK_SIZE
      74:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_IRQ|I_BIT|F_BIT // IRQ Mode
      78:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
        mov   sp,r0
      7c:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#IRQ_STACK_SIZE
      80:	e2400080 	sub	r0, r0, #128	; 0x80
        msr   CPSR_c,#MODE_SVC|I_BIT|F_BIT // Supervisor Mode
      84:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
        mov   sp,r0
      88:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#SVC_STACK_SIZE
      8c:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_SYS|I_BIT|F_BIT // System Mode
      90:	e321f0df 	msr	CPSR_c, #223	; 0xdf
        mov   sp,r0
      94:	e1a0d000 	mov	sp, r0

// Clear .bss
// ----------
        mov   r0,#0                     // get a zero
      98:	e3a00000 	mov	r0, #0	; 0x0
        ldr   r1,=__bss_start           // -> bss start
      9c:	e59f1078 	ldr	r1, [pc, #120]	; 11c <_reset+0x8>
        ldr   r2,=__bss_end__           // -> bss end
      a0:	e59f2078 	ldr	r2, [pc, #120]	; 120 <_reset+0xc>
2:      cmp   r1,r2                     // check if data to clear
      a4:	e1510002 	cmp	r1, r2
        strlo r0,[r1],#4                // clear 4 bytes
      a8:	34810004 	strcc	r0, [r1], #4
        blo   2b                        // loop until done
      ac:	3afffffc 	bcc	a4 <IRQ_STACK_SIZE+0x24>

// Copy initialized data to its execution address in RAM
// -----------------------------------------------------
#ifdef ROM_RUN
        ldr   r1,=_etext                // -> ROM data start
      b0:	e59f106c 	ldr	r1, [pc, #108]	; 124 <_reset+0x10>
        ldr   r2,=_data                 // -> data start
      b4:	e59f206c 	ldr	r2, [pc, #108]	; 128 <_reset+0x14>
        ldr   r3,=_edata                // -> end of data
      b8:	e59f306c 	ldr	r3, [pc, #108]	; 12c <_reset+0x18>
1:      cmp   r2,r3                     // check if data to move
      bc:	e1520003 	cmp	r2, r3
        ldrlo r0,[r1],#4                // copy it
      c0:	34910004 	ldrcc	r0, [r1], #4
        strlo r0,[r2],#4
      c4:	34820004 	strcc	r0, [r2], #4
        blo   1b                        // loop until done
      c8:	3afffffb 	bcc	bc <IRQ_STACK_SIZE+0x3c>
   Call C++ constructors (for objects in "global scope")
   ctor loop added by Martin Thomas 4/2005 
   based on a Anglia Design example-application for ST ARM
*/

		LDR 	r0, =__ctors_start__
      cc:	e59f005c 	ldr	r0, [pc, #92]	; 130 <_reset+0x1c>
		LDR 	r1, =__ctors_end__
      d0:	e59f105c 	ldr	r1, [pc, #92]	; 134 <_reset+0x20>

000000d4 <ctor_loop>:
ctor_loop:
		CMP 	r0, r1
      d4:	e1500001 	.word	0xe1500001
		BEQ 	ctor_end
      d8:	0a000005 	.word	0x0a000005
		LDR 	r2, [r0], #4
      dc:	e4902004 	.word	0xe4902004
		STMFD 	sp!, {r0-r1}
      e0:	e92d0003 	.word	0xe92d0003
		MOV 	lr, pc
      e4:	e1a0e00f 	.word	0xe1a0e00f
		MOV 	pc, r2
      e8:	e1a0f002 	.word	0xe1a0f002
		LDMFD 	sp!, {r0-r1}
      ec:	e8bd0003 	.word	0xe8bd0003
		B 		ctor_loop
      f0:	eafffff7 	.word	0xeafffff7

000000f4 <ctor_end>:
ctor_end:

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
      f4:	e3a00000 	.word	0xe3a00000
        mov   r1,r0
      f8:	e1a01000 	.word	0xe1a01000
        mov   r2,r0
      fc:	e1a02000 	.word	0xe1a02000
        mov   fp,r0                     // null frame pointer
     100:	e1a0b000 	.word	0xe1a0b000
        mov   r7,r0                     // null frame pointer for thumb
     104:	e1a07000 	.word	0xe1a07000
        ldr   r10,=main
     108:	e59fa028 	.word	0xe59fa028
        mov   lr,pc
     10c:	e1a0e00f 	.word	0xe1a0e00f

/* Enter the C code, use BX instruction so as to never return */
/* use BLX (?) main if you want to use c++ destructors below */

        bx    r10                       // enter main()
     110:	e12fff1a 	.word	0xe12fff1a

00000114 <_reset>:
        ldr   r0,=(1<<23)               // P23
        str   r0,[r1,#PIO_PER_OFF]      // make sure pin is contolled by PIO
        str   r0,[r1,#PIO_CODR_OFF]     // set the pin low
        str   r0,[r1,#PIO_OER_OFF]      // make it an output
#endif
        b     .                         // loop until reset
     114:	eafffffe 	.word	0xeafffffe
     118:	40001000 	.word	0x40001000
     11c:	4000004c 	.word	0x4000004c
     120:	4000079c 	.word	0x4000079c
     124:	00009824 	.word	0x00009824
     128:	40000000 	.word	0x40000000
     12c:	4000004c 	.word	0x4000004c
     130:	00009824 	.word	0x00009824
     134:	00009824 	.word	0x00009824
     138:	00000368 	.word	0x00000368

0000013c <SRAMInit>:
//Global flags that are set by the external interrupt
int takeSnapshot=0;
int startRecording=0;
int stopRecording=0;

void SRAMInit(){
     13c:	e1a0c00d 	mov	ip, sp
     140:	e92dd800 	push	{fp, ip, lr, pc}
     144:	e24cb004 	sub	fp, ip, #4	; 0x4
     148:	e24dd004 	sub	sp, sp, #4	; 0x4
	  PINSEL6 = 0x55555555;
     14c:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
     150:	e282290b 	add	r2, r2, #180224	; 0x2c000
     154:	e2822018 	add	r2, r2, #24	; 0x18
     158:	e3a03c55 	mov	r3, #21760	; 0x5500
     15c:	e2833055 	add	r3, r3, #85	; 0x55
     160:	e1833803 	orr	r3, r3, r3, lsl #16
     164:	e5823000 	str	r3, [r2]
	  PINSEL8 = PINSEL8 & 0x00000000;
     168:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
     16c:	e283390b 	add	r3, r3, #180224	; 0x2c000
     170:	e2833020 	add	r3, r3, #32	; 0x20
     174:	e5933000 	ldr	r3, [r3]
     178:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
     17c:	e283390b 	add	r3, r3, #180224	; 0x2c000
     180:	e2833020 	add	r3, r3, #32	; 0x20
     184:	e3a02000 	mov	r2, #0	; 0x0
     188:	e5832000 	str	r2, [r3]
	  PINSEL8 = PINSEL8 | 0x55555555; 	  //Set all 32:0 pins to 01 for address P4[0] - P4[15]
     18c:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
     190:	e282290b 	add	r2, r2, #180224	; 0x2c000
     194:	e2822020 	add	r2, r2, #32	; 0x20
     198:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
     19c:	e283390b 	add	r3, r3, #180224	; 0x2c000
     1a0:	e2833020 	add	r3, r3, #32	; 0x20
     1a4:	e5933000 	ldr	r3, [r3]
     1a8:	e3833455 	orr	r3, r3, #1426063360	; 0x55000000
     1ac:	e3833855 	orr	r3, r3, #5570560	; 0x550000
     1b0:	e3833c55 	orr	r3, r3, #21760	; 0x5500
     1b4:	e3833055 	orr	r3, r3, #85	; 0x55
     1b8:	e5823000 	str	r3, [r2]

	  PINSEL9 = PINSEL9 & 0x0F00FF00;	  //Set 7:0 pins to 01 for address P4[16] - P4[19]
     1bc:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
     1c0:	e282290b 	add	r2, r2, #180224	; 0x2c000
     1c4:	e2822024 	add	r2, r2, #36	; 0x24
     1c8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
     1cc:	e283390b 	add	r3, r3, #180224	; 0x2c000
     1d0:	e2833024 	add	r3, r3, #36	; 0x24
     1d4:	e5933000 	ldr	r3, [r3]
     1d8:	e3c3320f 	bic	r3, r3, #-268435456	; 0xf0000000
     1dc:	e3c338ff 	bic	r3, r3, #16711680	; 0xff0000
     1e0:	e3c330ff 	bic	r3, r3, #255	; 0xff
     1e4:	e5823000 	str	r3, [r2]
	  PINSEL9 = PINSEL9 | 0x50550055;
     1e8:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
     1ec:	e282290b 	add	r2, r2, #180224	; 0x2c000
     1f0:	e2822024 	add	r2, r2, #36	; 0x24
     1f4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
     1f8:	e283390b 	add	r3, r3, #180224	; 0x2c000
     1fc:	e2833024 	add	r3, r3, #36	; 0x24
     200:	e5933000 	ldr	r3, [r3]
     204:	e3833205 	orr	r3, r3, #1342177280	; 0x50000000
     208:	e3833855 	orr	r3, r3, #5570560	; 0x550000
     20c:	e3833055 	orr	r3, r3, #85	; 0x55
     210:	e5823000 	str	r3, [r2]

	  EMC_CTRL &= ~2;					// select normal memory map (enables CS0 operation)
     214:	e3a02482 	mov	r2, #-2113929216	; 0x82000000
     218:	e1a02542 	asr	r2, r2, #10
     21c:	e3a03482 	mov	r3, #-2113929216	; 0x82000000
     220:	e1a03543 	asr	r3, r3, #10
     224:	e5933000 	ldr	r3, [r3]
     228:	e3c33002 	bic	r3, r3, #2	; 0x2
     22c:	e5823000 	str	r3, [r2]
	  EMC_STA_CFG0 = 0x81;
     230:	e3a034ff 	mov	r3, #-16777216	; 0xff000000
     234:	e283360e 	add	r3, r3, #14680064	; 0xe00000
     238:	e2833c82 	add	r3, r3, #33280	; 0x8200
     23c:	e3a02081 	mov	r2, #129	; 0x81
     240:	e5832000 	str	r2, [r3]
	  EMC_STA_WAITWEN0 = 0x0;			// Keil had 2
     244:	e3a0324f 	mov	r3, #-268435452	; 0xf0000004
     248:	e28336fe 	add	r3, r3, #266338304	; 0xfe00000
     24c:	e2833c82 	add	r3, r3, #33280	; 0x8200
     250:	e3a02000 	mov	r2, #0	; 0x0
     254:	e5832000 	str	r2, [r3]
	  EMC_STA_WAITOEN0 = 0x0;			//          3
     258:	e3a0328f 	mov	r3, #-268435448	; 0xf0000008
     25c:	e28336fe 	add	r3, r3, #266338304	; 0xfe00000
     260:	e2833c82 	add	r3, r3, #33280	; 0x8200
     264:	e3a02000 	mov	r2, #0	; 0x0
     268:	e5832000 	str	r2, [r3]
	  EMC_STA_WAITRD0 = 0x1;			//          2
     26c:	e3a032cf 	mov	r3, #-268435444	; 0xf000000c
     270:	e28336fe 	add	r3, r3, #266338304	; 0xfe00000
     274:	e2833c82 	add	r3, r3, #33280	; 0x8200
     278:	e3a02001 	mov	r2, #1	; 0x1
     27c:	e5832000 	str	r2, [r3]
	  EMC_STA_WAITPAGE0 = 0x2;
     280:	e59f2020 	ldr	r2, [pc, #32]	; 2a8 <SRAMInit+0x16c>
     284:	e3a03002 	mov	r3, #2	; 0x2
     288:	e5823000 	str	r3, [r2]
	  EMC_STA_WAITWR0 = 0x0;			//          2
     28c:	e59f2018 	ldr	r2, [pc, #24]	; 2ac <SRAMInit+0x170>
     290:	e3a03000 	mov	r3, #0	; 0x0
     294:	e5823000 	str	r3, [r2]
	  EMC_STA_WAITTURN0 = 0x2;
     298:	e59f2010 	ldr	r2, [pc, #16]	; 2b0 <SRAMInit+0x174>
     29c:	e3a03002 	mov	r3, #2	; 0x2
     2a0:	e5823000 	str	r3, [r2]
}
     2a4:	e89da808 	ldm	sp, {r3, fp, sp, pc}
     2a8:	ffe08210 	.word	0xffe08210
     2ac:	ffe08214 	.word	0xffe08214
     2b0:	ffe08218 	.word	0xffe08218

000002b4 <IoInit>:


static
void IoInit (void)
{
     2b4:	e1a0c00d 	mov	ip, sp
     2b8:	e92dd800 	push	{fp, ip, lr, pc}
     2bc:	e24cb004 	sub	fp, ip, #4	; 0x4
	systemInit();
     2c0:	eb0001a4 	bl	958 <systemInit>
	uart0Init(B115200 ,UART_8N1 , UART_FIFO_8);
     2c4:	e3a0000a 	mov	r0, #10	; 0xa
     2c8:	e3a01003 	mov	r1, #3	; 0x3
     2cc:	e3a02081 	mov	r2, #129	; 0x81
     2d0:	eb0001d0 	bl	a18 <uart0Init>
	SPIInit();		/* initialize SPI 0 */
     2d4:	eb001eae 	bl	7d94 <SPIInit>
	setupCamera();
     2d8:	eb002271 	bl	8ca4 <setupCamera>
	init_VIC();
     2dc:	eb000217 	bl	b40 <init_VIC>
	EINTInit();
     2e0:	eb002331 	bl	8fac <EINTInit>
	SRAMInit();
     2e4:	ebffff94 	bl	13c <SRAMInit>
	initSDCard();
     2e8:	eb001e48 	bl	7c10 <initSDCard>
	enable_interrupt();
     2ec:	eb000000 	bl	2f4 <enable_interrupt>
}
     2f0:	e89da800 	ldm	sp, {fp, sp, pc}

000002f4 <enable_interrupt>:
}
#endif

/* enable interrupts */
static inline void enable_interrupt(void)
{
     2f4:	e1a0c00d 	mov	ip, sp
     2f8:	e92dd800 	push	{fp, ip, lr, pc}
     2fc:	e24cb004 	sub	fp, ip, #4	; 0x4
     300:	e24dd004 	sub	sp, sp, #4	; 0x4
	uint32_t temp;
	temp = __get_CPSR();
     304:	eb000006 	bl	324 <__get_CPSR>
     308:	e1a03000 	mov	r3, r0
     30c:	e50b3010 	str	r3, [fp, #-16]
	__set_CPSR(temp & ~0xC0);
     310:	e51b3010 	ldr	r3, [fp, #-16]
     314:	e3c330c0 	bic	r3, r3, #192	; 0xc0
     318:	e1a00003 	mov	r0, r3
     31c:	eb000009 	bl	348 <__set_CPSR>
}
     320:	e89da808 	ldm	sp, {r3, fp, sp, pc}

00000324 <__get_CPSR>:
#include <stdint.h>
//#include "inttypes.h"

#ifndef __thumb
static inline uint32_t __get_CPSR(void)
{
     324:	e1a0c00d 	mov	ip, sp
     328:	e92dd800 	push	{fp, ip, lr, pc}
     32c:	e24cb004 	sub	fp, ip, #4	; 0x4
     330:	e24dd004 	sub	sp, sp, #4	; 0x4
	uint32_t temp;
	asm volatile ("mrs %0,CPSR":"=r" (temp):) ;
     334:	e10f3000 	mrs	r3, CPSR
     338:	e50b3010 	str	r3, [fp, #-16]
	return temp;
     33c:	e51b3010 	ldr	r3, [fp, #-16]
}
     340:	e1a00003 	mov	r0, r3
     344:	e89da808 	ldm	sp, {r3, fp, sp, pc}

00000348 <__set_CPSR>:

static inline void __set_CPSR(uint32_t save_cpsr)
{
     348:	e1a0c00d 	mov	ip, sp
     34c:	e92dd800 	push	{fp, ip, lr, pc}
     350:	e24cb004 	sub	fp, ip, #4	; 0x4
     354:	e24dd004 	sub	sp, sp, #4	; 0x4
     358:	e50b0010 	str	r0, [fp, #-16]
	asm volatile (" msr CPSR_cxsf,%0"::"r"(save_cpsr) );
     35c:	e51b3010 	ldr	r3, [fp, #-16]
     360:	e12ff003 	msr	CPSR_fsxc, r3
}
     364:	e89da808 	ldm	sp, {r3, fp, sp, pc}

00000368 <main>:

int main (void)
{
     368:	e1a0c00d 	mov	ip, sp
     36c:	e92dd800 	push	{fp, ip, lr, pc}
     370:	e24cb004 	sub	fp, ip, #4	; 0x4
	IoInit();
     374:	ebffffce 	bl	2b4 <IoInit>
	while(1)
	{
		if(takeSnapshot)
     378:	e59f305c 	ldr	r3, [pc, #92]	; 3dc <main+0x74>
     37c:	e5933000 	ldr	r3, [r3]
     380:	e3530000 	cmp	r3, #0	; 0x0
     384:	0a000003 	beq	398 <main+0x30>
		{
			takeSnapshot=0;
     388:	e59f204c 	ldr	r2, [pc, #76]	; 3dc <main+0x74>
     38c:	e3a03000 	mov	r3, #0	; 0x0
     390:	e5823000 	str	r3, [r2]
			takePicture();
     394:	eb002249 	bl	8cc0 <takePicture>
		}
		if(startRecording)
     398:	e59f3040 	ldr	r3, [pc, #64]	; 3e0 <main+0x78>
     39c:	e5933000 	ldr	r3, [r3]
     3a0:	e3530000 	cmp	r3, #0	; 0x0
     3a4:	0a000003 	beq	3b8 <main+0x50>
		{
			startRecording=0;
     3a8:	e59f2030 	ldr	r2, [pc, #48]	; 3e0 <main+0x78>
     3ac:	e3a03000 	mov	r3, #0	; 0x0
     3b0:	e5823000 	str	r3, [r2]
			record();
     3b4:	eb00224b 	bl	8ce8 <record>
		}
		if(stopRecording)
     3b8:	e59f3024 	ldr	r3, [pc, #36]	; 3e4 <main+0x7c>
     3bc:	e5933000 	ldr	r3, [r3]
     3c0:	e3530000 	cmp	r3, #0	; 0x0
     3c4:	0affffeb 	beq	378 <main+0x10>
		{
			stopRecording=0;
     3c8:	e59f2014 	ldr	r2, [pc, #20]	; 3e4 <main+0x7c>
     3cc:	e3a03000 	mov	r3, #0	; 0x0
     3d0:	e5823000 	str	r3, [r2]
			stopRec();
     3d4:	eb00222a 	bl	8c84 <stopRec>
     3d8:	eaffffe6 	b	378 <main+0x10>
     3dc:	400006f4 	.word	0x400006f4
     3e0:	400006f8 	.word	0x400006f8
     3e4:	400006fc 	.word	0x400006fc

000003e8 <xputs>:




void xputs (const char* str)
{
     3e8:	e1a0c00d 	mov	ip, sp
     3ec:	e92dd800 	push	{fp, ip, lr, pc}
     3f0:	e24cb004 	sub	fp, ip, #4	; 0x4
     3f4:	e24dd004 	sub	sp, sp, #4	; 0x4
     3f8:	e50b0010 	str	r0, [fp, #-16]
     3fc:	ea000007 	b	420 <xputs+0x38>
	while (*str)
		xputc(*str++);
     400:	e51b3010 	ldr	r3, [fp, #-16]
     404:	e5d33000 	ldrb	r3, [r3]
     408:	e1a02003 	mov	r2, r3
     40c:	e51b3010 	ldr	r3, [fp, #-16]
     410:	e2833001 	add	r3, r3, #1	; 0x1
     414:	e50b3010 	str	r3, [fp, #-16]
     418:	e1a00002 	mov	r0, r2
     41c:	eb0001b2 	bl	aec <uart_put>



void xputs (const char* str)
{
	while (*str)
     420:	e51b3010 	ldr	r3, [fp, #-16]
     424:	e5d33000 	ldrb	r3, [r3]
     428:	e3530000 	cmp	r3, #0	; 0x0
     42c:	1afffff3 	bne	400 <xputs+0x18>
		xputc(*str++);
}
     430:	e89da808 	ldm	sp, {r3, fp, sp, pc}

00000434 <xitoa>:




void xitoa (signed long val, signed char radix, signed char len)
{
     434:	e1a0c00d 	mov	ip, sp
     438:	e92dd800 	push	{fp, ip, lr, pc}
     43c:	e24cb004 	sub	fp, ip, #4	; 0x4
     440:	e24dd02c 	sub	sp, sp, #44	; 0x2c
     444:	e50b0030 	str	r0, [fp, #-48]
     448:	e1a03001 	mov	r3, r1
     44c:	e54b3034 	strb	r3, [fp, #-52]
     450:	e1a03002 	mov	r3, r2
     454:	e54b3038 	strb	r3, [fp, #-56]
	BYTE c, r, sgn = 0, pad = ' ';
     458:	e3a03000 	mov	r3, #0	; 0x0
     45c:	e54b3013 	strb	r3, [fp, #-19]
     460:	e3a03020 	mov	r3, #32	; 0x20
     464:	e54b3012 	strb	r3, [fp, #-18]
	BYTE s[20], i = 0;
     468:	e3a03000 	mov	r3, #0	; 0x0
     46c:	e54b3011 	strb	r3, [fp, #-17]
	DWORD v;


	if (radix < 0) {
     470:	e15b33d4 	ldrsb	r3, [fp, #-52]
     474:	e3530000 	cmp	r3, #0	; 0x0
     478:	aa00000a 	bge	4a8 <xitoa+0x74>
		radix = -radix;
     47c:	e55b3034 	ldrb	r3, [fp, #-52]
     480:	e2633000 	rsb	r3, r3, #0	; 0x0
     484:	e54b3034 	strb	r3, [fp, #-52]
		if (val < 0) {
     488:	e51b3030 	ldr	r3, [fp, #-48]
     48c:	e3530000 	cmp	r3, #0	; 0x0
     490:	aa000004 	bge	4a8 <xitoa+0x74>
			val = -val;
     494:	e51b3030 	ldr	r3, [fp, #-48]
     498:	e2633000 	rsb	r3, r3, #0	; 0x0
     49c:	e50b3030 	str	r3, [fp, #-48]
			sgn = '-';
     4a0:	e3a0302d 	mov	r3, #45	; 0x2d
     4a4:	e54b3013 	strb	r3, [fp, #-19]
		}
	}
	v = val;
     4a8:	e51b3030 	ldr	r3, [fp, #-48]
     4ac:	e50b3010 	str	r3, [fp, #-16]
	r = radix;
     4b0:	e55b3034 	ldrb	r3, [fp, #-52]
     4b4:	e54b3014 	strb	r3, [fp, #-20]
	if (len < 0) {
     4b8:	e15b33d8 	ldrsb	r3, [fp, #-56]
     4bc:	e3530000 	cmp	r3, #0	; 0x0
     4c0:	aa000004 	bge	4d8 <xitoa+0xa4>
		len = -len;
     4c4:	e55b3038 	ldrb	r3, [fp, #-56]
     4c8:	e2633000 	rsb	r3, r3, #0	; 0x0
     4cc:	e54b3038 	strb	r3, [fp, #-56]
		pad = '0';
     4d0:	e3a03030 	mov	r3, #48	; 0x30
     4d4:	e54b3012 	strb	r3, [fp, #-18]
	}
	if (len > 20) return;
     4d8:	e15b33d8 	ldrsb	r3, [fp, #-56]
     4dc:	e3530014 	cmp	r3, #20	; 0x14
     4e0:	ca00004c 	bgt	618 <xitoa+0x1e4>
	do {
		c = (BYTE)(v % r);
     4e4:	e55b2014 	ldrb	r2, [fp, #-20]
     4e8:	e51b3010 	ldr	r3, [fp, #-16]
     4ec:	e1a00003 	mov	r0, r3
     4f0:	e1a01002 	mov	r1, r2
     4f4:	eb0023da 	bl	9464 <__umodsi3>
     4f8:	e1a03000 	mov	r3, r0
     4fc:	e54b3015 	strb	r3, [fp, #-21]
		if (c >= 10) c += 7;
     500:	e55b3015 	ldrb	r3, [fp, #-21]
     504:	e3530009 	cmp	r3, #9	; 0x9
     508:	9a000002 	bls	518 <xitoa+0xe4>
     50c:	e55b3015 	ldrb	r3, [fp, #-21]
     510:	e2833007 	add	r3, r3, #7	; 0x7
     514:	e54b3015 	strb	r3, [fp, #-21]
		c += '0';
     518:	e55b3015 	ldrb	r3, [fp, #-21]
     51c:	e2833030 	add	r3, r3, #48	; 0x30
     520:	e54b3015 	strb	r3, [fp, #-21]
		s[i++] = c;
     524:	e55b3011 	ldrb	r3, [fp, #-17]
     528:	e3e0201c 	mvn	r2, #28	; 0x1c
     52c:	e24b100c 	sub	r1, fp, #12	; 0xc
     530:	e0813003 	add	r3, r1, r3
     534:	e0832002 	add	r2, r3, r2
     538:	e55b3015 	ldrb	r3, [fp, #-21]
     53c:	e5c23000 	strb	r3, [r2]
     540:	e55b3011 	ldrb	r3, [fp, #-17]
     544:	e2833001 	add	r3, r3, #1	; 0x1
     548:	e54b3011 	strb	r3, [fp, #-17]
		v /= r;
     54c:	e55b3014 	ldrb	r3, [fp, #-20]
     550:	e51b0010 	ldr	r0, [fp, #-16]
     554:	e1a01003 	mov	r1, r3
     558:	eb00237d 	bl	9354 <__aeabi_uidiv>
     55c:	e1a03000 	mov	r3, r0
     560:	e50b3010 	str	r3, [fp, #-16]
	} while (v);
     564:	e51b3010 	ldr	r3, [fp, #-16]
     568:	e3530000 	cmp	r3, #0	; 0x0
     56c:	1affffdc 	bne	4e4 <xitoa+0xb0>
	if (sgn) s[i++] = sgn;
     570:	e55b3013 	ldrb	r3, [fp, #-19]
     574:	e3530000 	cmp	r3, #0	; 0x0
     578:	0a000014 	beq	5d0 <xitoa+0x19c>
     57c:	e55b3011 	ldrb	r3, [fp, #-17]
     580:	e3e0201c 	mvn	r2, #28	; 0x1c
     584:	e24b100c 	sub	r1, fp, #12	; 0xc
     588:	e0813003 	add	r3, r1, r3
     58c:	e0832002 	add	r2, r3, r2
     590:	e55b3013 	ldrb	r3, [fp, #-19]
     594:	e5c23000 	strb	r3, [r2]
     598:	e55b3011 	ldrb	r3, [fp, #-17]
     59c:	e2833001 	add	r3, r3, #1	; 0x1
     5a0:	e54b3011 	strb	r3, [fp, #-17]
     5a4:	ea000009 	b	5d0 <xitoa+0x19c>
	while (i < len)
		s[i++] = pad;
     5a8:	e55b3011 	ldrb	r3, [fp, #-17]
     5ac:	e3e0201c 	mvn	r2, #28	; 0x1c
     5b0:	e24b100c 	sub	r1, fp, #12	; 0xc
     5b4:	e0813003 	add	r3, r1, r3
     5b8:	e0832002 	add	r2, r3, r2
     5bc:	e55b3012 	ldrb	r3, [fp, #-18]
     5c0:	e5c23000 	strb	r3, [r2]
     5c4:	e55b3011 	ldrb	r3, [fp, #-17]
     5c8:	e2833001 	add	r3, r3, #1	; 0x1
     5cc:	e54b3011 	strb	r3, [fp, #-17]
		c += '0';
		s[i++] = c;
		v /= r;
	} while (v);
	if (sgn) s[i++] = sgn;
	while (i < len)
     5d0:	e55b2011 	ldrb	r2, [fp, #-17]
     5d4:	e15b33d8 	ldrsb	r3, [fp, #-56]
     5d8:	e1520003 	cmp	r2, r3
     5dc:	bafffff1 	blt	5a8 <xitoa+0x174>
		s[i++] = pad;
	do
		xputc(s[--i]);
     5e0:	e55b3011 	ldrb	r3, [fp, #-17]
     5e4:	e2433001 	sub	r3, r3, #1	; 0x1
     5e8:	e54b3011 	strb	r3, [fp, #-17]
     5ec:	e55b3011 	ldrb	r3, [fp, #-17]
     5f0:	e3e0201c 	mvn	r2, #28	; 0x1c
     5f4:	e24b100c 	sub	r1, fp, #12	; 0xc
     5f8:	e0813003 	add	r3, r1, r3
     5fc:	e0833002 	add	r3, r3, r2
     600:	e5d33000 	ldrb	r3, [r3]
     604:	e1a00003 	mov	r0, r3
     608:	eb000137 	bl	aec <uart_put>
	while (i);
     60c:	e55b3011 	ldrb	r3, [fp, #-17]
     610:	e3530000 	cmp	r3, #0	; 0x0
     614:	1afffff1 	bne	5e0 <xitoa+0x1ac>
}
     618:	e24bd00c 	sub	sp, fp, #12	; 0xc
     61c:	e89da800 	ldm	sp, {fp, sp, pc}

00000620 <xprintf>:




void xprintf (const char* str, ...)
{
     620:	e1a0c00d 	mov	ip, sp
     624:	e92d000f 	push	{r0, r1, r2, r3}
     628:	e92dd800 	push	{fp, ip, lr, pc}
     62c:	e24cb014 	sub	fp, ip, #20	; 0x14
     630:	e24dd00c 	sub	sp, sp, #12	; 0xc
	va_list arp;
	char d, r, w, s, l;


	va_start(arp, str);
     634:	e28b3008 	add	r3, fp, #8	; 0x8
     638:	e50b3018 	str	r3, [fp, #-24]
     63c:	ea0000b6 	b	91c <STACK_SIZE+0x11c>

	while ((d = *str++) != 0) {
		if (d != '%') {
     640:	e55b3011 	ldrb	r3, [fp, #-17]
     644:	e3530025 	cmp	r3, #37	; 0x25
     648:	0a000003 	beq	65c <xprintf+0x3c>
			xputc(d); continue;
     64c:	e55b3011 	ldrb	r3, [fp, #-17]
     650:	e1a00003 	mov	r0, r3
     654:	eb000124 	bl	aec <uart_put>
     658:	ea0000af 	b	91c <STACK_SIZE+0x11c>
		}
		d = *str++; w = r = s = l = 0;
     65c:	e59b3004 	ldr	r3, [fp, #4]
     660:	e5d33000 	ldrb	r3, [r3]
     664:	e54b3011 	strb	r3, [fp, #-17]
     668:	e59b3004 	ldr	r3, [fp, #4]
     66c:	e2833001 	add	r3, r3, #1	; 0x1
     670:	e58b3004 	str	r3, [fp, #4]
     674:	e3a03000 	mov	r3, #0	; 0x0
     678:	e54b300d 	strb	r3, [fp, #-13]
     67c:	e55b300d 	ldrb	r3, [fp, #-13]
     680:	e54b300e 	strb	r3, [fp, #-14]
     684:	e55b300e 	ldrb	r3, [fp, #-14]
     688:	e54b3010 	strb	r3, [fp, #-16]
     68c:	e55b3010 	ldrb	r3, [fp, #-16]
     690:	e54b300f 	strb	r3, [fp, #-15]
		if (d == '0') {
     694:	e55b3011 	ldrb	r3, [fp, #-17]
     698:	e3530030 	cmp	r3, #48	; 0x30
     69c:	1a00001b 	bne	710 <xprintf+0xf0>
			d = *str++; s = 1;
     6a0:	e59b3004 	ldr	r3, [fp, #4]
     6a4:	e5d33000 	ldrb	r3, [r3]
     6a8:	e54b3011 	strb	r3, [fp, #-17]
     6ac:	e59b3004 	ldr	r3, [fp, #4]
     6b0:	e2833001 	add	r3, r3, #1	; 0x1
     6b4:	e58b3004 	str	r3, [fp, #4]
     6b8:	e3a03001 	mov	r3, #1	; 0x1
     6bc:	e54b300e 	strb	r3, [fp, #-14]
     6c0:	ea000012 	b	710 <xprintf+0xf0>
		}
		while ((d >= '0')&&(d <= '9')) {
			w += w * 10 + (d - '0');
     6c4:	e55b300f 	ldrb	r3, [fp, #-15]
     6c8:	e1a02083 	lsl	r2, r3, #1
     6cc:	e1a03102 	lsl	r3, r2, #2
     6d0:	e0823003 	add	r3, r2, r3
     6d4:	e20320ff 	and	r2, r3, #255	; 0xff
     6d8:	e55b3011 	ldrb	r3, [fp, #-17]
     6dc:	e0823003 	add	r3, r2, r3
     6e0:	e20320ff 	and	r2, r3, #255	; 0xff
     6e4:	e55b300f 	ldrb	r3, [fp, #-15]
     6e8:	e0823003 	add	r3, r2, r3
     6ec:	e20330ff 	and	r3, r3, #255	; 0xff
     6f0:	e2433030 	sub	r3, r3, #48	; 0x30
     6f4:	e54b300f 	strb	r3, [fp, #-15]
			d = *str++;
     6f8:	e59b3004 	ldr	r3, [fp, #4]
     6fc:	e5d33000 	ldrb	r3, [r3]
     700:	e54b3011 	strb	r3, [fp, #-17]
     704:	e59b3004 	ldr	r3, [fp, #4]
     708:	e2833001 	add	r3, r3, #1	; 0x1
     70c:	e58b3004 	str	r3, [fp, #4]
		}
		d = *str++; w = r = s = l = 0;
		if (d == '0') {
			d = *str++; s = 1;
		}
		while ((d >= '0')&&(d <= '9')) {
     710:	e55b3011 	ldrb	r3, [fp, #-17]
     714:	e353002f 	cmp	r3, #47	; 0x2f
     718:	9a000002 	bls	728 <xprintf+0x108>
     71c:	e55b3011 	ldrb	r3, [fp, #-17]
     720:	e3530039 	cmp	r3, #57	; 0x39
     724:	9affffe6 	bls	6c4 <xprintf+0xa4>
			w += w * 10 + (d - '0');
			d = *str++;
		}
		if (s) w = -w;
     728:	e55b300e 	ldrb	r3, [fp, #-14]
     72c:	e3530000 	cmp	r3, #0	; 0x0
     730:	0a000003 	beq	744 <xprintf+0x124>
     734:	e55b300f 	ldrb	r3, [fp, #-15]
     738:	e2633000 	rsb	r3, r3, #0	; 0x0
     73c:	e20330ff 	and	r3, r3, #255	; 0xff
     740:	e54b300f 	strb	r3, [fp, #-15]
		if (d == 'l') {
     744:	e55b3011 	ldrb	r3, [fp, #-17]
     748:	e353006c 	cmp	r3, #108	; 0x6c
     74c:	1a000007 	bne	770 <xprintf+0x150>
			l = 1;
     750:	e3a03001 	mov	r3, #1	; 0x1
     754:	e54b300d 	strb	r3, [fp, #-13]
			d = *str++;
     758:	e59b3004 	ldr	r3, [fp, #4]
     75c:	e5d33000 	ldrb	r3, [r3]
     760:	e54b3011 	strb	r3, [fp, #-17]
     764:	e59b3004 	ldr	r3, [fp, #4]
     768:	e2833001 	add	r3, r3, #1	; 0x1
     76c:	e58b3004 	str	r3, [fp, #4]
		}
		if (!d) break;
     770:	e55b3011 	ldrb	r3, [fp, #-17]
     774:	e3530000 	cmp	r3, #0	; 0x0
     778:	0a000074 	beq	950 <STACK_SIZE+0x150>
		if (d == 's') {
     77c:	e55b3011 	ldrb	r3, [fp, #-17]
     780:	e3530073 	cmp	r3, #115	; 0x73
     784:	1a000007 	bne	7a8 <xprintf+0x188>
			xputs(va_arg(arp, char*));
     788:	e51b2018 	ldr	r2, [fp, #-24]
     78c:	e2823004 	add	r3, r2, #4	; 0x4
     790:	e50b3018 	str	r3, [fp, #-24]
     794:	e1a03002 	mov	r3, r2
     798:	e5933000 	ldr	r3, [r3]
     79c:	e1a00003 	mov	r0, r3
     7a0:	ebffff10 	bl	3e8 <xputs>
     7a4:	ea00005c 	b	91c <STACK_SIZE+0x11c>
			continue;
		}
		if (d == 'c') {
     7a8:	e55b3011 	ldrb	r3, [fp, #-17]
     7ac:	e3530063 	cmp	r3, #99	; 0x63
     7b0:	1a000008 	bne	7d8 <xprintf+0x1b8>
			// xputc(va_arg(arp, char));
			xputc(va_arg(arp, int));
     7b4:	e51b2018 	ldr	r2, [fp, #-24]
     7b8:	e2823004 	add	r3, r2, #4	; 0x4
     7bc:	e50b3018 	str	r3, [fp, #-24]
     7c0:	e1a03002 	mov	r3, r2
     7c4:	e5933000 	ldr	r3, [r3]
     7c8:	e20330ff 	and	r3, r3, #255	; 0xff
     7cc:	e1a00003 	mov	r0, r3
     7d0:	eb0000c5 	bl	aec <uart_put>
     7d4:	ea000050 	b	91c <STACK_SIZE+0x11c>
			continue;
		}
		if (d == 'u') r = 10;
     7d8:	e55b3011 	ldrb	r3, [fp, #-17]
     7dc:	e3530075 	cmp	r3, #117	; 0x75
     7e0:	1a000001 	bne	7ec <xprintf+0x1cc>
     7e4:	e3a0300a 	mov	r3, #10	; 0xa
     7e8:	e54b3010 	strb	r3, [fp, #-16]
		if (d == 'd') r = -10;
     7ec:	e55b3011 	ldrb	r3, [fp, #-17]
     7f0:	e3530064 	cmp	r3, #100	; 0x64
     7f4:	1a000001 	bne	800 <STACK_SIZE>
     7f8:	e3e03009 	mvn	r3, #9	; 0x9
     7fc:	e54b3010 	strb	r3, [fp, #-16]
		if (d == 'X') r = 16;
     800:	e55b3011 	ldrb	r3, [fp, #-17]
     804:	e3530058 	cmp	r3, #88	; 0x58
     808:	1a000001 	bne	814 <STACK_SIZE+0x14>
     80c:	e3a03010 	mov	r3, #16	; 0x10
     810:	e54b3010 	strb	r3, [fp, #-16]
		if (d == 'x') r = 16;
     814:	e55b3011 	ldrb	r3, [fp, #-17]
     818:	e3530078 	cmp	r3, #120	; 0x78
     81c:	1a000001 	bne	828 <STACK_SIZE+0x28>
     820:	e3a03010 	mov	r3, #16	; 0x10
     824:	e54b3010 	strb	r3, [fp, #-16]
		if (d == 'b') r = 2;
     828:	e55b3011 	ldrb	r3, [fp, #-17]
     82c:	e3530062 	cmp	r3, #98	; 0x62
     830:	1a000001 	bne	83c <STACK_SIZE+0x3c>
     834:	e3a03002 	mov	r3, #2	; 0x2
     838:	e54b3010 	strb	r3, [fp, #-16]
		if (!r) break;
     83c:	e55b3010 	ldrb	r3, [fp, #-16]
     840:	e3530000 	cmp	r3, #0	; 0x0
     844:	0a000041 	beq	950 <STACK_SIZE+0x150>
		if (l) {
     848:	e55b300d 	ldrb	r3, [fp, #-13]
     84c:	e3530000 	cmp	r3, #0	; 0x0
     850:	0a00000f 	beq	894 <STACK_SIZE+0x94>
			xitoa((long)va_arg(arp, long), r, w);
     854:	e51b2018 	ldr	r2, [fp, #-24]
     858:	e2823004 	add	r3, r2, #4	; 0x4
     85c:	e50b3018 	str	r3, [fp, #-24]
     860:	e1a03002 	mov	r3, r2
     864:	e5931000 	ldr	r1, [r3]
     868:	e55b3010 	ldrb	r3, [fp, #-16]
     86c:	e1a03c03 	lsl	r3, r3, #24
     870:	e1a02c43 	asr	r2, r3, #24
     874:	e55b300f 	ldrb	r3, [fp, #-15]
     878:	e1a03c03 	lsl	r3, r3, #24
     87c:	e1a03c43 	asr	r3, r3, #24
     880:	e1a00001 	mov	r0, r1
     884:	e1a01002 	mov	r1, r2
     888:	e1a02003 	mov	r2, r3
     88c:	ebfffee8 	bl	434 <xitoa>
     890:	ea000021 	b	91c <STACK_SIZE+0x11c>
		} else {
			if (r > 0)
     894:	e55b3010 	ldrb	r3, [fp, #-16]
     898:	e3530000 	cmp	r3, #0	; 0x0
     89c:	0a00000f 	beq	8e0 <STACK_SIZE+0xe0>
				xitoa((unsigned long)va_arg(arp, int), r, w);
     8a0:	e51b2018 	ldr	r2, [fp, #-24]
     8a4:	e2823004 	add	r3, r2, #4	; 0x4
     8a8:	e50b3018 	str	r3, [fp, #-24]
     8ac:	e1a03002 	mov	r3, r2
     8b0:	e5931000 	ldr	r1, [r3]
     8b4:	e55b3010 	ldrb	r3, [fp, #-16]
     8b8:	e1a03c03 	lsl	r3, r3, #24
     8bc:	e1a02c43 	asr	r2, r3, #24
     8c0:	e55b300f 	ldrb	r3, [fp, #-15]
     8c4:	e1a03c03 	lsl	r3, r3, #24
     8c8:	e1a03c43 	asr	r3, r3, #24
     8cc:	e1a00001 	mov	r0, r1
     8d0:	e1a01002 	mov	r1, r2
     8d4:	e1a02003 	mov	r2, r3
     8d8:	ebfffed5 	bl	434 <xitoa>
     8dc:	ea00000e 	b	91c <STACK_SIZE+0x11c>
			else
				xitoa((long)va_arg(arp, int), r, w);
     8e0:	e51b2018 	ldr	r2, [fp, #-24]
     8e4:	e2823004 	add	r3, r2, #4	; 0x4
     8e8:	e50b3018 	str	r3, [fp, #-24]
     8ec:	e1a03002 	mov	r3, r2
     8f0:	e5931000 	ldr	r1, [r3]
     8f4:	e55b3010 	ldrb	r3, [fp, #-16]
     8f8:	e1a03c03 	lsl	r3, r3, #24
     8fc:	e1a02c43 	asr	r2, r3, #24
     900:	e55b300f 	ldrb	r3, [fp, #-15]
     904:	e1a03c03 	lsl	r3, r3, #24
     908:	e1a03c43 	asr	r3, r3, #24
     90c:	e1a00001 	mov	r0, r1
     910:	e1a01002 	mov	r1, r2
     914:	e1a02003 	mov	r2, r3
     918:	ebfffec5 	bl	434 <xitoa>
	char d, r, w, s, l;


	va_start(arp, str);

	while ((d = *str++) != 0) {
     91c:	e59b3004 	ldr	r3, [fp, #4]
     920:	e5d33000 	ldrb	r3, [r3]
     924:	e54b3011 	strb	r3, [fp, #-17]
     928:	e55b3011 	ldrb	r3, [fp, #-17]
     92c:	e3530000 	cmp	r3, #0	; 0x0
     930:	03a03000 	moveq	r3, #0	; 0x0
     934:	13a03001 	movne	r3, #1	; 0x1
     938:	e20320ff 	and	r2, r3, #255	; 0xff
     93c:	e59b3004 	ldr	r3, [fp, #4]
     940:	e2833001 	add	r3, r3, #1	; 0x1
     944:	e58b3004 	str	r3, [fp, #4]
     948:	e3520000 	cmp	r2, #0	; 0x0
     94c:	1affff3b 	bne	640 <xprintf+0x20>
				xitoa((long)va_arg(arp, int), r, w);
		}
	}

	va_end(arp);
}
     950:	e24bd00c 	sub	sp, fp, #12	; 0xc
     954:	e89da800 	ldm	sp, {fp, sp, pc}

00000958 <systemInit>:

void systemInit(void)
{


	  if ( PLLSTAT & (1 << 25) )	// is PLL "connected"?
     958:	e59f20b0 	ldr	r2, [pc, #176]	; a10 <systemInit+0xb8>
     95c:	e5923088 	ldr	r3, [r2, #136]
*/

#include "LPC24xx.h"

void systemInit(void)
{
     960:	e1a0c00d 	mov	ip, sp


	  if ( PLLSTAT & (1 << 25) )	// is PLL "connected"?
     964:	e3130402 	tst	r3, #33554432	; 0x2000000
*/

#include "LPC24xx.h"

void systemInit(void)
{
     968:	e92dd800 	push	{fp, ip, lr, pc}
     96c:	e24cb004 	sub	fp, ip, #4	; 0x4


	  if ( PLLSTAT & (1 << 25) )	// is PLL "connected"?
     970:	0a000005 	beq	98c <systemInit+0x34>
	  {
		PLLCON = 1;			// Enable PLL, disconnected
     974:	e3a03001 	mov	r3, #1	; 0x1
     978:	e5823080 	str	r3, [r2, #128]
		PLLFEED = 0xaa;
     97c:	e28330a9 	add	r3, r3, #169	; 0xa9
     980:	e582308c 	str	r3, [r2, #140]
		PLLFEED = 0x55;
     984:	e3a03055 	mov	r3, #85	; 0x55
     988:	e582308c 	str	r3, [r2, #140]
	  }

	  PLLCON = 0;			// Disable PLL, disconnected
     98c:	e59f307c 	ldr	r3, [pc, #124]	; a10 <systemInit+0xb8>
	  PLLFEED = 0xaa;
     990:	e3a010aa 	mov	r1, #170	; 0xaa
	  PLLFEED = 0x55;
     994:	e3a00055 	mov	r0, #85	; 0x55
		PLLCON = 1;			// Enable PLL, disconnected
		PLLFEED = 0xaa;
		PLLFEED = 0x55;
	  }

	  PLLCON = 0;			// Disable PLL, disconnected
     998:	e3a02000 	mov	r2, #0	; 0x0
     99c:	e5832080 	str	r2, [r3, #128]
	  PLLFEED = 0xaa;
     9a0:	e583108c 	str	r1, [r3, #140]
	  PLLFEED = 0x55;
     9a4:	e583008c 	str	r0, [r3, #140]

//	  SCS |= 1;				//  Enable fast GPIO access 
//	  while( !(SCS & 0x40) );	// Wait until main OSC is usable

	  CLKSRCSEL = 0;		// pg. 46: select internal OSC, 4MHz, as the PLL clock source
     9a8:	e583210c 	str	r2, [r3, #268]
	  // for RTC OSC, use M = 6750 and N = 1 
	  // for internal 4MHz osc, use M=144 and N=4 

	  //PLLCFG = 143 | (24 << 16);			// pg. 49: Main OSC PLL Setup
	  //PLLCFG = 6750 | (1 << 16);			// pg. 49: RTC OSC PLL Setup 
	  PLLCFG = (144-1) | ((4-1) << 16);		// pg. 49: Internal OSC PLL Setup 
     9ac:	e59f2060 	ldr	r2, [pc, #96]	; a14 <systemInit+0xbc>
     9b0:	e5832084 	str	r2, [r3, #132]
	  PLLFEED = 0xaa;
	  PLLFEED = 0x55;

	  PLLCON = 1;					// pg. 49: Enable PLL, disconnected
     9b4:	e3a02001 	mov	r2, #1	; 0x1
	  // for internal 4MHz osc, use M=144 and N=4 

	  //PLLCFG = 143 | (24 << 16);			// pg. 49: Main OSC PLL Setup
	  //PLLCFG = 6750 | (1 << 16);			// pg. 49: RTC OSC PLL Setup 
	  PLLCFG = (144-1) | ((4-1) << 16);		// pg. 49: Internal OSC PLL Setup 
	  PLLFEED = 0xaa;
     9b8:	e583108c 	str	r1, [r3, #140]
	  PLLFEED = 0x55;
     9bc:	e583008c 	str	r0, [r3, #140]

	  PLLCON = 1;					// pg. 49: Enable PLL, disconnected
     9c0:	e5832080 	str	r2, [r3, #128]
	  PLLFEED = 0xaa;				// pg. 53
	  PLLFEED = 0x55;				// pg. 53

	  //CCLKCFG = CCLKDivValue;	/* Set clock divider */

	  CCLKCFG = (4-1);	/* pg. 57: Set clock divider (meant for Main OSC) */
     9c4:	e2822002 	add	r2, r2, #2	; 0x2
	  PLLCFG = (144-1) | ((4-1) << 16);		// pg. 49: Internal OSC PLL Setup 
	  PLLFEED = 0xaa;
	  PLLFEED = 0x55;

	  PLLCON = 1;					// pg. 49: Enable PLL, disconnected
	  PLLFEED = 0xaa;				// pg. 53
     9c8:	e583108c 	str	r1, [r3, #140]
	  PLLFEED = 0x55;				// pg. 53
     9cc:	e583008c 	str	r0, [r3, #140]

	  //CCLKCFG = CCLKDivValue;	/* Set clock divider */

	  CCLKCFG = (4-1);	/* pg. 57: Set clock divider (meant for Main OSC) */
     9d0:	e5832104 	str	r2, [r3, #260]

	//#if USE_USB
	//  USBCLKCFG = USBCLKDivValue;		/* usbclk = 288 MHz/6 = 48 MHz */
	//#endif

	  while ( ((PLLSTAT & (1 << 26)) == 0) );	// wait for PLL to lock
     9d4:	e1a01003 	mov	r1, r3
     9d8:	e5913088 	ldr	r3, [r1, #136]
     9dc:	e3130301 	tst	r3, #67108864	; 0x4000000
     9e0:	e59f2028 	ldr	r2, [pc, #40]	; a10 <systemInit+0xb8>
     9e4:	0afffffb 	beq	9d8 <systemInit+0x80>
//	  MValue = PLLSTAT & 0x00007FFF;		/* pg. 52: seems to just read in current M value */
//	  NValue = (PLLSTAT & 0x00FF0000) >> 16;		/* pg. 52: seems to just read in current N value */
	  //while ((MValue != 72) && ( NValue != 25) );		/* Main OSC */
	  //while ((MValue != 6750) && ( NValue != 1) );	/* RTC OSC */

	  PLLCON = 3;								// enable and connect PLL
     9e8:	e3a03003 	mov	r3, #3	; 0x3
     9ec:	e5823080 	str	r3, [r2, #128]
	  PLLFEED = 0xaa;
     9f0:	e28330a7 	add	r3, r3, #167	; 0xa7
     9f4:	e582308c 	str	r3, [r2, #140]
	  PLLFEED = 0x55;
     9f8:	e3a03055 	mov	r3, #85	; 0x55
     9fc:	e582308c 	str	r3, [r2, #140]
	  while ( ((PLLSTAT & (1 << 25)) == 0) );	// Check connect status
     a00:	e5923088 	ldr	r3, [r2, #136]
     a04:	e3130402 	tst	r3, #33554432	; 0x2000000
     a08:	0afffffc 	beq	a00 <systemInit+0xa8>
	  return;
	
}
     a0c:	e89da800 	ldm	sp, {fp, sp, pc}
     a10:	e01fc000 	.word	0xe01fc000
     a14:	0003008f 	.word	0x0003008f

00000a18 <uart0Init>:
 *    fmode - see typical fmodes (uart.h)
 *    NOTE: uart0Init(UART_BAUD(9600), UART_8N1, UART_FIFO_8); 
 */

void uart0Init(uint16_t baud, uint8_t mode, uint8_t fmode)
{
     a18:	e1a0c00d 	mov	ip, sp
     a1c:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
	 U0IER = 0x00;             	// disable all interrupts
     a20:	e59f4078 	ldr	r4, [pc, #120]	; aa0 <uart0Init+0x88>
     a24:	e3a03000 	mov	r3, #0	; 0x0
     a28:	e5843004 	str	r3, [r4, #4]
 *    fmode - see typical fmodes (uart.h)
 *    NOTE: uart0Init(UART_BAUD(9600), UART_8N1, UART_FIFO_8); 
 */

void uart0Init(uint16_t baud, uint8_t mode, uint8_t fmode)
{
     a2c:	e24cb004 	sub	fp, ip, #4	; 0x4
	 U0IER = 0x00;             	// disable all interrupts
	 U0IIR = 0x00;             	// clear interrupt ID register
     a30:	e5843008 	str	r3, [r4, #8]
	 U0LSR = 0x00;             	// clear line status register
  	 PCONP = (PCONP | 8); 		// enables uart0 on reset
     a34:	e59fc068 	ldr	ip, [pc, #104]	; aa4 <uart0Init+0x8c>

void uart0Init(uint16_t baud, uint8_t mode, uint8_t fmode)
{
	 U0IER = 0x00;             	// disable all interrupts
	 U0IIR = 0x00;             	// clear interrupt ID register
	 U0LSR = 0x00;             	// clear line status register
     a38:	e5843014 	str	r3, [r4, #20]
  	 PCONP = (PCONP | 8); 		// enables uart0 on reset
     a3c:	e59c30c4 	ldr	r3, [ip, #196]
     a40:	e3833008 	orr	r3, r3, #8	; 0x8
     a44:	e58c30c4 	str	r3, [ip, #196]

	//PCLK_UART0 on reset the value is 00 so pclk = cclk/4 = 18MHz
	// setup Pin Function Select Register (Pin Connect Block) 
	// make sure old values of Bits 0-4 are masked out and
	// set them according to UART0-Pin-Selection
  	PINSEL0 = (PINSEL0 & ~UART0_PINMASK) | UART0_PINSEL;
     a48:	e59f5058 	ldr	r5, [pc, #88]	; aa8 <uart0Init+0x90>
     a4c:	e5953000 	ldr	r3, [r5]
     a50:	e3c330f0 	bic	r3, r3, #240	; 0xf0
     a54:	e3833050 	orr	r3, r3, #80	; 0x50
     a58:	e5853000 	str	r3, [r5]
	PINMODE0= (PINMODE0& ~UART0_PINMASK) | UART0_PINMODE;
     a5c:	e5953040 	ldr	r3, [r5, #64]
 *    fmode - see typical fmodes (uart.h)
 *    NOTE: uart0Init(UART_BAUD(9600), UART_8N1, UART_FIFO_8); 
 */

void uart0Init(uint16_t baud, uint8_t mode, uint8_t fmode)
{
     a60:	e1a00800 	lsl	r0, r0, #16
	//PCLK_UART0 on reset the value is 00 so pclk = cclk/4 = 18MHz
	// setup Pin Function Select Register (Pin Connect Block) 
	// make sure old values of Bits 0-4 are masked out and
	// set them according to UART0-Pin-Selection
  	PINSEL0 = (PINSEL0 & ~UART0_PINMASK) | UART0_PINSEL;
	PINMODE0= (PINMODE0& ~UART0_PINMASK) | UART0_PINMODE;
     a64:	e3c330f0 	bic	r3, r3, #240	; 0xf0
 *    fmode - see typical fmodes (uart.h)
 *    NOTE: uart0Init(UART_BAUD(9600), UART_8N1, UART_FIFO_8); 
 */

void uart0Init(uint16_t baud, uint8_t mode, uint8_t fmode)
{
     a68:	e1a0c820 	lsr	ip, r0, #16
	//PCLK_UART0 on reset the value is 00 so pclk = cclk/4 = 18MHz
	// setup Pin Function Select Register (Pin Connect Block) 
	// make sure old values of Bits 0-4 are masked out and
	// set them according to UART0-Pin-Selection
  	PINSEL0 = (PINSEL0 & ~UART0_PINMASK) | UART0_PINSEL;
	PINMODE0= (PINMODE0& ~UART0_PINMASK) | UART0_PINMODE;
     a6c:	e38330a0 	orr	r3, r3, #160	; 0xa0
     a70:	e5853040 	str	r3, [r5, #64]
 *    fmode - see typical fmodes (uart.h)
 *    NOTE: uart0Init(UART_BAUD(9600), UART_8N1, UART_FIFO_8); 
 */

void uart0Init(uint16_t baud, uint8_t mode, uint8_t fmode)
{
     a74:	e20220ff 	and	r2, r2, #255	; 0xff
  	PINSEL0 = (PINSEL0 & ~UART0_PINMASK) | UART0_PINSEL;
	PINMODE0= (PINMODE0& ~UART0_PINMASK) | UART0_PINMODE;

  	// set the baudrate - DLAB must be set to access DLL/DLM
  	U0LCR = ULCR_DLAB_ENABLE; 	 // set divisor latches (DLAB)
  	U0DLL = (uint8_t)baud;       // set for baud low byte
     a78:	e20cc0ff 	and	ip, ip, #255	; 0xff
  	U0DLM = (uint8_t)(baud >> 8);// set for baud high byte
     a7c:	e1a00c20 	lsr	r0, r0, #24
  
  	// set the number of characters and other
  	// user specified operating parameters
  	// Databits, Parity, Stopbits - Settings in Line Control Register
  	U0LCR = (mode & ~(ULCR_DLAB_ENABLE)); // clear DLAB "on-the-fly"
     a80:	e201107f 	and	r1, r1, #127	; 0x7f
	// set them according to UART0-Pin-Selection
  	PINSEL0 = (PINSEL0 & ~UART0_PINMASK) | UART0_PINSEL;
	PINMODE0= (PINMODE0& ~UART0_PINMASK) | UART0_PINMODE;

  	// set the baudrate - DLAB must be set to access DLL/DLM
  	U0LCR = ULCR_DLAB_ENABLE; 	 // set divisor latches (DLAB)
     a84:	e3a03080 	mov	r3, #128	; 0x80
     a88:	e584300c 	str	r3, [r4, #12]
  	U0DLL = (uint8_t)baud;       // set for baud low byte
     a8c:	e584c000 	str	ip, [r4]
  	U0DLM = (uint8_t)(baud >> 8);// set for baud high byte
     a90:	e5840004 	str	r0, [r4, #4]
  
  	// set the number of characters and other
  	// user specified operating parameters
  	// Databits, Parity, Stopbits - Settings in Line Control Register
  	U0LCR = (mode & ~(ULCR_DLAB_ENABLE)); // clear DLAB "on-the-fly"
     a94:	e584100c 	str	r1, [r4, #12]
  	// setup FIFO Control Register (fifo-enabled + xx trig) 
  	U0FCR = fmode;
     a98:	e5842008 	str	r2, [r4, #8]
}
     a9c:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
     aa0:	e000c000 	.word	0xe000c000
     aa4:	e01fc000 	.word	0xe01fc000
     aa8:	e002c000 	.word	0xe002c000

00000aac <uart0Puts>:

int uart0Putch(int ch)
{
  while (!(U0LSR & ULSR_THRE))          // wait for TX buffer to empty
     aac:	e59f1034 	ldr	r1, [pc, #52]	; ae8 <uart0Puts+0x3c>

  return (uint8_t)ch;      // return char ("stdio-compatible"?)
}

const char *uart0Puts(const char *string)
{
     ab0:	e1a0c00d 	mov	ip, sp
     ab4:	e92dd800 	push	{fp, ip, lr, pc}
     ab8:	e24cb004 	sub	fp, ip, #4	; 0x4
  	U0FCR = fmode;
}

int uart0Putch(int ch)
{
  while (!(U0LSR & ULSR_THRE))          // wait for TX buffer to empty
     abc:	e1a0c001 	mov	ip, r1
     ac0:	ea000004 	b	ad8 <uart0Puts+0x2c>
     ac4:	e5913014 	ldr	r3, [r1, #20]
     ac8:	e3130020 	tst	r3, #32	; 0x20
     acc:	0afffffc 	beq	ac4 <uart0Puts+0x18>
    continue;                           // also either WDOG() or swap()

  U0THR = (uint8_t)ch;  // put char to Transmit Holding Register
     ad0:	e58c2000 	str	r2, [ip]
{
	char ch;
	
	while ((ch = *string)) {
		if (uart0Putch(ch)<0) break;
		string++;
     ad4:	e2800001 	add	r0, r0, #1	; 0x1

const char *uart0Puts(const char *string)
{
	char ch;
	
	while ((ch = *string)) {
     ad8:	e5d02000 	ldrb	r2, [r0]
     adc:	e3520000 	cmp	r2, #0	; 0x0
     ae0:	1afffff7 	bne	ac4 <uart0Puts+0x18>
		if (uart0Putch(ch)<0) break;
		string++;
	}
	
	return string;
}
     ae4:	e89da800 	ldm	sp, {fp, sp, pc}
     ae8:	e000c000 	.word	0xe000c000

00000aec <uart_put>:
	uart_xmit( ch );
	return 1;
}

void uart_put (BYTE d)
{
     aec:	e20000ff 	and	r0, r0, #255	; 0xff
     af0:	e1a0c00d 	mov	ip, sp
// (used during tests until eval-version-limit
//  forced early migration to GNU-tools)
int sendchar( int ch );
int sendchar( int ch )
{
	if ( ch == '\n' ) {
     af4:	e350000a 	cmp	r0, #10	; 0xa
	uart_xmit( ch );
	return 1;
}

void uart_put (BYTE d)
{
     af8:	e92dd800 	push	{fp, ip, lr, pc}
     afc:	e24cb004 	sub	fp, ip, #4	; 0x4
// (used during tests until eval-version-limit
//  forced early migration to GNU-tools)
int sendchar( int ch );
int sendchar( int ch )
{
	if ( ch == '\n' ) {
     b00:	1a000006 	bne	b20 <uart_put+0x34>
	return U0RBR;
}

static void uart_xmit( BYTE d )
{
	while ( !( U0LSR & 0x20 ) ) {
     b04:	e59f2030 	ldr	r2, [pc, #48]	; b3c <uart_put+0x50>
     b08:	e5923014 	ldr	r3, [r2, #20]
     b0c:	e3130020 	tst	r3, #32	; 0x20
     b10:	0afffffc 	beq	b08 <uart_put+0x1c>
		// wait for send possible
		;
	}
	U0THR = d;
     b14:	e59f3020 	ldr	r3, [pc, #32]	; b3c <uart_put+0x50>
     b18:	e3a0200d 	mov	r2, #13	; 0xd
     b1c:	e5832000 	str	r2, [r3]
	return U0RBR;
}

static void uart_xmit( BYTE d )
{
	while ( !( U0LSR & 0x20 ) ) {
     b20:	e59f2014 	ldr	r2, [pc, #20]	; b3c <uart_put+0x50>
     b24:	e5923014 	ldr	r3, [r2, #20]
     b28:	e3130020 	tst	r3, #32	; 0x20
     b2c:	0afffffc 	beq	b24 <uart_put+0x38>
		// wait for send possible
		;
	}
	U0THR = d;
     b30:	e59f3004 	ldr	r3, [pc, #4]	; b3c <uart_put+0x50>
     b34:	e5830000 	str	r0, [r3]
}

void uart_put (BYTE d)
{
	sendchar( d );
}
     b38:	e89da800 	ldm	sp, {fp, sp, pc}
     b3c:	e000c000 	.word	0xe000c000

00000b40 <init_VIC>:
{
    DWORD i = 0;
    DWORD *vect_addr, *vect_prio;
   	
    /* initialize VIC*/
    VICIntEnClr = 0xffffffff;
     b40:	e3e03000 	mvn	r3, #0	; 0x0
    VICVectAddr = 0;
     b44:	e3a02000 	mov	r2, #0	; 0x0
{
    DWORD i = 0;
    DWORD *vect_addr, *vect_prio;
   	
    /* initialize VIC*/
    VICIntEnClr = 0xffffffff;
     b48:	e5033feb 	str	r3, [r3, #-4075]
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
void init_VIC(void) 
{
     b4c:	e1a0c00d 	mov	ip, sp
    DWORD i = 0;
    DWORD *vect_addr, *vect_prio;
   	
    /* initialize VIC*/
    VICIntEnClr = 0xffffffff;
    VICVectAddr = 0;
     b50:	e50320ff 	str	r2, [r3, #-255]
    VICIntSelect = 0;
     b54:	e5032ff3 	str	r2, [r3, #-4083]
     b58:	e59f3020 	ldr	r3, [pc, #32]	; b80 <init_VIC+0x40>
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
void init_VIC(void) 
{
     b5c:	e92dd800 	push	{fp, ip, lr, pc}
    for ( i = 0; i < VIC_SIZE; i++ )
    {
		vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + i*4);
		vect_prio = (DWORD *)(VIC_BASE_ADDR + VECT_PRIO_INDEX + i*4);
		*vect_addr = 0x0;	
		*vect_prio = 0xF;
     b60:	e3a0100f 	mov	r1, #15	; 0xf
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
void init_VIC(void) 
{
     b64:	e24cb004 	sub	fp, ip, #4	; 0x4
    /* set all the vector and vector control register to 0 */
    for ( i = 0; i < VIC_SIZE; i++ )
    {
		vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + i*4);
		vect_prio = (DWORD *)(VIC_BASE_ADDR + VECT_PRIO_INDEX + i*4);
		*vect_addr = 0x0;	
     b68:	e5832000 	str	r2, [r3]
		*vect_prio = 0xF;
     b6c:	e5831100 	str	r1, [r3, #256]
     b70:	e2833004 	add	r3, r3, #4	; 0x4
    VICIntEnClr = 0xffffffff;
    VICVectAddr = 0;
    VICIntSelect = 0;

    /* set all the vector and vector control register to 0 */
    for ( i = 0; i < VIC_SIZE; i++ )
     b74:	e3730d3a 	cmn	r3, #3712	; 0xe80
     b78:	1afffffa 	bne	b68 <init_VIC+0x28>
		vect_prio = (DWORD *)(VIC_BASE_ADDR + VECT_PRIO_INDEX + i*4);
		*vect_addr = 0x0;	
		*vect_prio = 0xF;
    }
    return;
}
     b7c:	e89da800 	ldm	sp, {fp, sp, pc}
     b80:	fffff100 	.word	0xfffff100

00000b84 <install_irq>:
**						interrupt priority
** Returned value:		true or false, return false if IntNum is out of range
** 
******************************************************************************/
DWORD install_irq( DWORD IntNumber, void *HandlerAddr, DWORD Priority )
{
     b84:	e1a0c00d 	mov	ip, sp
     b88:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
    DWORD *vect_addr;
    DWORD *vect_prio;
      
    VICIntEnClr = 1 << IntNumber;	/* Disable Interrupt */
     b8c:	e3a05001 	mov	r5, #1	; 0x1
**						interrupt priority
** Returned value:		true or false, return false if IntNum is out of range
** 
******************************************************************************/
DWORD install_irq( DWORD IntNumber, void *HandlerAddr, DWORD Priority )
{
     b90:	e24cb004 	sub	fp, ip, #4	; 0x4
    DWORD *vect_addr;
    DWORD *vect_prio;
      
    VICIntEnClr = 1 << IntNumber;	/* Disable Interrupt */
     b94:	e1a0c015 	lsl	ip, r5, r0
    if ( IntNumber >= VIC_SIZE )
     b98:	e350001f 	cmp	r0, #31	; 0x1f
		return ( FALSE );
    }
    else
    {
		/* find first un-assigned VIC address for the handler */
		vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + IntNumber*4);
     b9c:	91a03100 	lslls	r3, r0, #2
DWORD install_irq( DWORD IntNumber, void *HandlerAddr, DWORD Priority )
{
    DWORD *vect_addr;
    DWORD *vect_prio;
      
    VICIntEnClr = 1 << IntNumber;	/* Disable Interrupt */
     ba0:	e3e04000 	mvn	r4, #0	; 0x0
     ba4:	e504cfeb 	str	ip, [r4, #-4075]
    if ( IntNumber >= VIC_SIZE )
     ba8:	83a00000 	movhi	r0, #0	; 0x0
    {
		/* find first un-assigned VIC address for the handler */
		vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + IntNumber*4);
		vect_prio = (DWORD *)(VIC_BASE_ADDR + VECT_PRIO_INDEX + IntNumber*4);
		*vect_addr = (DWORD)HandlerAddr;	/* set interrupt vector */
		*vect_prio = Priority;
     bac:	95032e00 	strls	r2, [r3, #-3584]
    else
    {
		/* find first un-assigned VIC address for the handler */
		vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + IntNumber*4);
		vect_prio = (DWORD *)(VIC_BASE_ADDR + VECT_PRIO_INDEX + IntNumber*4);
		*vect_addr = (DWORD)HandlerAddr;	/* set interrupt vector */
     bb0:	95031f00 	strls	r1, [r3, #-3840]
		*vect_prio = Priority;
		VICIntEnable = 1 << IntNumber;	/* Enable Interrupt */
     bb4:	91a00005 	movls	r0, r5
     bb8:	9504cfef 	strls	ip, [r4, #-4079]
		return( TRUE );
    }
}
     bbc:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}

00000bc0 <RTCGetTime>:
** parameters:			ptr to RTCTime object
** Returned value:		updated object
**
*****************************************************************************/
void RTCGetTime( RTCTime* LocalTime ) 
{
     bc0:	e1a0c00d 	mov	ip, sp
	if ( LocalTime == NULL ) return;
     bc4:	e3500000 	cmp	r0, #0	; 0x0
** parameters:			ptr to RTCTime object
** Returned value:		updated object
**
*****************************************************************************/
void RTCGetTime( RTCTime* LocalTime ) 
{
     bc8:	e92dd800 	push	{fp, ip, lr, pc}
     bcc:	e24cb004 	sub	fp, ip, #4	; 0x4
	if ( LocalTime == NULL ) return;
     bd0:	089da800 	ldmeq	sp, {fp, sp, pc}

	LocalTime->RTC_Sec  = RTC_SEC;
     bd4:	e59f2040 	ldr	r2, [pc, #64]	; c1c <RTCGetTime+0x5c>
     bd8:	e5923020 	ldr	r3, [r2, #32]
     bdc:	e5803000 	str	r3, [r0]
	LocalTime->RTC_Min  = RTC_MIN;
     be0:	e5923024 	ldr	r3, [r2, #36]
     be4:	e5803004 	str	r3, [r0, #4]
	LocalTime->RTC_Hour = RTC_HOUR;
     be8:	e5923028 	ldr	r3, [r2, #40]
     bec:	e5803008 	str	r3, [r0, #8]
	LocalTime->RTC_Mday = RTC_DOM;
     bf0:	e592302c 	ldr	r3, [r2, #44]
     bf4:	e580300c 	str	r3, [r0, #12]
	LocalTime->RTC_Wday = RTC_DOW;
     bf8:	e5923030 	ldr	r3, [r2, #48]
     bfc:	e5803018 	str	r3, [r0, #24]
	LocalTime->RTC_Yday = RTC_DOY;
     c00:	e5923034 	ldr	r3, [r2, #52]
     c04:	e580301c 	str	r3, [r0, #28]
	LocalTime->RTC_Mon  = RTC_MONTH;
     c08:	e5923038 	ldr	r3, [r2, #56]
     c0c:	e5803010 	str	r3, [r0, #16]
	LocalTime->RTC_Year = RTC_YEAR;
     c10:	e592303c 	ldr	r3, [r2, #60]
     c14:	e5803014 	str	r3, [r0, #20]
     c18:	e89da800 	ldm	sp, {fp, sp, pc}
     c1c:	e0024000 	.word	0xe0024000

00000c20 <move_window>:
static
BOOL move_window (	/* TRUE: successful, FALSE: failed */
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make apperance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
     c20:	e1a0c00d 	mov	ip, sp
     c24:	e92dd800 	push	{fp, ip, lr, pc}
     c28:	e24cb004 	sub	fp, ip, #4	; 0x4
     c2c:	e24dd014 	sub	sp, sp, #20	; 0x14
		disk_write(drv, tbl, b_part+6, 1);

	/* Initialize FAT area */
	for (m = 0; m < N_FATS; m++) {
		memset(tbl, 0, SS(fs));		/* 1st sector of the FAT  */
		if (fmt != FS_FAT32) {
     c30:	e50b0018 	str	r0, [fp, #-24]
     c34:	e50b101c 	str	r1, [fp, #-28]
)					/* Move to zero only writes back dirty window */
{
	DWORD wsect;


	wsect = fs->winsect;
     c38:	e51b3018 	ldr	r3, [fp, #-24]

	/* Initialize FAT area */
	for (m = 0; m < N_FATS; m++) {
		memset(tbl, 0, SS(fs));		/* 1st sector of the FAT  */
		if (fmt != FS_FAT32) {
			n = (fmt == FS_FAT12) ? 0x00FFFFF8 : 0xFFFFFFF8;
     c3c:	e5933004 	ldr	r3, [r3, #4]
     c40:	e50b3014 	str	r3, [fp, #-20]
{
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
     c44:	e51b2014 	ldr	r2, [fp, #-20]
     c48:	e51b301c 	ldr	r3, [fp, #-28]
     c4c:	e1520003 	cmp	r2, r3
     c50:	0a00004d 	beq	d8c <move_window+0x16c>
#if !_FS_READONLY
		BYTE n;
		if (fs->winflag) {	/* Write back dirty window if needed */
     c54:	e51b3018 	ldr	r3, [fp, #-24]
     c58:	e5d3302e 	ldrb	r3, [r3, #46]
     c5c:	e3530000 	cmp	r3, #0	; 0x0
     c60:	0a000033 	beq	d34 <move_window+0x114>
			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
     c64:	e51b3018 	ldr	r3, [fp, #-24]
     c68:	e5d3302d 	ldrb	r3, [r3, #45]
     c6c:	e1a02003 	mov	r2, r3
	/* Initialize FAT area */
	for (m = 0; m < N_FATS; m++) {
		memset(tbl, 0, SS(fs));		/* 1st sector of the FAT  */
		if (fmt != FS_FAT32) {
			n = (fmt == FS_FAT12) ? 0x00FFFFF8 : 0xFFFFFFF8;
			ST_DWORD(&tbl[0], n);			/* Reserve cluster #0-1 (FAT12/16) */
     c70:	e51b3018 	ldr	r3, [fp, #-24]
     c74:	e2833030 	add	r3, r3, #48	; 0x30
     c78:	e1a00002 	mov	r0, r2
     c7c:	e1a01003 	mov	r1, r3
     c80:	e51b2014 	ldr	r2, [fp, #-20]
     c84:	e3a03001 	mov	r3, #1	; 0x1
     c88:	eb000fed 	bl	4c44 <disk_write>
     c8c:	e1a03000 	mov	r3, r0
     c90:	e3530000 	cmp	r3, #0	; 0x0
     c94:	0a000002 	beq	ca4 <move_window+0x84>
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		BYTE n;
		if (fs->winflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
				return FALSE;
     c98:	e3a03000 	mov	r3, #0	; 0x0
     c9c:	e50b3020 	str	r3, [fp, #-32]
     ca0:	ea00003b 	b	d94 <move_window+0x174>
			fs->winflag = 0;
     ca4:	e51b2018 	ldr	r2, [fp, #-24]
     ca8:	e3a03000 	mov	r3, #0	; 0x0
     cac:	e5c2302e 	strb	r3, [r2, #46]
			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
     cb0:	e51b3018 	ldr	r3, [fp, #-24]
     cb4:	e5932010 	ldr	r2, [r3, #16]
     cb8:	e51b3018 	ldr	r3, [fp, #-24]
     cbc:	e5933008 	ldr	r3, [r3, #8]
     cc0:	e0822003 	add	r2, r2, r3
     cc4:	e51b3014 	ldr	r3, [fp, #-20]
     cc8:	e1520003 	cmp	r2, r3
     ccc:	9a000018 	bls	d34 <move_window+0x114>
				for (n = fs->n_fats; n >= 2; n--) {	/* Refrect the change to FAT copy */
     cd0:	e51b3018 	ldr	r3, [fp, #-24]
     cd4:	e5d3302c 	ldrb	r3, [r3, #44]
     cd8:	e54b300d 	strb	r3, [fp, #-13]
		memset(tbl, 0, SS(fs));		/* 1st sector of the FAT  */
		if (fmt != FS_FAT32) {
			n = (fmt == FS_FAT12) ? 0x00FFFFF8 : 0xFFFFFFF8;
			ST_DWORD(&tbl[0], n);			/* Reserve cluster #0-1 (FAT12/16) */
		} else {
			ST_DWORD(&tbl[0], 0xFFFFFFF8);	/* Reserve cluster #0-1 (FAT32) */
     cdc:	ea000011 	b	d28 <move_window+0x108>
			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
				return FALSE;
			fs->winflag = 0;
			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
				for (n = fs->n_fats; n >= 2; n--) {	/* Refrect the change to FAT copy */
					wsect += fs->sects_fat;
     ce0:	e51b3018 	ldr	r3, [fp, #-24]
     ce4:	e5932008 	ldr	r2, [r3, #8]
     ce8:	e51b3014 	ldr	r3, [fp, #-20]
     cec:	e0833002 	add	r3, r3, r2
     cf0:	e50b3014 	str	r3, [fp, #-20]
					disk_write(fs->drive, fs->win, wsect, 1);
     cf4:	e51b3018 	ldr	r3, [fp, #-24]
     cf8:	e5d3302d 	ldrb	r3, [r3, #45]
     cfc:	e1a02003 	mov	r2, r3
     d00:	e51b3018 	ldr	r3, [fp, #-24]
     d04:	e2833030 	add	r3, r3, #48	; 0x30
     d08:	e1a00002 	mov	r0, r2
     d0c:	e1a01003 	mov	r1, r3
     d10:	e51b2014 	ldr	r2, [fp, #-20]
     d14:	e3a03001 	mov	r3, #1	; 0x1
		if (fmt != FS_FAT32) {
			n = (fmt == FS_FAT12) ? 0x00FFFFF8 : 0xFFFFFFF8;
			ST_DWORD(&tbl[0], n);			/* Reserve cluster #0-1 (FAT12/16) */
		} else {
			ST_DWORD(&tbl[0], 0xFFFFFFF8);	/* Reserve cluster #0-1 (FAT32) */
			ST_DWORD(&tbl[4], 0xFFFFFFFF);
     d18:	eb000fc9 	bl	4c44 <disk_write>
		if (fs->winflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
				return FALSE;
			fs->winflag = 0;
			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
				for (n = fs->n_fats; n >= 2; n--) {	/* Refrect the change to FAT copy */
     d1c:	e55b300d 	ldrb	r3, [fp, #-13]
     d20:	e2433001 	sub	r3, r3, #1	; 0x1
     d24:	e54b300d 	strb	r3, [fp, #-13]
     d28:	e55b300d 	ldrb	r3, [fp, #-13]
     d2c:	e3530001 	cmp	r3, #1	; 0x1
     d30:	8affffea 	bhi	ce0 <move_window+0xc0>
					disk_write(fs->drive, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
     d34:	e51b301c 	ldr	r3, [fp, #-28]
     d38:	e3530000 	cmp	r3, #0	; 0x0
     d3c:	0a000012 	beq	d8c <move_window+0x16c>
			if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
     d40:	e51b3018 	ldr	r3, [fp, #-24]
     d44:	e5d3302d 	ldrb	r3, [r3, #45]
     d48:	e1a02003 	mov	r2, r3
     d4c:	e51b3018 	ldr	r3, [fp, #-24]
     d50:	e2833030 	add	r3, r3, #48	; 0x30
     d54:	e1a00002 	mov	r0, r2
			n = (fmt == FS_FAT12) ? 0x00FFFFF8 : 0xFFFFFFF8;
			ST_DWORD(&tbl[0], n);			/* Reserve cluster #0-1 (FAT12/16) */
		} else {
			ST_DWORD(&tbl[0], 0xFFFFFFF8);	/* Reserve cluster #0-1 (FAT32) */
			ST_DWORD(&tbl[4], 0xFFFFFFFF);
			ST_DWORD(&tbl[8], 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
     d58:	e1a01003 	mov	r1, r3
     d5c:	e51b201c 	ldr	r2, [fp, #-28]
     d60:	e3a03001 	mov	r3, #1	; 0x1
     d64:	eb000f6e 	bl	4b24 <disk_read>
     d68:	e1a03000 	mov	r3, r0
     d6c:	e3530000 	cmp	r3, #0	; 0x0
     d70:	0a000002 	beq	d80 <move_window+0x160>
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
				return FALSE;
     d74:	e3a03000 	mov	r3, #0	; 0x0
     d78:	e50b3020 	str	r3, [fp, #-32]
     d7c:	ea000004 	b	d94 <move_window+0x174>
			fs->winsect = sector;
     d80:	e51b2018 	ldr	r2, [fp, #-24]
     d84:	e51b301c 	ldr	r3, [fp, #-28]
     d88:	e5823004 	str	r3, [r2, #4]
		}
	}
	return TRUE;
     d8c:	e3a03001 	mov	r3, #1	; 0x1
     d90:	e50b3020 	str	r3, [fp, #-32]
     d94:	e51b3020 	ldr	r3, [fp, #-32]
}
     d98:	e1a00003 	mov	r0, r3
     d9c:	e24bd00c 	sub	sp, fp, #12	; 0xc
     da0:	e89da800 	ldm	sp, {fp, sp, pc}

00000da4 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_RW_ERROR: failed */
	FATFS *fs	/* File system object */
)
{
     da4:	e1a0c00d 	mov	ip, sp
     da8:	e92dd800 	push	{fp, ip, lr, pc}
     dac:	e24cb004 	sub	fp, ip, #4	; 0x4
     db0:	e24dd008 	sub	sp, sp, #8	; 0x8
     db4:	e50b0010 	str	r0, [fp, #-16]
	fs->winflag = 1;
     db8:	e51b2010 	ldr	r2, [fp, #-16]
     dbc:	e3a03001 	mov	r3, #1	; 0x1
     dc0:	e5c2302e 	strb	r3, [r2, #46]
	if (!move_window(fs, 0)) return FR_RW_ERROR;
     dc4:	e51b0010 	ldr	r0, [fp, #-16]
     dc8:	e3a01000 	mov	r1, #0	; 0x0
			ST_DWORD(&tbl[0], 0xFFFFFFF8);	/* Reserve cluster #0-1 (FAT32) */
			ST_DWORD(&tbl[4], 0xFFFFFFFF);
			ST_DWORD(&tbl[8], 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
		}
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
			return FR_RW_ERROR;
     dcc:	ebffff93 	bl	c20 <move_window>
     dd0:	e1a03000 	mov	r3, r0
     dd4:	e3530000 	cmp	r3, #0	; 0x0
		memset(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
     dd8:	1a000002 	bne	de8 <sync+0x44>
     ddc:	e3a03008 	mov	r3, #8	; 0x8
     de0:	e50b3014 	str	r3, [fp, #-20]
     de4:	ea0000af 	b	10a8 <sync+0x304>
{
	fs->winflag = 1;
	if (!move_window(fs, 0)) return FR_RW_ERROR;
#if _USE_FSINFO
	/* Update FSInfo sector if needed */
	if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
     de8:	e51b3010 	ldr	r3, [fp, #-16]
     dec:	e5d3302a 	ldrb	r3, [r3, #42]
     df0:	e3530003 	cmp	r3, #3	; 0x3
		}
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
			return FR_RW_ERROR;
		memset(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
		for (n = 1; n < n_fat; n++) {
			if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
     df4:	1a00009d 	bne	1070 <sync+0x2cc>
     df8:	e51b3010 	ldr	r3, [fp, #-16]
     dfc:	e5d33028 	ldrb	r3, [r3, #40]
     e00:	e3530000 	cmp	r3, #0	; 0x0
     e04:	0a000099 	beq	1070 <sync+0x2cc>
	fs->winflag = 1;
	if (!move_window(fs, 0)) return FR_RW_ERROR;
#if _USE_FSINFO
	/* Update FSInfo sector if needed */
	if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
		fs->winsect = 0;
     e08:	e51b2010 	ldr	r2, [fp, #-16]
     e0c:	e3a03000 	mov	r3, #0	; 0x0
     e10:	e5823004 	str	r3, [r2, #4]
		memset(fs->win, 0, 512);
     e14:	e51b3010 	ldr	r3, [fp, #-16]
     e18:	e2833030 	add	r3, r3, #48	; 0x30
     e1c:	e1a00003 	mov	r0, r3
     e20:	e3a01000 	mov	r1, #0	; 0x0
     e24:	e3a02c02 	mov	r2, #512	; 0x200
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
			return FR_RW_ERROR;
		memset(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
		for (n = 1; n < n_fat; n++) {
			if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
				return FR_RW_ERROR;
     e28:	eb002107 	bl	924c <memset>
#if _USE_FSINFO
	/* Update FSInfo sector if needed */
	if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
		fs->winsect = 0;
		memset(fs->win, 0, 512);
		ST_WORD(&fs->win[BS_55AA], 0xAA55);
     e2c:	e51b3010 	ldr	r3, [fp, #-16]
     e30:	e2833f8b 	add	r3, r3, #556	; 0x22c
			ST_DWORD(&tbl[8], 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
		}
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
			return FR_RW_ERROR;
		memset(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
		for (n = 1; n < n_fat; n++) {
     e34:	e2833002 	add	r3, r3, #2	; 0x2
     e38:	e1a02003 	mov	r2, r3
     e3c:	e3a03055 	mov	r3, #85	; 0x55
     e40:	e5c23000 	strb	r3, [r2]
     e44:	e51b3010 	ldr	r3, [fp, #-16]
     e48:	e2833f8b 	add	r3, r3, #556	; 0x22c
     e4c:	e2833003 	add	r3, r3, #3	; 0x3
		return FR_RW_ERROR;
	if (fmt == FS_FAT32)
		disk_write(drv, tbl, b_part+6, 1);

	/* Initialize FAT area */
	for (m = 0; m < N_FATS; m++) {
     e50:	e1a02003 	mov	r2, r3
     e54:	e3e03055 	mvn	r3, #85	; 0x55
     e58:	e5c23000 	strb	r3, [r2]
	/* Update FSInfo sector if needed */
	if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
		fs->winsect = 0;
		memset(fs->win, 0, 512);
		ST_WORD(&fs->win[BS_55AA], 0xAA55);
		ST_DWORD(&fs->win[FSI_LeadSig], 0x41615252);
     e5c:	e51b3010 	ldr	r3, [fp, #-16]
     e60:	e2833030 	add	r3, r3, #48	; 0x30
     e64:	e1a02003 	mov	r2, r3
				return FR_RW_ERROR;
		}
	}

	/* Initialize Root directory */
	m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
     e68:	e3a03052 	mov	r3, #82	; 0x52
     e6c:	e5c23000 	strb	r3, [r2]
     e70:	e51b3010 	ldr	r3, [fp, #-16]
     e74:	e2833031 	add	r3, r3, #49	; 0x31
     e78:	e1a02003 	mov	r2, r3
     e7c:	e3a03052 	mov	r3, #82	; 0x52
     e80:	e5c23000 	strb	r3, [r2]
     e84:	e51b3010 	ldr	r3, [fp, #-16]
     e88:	e2833032 	add	r3, r3, #50	; 0x32
     e8c:	e1a02003 	mov	r2, r3
     e90:	e3a03061 	mov	r3, #97	; 0x61
     e94:	e5c23000 	strb	r3, [r2]
     e98:	e51b3010 	ldr	r3, [fp, #-16]
	do {
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
     e9c:	e2833033 	add	r3, r3, #51	; 0x33
     ea0:	e1a02003 	mov	r2, r3
     ea4:	e3a03041 	mov	r3, #65	; 0x41
     ea8:	e5c23000 	strb	r3, [r2]
	if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
		fs->winsect = 0;
		memset(fs->win, 0, 512);
		ST_WORD(&fs->win[BS_55AA], 0xAA55);
		ST_DWORD(&fs->win[FSI_LeadSig], 0x41615252);
		ST_DWORD(&fs->win[FSI_StrucSig], 0x61417272);
     eac:	e51b3010 	ldr	r3, [fp, #-16]
     eb0:	e2833f85 	add	r3, r3, #532	; 0x214
     eb4:	e1a02003 	mov	r2, r3
     eb8:	e3a03072 	mov	r3, #114	; 0x72
     ebc:	e5c23000 	strb	r3, [r2]
     ec0:	e51b3010 	ldr	r3, [fp, #-16]
     ec4:	e2833f85 	add	r3, r3, #532	; 0x214
     ec8:	e2833001 	add	r3, r3, #1	; 0x1
     ecc:	e1a02003 	mov	r2, r3

	/* Initialize Root directory */
	m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
	do {
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
			return FR_RW_ERROR;
     ed0:	e3a03072 	mov	r3, #114	; 0x72
     ed4:	e5c23000 	strb	r3, [r2]
     ed8:	e51b3010 	ldr	r3, [fp, #-16]
     edc:	e2833f85 	add	r3, r3, #532	; 0x214
     ee0:	e2833002 	add	r3, r3, #2	; 0x2
     ee4:	e1a02003 	mov	r2, r3
     ee8:	e3a03041 	mov	r3, #65	; 0x41
	} while (--m);
     eec:	e5c23000 	strb	r3, [r2]
     ef0:	e51b3010 	ldr	r3, [fp, #-16]
     ef4:	e2833f85 	add	r3, r3, #532	; 0x214
     ef8:	e2833003 	add	r3, r3, #3	; 0x3
     efc:	e1a02003 	mov	r2, r3
     f00:	e3a03061 	mov	r3, #97	; 0x61

	/* Create FSInfo record if needed */
	if (fmt == FS_FAT32) {
     f04:	e5c23000 	strb	r3, [r2]
		fs->winsect = 0;
		memset(fs->win, 0, 512);
		ST_WORD(&fs->win[BS_55AA], 0xAA55);
		ST_DWORD(&fs->win[FSI_LeadSig], 0x41615252);
		ST_DWORD(&fs->win[FSI_StrucSig], 0x61417272);
		ST_DWORD(&fs->win[FSI_Free_Count], fs->free_clust);
     f08:	e51b3010 	ldr	r3, [fp, #-16]
     f0c:	e2833f86 	add	r3, r3, #536	; 0x218
			return FR_RW_ERROR;
	} while (--m);

	/* Create FSInfo record if needed */
	if (fmt == FS_FAT32) {
		ST_WORD(&tbl[BS_55AA], 0xAA55);
     f10:	e1a02003 	mov	r2, r3
     f14:	e51b3010 	ldr	r3, [fp, #-16]
     f18:	e5933020 	ldr	r3, [r3, #32]
     f1c:	e20330ff 	and	r3, r3, #255	; 0xff
     f20:	e5c23000 	strb	r3, [r2]
     f24:	e51b3010 	ldr	r3, [fp, #-16]
     f28:	e2833f86 	add	r3, r3, #536	; 0x218
     f2c:	e2833001 	add	r3, r3, #1	; 0x1
     f30:	e1a02003 	mov	r2, r3
     f34:	e51b3010 	ldr	r3, [fp, #-16]
		ST_DWORD(&tbl[FSI_LeadSig], 0x41615252);
     f38:	e5933020 	ldr	r3, [r3, #32]
     f3c:	e1a03803 	lsl	r3, r3, #16
     f40:	e1a03823 	lsr	r3, r3, #16
     f44:	e1a03423 	lsr	r3, r3, #8
     f48:	e1a03803 	lsl	r3, r3, #16
     f4c:	e1a03823 	lsr	r3, r3, #16
     f50:	e20330ff 	and	r3, r3, #255	; 0xff
     f54:	e5c23000 	strb	r3, [r2]
     f58:	e51b3010 	ldr	r3, [fp, #-16]
     f5c:	e2833f86 	add	r3, r3, #536	; 0x218
     f60:	e2833002 	add	r3, r3, #2	; 0x2
     f64:	e1a02003 	mov	r2, r3
     f68:	e51b3010 	ldr	r3, [fp, #-16]
     f6c:	e5933020 	ldr	r3, [r3, #32]
     f70:	e1a03823 	lsr	r3, r3, #16
		ST_DWORD(&tbl[FSI_StrucSig], 0x61417272);
     f74:	e20330ff 	and	r3, r3, #255	; 0xff
     f78:	e5c23000 	strb	r3, [r2]
     f7c:	e51b3010 	ldr	r3, [fp, #-16]
     f80:	e2833f86 	add	r3, r3, #536	; 0x218
     f84:	e2833003 	add	r3, r3, #3	; 0x3
     f88:	e1a02003 	mov	r2, r3
     f8c:	e51b3010 	ldr	r3, [fp, #-16]
     f90:	e5933020 	ldr	r3, [r3, #32]
     f94:	e1a03c23 	lsr	r3, r3, #24
     f98:	e20330ff 	and	r3, r3, #255	; 0xff
     f9c:	e5c23000 	strb	r3, [r2]
		memset(fs->win, 0, 512);
		ST_WORD(&fs->win[BS_55AA], 0xAA55);
		ST_DWORD(&fs->win[FSI_LeadSig], 0x41615252);
		ST_DWORD(&fs->win[FSI_StrucSig], 0x61417272);
		ST_DWORD(&fs->win[FSI_Free_Count], fs->free_clust);
		ST_DWORD(&fs->win[FSI_Nxt_Free], fs->last_clust);
     fa0:	e51b3010 	ldr	r3, [fp, #-16]
     fa4:	e2833f87 	add	r3, r3, #540	; 0x21c
     fa8:	e1a02003 	mov	r2, r3
     fac:	e51b3010 	ldr	r3, [fp, #-16]
     fb0:	e593301c 	ldr	r3, [r3, #28]
     fb4:	e20330ff 	and	r3, r3, #255	; 0xff
     fb8:	e5c23000 	strb	r3, [r2]
     fbc:	e51b3010 	ldr	r3, [fp, #-16]
	/* Create FSInfo record if needed */
	if (fmt == FS_FAT32) {
		ST_WORD(&tbl[BS_55AA], 0xAA55);
		ST_DWORD(&tbl[FSI_LeadSig], 0x41615252);
		ST_DWORD(&tbl[FSI_StrucSig], 0x61417272);
		ST_DWORD(&tbl[FSI_Free_Count], n_clust - 1);
     fc0:	e2833f87 	add	r3, r3, #540	; 0x21c
     fc4:	e2833001 	add	r3, r3, #1	; 0x1
     fc8:	e1a02003 	mov	r2, r3
     fcc:	e51b3010 	ldr	r3, [fp, #-16]
     fd0:	e593301c 	ldr	r3, [r3, #28]
     fd4:	e1a03803 	lsl	r3, r3, #16
     fd8:	e1a03823 	lsr	r3, r3, #16
     fdc:	e1a03423 	lsr	r3, r3, #8
     fe0:	e1a03803 	lsl	r3, r3, #16
     fe4:	e1a03823 	lsr	r3, r3, #16
     fe8:	e20330ff 	and	r3, r3, #255	; 0xff
     fec:	e5c23000 	strb	r3, [r2]
     ff0:	e51b3010 	ldr	r3, [fp, #-16]
     ff4:	e2833f87 	add	r3, r3, #540	; 0x21c
     ff8:	e2833002 	add	r3, r3, #2	; 0x2
     ffc:	e1a02003 	mov	r2, r3
    1000:	e51b3010 	ldr	r3, [fp, #-16]
    1004:	e593301c 	ldr	r3, [r3, #28]
    1008:	e1a03823 	lsr	r3, r3, #16
    100c:	e20330ff 	and	r3, r3, #255	; 0xff
    1010:	e5c23000 	strb	r3, [r2]
    1014:	e51b3010 	ldr	r3, [fp, #-16]
    1018:	e2833f87 	add	r3, r3, #540	; 0x21c
    101c:	e2833003 	add	r3, r3, #3	; 0x3
    1020:	e1a02003 	mov	r2, r3
    1024:	e51b3010 	ldr	r3, [fp, #-16]
    1028:	e593301c 	ldr	r3, [r3, #28]
    102c:	e1a03c23 	lsr	r3, r3, #24
    1030:	e20330ff 	and	r3, r3, #255	; 0xff
    1034:	e5c23000 	strb	r3, [r2]
		ST_WORD(&fs->win[BS_55AA], 0xAA55);
		ST_DWORD(&fs->win[FSI_LeadSig], 0x41615252);
		ST_DWORD(&fs->win[FSI_StrucSig], 0x61417272);
		ST_DWORD(&fs->win[FSI_Free_Count], fs->free_clust);
		ST_DWORD(&fs->win[FSI_Nxt_Free], fs->last_clust);
		disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
    1038:	e51b3010 	ldr	r3, [fp, #-16]
    103c:	e5d3302d 	ldrb	r3, [r3, #45]
    1040:	e1a02003 	mov	r2, r3
    1044:	e51b3010 	ldr	r3, [fp, #-16]
    1048:	e2831030 	add	r1, r3, #48	; 0x30
    104c:	e51b3010 	ldr	r3, [fp, #-16]
    1050:	e5933024 	ldr	r3, [r3, #36]
	if (fmt == FS_FAT32) {
		ST_WORD(&tbl[BS_55AA], 0xAA55);
		ST_DWORD(&tbl[FSI_LeadSig], 0x41615252);
		ST_DWORD(&tbl[FSI_StrucSig], 0x61417272);
		ST_DWORD(&tbl[FSI_Free_Count], n_clust - 1);
		ST_DWORD(&tbl[FSI_Nxt_Free], 0xFFFFFFFF);
    1054:	e1a00002 	mov	r0, r2
    1058:	e1a02003 	mov	r2, r3
    105c:	e3a03001 	mov	r3, #1	; 0x1
    1060:	eb000ef7 	bl	4c44 <disk_write>
		ST_DWORD(&fs->win[FSI_LeadSig], 0x41615252);
		ST_DWORD(&fs->win[FSI_StrucSig], 0x61417272);
		ST_DWORD(&fs->win[FSI_Free_Count], fs->free_clust);
		ST_DWORD(&fs->win[FSI_Nxt_Free], fs->last_clust);
		disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
		fs->fsi_flag = 0;
    1064:	e51b2010 	ldr	r2, [fp, #-16]
    1068:	e3a03000 	mov	r3, #0	; 0x0
    106c:	e5c23028 	strb	r3, [r2, #40]
	}
#endif
	/* Make sure that no pending write process in the physical drive */
	if (disk_ioctl(fs->drive, CTRL_SYNC, NULL) != RES_OK)
    1070:	e51b3010 	ldr	r3, [fp, #-16]
    1074:	e5d3302d 	ldrb	r3, [r3, #45]
    1078:	e1a00003 	mov	r0, r3
    107c:	e3a01000 	mov	r1, #0	; 0x0
    1080:	e3a02000 	mov	r2, #0	; 0x0
    1084:	eb000f45 	bl	4da0 <disk_ioctl>
    1088:	e1a03000 	mov	r3, r0
    108c:	e3530000 	cmp	r3, #0	; 0x0
    1090:	0a000002 	beq	10a0 <sync+0x2fc>
		return FR_RW_ERROR;
    1094:	e3a03008 	mov	r3, #8	; 0x8
    1098:	e50b3014 	str	r3, [fp, #-20]
    109c:	ea000001 	b	10a8 <sync+0x304>
	return FR_OK;
    10a0:	e3a03000 	mov	r3, #0	; 0x0
    10a4:	e50b3014 	str	r3, [fp, #-20]
    10a8:	e51b3014 	ldr	r3, [fp, #-20]
}
    10ac:	e1a00003 	mov	r0, r3
    10b0:	e24bd00c 	sub	sp, fp, #12	; 0xc
    10b4:	e89da800 	ldm	sp, {fp, sp, pc}

000010b8 <get_cluster>:
static
DWORD get_cluster (	/* 0,>=2: successful, 1: failed */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to get the link information */
)
{
    10b8:	e1a0c00d 	mov	ip, sp
    10bc:	e92dd800 	push	{fp, ip, lr, pc}
		ST_DWORD(&tbl[FSI_LeadSig], 0x41615252);
		ST_DWORD(&tbl[FSI_StrucSig], 0x61417272);
		ST_DWORD(&tbl[FSI_Free_Count], n_clust - 1);
		ST_DWORD(&tbl[FSI_Nxt_Free], 0xFFFFFFFF);
		disk_write(drv, tbl, b_part+1, 1);
		disk_write(drv, tbl, b_part+7, 1);
    10c0:	e24cb004 	sub	fp, ip, #4	; 0x4
    10c4:	e24dd01c 	sub	sp, sp, #28	; 0x1c
    10c8:	e50b0018 	str	r0, [fp, #-24]
    10cc:	e50b101c 	str	r1, [fp, #-28]
{
	WORD wc, bc;
	DWORD fatsect;


	if (clust >= 2 && clust < fs->max_clust) {		/* Is it a valid cluster#? */
    10d0:	e51b301c 	ldr	r3, [fp, #-28]
    10d4:	e3530001 	cmp	r3, #1	; 0x1
    10d8:	9a0000de 	bls	1458 <get_cluster+0x3a0>
    10dc:	e51b3018 	ldr	r3, [fp, #-24]
		ST_DWORD(&tbl[FSI_Nxt_Free], 0xFFFFFFFF);
		disk_write(drv, tbl, b_part+1, 1);
		disk_write(drv, tbl, b_part+7, 1);
	}

	return (disk_ioctl(drv, CTRL_SYNC, NULL) == RES_OK) ? FR_OK : FR_RW_ERROR;
    10e0:	e593200c 	ldr	r2, [r3, #12]
    10e4:	e51b301c 	ldr	r3, [fp, #-28]
    10e8:	e1520003 	cmp	r2, r3
    10ec:	9a0000d9 	bls	1458 <get_cluster+0x3a0>
	WORD wc, bc;
	DWORD fatsect;


	if (clust >= 2 && clust < fs->max_clust) {		/* Is it a valid cluster#? */
		fatsect = fs->fatbase;
    10f0:	e51b3018 	ldr	r3, [fp, #-24]
    10f4:	e5933010 	ldr	r3, [r3, #16]
    10f8:	e50b3010 	str	r3, [fp, #-16]
		switch (fs->fs_type) {
    10fc:	e51b3018 	ldr	r3, [fp, #-24]
    1100:	e5d3302a 	ldrb	r3, [r3, #42]
    1104:	e50b3028 	str	r3, [fp, #-40]
    1108:	e51b3028 	ldr	r3, [fp, #-40]
    110c:	e3530002 	cmp	r3, #2	; 0x2
    1110:	0a00005c 	beq	1288 <get_cluster+0x1d0>
    1114:	e51b3028 	ldr	r3, [fp, #-40]
    1118:	e3530003 	cmp	r3, #3	; 0x3
    111c:	0a000087 	beq	1340 <get_cluster+0x288>
		disk_write(drv, tbl, b_part+1, 1);
		disk_write(drv, tbl, b_part+7, 1);
	}

	return (disk_ioctl(drv, CTRL_SYNC, NULL) == RES_OK) ? FR_OK : FR_RW_ERROR;
}
    1120:	e51b3028 	ldr	r3, [fp, #-40]
    1124:	e3530001 	cmp	r3, #1	; 0x1
    1128:	1a0000ca 	bne	1458 <get_cluster+0x3a0>

	if (clust >= 2 && clust < fs->max_clust) {		/* Is it a valid cluster#? */
		fatsect = fs->fatbase;
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (WORD)clust * 3 / 2;
    112c:	e51b301c 	ldr	r3, [fp, #-28]
    1130:	e1a03803 	lsl	r3, r3, #16
    1134:	e1a03823 	lsr	r3, r3, #16
    1138:	e1a02003 	mov	r2, r3
    113c:	e1a03002 	mov	r3, r2
    1140:	e1a03083 	lsl	r3, r3, #1
    1144:	e0832002 	add	r2, r3, r2
    1148:	e1a03fa2 	lsr	r3, r2, #31
    114c:	e0833002 	add	r3, r3, r2
    1150:	e1a030c3 	asr	r3, r3, #1
    1154:	e14b31b2 	strh	r3, [fp, #-18]
			if (!move_window(fs, fatsect + (bc / SS(fs)))) break;
    1158:	e15b31b2 	ldrh	r3, [fp, #-18]
    115c:	e1a034a3 	lsr	r3, r3, #9
    1160:	e1a03803 	lsl	r3, r3, #16
    1164:	e1a03823 	lsr	r3, r3, #16
    1168:	e1a02003 	mov	r2, r3
    116c:	e51b3010 	ldr	r3, [fp, #-16]
    1170:	e0823003 	add	r3, r2, r3
    1174:	e51b0018 	ldr	r0, [fp, #-24]
    1178:	e1a01003 	mov	r1, r3
    117c:	ebfffea7 	bl	c20 <move_window>
    1180:	e1a03000 	mov	r3, r0
    1184:	e3530000 	cmp	r3, #0	; 0x0
    1188:	0a0000b2 	beq	1458 <get_cluster+0x3a0>
			wc = fs->win[bc & (SS(fs) - 1)]; bc++;
    118c:	e15b31b2 	ldrh	r3, [fp, #-18]
    1190:	e1a03b83 	lsl	r3, r3, #23
    1194:	e1a03ba3 	lsr	r3, r3, #23
    1198:	e51b2018 	ldr	r2, [fp, #-24]
    119c:	e3a01030 	mov	r1, #48	; 0x30
    11a0:	e0823003 	add	r3, r2, r3
    11a4:	e0833001 	add	r3, r3, r1
    11a8:	e5d33000 	ldrb	r3, [r3]
    11ac:	e14b31b4 	strh	r3, [fp, #-20]
    11b0:	e15b31b2 	ldrh	r3, [fp, #-18]
    11b4:	e2833001 	add	r3, r3, #1	; 0x1
    11b8:	e14b31b2 	strh	r3, [fp, #-18]
			if (!move_window(fs, fatsect + (bc / SS(fs)))) break;
    11bc:	e15b31b2 	ldrh	r3, [fp, #-18]
    11c0:	e1a034a3 	lsr	r3, r3, #9
    11c4:	e1a03803 	lsl	r3, r3, #16
    11c8:	e1a03823 	lsr	r3, r3, #16
    11cc:	e1a02003 	mov	r2, r3
    11d0:	e51b3010 	ldr	r3, [fp, #-16]
    11d4:	e0823003 	add	r3, r2, r3
    11d8:	e51b0018 	ldr	r0, [fp, #-24]
    11dc:	e1a01003 	mov	r1, r3
    11e0:	ebfffe8e 	bl	c20 <move_window>
    11e4:	e1a03000 	mov	r3, r0
    11e8:	e3530000 	cmp	r3, #0	; 0x0
    11ec:	0a000099 	beq	1458 <get_cluster+0x3a0>
			wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
    11f0:	e15b31b2 	ldrh	r3, [fp, #-18]
    11f4:	e1a03b83 	lsl	r3, r3, #23
    11f8:	e1a03ba3 	lsr	r3, r3, #23
    11fc:	e51b2018 	ldr	r2, [fp, #-24]
    1200:	e3a01030 	mov	r1, #48	; 0x30
    1204:	e0823003 	add	r3, r2, r3
    1208:	e0833001 	add	r3, r3, r1
    120c:	e5d33000 	ldrb	r3, [r3]
    1210:	e1a03403 	lsl	r3, r3, #8
    1214:	e1a03803 	lsl	r3, r3, #16
    1218:	e1a03823 	lsr	r3, r3, #16
    121c:	e15b21b4 	ldrh	r2, [fp, #-20]
    1220:	e1a01003 	mov	r1, r3
    1224:	e1a03002 	mov	r3, r2
    1228:	e1813003 	orr	r3, r1, r3
    122c:	e1a03803 	lsl	r3, r3, #16
    1230:	e1a03823 	lsr	r3, r3, #16
    1234:	e14b31b4 	strh	r3, [fp, #-20]
			return (clust & 1) ? (wc >> 4) : (wc & 0xFFF);
    1238:	e51b301c 	ldr	r3, [fp, #-28]
    123c:	e2033001 	and	r3, r3, #1	; 0x1
    1240:	e20330ff 	and	r3, r3, #255	; 0xff
    1244:	e3530000 	cmp	r3, #0	; 0x0
    1248:	0a000005 	beq	1264 <get_cluster+0x1ac>
    124c:	e15b31b4 	ldrh	r3, [fp, #-20]
    1250:	e1a03223 	lsr	r3, r3, #4
    1254:	e1a03803 	lsl	r3, r3, #16
    1258:	e1a03823 	lsr	r3, r3, #16
    125c:	e50b3020 	str	r3, [fp, #-32]
    1260:	ea000005 	b	127c <get_cluster+0x1c4>
    1264:	e15b31b4 	ldrh	r3, [fp, #-20]
    1268:	e1a03a03 	lsl	r3, r3, #20
    126c:	e50b3020 	str	r3, [fp, #-32]
    1270:	e51b3020 	ldr	r3, [fp, #-32]
    1274:	e1a03a23 	lsr	r3, r3, #20
    1278:	e50b3020 	str	r3, [fp, #-32]
    127c:	e51b3020 	ldr	r3, [fp, #-32]
    1280:	e50b3024 	str	r3, [fp, #-36]
    1284:	ea000075 	b	1460 <get_cluster+0x3a8>

		case FS_FAT16 :
			if (!move_window(fs, fatsect + (clust / (SS(fs) / 2)))) break;
    1288:	e51b301c 	ldr	r3, [fp, #-28]
    128c:	e1a02423 	lsr	r2, r3, #8
    1290:	e51b3010 	ldr	r3, [fp, #-16]
    1294:	e0823003 	add	r3, r2, r3
    1298:	e51b0018 	ldr	r0, [fp, #-24]
    129c:	e1a01003 	mov	r1, r3
    12a0:	ebfffe5e 	bl	c20 <move_window>
    12a4:	e1a03000 	mov	r3, r0
    12a8:	e3530000 	cmp	r3, #0	; 0x0
    12ac:	0a000069 	beq	1458 <get_cluster+0x3a0>
			return LD_WORD(&fs->win[((WORD)clust * 2) & (SS(fs) - 1)]);
    12b0:	e51b3018 	ldr	r3, [fp, #-24]
    12b4:	e2833030 	add	r3, r3, #48	; 0x30
    12b8:	e1a02003 	mov	r2, r3
    12bc:	e51b301c 	ldr	r3, [fp, #-28]
    12c0:	e1a03803 	lsl	r3, r3, #16
    12c4:	e1a03823 	lsr	r3, r3, #16
    12c8:	e1a03083 	lsl	r3, r3, #1
    12cc:	e1a03b83 	lsl	r3, r3, #23
    12d0:	e1a03ba3 	lsr	r3, r3, #23
    12d4:	e2833001 	add	r3, r3, #1	; 0x1
    12d8:	e0823003 	add	r3, r2, r3
    12dc:	e5d33000 	ldrb	r3, [r3]
    12e0:	e20330ff 	and	r3, r3, #255	; 0xff
    12e4:	e1a03403 	lsl	r3, r3, #8
    12e8:	e1a03803 	lsl	r3, r3, #16
    12ec:	e1a01823 	lsr	r1, r3, #16
    12f0:	e51b3018 	ldr	r3, [fp, #-24]
    12f4:	e2833030 	add	r3, r3, #48	; 0x30
    12f8:	e1a02003 	mov	r2, r3
    12fc:	e51b301c 	ldr	r3, [fp, #-28]
    1300:	e1a03803 	lsl	r3, r3, #16
    1304:	e1a03823 	lsr	r3, r3, #16
    1308:	e1a03083 	lsl	r3, r3, #1
    130c:	e1a03b83 	lsl	r3, r3, #23
    1310:	e1a03ba3 	lsr	r3, r3, #23
    1314:	e0823003 	add	r3, r2, r3
    1318:	e5d33000 	ldrb	r3, [r3]
    131c:	e20330ff 	and	r3, r3, #255	; 0xff
    1320:	e1a02001 	mov	r2, r1
    1324:	e1823003 	orr	r3, r2, r3
    1328:	e1a03803 	lsl	r3, r3, #16
    132c:	e1a03823 	lsr	r3, r3, #16
    1330:	e1a03803 	lsl	r3, r3, #16
    1334:	e1a03823 	lsr	r3, r3, #16
    1338:	e50b3024 	str	r3, [fp, #-36]
    133c:	ea000047 	b	1460 <get_cluster+0x3a8>

		case FS_FAT32 :
			if (!move_window(fs, fatsect + (clust / (SS(fs) / 4)))) break;
    1340:	e51b301c 	ldr	r3, [fp, #-28]
    1344:	e1a023a3 	lsr	r2, r3, #7
    1348:	e51b3010 	ldr	r3, [fp, #-16]
    134c:	e0823003 	add	r3, r2, r3
    1350:	e51b0018 	ldr	r0, [fp, #-24]
    1354:	e1a01003 	mov	r1, r3
    1358:	ebfffe30 	bl	c20 <move_window>
    135c:	e1a03000 	mov	r3, r0
    1360:	e3530000 	cmp	r3, #0	; 0x0
    1364:	0a00003b 	beq	1458 <get_cluster+0x3a0>
			return LD_DWORD(&fs->win[((WORD)clust * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
    1368:	e51b3018 	ldr	r3, [fp, #-24]
    136c:	e2833030 	add	r3, r3, #48	; 0x30
    1370:	e1a02003 	mov	r2, r3
    1374:	e51b301c 	ldr	r3, [fp, #-28]
    1378:	e1a03803 	lsl	r3, r3, #16
    137c:	e1a03823 	lsr	r3, r3, #16
    1380:	e1a03103 	lsl	r3, r3, #2
    1384:	e1a03b83 	lsl	r3, r3, #23
    1388:	e1a03ba3 	lsr	r3, r3, #23
    138c:	e2833003 	add	r3, r3, #3	; 0x3
    1390:	e0823003 	add	r3, r2, r3
    1394:	e5d33000 	ldrb	r3, [r3]
    1398:	e20330ff 	and	r3, r3, #255	; 0xff
    139c:	e1a01c03 	lsl	r1, r3, #24
    13a0:	e51b3018 	ldr	r3, [fp, #-24]
    13a4:	e2833030 	add	r3, r3, #48	; 0x30
    13a8:	e1a02003 	mov	r2, r3
    13ac:	e51b301c 	ldr	r3, [fp, #-28]
    13b0:	e1a03803 	lsl	r3, r3, #16
    13b4:	e1a03823 	lsr	r3, r3, #16
    13b8:	e1a03103 	lsl	r3, r3, #2
    13bc:	e1a03b83 	lsl	r3, r3, #23
    13c0:	e1a03ba3 	lsr	r3, r3, #23
    13c4:	e2833002 	add	r3, r3, #2	; 0x2
    13c8:	e0823003 	add	r3, r2, r3
    13cc:	e5d33000 	ldrb	r3, [r3]
    13d0:	e20330ff 	and	r3, r3, #255	; 0xff
    13d4:	e1a03803 	lsl	r3, r3, #16
    13d8:	e1811003 	orr	r1, r1, r3
    13dc:	e51b3018 	ldr	r3, [fp, #-24]
    13e0:	e2833030 	add	r3, r3, #48	; 0x30
    13e4:	e1a02003 	mov	r2, r3
    13e8:	e51b301c 	ldr	r3, [fp, #-28]
    13ec:	e1a03803 	lsl	r3, r3, #16
    13f0:	e1a03823 	lsr	r3, r3, #16
    13f4:	e1a03103 	lsl	r3, r3, #2
    13f8:	e1a03b83 	lsl	r3, r3, #23
    13fc:	e1a03ba3 	lsr	r3, r3, #23
    1400:	e2833001 	add	r3, r3, #1	; 0x1
    1404:	e0823003 	add	r3, r2, r3
    1408:	e5d33000 	ldrb	r3, [r3]
    140c:	e20330ff 	and	r3, r3, #255	; 0xff
    1410:	e1a03403 	lsl	r3, r3, #8
    1414:	e1811003 	orr	r1, r1, r3
    1418:	e51b3018 	ldr	r3, [fp, #-24]
    141c:	e2833030 	add	r3, r3, #48	; 0x30
    1420:	e1a02003 	mov	r2, r3
    1424:	e51b301c 	ldr	r3, [fp, #-28]
    1428:	e1a03803 	lsl	r3, r3, #16
    142c:	e1a03823 	lsr	r3, r3, #16
    1430:	e1a03103 	lsl	r3, r3, #2
    1434:	e1a03b83 	lsl	r3, r3, #23
    1438:	e1a03ba3 	lsr	r3, r3, #23
    143c:	e0823003 	add	r3, r2, r3
    1440:	e5d33000 	ldrb	r3, [r3]
    1444:	e20330ff 	and	r3, r3, #255	; 0xff
    1448:	e1813003 	orr	r3, r1, r3
    144c:	e3c3320f 	bic	r3, r3, #-268435456	; 0xf0000000
    1450:	e50b3024 	str	r3, [fp, #-36]
    1454:	ea000001 	b	1460 <get_cluster+0x3a8>
		}
	}

	return 1;	/* Out of cluster range, or an error occured */
    1458:	e3a03001 	mov	r3, #1	; 0x1
    145c:	e50b3024 	str	r3, [fp, #-36]
    1460:	e51b3024 	ldr	r3, [fp, #-36]
}
    1464:	e1a00003 	mov	r0, r3
    1468:	e24bd00c 	sub	sp, fp, #12	; 0xc
    146c:	e89da800 	ldm	sp, {fp, sp, pc}

00001470 <put_cluster>:
BOOL put_cluster (	/* TRUE: successful, FALSE: failed */
	FATFS *fs,		/* File system object */
	DWORD clust,	/* Cluster# to change (must be 2 to fs->max_clust-1) */
	DWORD val		/* New value to mark the cluster */
)
{
    1470:	e1a0c00d 	mov	ip, sp
    1474:	e92dd800 	push	{fp, ip, lr, pc}
    1478:	e24cb004 	sub	fp, ip, #4	; 0x4
    147c:	e24dd028 	sub	sp, sp, #40	; 0x28
    1480:	e50b001c 	str	r0, [fp, #-28]
    1484:	e50b1020 	str	r1, [fp, #-32]
    1488:	e50b2024 	str	r2, [fp, #-36]
	WORD bc;
	BYTE *p;
	DWORD fatsect;


	fatsect = fs->fatbase;
    148c:	e51b301c 	ldr	r3, [fp, #-28]
    1490:	e5933010 	ldr	r3, [r3, #16]
    1494:	e50b3010 	str	r3, [fp, #-16]
	switch (fs->fs_type) {
    1498:	e51b301c 	ldr	r3, [fp, #-28]
    149c:	e5d3302a 	ldrb	r3, [r3, #42]
    14a0:	e50b3034 	str	r3, [fp, #-52]
    14a4:	e51b1034 	ldr	r1, [fp, #-52]
    14a8:	e3510002 	cmp	r1, #2	; 0x2
    14ac:	0a000079 	beq	1698 <put_cluster+0x228>
    14b0:	e51b3034 	ldr	r3, [fp, #-52]
    14b4:	e3530003 	cmp	r3, #3	; 0x3
    14b8:	0a0000a4 	beq	1750 <put_cluster+0x2e0>
    14bc:	e51b1034 	ldr	r1, [fp, #-52]
    14c0:	e3510001 	cmp	r1, #1	; 0x1
    14c4:	1a0000ed 	bne	1880 <put_cluster+0x410>
	case FS_FAT12 :
		bc = (WORD)clust * 3 / 2;
    14c8:	e51b3020 	ldr	r3, [fp, #-32]
    14cc:	e1a03803 	lsl	r3, r3, #16
    14d0:	e1a03823 	lsr	r3, r3, #16
    14d4:	e1a02003 	mov	r2, r3
    14d8:	e1a03002 	mov	r3, r2
    14dc:	e1a03083 	lsl	r3, r3, #1
    14e0:	e0832002 	add	r2, r3, r2
    14e4:	e1a03fa2 	lsr	r3, r2, #31
    14e8:	e0833002 	add	r3, r3, r2
    14ec:	e1a030c3 	asr	r3, r3, #1
    14f0:	e14b31b6 	strh	r3, [fp, #-22]
		if (!move_window(fs, fatsect + (bc / SS(fs)))) return FALSE;
    14f4:	e15b31b6 	ldrh	r3, [fp, #-22]
    14f8:	e1a034a3 	lsr	r3, r3, #9
    14fc:	e1a03803 	lsl	r3, r3, #16
    1500:	e1a03823 	lsr	r3, r3, #16
    1504:	e1a02003 	mov	r2, r3
    1508:	e51b3010 	ldr	r3, [fp, #-16]
    150c:	e0823003 	add	r3, r2, r3
    1510:	e51b001c 	ldr	r0, [fp, #-28]
    1514:	e1a01003 	mov	r1, r3
    1518:	ebfffdc0 	bl	c20 <move_window>
    151c:	e1a03000 	mov	r3, r0
    1520:	e3530000 	cmp	r3, #0	; 0x0
    1524:	1a000002 	bne	1534 <put_cluster+0xc4>
    1528:	e3a03000 	mov	r3, #0	; 0x0
    152c:	e50b3030 	str	r3, [fp, #-48]
    1530:	ea0000da 	b	18a0 <put_cluster+0x430>
		p = &fs->win[bc & (SS(fs) - 1)];
    1534:	e51b301c 	ldr	r3, [fp, #-28]
    1538:	e2832030 	add	r2, r3, #48	; 0x30
    153c:	e15b31b6 	ldrh	r3, [fp, #-22]
    1540:	e1a03b83 	lsl	r3, r3, #23
    1544:	e1a03ba3 	lsr	r3, r3, #23
    1548:	e0823003 	add	r3, r2, r3
    154c:	e50b3014 	str	r3, [fp, #-20]
		*p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    1550:	e51b3020 	ldr	r3, [fp, #-32]
    1554:	e2033001 	and	r3, r3, #1	; 0x1
    1558:	e20330ff 	and	r3, r3, #255	; 0xff
    155c:	e3530000 	cmp	r3, #0	; 0x0
    1560:	0a00000c 	beq	1598 <put_cluster+0x128>
    1564:	e51b3014 	ldr	r3, [fp, #-20]
    1568:	e5d33000 	ldrb	r3, [r3]
    156c:	e20320ff 	and	r2, r3, #255	; 0xff
    1570:	e202200f 	and	r2, r2, #15	; 0xf
    1574:	e51b3024 	ldr	r3, [fp, #-36]
    1578:	e20330ff 	and	r3, r3, #255	; 0xff
    157c:	e1a03203 	lsl	r3, r3, #4
    1580:	e20330ff 	and	r3, r3, #255	; 0xff
    1584:	e1823003 	orr	r3, r2, r3
    1588:	e20330ff 	and	r3, r3, #255	; 0xff
    158c:	e20330ff 	and	r3, r3, #255	; 0xff
    1590:	e50b302c 	str	r3, [fp, #-44]
    1594:	ea000002 	b	15a4 <put_cluster+0x134>
    1598:	e51b3024 	ldr	r3, [fp, #-36]
    159c:	e20330ff 	and	r3, r3, #255	; 0xff
    15a0:	e50b302c 	str	r3, [fp, #-44]
    15a4:	e51b2014 	ldr	r2, [fp, #-20]
    15a8:	e51b102c 	ldr	r1, [fp, #-44]
    15ac:	e1a03001 	mov	r3, r1
    15b0:	e5c23000 	strb	r3, [r2]
		bc++;
    15b4:	e15b31b6 	ldrh	r3, [fp, #-22]
    15b8:	e2833001 	add	r3, r3, #1	; 0x1
    15bc:	e14b31b6 	strh	r3, [fp, #-22]
		fs->winflag = 1;
    15c0:	e51b201c 	ldr	r2, [fp, #-28]
    15c4:	e3a03001 	mov	r3, #1	; 0x1
    15c8:	e5c2302e 	strb	r3, [r2, #46]
		if (!move_window(fs, fatsect + (bc / SS(fs)))) return FALSE;
    15cc:	e15b31b6 	ldrh	r3, [fp, #-22]
    15d0:	e1a034a3 	lsr	r3, r3, #9
    15d4:	e1a03803 	lsl	r3, r3, #16
    15d8:	e1a03823 	lsr	r3, r3, #16
    15dc:	e1a02003 	mov	r2, r3
    15e0:	e51b3010 	ldr	r3, [fp, #-16]
    15e4:	e0823003 	add	r3, r2, r3
    15e8:	e51b001c 	ldr	r0, [fp, #-28]
    15ec:	e1a01003 	mov	r1, r3
    15f0:	ebfffd8a 	bl	c20 <move_window>
    15f4:	e1a03000 	mov	r3, r0
    15f8:	e3530000 	cmp	r3, #0	; 0x0
    15fc:	1a000002 	bne	160c <put_cluster+0x19c>
    1600:	e3a03000 	mov	r3, #0	; 0x0
    1604:	e50b3030 	str	r3, [fp, #-48]
    1608:	ea0000a4 	b	18a0 <put_cluster+0x430>
		p = &fs->win[bc & (SS(fs) - 1)];
    160c:	e51b301c 	ldr	r3, [fp, #-28]
    1610:	e2832030 	add	r2, r3, #48	; 0x30
    1614:	e15b31b6 	ldrh	r3, [fp, #-22]
    1618:	e1a03b83 	lsl	r3, r3, #23
    161c:	e1a03ba3 	lsr	r3, r3, #23
    1620:	e0823003 	add	r3, r2, r3
    1624:	e50b3014 	str	r3, [fp, #-20]
		*p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    1628:	e51b3020 	ldr	r3, [fp, #-32]
    162c:	e2033001 	and	r3, r3, #1	; 0x1
    1630:	e20330ff 	and	r3, r3, #255	; 0xff
    1634:	e3530000 	cmp	r3, #0	; 0x0
    1638:	0a000004 	beq	1650 <put_cluster+0x1e0>
    163c:	e51b3024 	ldr	r3, [fp, #-36]
    1640:	e1a03223 	lsr	r3, r3, #4
    1644:	e20330ff 	and	r3, r3, #255	; 0xff
    1648:	e50b3028 	str	r3, [fp, #-40]
    164c:	ea00000c 	b	1684 <put_cluster+0x214>
    1650:	e51b3014 	ldr	r3, [fp, #-20]
    1654:	e5d33000 	ldrb	r3, [r3]
    1658:	e20320ff 	and	r2, r3, #255	; 0xff
    165c:	e20220f0 	and	r2, r2, #240	; 0xf0
    1660:	e51b3024 	ldr	r3, [fp, #-36]
    1664:	e1a03423 	lsr	r3, r3, #8
    1668:	e20330ff 	and	r3, r3, #255	; 0xff
    166c:	e20330ff 	and	r3, r3, #255	; 0xff
    1670:	e203300f 	and	r3, r3, #15	; 0xf
    1674:	e1823003 	orr	r3, r2, r3
    1678:	e20330ff 	and	r3, r3, #255	; 0xff
    167c:	e20330ff 	and	r3, r3, #255	; 0xff
    1680:	e50b3028 	str	r3, [fp, #-40]
    1684:	e51b2014 	ldr	r2, [fp, #-20]
    1688:	e51b1028 	ldr	r1, [fp, #-40]
    168c:	e1a03001 	mov	r3, r1
    1690:	e5c23000 	strb	r3, [r2]
    1694:	ea00007c 	b	188c <put_cluster+0x41c>
		break;

	case FS_FAT16 :
		if (!move_window(fs, fatsect + (clust / (SS(fs) / 2)))) return FALSE;
    1698:	e51b3020 	ldr	r3, [fp, #-32]
    169c:	e1a02423 	lsr	r2, r3, #8
    16a0:	e51b3010 	ldr	r3, [fp, #-16]
    16a4:	e0823003 	add	r3, r2, r3
    16a8:	e51b001c 	ldr	r0, [fp, #-28]
    16ac:	e1a01003 	mov	r1, r3
    16b0:	ebfffd5a 	bl	c20 <move_window>
    16b4:	e1a03000 	mov	r3, r0
    16b8:	e3530000 	cmp	r3, #0	; 0x0
    16bc:	1a000002 	bne	16cc <put_cluster+0x25c>
    16c0:	e3a03000 	mov	r3, #0	; 0x0
    16c4:	e50b3030 	str	r3, [fp, #-48]
    16c8:	ea000074 	b	18a0 <put_cluster+0x430>
		ST_WORD(&fs->win[((WORD)clust * 2) & (SS(fs) - 1)], (WORD)val);
    16cc:	e51b301c 	ldr	r3, [fp, #-28]
    16d0:	e2833030 	add	r3, r3, #48	; 0x30
    16d4:	e1a02003 	mov	r2, r3
    16d8:	e51b3020 	ldr	r3, [fp, #-32]
    16dc:	e1a03803 	lsl	r3, r3, #16
    16e0:	e1a03823 	lsr	r3, r3, #16
    16e4:	e1a03083 	lsl	r3, r3, #1
    16e8:	e1a03b83 	lsl	r3, r3, #23
    16ec:	e1a03ba3 	lsr	r3, r3, #23
    16f0:	e0822003 	add	r2, r2, r3
    16f4:	e51b3024 	ldr	r3, [fp, #-36]
    16f8:	e20330ff 	and	r3, r3, #255	; 0xff
    16fc:	e5c23000 	strb	r3, [r2]
    1700:	e51b301c 	ldr	r3, [fp, #-28]
    1704:	e2833030 	add	r3, r3, #48	; 0x30
    1708:	e1a02003 	mov	r2, r3
    170c:	e51b3020 	ldr	r3, [fp, #-32]
    1710:	e1a03803 	lsl	r3, r3, #16
    1714:	e1a03823 	lsr	r3, r3, #16
    1718:	e1a03083 	lsl	r3, r3, #1
    171c:	e1a03b83 	lsl	r3, r3, #23
    1720:	e1a03ba3 	lsr	r3, r3, #23
    1724:	e2833001 	add	r3, r3, #1	; 0x1
    1728:	e0822003 	add	r2, r2, r3
    172c:	e51b3024 	ldr	r3, [fp, #-36]
    1730:	e1a03803 	lsl	r3, r3, #16
    1734:	e1a03823 	lsr	r3, r3, #16
    1738:	e1a03423 	lsr	r3, r3, #8
    173c:	e1a03803 	lsl	r3, r3, #16
    1740:	e1a03823 	lsr	r3, r3, #16
    1744:	e20330ff 	and	r3, r3, #255	; 0xff
    1748:	e5c23000 	strb	r3, [r2]
    174c:	ea00004e 	b	188c <put_cluster+0x41c>
		break;

	case FS_FAT32 :
		if (!move_window(fs, fatsect + (clust / (SS(fs) / 4)))) return FALSE;
    1750:	e51b3020 	ldr	r3, [fp, #-32]
    1754:	e1a023a3 	lsr	r2, r3, #7
    1758:	e51b3010 	ldr	r3, [fp, #-16]
    175c:	e0823003 	add	r3, r2, r3
    1760:	e51b001c 	ldr	r0, [fp, #-28]
    1764:	e1a01003 	mov	r1, r3
    1768:	ebfffd2c 	bl	c20 <move_window>
    176c:	e1a03000 	mov	r3, r0
    1770:	e3530000 	cmp	r3, #0	; 0x0
    1774:	1a000002 	bne	1784 <put_cluster+0x314>
    1778:	e3a01000 	mov	r1, #0	; 0x0
    177c:	e50b1030 	str	r1, [fp, #-48]
    1780:	ea000046 	b	18a0 <put_cluster+0x430>
		ST_DWORD(&fs->win[((WORD)clust * 4) & (SS(fs) - 1)], val);
    1784:	e51b301c 	ldr	r3, [fp, #-28]
    1788:	e2833030 	add	r3, r3, #48	; 0x30
    178c:	e1a02003 	mov	r2, r3
    1790:	e51b3020 	ldr	r3, [fp, #-32]
    1794:	e1a03803 	lsl	r3, r3, #16
    1798:	e1a03823 	lsr	r3, r3, #16
    179c:	e1a03103 	lsl	r3, r3, #2
    17a0:	e1a03b83 	lsl	r3, r3, #23
    17a4:	e1a03ba3 	lsr	r3, r3, #23
    17a8:	e0822003 	add	r2, r2, r3
    17ac:	e51b3024 	ldr	r3, [fp, #-36]
    17b0:	e20330ff 	and	r3, r3, #255	; 0xff
    17b4:	e5c23000 	strb	r3, [r2]
    17b8:	e51b301c 	ldr	r3, [fp, #-28]
    17bc:	e2833030 	add	r3, r3, #48	; 0x30
    17c0:	e1a02003 	mov	r2, r3
    17c4:	e51b3020 	ldr	r3, [fp, #-32]
    17c8:	e1a03803 	lsl	r3, r3, #16
    17cc:	e1a03823 	lsr	r3, r3, #16
    17d0:	e1a03103 	lsl	r3, r3, #2
    17d4:	e1a03b83 	lsl	r3, r3, #23
    17d8:	e1a03ba3 	lsr	r3, r3, #23
    17dc:	e2833001 	add	r3, r3, #1	; 0x1
    17e0:	e0822003 	add	r2, r2, r3
    17e4:	e51b3024 	ldr	r3, [fp, #-36]
    17e8:	e1a03803 	lsl	r3, r3, #16
    17ec:	e1a03823 	lsr	r3, r3, #16
    17f0:	e1a03423 	lsr	r3, r3, #8
    17f4:	e1a03803 	lsl	r3, r3, #16
    17f8:	e1a03823 	lsr	r3, r3, #16
    17fc:	e20330ff 	and	r3, r3, #255	; 0xff
    1800:	e5c23000 	strb	r3, [r2]
    1804:	e51b301c 	ldr	r3, [fp, #-28]
    1808:	e2833030 	add	r3, r3, #48	; 0x30
    180c:	e1a02003 	mov	r2, r3
    1810:	e51b3020 	ldr	r3, [fp, #-32]
    1814:	e1a03803 	lsl	r3, r3, #16
    1818:	e1a03823 	lsr	r3, r3, #16
    181c:	e1a03103 	lsl	r3, r3, #2
    1820:	e1a03b83 	lsl	r3, r3, #23
    1824:	e1a03ba3 	lsr	r3, r3, #23
    1828:	e2833002 	add	r3, r3, #2	; 0x2
    182c:	e0822003 	add	r2, r2, r3
    1830:	e51b3024 	ldr	r3, [fp, #-36]
    1834:	e1a03823 	lsr	r3, r3, #16
    1838:	e20330ff 	and	r3, r3, #255	; 0xff
    183c:	e5c23000 	strb	r3, [r2]
    1840:	e51b301c 	ldr	r3, [fp, #-28]
    1844:	e2833030 	add	r3, r3, #48	; 0x30
    1848:	e1a02003 	mov	r2, r3
    184c:	e51b3020 	ldr	r3, [fp, #-32]
    1850:	e1a03803 	lsl	r3, r3, #16
    1854:	e1a03823 	lsr	r3, r3, #16
    1858:	e1a03103 	lsl	r3, r3, #2
    185c:	e1a03b83 	lsl	r3, r3, #23
    1860:	e1a03ba3 	lsr	r3, r3, #23
    1864:	e2833003 	add	r3, r3, #3	; 0x3
    1868:	e0822003 	add	r2, r2, r3
    186c:	e51b3024 	ldr	r3, [fp, #-36]
    1870:	e1a03c23 	lsr	r3, r3, #24
    1874:	e20330ff 	and	r3, r3, #255	; 0xff
    1878:	e5c23000 	strb	r3, [r2]
    187c:	ea000002 	b	188c <put_cluster+0x41c>
		break;

	default :
		return FALSE;
    1880:	e3a03000 	mov	r3, #0	; 0x0
    1884:	e50b3030 	str	r3, [fp, #-48]
    1888:	ea000004 	b	18a0 <put_cluster+0x430>
	}
	fs->winflag = 1;
    188c:	e51b301c 	ldr	r3, [fp, #-28]
    1890:	e3a02001 	mov	r2, #1	; 0x1
    1894:	e5c3202e 	strb	r2, [r3, #46]
	return TRUE;
    1898:	e3a01001 	mov	r1, #1	; 0x1
    189c:	e50b1030 	str	r1, [fp, #-48]
    18a0:	e51b3030 	ldr	r3, [fp, #-48]
}
    18a4:	e1a00003 	mov	r0, r3
    18a8:	e24bd00c 	sub	sp, fp, #12	; 0xc
    18ac:	e89da800 	ldm	sp, {fp, sp, pc}

000018b0 <remove_chain>:
static
BOOL remove_chain (	/* TRUE: successful, FALSE: failed */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to remove chain from */
)
{
    18b0:	e1a0c00d 	mov	ip, sp
    18b4:	e92dd800 	push	{fp, ip, lr, pc}
    18b8:	e24cb004 	sub	fp, ip, #4	; 0x4
    18bc:	e24dd010 	sub	sp, sp, #16	; 0x10
    18c0:	e50b0014 	str	r0, [fp, #-20]
    18c4:	e50b1018 	str	r1, [fp, #-24]
    18c8:	ea000022 	b	1958 <remove_chain+0xa8>
	DWORD nxt;


	while (clust >= 2 && clust < fs->max_clust) {
		nxt = get_cluster(fs, clust);
    18cc:	e51b0014 	ldr	r0, [fp, #-20]
    18d0:	e51b1018 	ldr	r1, [fp, #-24]
    18d4:	ebfffdf7 	bl	10b8 <get_cluster>
    18d8:	e1a03000 	mov	r3, r0
    18dc:	e50b3010 	str	r3, [fp, #-16]
		if (nxt == 1) return FALSE;
    18e0:	e51b3010 	ldr	r3, [fp, #-16]
    18e4:	e3530001 	cmp	r3, #1	; 0x1
    18e8:	1a000002 	bne	18f8 <remove_chain+0x48>
    18ec:	e3a03000 	mov	r3, #0	; 0x0
    18f0:	e50b301c 	str	r3, [fp, #-28]
    18f4:	ea000021 	b	1980 <remove_chain+0xd0>
		if (!put_cluster(fs, clust, 0)) return FALSE;
    18f8:	e51b0014 	ldr	r0, [fp, #-20]
    18fc:	e51b1018 	ldr	r1, [fp, #-24]
    1900:	e3a02000 	mov	r2, #0	; 0x0
    1904:	ebfffed9 	bl	1470 <put_cluster>
    1908:	e1a03000 	mov	r3, r0
    190c:	e3530000 	cmp	r3, #0	; 0x0
    1910:	1a000002 	bne	1920 <remove_chain+0x70>
    1914:	e3a03000 	mov	r3, #0	; 0x0
    1918:	e50b301c 	str	r3, [fp, #-28]
    191c:	ea000017 	b	1980 <remove_chain+0xd0>
		if (fs->free_clust != 0xFFFFFFFF) {
    1920:	e51b3014 	ldr	r3, [fp, #-20]
    1924:	e5933020 	ldr	r3, [r3, #32]
    1928:	e3730001 	cmn	r3, #1	; 0x1
    192c:	0a000007 	beq	1950 <remove_chain+0xa0>
			fs->free_clust++;
    1930:	e51b3014 	ldr	r3, [fp, #-20]
    1934:	e5933020 	ldr	r3, [r3, #32]
    1938:	e2832001 	add	r2, r3, #1	; 0x1
    193c:	e51b3014 	ldr	r3, [fp, #-20]
    1940:	e5832020 	str	r2, [r3, #32]
#if _USE_FSINFO
			fs->fsi_flag = 1;
    1944:	e51b2014 	ldr	r2, [fp, #-20]
    1948:	e3a03001 	mov	r3, #1	; 0x1
    194c:	e5c23028 	strb	r3, [r2, #40]
#endif
		}
		clust = nxt;
    1950:	e51b3010 	ldr	r3, [fp, #-16]
    1954:	e50b3018 	str	r3, [fp, #-24]
)
{
	DWORD nxt;


	while (clust >= 2 && clust < fs->max_clust) {
    1958:	e51b3018 	ldr	r3, [fp, #-24]
    195c:	e3530001 	cmp	r3, #1	; 0x1
    1960:	9a000004 	bls	1978 <remove_chain+0xc8>
    1964:	e51b3014 	ldr	r3, [fp, #-20]
    1968:	e593200c 	ldr	r2, [r3, #12]
    196c:	e51b3018 	ldr	r3, [fp, #-24]
    1970:	e1520003 	cmp	r2, r3
    1974:	8affffd4 	bhi	18cc <remove_chain+0x1c>
			fs->fsi_flag = 1;
#endif
		}
		clust = nxt;
	}
	return TRUE;
    1978:	e3a03001 	mov	r3, #1	; 0x1
    197c:	e50b301c 	str	r3, [fp, #-28]
    1980:	e51b301c 	ldr	r3, [fp, #-28]
}
    1984:	e1a00003 	mov	r0, r3
    1988:	e24bd00c 	sub	sp, fp, #12	; 0xc
    198c:	e89da800 	ldm	sp, {fp, sp, pc}

00001990 <create_chain>:
static
DWORD create_chain (	/* 0: No free cluster, 1: Error, >=2: New cluster number */
	FATFS *fs,			/* File system object */
	DWORD clust			/* Cluster# to stretch, 0 means create new */
)
{
    1990:	e1a0c00d 	mov	ip, sp
    1994:	e92dd800 	push	{fp, ip, lr, pc}
    1998:	e24cb004 	sub	fp, ip, #4	; 0x4
    199c:	e24dd01c 	sub	sp, sp, #28	; 0x1c
    19a0:	e50b0020 	str	r0, [fp, #-32]
    19a4:	e50b1024 	str	r1, [fp, #-36]
	DWORD cstat, ncl, scl, mcl = fs->max_clust;
    19a8:	e51b3020 	ldr	r3, [fp, #-32]
    19ac:	e593300c 	ldr	r3, [r3, #12]
    19b0:	e50b3010 	str	r3, [fp, #-16]


	if (clust == 0) {		/* Create new chain */
    19b4:	e51b3024 	ldr	r3, [fp, #-36]
    19b8:	e3530000 	cmp	r3, #0	; 0x0
    19bc:	1a00000c 	bne	19f4 <create_chain+0x64>
		scl = fs->last_clust;			/* Get suggested start point */
    19c0:	e51b3020 	ldr	r3, [fp, #-32]
    19c4:	e593301c 	ldr	r3, [r3, #28]
    19c8:	e50b3014 	str	r3, [fp, #-20]
		if (scl == 0 || scl >= mcl) scl = 1;
    19cc:	e51b3014 	ldr	r3, [fp, #-20]
    19d0:	e3530000 	cmp	r3, #0	; 0x0
    19d4:	0a000003 	beq	19e8 <create_chain+0x58>
    19d8:	e51b2014 	ldr	r2, [fp, #-20]
    19dc:	e51b3010 	ldr	r3, [fp, #-16]
    19e0:	e1520003 	cmp	r2, r3
    19e4:	3a000016 	bcc	1a44 <create_chain+0xb4>
    19e8:	e3a03001 	mov	r3, #1	; 0x1
    19ec:	e50b3014 	str	r3, [fp, #-20]
    19f0:	ea000013 	b	1a44 <create_chain+0xb4>
	}
	else {					/* Stretch existing chain */
		cstat = get_cluster(fs, clust);	/* Check the cluster status */
    19f4:	e51b0020 	ldr	r0, [fp, #-32]
    19f8:	e51b1024 	ldr	r1, [fp, #-36]
    19fc:	ebfffdad 	bl	10b8 <get_cluster>
    1a00:	e1a03000 	mov	r3, r0
    1a04:	e50b301c 	str	r3, [fp, #-28]
		if (cstat < 2) return 1;		/* It is an invalid cluster */
    1a08:	e51b301c 	ldr	r3, [fp, #-28]
    1a0c:	e3530001 	cmp	r3, #1	; 0x1
    1a10:	8a000002 	bhi	1a20 <create_chain+0x90>
    1a14:	e3a03001 	mov	r3, #1	; 0x1
    1a18:	e50b3028 	str	r3, [fp, #-40]
    1a1c:	ea000057 	b	1b80 <create_chain+0x1f0>
		if (cstat < mcl) return cstat;	/* It is already followed by next cluster */
    1a20:	e51b201c 	ldr	r2, [fp, #-28]
    1a24:	e51b3010 	ldr	r3, [fp, #-16]
    1a28:	e1520003 	cmp	r2, r3
    1a2c:	2a000002 	bcs	1a3c <create_chain+0xac>
    1a30:	e51b301c 	ldr	r3, [fp, #-28]
    1a34:	e50b3028 	str	r3, [fp, #-40]
    1a38:	ea000050 	b	1b80 <create_chain+0x1f0>
		scl = clust;
    1a3c:	e51b3024 	ldr	r3, [fp, #-36]
    1a40:	e50b3014 	str	r3, [fp, #-20]
	}

	ncl = scl;				/* Start cluster */
    1a44:	e51b3014 	ldr	r3, [fp, #-20]
    1a48:	e50b3018 	str	r3, [fp, #-24]
	for (;;) {
		ncl++;							/* Next cluster */
    1a4c:	e51b3018 	ldr	r3, [fp, #-24]
    1a50:	e2833001 	add	r3, r3, #1	; 0x1
    1a54:	e50b3018 	str	r3, [fp, #-24]
		if (ncl >= mcl) {				/* Wrap around */
    1a58:	e51b2018 	ldr	r2, [fp, #-24]
    1a5c:	e51b3010 	ldr	r3, [fp, #-16]
    1a60:	e1520003 	cmp	r2, r3
    1a64:	3a000008 	bcc	1a8c <create_chain+0xfc>
			ncl = 2;
    1a68:	e3a03002 	mov	r3, #2	; 0x2
    1a6c:	e50b3018 	str	r3, [fp, #-24]
			if (ncl > scl) return 0;	/* No free custer */
    1a70:	e51b2018 	ldr	r2, [fp, #-24]
    1a74:	e51b3014 	ldr	r3, [fp, #-20]
    1a78:	e1520003 	cmp	r2, r3
    1a7c:	9a000002 	bls	1a8c <create_chain+0xfc>
    1a80:	e3a03000 	mov	r3, #0	; 0x0
    1a84:	e50b3028 	str	r3, [fp, #-40]
    1a88:	ea00003c 	b	1b80 <create_chain+0x1f0>
		}
		cstat = get_cluster(fs, ncl);	/* Get the cluster status */
    1a8c:	e51b0020 	ldr	r0, [fp, #-32]
    1a90:	e51b1018 	ldr	r1, [fp, #-24]
    1a94:	ebfffd87 	bl	10b8 <get_cluster>
    1a98:	e1a03000 	mov	r3, r0
    1a9c:	e50b301c 	str	r3, [fp, #-28]
		if (cstat == 0) break;			/* Found a free cluster */
    1aa0:	e51b301c 	ldr	r3, [fp, #-28]
    1aa4:	e3530000 	cmp	r3, #0	; 0x0
    1aa8:	0a00000c 	beq	1ae0 <create_chain+0x150>
		if (cstat == 1) return 1;		/* Any error occured */
    1aac:	e51b301c 	ldr	r3, [fp, #-28]
    1ab0:	e3530001 	cmp	r3, #1	; 0x1
    1ab4:	1a000002 	bne	1ac4 <create_chain+0x134>
    1ab8:	e3a03001 	mov	r3, #1	; 0x1
    1abc:	e50b3028 	str	r3, [fp, #-40]
    1ac0:	ea00002e 	b	1b80 <create_chain+0x1f0>
		if (ncl == scl) return 0;		/* No free custer */
    1ac4:	e51b2018 	ldr	r2, [fp, #-24]
    1ac8:	e51b3014 	ldr	r3, [fp, #-20]
    1acc:	e1520003 	cmp	r2, r3
    1ad0:	1affffdd 	bne	1a4c <create_chain+0xbc>
    1ad4:	e3a03000 	mov	r3, #0	; 0x0
    1ad8:	e50b3028 	str	r3, [fp, #-40]
    1adc:	ea000027 	b	1b80 <create_chain+0x1f0>
	}

	if (!put_cluster(fs, ncl, 0x0FFFFFFF)) return 1;			/* Mark the new cluster "in use" */
    1ae0:	e51b0020 	ldr	r0, [fp, #-32]
    1ae4:	e51b1018 	ldr	r1, [fp, #-24]
    1ae8:	e3e0220f 	mvn	r2, #-268435456	; 0xf0000000
    1aec:	ebfffe5f 	bl	1470 <put_cluster>
    1af0:	e1a03000 	mov	r3, r0
    1af4:	e3530000 	cmp	r3, #0	; 0x0
    1af8:	1a000002 	bne	1b08 <create_chain+0x178>
    1afc:	e3a03001 	mov	r3, #1	; 0x1
    1b00:	e50b3028 	str	r3, [fp, #-40]
    1b04:	ea00001d 	b	1b80 <create_chain+0x1f0>
	if (clust != 0 && !put_cluster(fs, clust, ncl)) return 1;	/* Link it to previous one if needed */
    1b08:	e51b3024 	ldr	r3, [fp, #-36]
    1b0c:	e3530000 	cmp	r3, #0	; 0x0
    1b10:	0a000009 	beq	1b3c <create_chain+0x1ac>
    1b14:	e51b0020 	ldr	r0, [fp, #-32]
    1b18:	e51b1024 	ldr	r1, [fp, #-36]
    1b1c:	e51b2018 	ldr	r2, [fp, #-24]
    1b20:	ebfffe52 	bl	1470 <put_cluster>
    1b24:	e1a03000 	mov	r3, r0
    1b28:	e3530000 	cmp	r3, #0	; 0x0
    1b2c:	1a000002 	bne	1b3c <create_chain+0x1ac>
    1b30:	e3a03001 	mov	r3, #1	; 0x1
    1b34:	e50b3028 	str	r3, [fp, #-40]
    1b38:	ea000010 	b	1b80 <create_chain+0x1f0>

	fs->last_clust = ncl;				/* Update fsinfo */
    1b3c:	e51b2020 	ldr	r2, [fp, #-32]
    1b40:	e51b3018 	ldr	r3, [fp, #-24]
    1b44:	e582301c 	str	r3, [r2, #28]
	if (fs->free_clust != 0xFFFFFFFF) {
    1b48:	e51b3020 	ldr	r3, [fp, #-32]
    1b4c:	e5933020 	ldr	r3, [r3, #32]
    1b50:	e3730001 	cmn	r3, #1	; 0x1
    1b54:	0a000007 	beq	1b78 <create_chain+0x1e8>
		fs->free_clust--;
    1b58:	e51b3020 	ldr	r3, [fp, #-32]
    1b5c:	e5933020 	ldr	r3, [r3, #32]
    1b60:	e2432001 	sub	r2, r3, #1	; 0x1
    1b64:	e51b3020 	ldr	r3, [fp, #-32]
    1b68:	e5832020 	str	r2, [r3, #32]
#if _USE_FSINFO
		fs->fsi_flag = 1;
    1b6c:	e51b2020 	ldr	r2, [fp, #-32]
    1b70:	e3a03001 	mov	r3, #1	; 0x1
    1b74:	e5c23028 	strb	r3, [r2, #40]
#endif
	}

	return ncl;		/* Return new cluster number */
    1b78:	e51b3018 	ldr	r3, [fp, #-24]
    1b7c:	e50b3028 	str	r3, [fp, #-40]
    1b80:	e51b3028 	ldr	r3, [fp, #-40]
}
    1b84:	e1a00003 	mov	r0, r3
    1b88:	e24bd00c 	sub	sp, fp, #12	; 0xc
    1b8c:	e89da800 	ldm	sp, {fp, sp, pc}

00001b90 <clust2sect>:
static
DWORD clust2sect (	/* !=0: sector number, 0: failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
    1b90:	e1a0c00d 	mov	ip, sp
    1b94:	e92dd800 	push	{fp, ip, lr, pc}
    1b98:	e24cb004 	sub	fp, ip, #4	; 0x4
    1b9c:	e24dd00c 	sub	sp, sp, #12	; 0xc
    1ba0:	e50b0010 	str	r0, [fp, #-16]
    1ba4:	e50b1014 	str	r1, [fp, #-20]
	clust -= 2;
    1ba8:	e51b3014 	ldr	r3, [fp, #-20]
    1bac:	e2433002 	sub	r3, r3, #2	; 0x2
    1bb0:	e50b3014 	str	r3, [fp, #-20]
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    1bb4:	e51b3010 	ldr	r3, [fp, #-16]
    1bb8:	e593300c 	ldr	r3, [r3, #12]
    1bbc:	e2432002 	sub	r2, r3, #2	; 0x2
    1bc0:	e51b3014 	ldr	r3, [fp, #-20]
    1bc4:	e1520003 	cmp	r2, r3
    1bc8:	8a000002 	bhi	1bd8 <clust2sect+0x48>
    1bcc:	e3a03000 	mov	r3, #0	; 0x0
    1bd0:	e50b3018 	str	r3, [fp, #-24]
    1bd4:	ea000008 	b	1bfc <clust2sect+0x6c>
	return clust * fs->csize + fs->database;
    1bd8:	e51b3010 	ldr	r3, [fp, #-16]
    1bdc:	e5d3302b 	ldrb	r3, [r3, #43]
    1be0:	e1a02003 	mov	r2, r3
    1be4:	e51b3014 	ldr	r3, [fp, #-20]
    1be8:	e0020293 	mul	r2, r3, r2
    1bec:	e51b3010 	ldr	r3, [fp, #-16]
    1bf0:	e5933018 	ldr	r3, [r3, #24]
    1bf4:	e0822003 	add	r2, r2, r3
    1bf8:	e50b2018 	str	r2, [fp, #-24]
    1bfc:	e51b3018 	ldr	r3, [fp, #-24]
}
    1c00:	e1a00003 	mov	r0, r3
    1c04:	e24bd00c 	sub	sp, fp, #12	; 0xc
    1c08:	e89da800 	ldm	sp, {fp, sp, pc}

00001c0c <next_dir_entry>:

static
BOOL next_dir_entry (	/* TRUE: successful, FALSE: could not move next */
	DIR *dj				/* Pointer to directory object */
)
{
    1c0c:	e1a0c00d 	mov	ip, sp
    1c10:	e92dd800 	push	{fp, ip, lr, pc}
    1c14:	e24cb004 	sub	fp, ip, #4	; 0x4
    1c18:	e24dd010 	sub	sp, sp, #16	; 0x10
    1c1c:	e50b0018 	str	r0, [fp, #-24]
	DWORD clust;
	WORD idx;


	idx = dj->index + 1;
    1c20:	e51b3018 	ldr	r3, [fp, #-24]
    1c24:	e1d330b2 	ldrh	r3, [r3, #2]
    1c28:	e2833001 	add	r3, r3, #1	; 0x1
    1c2c:	e14b30be 	strh	r3, [fp, #-14]
	if ((idx & ((SS(dj->fs) - 1) / 32)) == 0) {		/* Table sector changed? */
    1c30:	e15b30be 	ldrh	r3, [fp, #-14]
    1c34:	e203300f 	and	r3, r3, #15	; 0xf
    1c38:	e3530000 	cmp	r3, #0	; 0x0
    1c3c:	1a00003d 	bne	1d38 <next_dir_entry+0x12c>
		dj->sect++;				/* Next sector */
    1c40:	e51b3018 	ldr	r3, [fp, #-24]
    1c44:	e5933010 	ldr	r3, [r3, #16]
    1c48:	e2832001 	add	r2, r3, #1	; 0x1
    1c4c:	e51b3018 	ldr	r3, [fp, #-24]
    1c50:	e5832010 	str	r2, [r3, #16]
		if (dj->clust == 0) {	/* In static table */
    1c54:	e51b3018 	ldr	r3, [fp, #-24]
    1c58:	e593300c 	ldr	r3, [r3, #12]
    1c5c:	e3530000 	cmp	r3, #0	; 0x0
    1c60:	1a000008 	bne	1c88 <next_dir_entry+0x7c>
			if (idx >= dj->fs->n_rootdir) return FALSE;	/* Reached to end of table */
    1c64:	e51b3018 	ldr	r3, [fp, #-24]
    1c68:	e5933004 	ldr	r3, [r3, #4]
    1c6c:	e1d320b2 	ldrh	r2, [r3, #2]
    1c70:	e15b30be 	ldrh	r3, [fp, #-14]
    1c74:	e1530002 	cmp	r3, r2
    1c78:	3a00002e 	bcc	1d38 <next_dir_entry+0x12c>
    1c7c:	e3a03000 	mov	r3, #0	; 0x0
    1c80:	e50b301c 	str	r3, [fp, #-28]
    1c84:	ea000030 	b	1d4c <next_dir_entry+0x140>
		} else {					/* In dynamic table */
			if (((idx / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    1c88:	e15b30be 	ldrh	r3, [fp, #-14]
    1c8c:	e1a03223 	lsr	r3, r3, #4
    1c90:	e1a03803 	lsl	r3, r3, #16
    1c94:	e1a03823 	lsr	r3, r3, #16
    1c98:	e1a02003 	mov	r2, r3
    1c9c:	e51b3018 	ldr	r3, [fp, #-24]
    1ca0:	e5933004 	ldr	r3, [r3, #4]
    1ca4:	e5d3302b 	ldrb	r3, [r3, #43]
    1ca8:	e2433001 	sub	r3, r3, #1	; 0x1
    1cac:	e0023003 	and	r3, r2, r3
    1cb0:	e3530000 	cmp	r3, #0	; 0x0
    1cb4:	1a00001f 	bne	1d38 <next_dir_entry+0x12c>
				clust = get_cluster(dj->fs, dj->clust);			/* Get next cluster */
    1cb8:	e51b3018 	ldr	r3, [fp, #-24]
    1cbc:	e5932004 	ldr	r2, [r3, #4]
    1cc0:	e51b3018 	ldr	r3, [fp, #-24]
    1cc4:	e593300c 	ldr	r3, [r3, #12]
    1cc8:	e1a00002 	mov	r0, r2
    1ccc:	e1a01003 	mov	r1, r3
    1cd0:	ebfffcf8 	bl	10b8 <get_cluster>
    1cd4:	e1a03000 	mov	r3, r0
    1cd8:	e50b3014 	str	r3, [fp, #-20]
				if (clust < 2 || clust >= dj->fs->max_clust)	/* Reached to end of table */
    1cdc:	e51b3014 	ldr	r3, [fp, #-20]
    1ce0:	e3530001 	cmp	r3, #1	; 0x1
    1ce4:	9a000005 	bls	1d00 <next_dir_entry+0xf4>
    1ce8:	e51b3018 	ldr	r3, [fp, #-24]
    1cec:	e5933004 	ldr	r3, [r3, #4]
    1cf0:	e593200c 	ldr	r2, [r3, #12]
    1cf4:	e51b3014 	ldr	r3, [fp, #-20]
    1cf8:	e1520003 	cmp	r2, r3
    1cfc:	8a000002 	bhi	1d0c <next_dir_entry+0x100>
					return FALSE;
    1d00:	e3a03000 	mov	r3, #0	; 0x0
    1d04:	e50b301c 	str	r3, [fp, #-28]
    1d08:	ea00000f 	b	1d4c <next_dir_entry+0x140>
				dj->clust = clust;				/* Initialize for new cluster */
    1d0c:	e51b2018 	ldr	r2, [fp, #-24]
    1d10:	e51b3014 	ldr	r3, [fp, #-20]
    1d14:	e582300c 	str	r3, [r2, #12]
				dj->sect = clust2sect(dj->fs, clust);
    1d18:	e51b3018 	ldr	r3, [fp, #-24]
    1d1c:	e5933004 	ldr	r3, [r3, #4]
    1d20:	e1a00003 	mov	r0, r3
    1d24:	e51b1014 	ldr	r1, [fp, #-20]
    1d28:	ebffff98 	bl	1b90 <clust2sect>
    1d2c:	e1a02000 	mov	r2, r0
    1d30:	e51b3018 	ldr	r3, [fp, #-24]
    1d34:	e5832010 	str	r2, [r3, #16]
			}
		}
	}
	dj->index = idx;	/* Lower several bits of dj->index indicates offset in dj->sect */
    1d38:	e51b2018 	ldr	r2, [fp, #-24]
    1d3c:	e15b30be 	ldrh	r3, [fp, #-14]
    1d40:	e1c230b2 	strh	r3, [r2, #2]
	return TRUE;
    1d44:	e3a03001 	mov	r3, #1	; 0x1
    1d48:	e50b301c 	str	r3, [fp, #-28]
    1d4c:	e51b301c 	ldr	r3, [fp, #-28]
}
    1d50:	e1a00003 	mov	r0, r3
    1d54:	e24bd00c 	sub	sp, fp, #12	; 0xc
    1d58:	e89da800 	ldm	sp, {fp, sp, pc}

00001d5c <make_dirfile>:
static
char make_dirfile (		/* 1: error - detected an invalid format, '\0'or'/': next character */
	const char **path,	/* Pointer to the file path pointer */
	char *dirname		/* Pointer to directory name buffer {Name(8), Ext(3), NT flag(1)} */
)
{
    1d5c:	e1a0c00d 	mov	ip, sp
    1d60:	e92dd800 	push	{fp, ip, lr, pc}
    1d64:	e24cb004 	sub	fp, ip, #4	; 0x4
    1d68:	e24dd014 	sub	sp, sp, #20	; 0x14
    1d6c:	e50b0018 	str	r0, [fp, #-24]
    1d70:	e50b101c 	str	r1, [fp, #-28]
	BYTE n, t, c, a, b;


	memset(dirname, ' ', 8+3);	/* Fill buffer with spaces */
    1d74:	e51b001c 	ldr	r0, [fp, #-28]
    1d78:	e3a01020 	mov	r1, #32	; 0x20
    1d7c:	e3a0200b 	mov	r2, #11	; 0xb
    1d80:	eb001d31 	bl	924c <memset>
	a = 0; b = 0x18;	/* NT flag */
    1d84:	e3a03000 	mov	r3, #0	; 0x0
    1d88:	e54b300e 	strb	r3, [fp, #-14]
    1d8c:	e3a03018 	mov	r3, #24	; 0x18
    1d90:	e54b300d 	strb	r3, [fp, #-13]
	n = 0; t = 8;
    1d94:	e3a03000 	mov	r3, #0	; 0x0
    1d98:	e54b3011 	strb	r3, [fp, #-17]
    1d9c:	e3a03008 	mov	r3, #8	; 0x8
    1da0:	e54b3010 	strb	r3, [fp, #-16]
	for (;;) {
		c = *(*path)++;
    1da4:	e51b3018 	ldr	r3, [fp, #-24]
    1da8:	e5932000 	ldr	r2, [r3]
    1dac:	e5d23000 	ldrb	r3, [r2]
    1db0:	e54b300f 	strb	r3, [fp, #-15]
    1db4:	e2822001 	add	r2, r2, #1	; 0x1
    1db8:	e51b3018 	ldr	r3, [fp, #-24]
    1dbc:	e5832000 	str	r2, [r3]
		if (c == '\0' || c == '/') {		/* Reached to end of str or directory separator */
    1dc0:	e55b300f 	ldrb	r3, [fp, #-15]
    1dc4:	e3530000 	cmp	r3, #0	; 0x0
    1dc8:	0a000002 	beq	1dd8 <make_dirfile+0x7c>
    1dcc:	e55b300f 	ldrb	r3, [fp, #-15]
    1dd0:	e353002f 	cmp	r3, #47	; 0x2f
    1dd4:	1a00000c 	bne	1e0c <make_dirfile+0xb0>
			if (n == 0) break;
    1dd8:	e55b3011 	ldrb	r3, [fp, #-17]
    1ddc:	e3530000 	cmp	r3, #0	; 0x0
    1de0:	0a000088 	beq	2008 <make_dirfile+0x2ac>
			dirname[11] = _USE_NTFLAG ? (a & b) : 0;
    1de4:	e51b301c 	ldr	r3, [fp, #-28]
    1de8:	e283100b 	add	r1, r3, #11	; 0xb
    1dec:	e55b200e 	ldrb	r2, [fp, #-14]
    1df0:	e55b300d 	ldrb	r3, [fp, #-13]
    1df4:	e0023003 	and	r3, r2, r3
    1df8:	e20330ff 	and	r3, r3, #255	; 0xff
    1dfc:	e5c13000 	strb	r3, [r1]
			return c;
    1e00:	e55b300f 	ldrb	r3, [fp, #-15]
    1e04:	e50b3020 	str	r3, [fp, #-32]
    1e08:	ea000080 	b	2010 <make_dirfile+0x2b4>
		}
		if (c <= ' ' || c == 0x7F) break;		/* Reject invisible chars */
    1e0c:	e55b300f 	ldrb	r3, [fp, #-15]
    1e10:	e3530020 	cmp	r3, #32	; 0x20
    1e14:	9a00007b 	bls	2008 <make_dirfile+0x2ac>
    1e18:	e55b300f 	ldrb	r3, [fp, #-15]
    1e1c:	e353007f 	cmp	r3, #127	; 0x7f
    1e20:	0a000078 	beq	2008 <make_dirfile+0x2ac>
		if (c == '.') {
    1e24:	e55b300f 	ldrb	r3, [fp, #-15]
    1e28:	e353002e 	cmp	r3, #46	; 0x2e
    1e2c:	1a00000e 	bne	1e6c <make_dirfile+0x110>
			if (!(a & 1) && n >= 1 && n <= 8) {	/* Enter extension part */
    1e30:	e55b300e 	ldrb	r3, [fp, #-14]
    1e34:	e2033001 	and	r3, r3, #1	; 0x1
    1e38:	e3530000 	cmp	r3, #0	; 0x0
    1e3c:	1a000071 	bne	2008 <make_dirfile+0x2ac>
    1e40:	e55b3011 	ldrb	r3, [fp, #-17]
    1e44:	e3530000 	cmp	r3, #0	; 0x0
    1e48:	0a00006e 	beq	2008 <make_dirfile+0x2ac>
    1e4c:	e55b3011 	ldrb	r3, [fp, #-17]
    1e50:	e3530008 	cmp	r3, #8	; 0x8
    1e54:	8a00006b 	bhi	2008 <make_dirfile+0x2ac>
				n = 8; t = 11; continue;
    1e58:	e3a03008 	mov	r3, #8	; 0x8
    1e5c:	e54b3011 	strb	r3, [fp, #-17]
    1e60:	e3a0300b 	mov	r3, #11	; 0xb
    1e64:	e54b3010 	strb	r3, [fp, #-16]
    1e68:	eaffffcd 	b	1da4 <make_dirfile+0x48>
			}
			break;
		}
		if (_USE_SJIS &&
    1e6c:	e55b300f 	ldrb	r3, [fp, #-15]
    1e70:	e3530080 	cmp	r3, #128	; 0x80
    1e74:	9a000002 	bls	1e84 <make_dirfile+0x128>
    1e78:	e55b300f 	ldrb	r3, [fp, #-15]
    1e7c:	e353009f 	cmp	r3, #159	; 0x9f
    1e80:	9a000005 	bls	1e9c <make_dirfile+0x140>
    1e84:	e55b300f 	ldrb	r3, [fp, #-15]
    1e88:	e35300df 	cmp	r3, #223	; 0xdf
    1e8c:	9a00000e 	bls	1ecc <make_dirfile+0x170>
    1e90:	e55b300f 	ldrb	r3, [fp, #-15]
    1e94:	e35300fc 	cmp	r3, #252	; 0xfc
    1e98:	8a00000b 	bhi	1ecc <make_dirfile+0x170>
			((c >= 0x81 && c <= 0x9F) ||	/* Accept S-JIS code */
		    (c >= 0xE0 && c <= 0xFC))) {
			if (n == 0 && c == 0xE5)		/* Change heading \xE5 to \x05 */
    1e9c:	e55b3011 	ldrb	r3, [fp, #-17]
    1ea0:	e3530000 	cmp	r3, #0	; 0x0
    1ea4:	1a000004 	bne	1ebc <make_dirfile+0x160>
    1ea8:	e55b300f 	ldrb	r3, [fp, #-15]
    1eac:	e35300e5 	cmp	r3, #229	; 0xe5
    1eb0:	1a000001 	bne	1ebc <make_dirfile+0x160>
				c = 0x05;
    1eb4:	e3a03005 	mov	r3, #5	; 0x5
    1eb8:	e54b300f 	strb	r3, [fp, #-15]
			a ^= 0x01; goto md_l2;
    1ebc:	e55b300e 	ldrb	r3, [fp, #-14]
    1ec0:	e2233001 	eor	r3, r3, #1	; 0x1
    1ec4:	e54b300e 	strb	r3, [fp, #-14]
    1ec8:	ea000041 	b	1fd4 <make_dirfile+0x278>
		}
		if (c == '"') break;				/* Reject " */
    1ecc:	e55b300f 	ldrb	r3, [fp, #-15]
    1ed0:	e3530022 	cmp	r3, #34	; 0x22
    1ed4:	0a00004b 	beq	2008 <make_dirfile+0x2ac>
		if (c <= ')') goto md_l1;			/* Accept ! # $ % & ' ( ) */
    1ed8:	e55b300f 	ldrb	r3, [fp, #-15]
    1edc:	e3530029 	cmp	r3, #41	; 0x29
    1ee0:	9a000038 	bls	1fc8 <make_dirfile+0x26c>
		if (c <= ',') break;				/* Reject * + , */
    1ee4:	e55b300f 	ldrb	r3, [fp, #-15]
    1ee8:	e353002c 	cmp	r3, #44	; 0x2c
    1eec:	9a000045 	bls	2008 <make_dirfile+0x2ac>
		if (c <= '9') goto md_l1;			/* Accept - 0-9 */
    1ef0:	e55b300f 	ldrb	r3, [fp, #-15]
    1ef4:	e3530039 	cmp	r3, #57	; 0x39
    1ef8:	9a000032 	bls	1fc8 <make_dirfile+0x26c>
		if (c <= '?') break;				/* Reject : ; < = > ? */
    1efc:	e55b300f 	ldrb	r3, [fp, #-15]
    1f00:	e353003f 	cmp	r3, #63	; 0x3f
    1f04:	9a00003f 	bls	2008 <make_dirfile+0x2ac>
		if (!(a & 1)) {	/* These checks are not applied to S-JIS 2nd byte */
    1f08:	e55b300e 	ldrb	r3, [fp, #-14]
    1f0c:	e2033001 	and	r3, r3, #1	; 0x1
    1f10:	e3530000 	cmp	r3, #0	; 0x0
    1f14:	1a00002b 	bne	1fc8 <make_dirfile+0x26c>
			if (c == '|') break;			/* Reject | */
    1f18:	e55b300f 	ldrb	r3, [fp, #-15]
    1f1c:	e353007c 	cmp	r3, #124	; 0x7c
    1f20:	0a000038 	beq	2008 <make_dirfile+0x2ac>
			if (c >= '[' && c <= ']') break;/* Reject [ \ ] */
    1f24:	e55b300f 	ldrb	r3, [fp, #-15]
    1f28:	e353005a 	cmp	r3, #90	; 0x5a
    1f2c:	9a000002 	bls	1f3c <make_dirfile+0x1e0>
    1f30:	e55b300f 	ldrb	r3, [fp, #-15]
    1f34:	e353005d 	cmp	r3, #93	; 0x5d
    1f38:	9a000032 	bls	2008 <make_dirfile+0x2ac>
			if (_USE_NTFLAG && c >= 'A' && c <= 'Z')
    1f3c:	e55b300f 	ldrb	r3, [fp, #-15]
    1f40:	e3530040 	cmp	r3, #64	; 0x40
    1f44:	9a00000c 	bls	1f7c <make_dirfile+0x220>
    1f48:	e55b300f 	ldrb	r3, [fp, #-15]
    1f4c:	e353005a 	cmp	r3, #90	; 0x5a
    1f50:	8a000009 	bhi	1f7c <make_dirfile+0x220>
				(t == 8) ? (b &= 0xF7) : (b &= 0xEF);
    1f54:	e55b3010 	ldrb	r3, [fp, #-16]
    1f58:	e3530008 	cmp	r3, #8	; 0x8
    1f5c:	1a000003 	bne	1f70 <make_dirfile+0x214>
    1f60:	e55b300d 	ldrb	r3, [fp, #-13]
    1f64:	e3c33008 	bic	r3, r3, #8	; 0x8
    1f68:	e54b300d 	strb	r3, [fp, #-13]
    1f6c:	ea000002 	b	1f7c <make_dirfile+0x220>
    1f70:	e55b300d 	ldrb	r3, [fp, #-13]
    1f74:	e3c33010 	bic	r3, r3, #16	; 0x10
    1f78:	e54b300d 	strb	r3, [fp, #-13]
			if (c >= 'a' && c <= 'z') {		/* Convert to upper case */
    1f7c:	e55b300f 	ldrb	r3, [fp, #-15]
    1f80:	e3530060 	cmp	r3, #96	; 0x60
    1f84:	9a00000f 	bls	1fc8 <make_dirfile+0x26c>
    1f88:	e55b300f 	ldrb	r3, [fp, #-15]
    1f8c:	e353007a 	cmp	r3, #122	; 0x7a
    1f90:	8a00000c 	bhi	1fc8 <make_dirfile+0x26c>
				c -= 0x20;
    1f94:	e55b300f 	ldrb	r3, [fp, #-15]
    1f98:	e2433020 	sub	r3, r3, #32	; 0x20
    1f9c:	e54b300f 	strb	r3, [fp, #-15]
				if (_USE_NTFLAG) (t == 8) ? (a |= 0x08) : (a |= 0x10);
    1fa0:	e55b3010 	ldrb	r3, [fp, #-16]
    1fa4:	e3530008 	cmp	r3, #8	; 0x8
    1fa8:	1a000003 	bne	1fbc <make_dirfile+0x260>
    1fac:	e55b300e 	ldrb	r3, [fp, #-14]
    1fb0:	e3833008 	orr	r3, r3, #8	; 0x8
    1fb4:	e54b300e 	strb	r3, [fp, #-14]
    1fb8:	ea000002 	b	1fc8 <make_dirfile+0x26c>
    1fbc:	e55b300e 	ldrb	r3, [fp, #-14]
    1fc0:	e3833010 	orr	r3, r3, #16	; 0x10
    1fc4:	e54b300e 	strb	r3, [fp, #-14]
			}
		}
	md_l1:
		a &= 0xFE;
    1fc8:	e55b300e 	ldrb	r3, [fp, #-14]
    1fcc:	e3c33001 	bic	r3, r3, #1	; 0x1
    1fd0:	e54b300e 	strb	r3, [fp, #-14]
	md_l2:
		if (n >= t) break;
    1fd4:	e55b2011 	ldrb	r2, [fp, #-17]
    1fd8:	e55b3010 	ldrb	r3, [fp, #-16]
    1fdc:	e1520003 	cmp	r2, r3
    1fe0:	2a000008 	bcs	2008 <make_dirfile+0x2ac>
		dirname[n++] = c;
    1fe4:	e55b2011 	ldrb	r2, [fp, #-17]
    1fe8:	e51b301c 	ldr	r3, [fp, #-28]
    1fec:	e0832002 	add	r2, r3, r2
    1ff0:	e55b300f 	ldrb	r3, [fp, #-15]
    1ff4:	e5c23000 	strb	r3, [r2]
    1ff8:	e55b3011 	ldrb	r3, [fp, #-17]
    1ffc:	e2833001 	add	r3, r3, #1	; 0x1
    2000:	e54b3011 	strb	r3, [fp, #-17]
    2004:	eaffff66 	b	1da4 <make_dirfile+0x48>
	}
	return 1;
    2008:	e3a03001 	mov	r3, #1	; 0x1
    200c:	e50b3020 	str	r3, [fp, #-32]
    2010:	e51b3020 	ldr	r3, [fp, #-32]
}
    2014:	e1a00003 	mov	r0, r3
    2018:	e24bd00c 	sub	sp, fp, #12	; 0xc
    201c:	e89da800 	ldm	sp, {fp, sp, pc}

00002020 <trace_path>:
	DIR *dj,			/* Pointer to directory object to return last directory */
	char *fn,			/* Pointer to last segment name to return {file(8),ext(3),attr(1)} */
	const char *path,	/* Full-path string to trace a file or directory */
	BYTE **dir			/* Pointer to pointer to found entry to retutn */
)
{
    2020:	e1a0c00d 	mov	ip, sp
    2024:	e92dd800 	push	{fp, ip, lr, pc}
    2028:	e24cb004 	sub	fp, ip, #4	; 0x4
    202c:	e24dd02c 	sub	sp, sp, #44	; 0x2c
    2030:	e50b0020 	str	r0, [fp, #-32]
    2034:	e50b1024 	str	r1, [fp, #-36]
    2038:	e50b2028 	str	r2, [fp, #-40]
    203c:	e50b302c 	str	r3, [fp, #-44]
	DWORD clust;
	char ds;
	BYTE *dptr = NULL;
    2040:	e3a03000 	mov	r3, #0	; 0x0
    2044:	e50b3014 	str	r3, [fp, #-20]
	FATFS *fs = dj->fs;
    2048:	e51b3020 	ldr	r3, [fp, #-32]
    204c:	e5933004 	ldr	r3, [r3, #4]
    2050:	e50b3010 	str	r3, [fp, #-16]


	/* Initialize directory object */
	clust = fs->dirbase;
    2054:	e51b3010 	ldr	r3, [fp, #-16]
    2058:	e5933014 	ldr	r3, [r3, #20]
    205c:	e50b301c 	str	r3, [fp, #-28]
	if (fs->fs_type == FS_FAT32) {
    2060:	e51b3010 	ldr	r3, [fp, #-16]
    2064:	e5d3302a 	ldrb	r3, [r3, #42]
    2068:	e3530003 	cmp	r3, #3	; 0x3
    206c:	1a00000d 	bne	20a8 <trace_path+0x88>
		dj->clust = dj->sclust = clust;
    2070:	e51b2020 	ldr	r2, [fp, #-32]
    2074:	e51b301c 	ldr	r3, [fp, #-28]
    2078:	e5823008 	str	r3, [r2, #8]
    207c:	e51b3020 	ldr	r3, [fp, #-32]
    2080:	e5932008 	ldr	r2, [r3, #8]
    2084:	e51b3020 	ldr	r3, [fp, #-32]
    2088:	e583200c 	str	r2, [r3, #12]
		dj->sect = clust2sect(fs, clust);
    208c:	e51b0010 	ldr	r0, [fp, #-16]
    2090:	e51b101c 	ldr	r1, [fp, #-28]
    2094:	ebfffebd 	bl	1b90 <clust2sect>
    2098:	e1a02000 	mov	r2, r0
    209c:	e51b3020 	ldr	r3, [fp, #-32]
    20a0:	e5832010 	str	r2, [r3, #16]
    20a4:	ea000009 	b	20d0 <trace_path+0xb0>
	} else {
		dj->clust = dj->sclust = 0;
    20a8:	e51b2020 	ldr	r2, [fp, #-32]
    20ac:	e3a03000 	mov	r3, #0	; 0x0
    20b0:	e5823008 	str	r3, [r2, #8]
    20b4:	e51b3020 	ldr	r3, [fp, #-32]
    20b8:	e5932008 	ldr	r2, [r3, #8]
    20bc:	e51b3020 	ldr	r3, [fp, #-32]
    20c0:	e583200c 	str	r2, [r3, #12]
		dj->sect = clust;
    20c4:	e51b2020 	ldr	r2, [fp, #-32]
    20c8:	e51b301c 	ldr	r3, [fp, #-28]
    20cc:	e5823010 	str	r3, [r2, #16]
	}
	dj->index = 0;
    20d0:	e51b2020 	ldr	r2, [fp, #-32]
    20d4:	e3a03000 	mov	r3, #0	; 0x0
    20d8:	e1c230b2 	strh	r3, [r2, #2]

	if (*path == '\0') {					/* Null path means the root directory */
    20dc:	e51b3028 	ldr	r3, [fp, #-40]
    20e0:	e5d33000 	ldrb	r3, [r3]
    20e4:	e3530000 	cmp	r3, #0	; 0x0
    20e8:	1a000005 	bne	2104 <trace_path+0xe4>
		*dir = NULL; return FR_OK;
    20ec:	e51b202c 	ldr	r2, [fp, #-44]
    20f0:	e3a03000 	mov	r3, #0	; 0x0
    20f4:	e5823000 	str	r3, [r2]
    20f8:	e3a03000 	mov	r3, #0	; 0x0
    20fc:	e50b3038 	str	r3, [fp, #-56]
    2100:	ea000094 	b	2358 <trace_path+0x338>
	}

	for (;;) {
		ds = make_dirfile(&path, fn);			/* Get a paragraph into fn[] */
    2104:	e24b3028 	sub	r3, fp, #40	; 0x28
    2108:	e1a00003 	mov	r0, r3
    210c:	e51b1024 	ldr	r1, [fp, #-36]
    2110:	ebffff11 	bl	1d5c <make_dirfile>
    2114:	e1a03000 	mov	r3, r0
    2118:	e54b3015 	strb	r3, [fp, #-21]
		if (ds == 1) return FR_INVALID_NAME;
    211c:	e55b3015 	ldrb	r3, [fp, #-21]
    2120:	e3530001 	cmp	r3, #1	; 0x1
    2124:	1a000002 	bne	2134 <trace_path+0x114>
    2128:	e3a03004 	mov	r3, #4	; 0x4
    212c:	e50b3038 	str	r3, [fp, #-56]
    2130:	ea000088 	b	2358 <trace_path+0x338>
		for (;;) {
			if (!move_window(fs, dj->sect)) return FR_RW_ERROR;
    2134:	e51b3020 	ldr	r3, [fp, #-32]
    2138:	e5933010 	ldr	r3, [r3, #16]
    213c:	e51b0010 	ldr	r0, [fp, #-16]
    2140:	e1a01003 	mov	r1, r3
    2144:	ebfffab5 	bl	c20 <move_window>
    2148:	e1a03000 	mov	r3, r0
    214c:	e3530000 	cmp	r3, #0	; 0x0
    2150:	1a000002 	bne	2160 <trace_path+0x140>
    2154:	e3a03008 	mov	r3, #8	; 0x8
    2158:	e50b3038 	str	r3, [fp, #-56]
    215c:	ea00007d 	b	2358 <trace_path+0x338>
			dptr = &fs->win[(dj->index & ((SS(fs) - 1) / 32)) * 32];	/* Pointer to the directory entry */
    2160:	e51b3010 	ldr	r3, [fp, #-16]
    2164:	e2832030 	add	r2, r3, #48	; 0x30
    2168:	e51b3020 	ldr	r3, [fp, #-32]
    216c:	e1d330b2 	ldrh	r3, [r3, #2]
    2170:	e203300f 	and	r3, r3, #15	; 0xf
    2174:	e1a03283 	lsl	r3, r3, #5
    2178:	e0823003 	add	r3, r2, r3
    217c:	e50b3014 	str	r3, [fp, #-20]
			if (dptr[DIR_Name] == 0)						/* Has it reached to end of dir? */
    2180:	e51b3014 	ldr	r3, [fp, #-20]
    2184:	e5d33000 	ldrb	r3, [r3]
    2188:	e3530000 	cmp	r3, #0	; 0x0
    218c:	1a00000a 	bne	21bc <trace_path+0x19c>
				return !ds ? FR_NO_FILE : FR_NO_PATH;
    2190:	e55b3015 	ldrb	r3, [fp, #-21]
    2194:	e3530000 	cmp	r3, #0	; 0x0
    2198:	1a000002 	bne	21a8 <trace_path+0x188>
    219c:	e3a03002 	mov	r3, #2	; 0x2
    21a0:	e50b3034 	str	r3, [fp, #-52]
    21a4:	ea000001 	b	21b0 <trace_path+0x190>
    21a8:	e3a03003 	mov	r3, #3	; 0x3
    21ac:	e50b3034 	str	r3, [fp, #-52]
    21b0:	e51b3034 	ldr	r3, [fp, #-52]
    21b4:	e50b3038 	str	r3, [fp, #-56]
    21b8:	ea000066 	b	2358 <trace_path+0x338>
			if (dptr[DIR_Name] != 0xE5						/* Matched? */
    21bc:	e51b3014 	ldr	r3, [fp, #-20]
    21c0:	e5d33000 	ldrb	r3, [r3]
    21c4:	e35300e5 	cmp	r3, #229	; 0xe5
    21c8:	0a00000c 	beq	2200 <trace_path+0x1e0>
    21cc:	e51b3014 	ldr	r3, [fp, #-20]
    21d0:	e283300b 	add	r3, r3, #11	; 0xb
    21d4:	e5d33000 	ldrb	r3, [r3]
    21d8:	e2033008 	and	r3, r3, #8	; 0x8
    21dc:	e3530000 	cmp	r3, #0	; 0x0
    21e0:	1a000006 	bne	2200 <trace_path+0x1e0>
    21e4:	e51b0014 	ldr	r0, [fp, #-20]
    21e8:	e51b1024 	ldr	r1, [fp, #-36]
    21ec:	e3a0200b 	mov	r2, #11	; 0xb
    21f0:	eb001bab 	bl	90a4 <memcmp>
    21f4:	e1a03000 	mov	r3, r0
    21f8:	e3530000 	cmp	r3, #0	; 0x0
    21fc:	0a00000f 	beq	2240 <trace_path+0x220>
				&& !(dptr[DIR_Attr] & AM_VOL)
				&& !memcmp(&dptr[DIR_Name], fn, 8+3) ) break;
			if (!next_dir_entry(dj))						/* Next directory pointer */
    2200:	e51b0020 	ldr	r0, [fp, #-32]
    2204:	ebfffe80 	bl	1c0c <next_dir_entry>
    2208:	e1a03000 	mov	r3, r0
    220c:	e3530000 	cmp	r3, #0	; 0x0
    2210:	1affffc7 	bne	2134 <trace_path+0x114>
				return !ds ? FR_NO_FILE : FR_NO_PATH;
    2214:	e55b3015 	ldrb	r3, [fp, #-21]
    2218:	e3530000 	cmp	r3, #0	; 0x0
    221c:	1a000002 	bne	222c <trace_path+0x20c>
    2220:	e3a03002 	mov	r3, #2	; 0x2
    2224:	e50b3030 	str	r3, [fp, #-48]
    2228:	ea000001 	b	2234 <trace_path+0x214>
    222c:	e3a03003 	mov	r3, #3	; 0x3
    2230:	e50b3030 	str	r3, [fp, #-48]
    2234:	e51b3030 	ldr	r3, [fp, #-48]
    2238:	e50b3038 	str	r3, [fp, #-56]
    223c:	ea000045 	b	2358 <trace_path+0x338>
		}
		if (!ds) { *dir = dptr; return FR_OK; }				/* Matched with end of path */
    2240:	e55b3015 	ldrb	r3, [fp, #-21]
    2244:	e3530000 	cmp	r3, #0	; 0x0
    2248:	1a000005 	bne	2264 <trace_path+0x244>
    224c:	e51b202c 	ldr	r2, [fp, #-44]
    2250:	e51b3014 	ldr	r3, [fp, #-20]
    2254:	e5823000 	str	r3, [r2]
    2258:	e3a03000 	mov	r3, #0	; 0x0
    225c:	e50b3038 	str	r3, [fp, #-56]
    2260:	ea00003c 	b	2358 <trace_path+0x338>
		if (!(dptr[DIR_Attr] & AM_DIR)) return FR_NO_PATH;	/* Cannot trace because it is a file */
    2264:	e51b3014 	ldr	r3, [fp, #-20]
    2268:	e283300b 	add	r3, r3, #11	; 0xb
    226c:	e5d33000 	ldrb	r3, [r3]
    2270:	e2033010 	and	r3, r3, #16	; 0x10
    2274:	e3530000 	cmp	r3, #0	; 0x0
    2278:	1a000002 	bne	2288 <trace_path+0x268>
    227c:	e3a03003 	mov	r3, #3	; 0x3
    2280:	e50b3038 	str	r3, [fp, #-56]
    2284:	ea000033 	b	2358 <trace_path+0x338>
		clust = ((DWORD)LD_WORD(&dptr[DIR_FstClusHI]) << 16) | LD_WORD(&dptr[DIR_FstClusLO]); /* Get cluster# of the directory */
    2288:	e51b3014 	ldr	r3, [fp, #-20]
    228c:	e2833015 	add	r3, r3, #21	; 0x15
    2290:	e5d33000 	ldrb	r3, [r3]
    2294:	e20330ff 	and	r3, r3, #255	; 0xff
    2298:	e1a03403 	lsl	r3, r3, #8
    229c:	e1a03803 	lsl	r3, r3, #16
    22a0:	e1a02823 	lsr	r2, r3, #16
    22a4:	e51b3014 	ldr	r3, [fp, #-20]
    22a8:	e2833014 	add	r3, r3, #20	; 0x14
    22ac:	e5d33000 	ldrb	r3, [r3]
    22b0:	e20330ff 	and	r3, r3, #255	; 0xff
    22b4:	e1823003 	orr	r3, r2, r3
    22b8:	e1a03803 	lsl	r3, r3, #16
    22bc:	e1a03823 	lsr	r3, r3, #16
    22c0:	e1a03803 	lsl	r3, r3, #16
    22c4:	e1a03823 	lsr	r3, r3, #16
    22c8:	e1a01803 	lsl	r1, r3, #16
    22cc:	e51b3014 	ldr	r3, [fp, #-20]
    22d0:	e283301b 	add	r3, r3, #27	; 0x1b
    22d4:	e5d33000 	ldrb	r3, [r3]
    22d8:	e20330ff 	and	r3, r3, #255	; 0xff
    22dc:	e1a03403 	lsl	r3, r3, #8
    22e0:	e1a03803 	lsl	r3, r3, #16
    22e4:	e1a02823 	lsr	r2, r3, #16
    22e8:	e51b3014 	ldr	r3, [fp, #-20]
    22ec:	e283301a 	add	r3, r3, #26	; 0x1a
    22f0:	e5d33000 	ldrb	r3, [r3]
    22f4:	e20330ff 	and	r3, r3, #255	; 0xff
    22f8:	e1823003 	orr	r3, r2, r3
    22fc:	e1a03803 	lsl	r3, r3, #16
    2300:	e1a03823 	lsr	r3, r3, #16
    2304:	e1a03803 	lsl	r3, r3, #16
    2308:	e1a03823 	lsr	r3, r3, #16
    230c:	e1813003 	orr	r3, r1, r3
    2310:	e50b301c 	str	r3, [fp, #-28]
		dj->clust = dj->sclust = clust;				/* Restart scanning at the new directory */
    2314:	e51b2020 	ldr	r2, [fp, #-32]
    2318:	e51b301c 	ldr	r3, [fp, #-28]
    231c:	e5823008 	str	r3, [r2, #8]
    2320:	e51b3020 	ldr	r3, [fp, #-32]
    2324:	e5932008 	ldr	r2, [r3, #8]
    2328:	e51b3020 	ldr	r3, [fp, #-32]
    232c:	e583200c 	str	r2, [r3, #12]
		dj->sect = clust2sect(fs, clust);
    2330:	e51b0010 	ldr	r0, [fp, #-16]
    2334:	e51b101c 	ldr	r1, [fp, #-28]
    2338:	ebfffe14 	bl	1b90 <clust2sect>
    233c:	e1a02000 	mov	r2, r0
    2340:	e51b3020 	ldr	r3, [fp, #-32]
    2344:	e5832010 	str	r2, [r3, #16]
		dj->index = 2;
    2348:	e51b2020 	ldr	r2, [fp, #-32]
    234c:	e3a03002 	mov	r3, #2	; 0x2
    2350:	e1c230b2 	strh	r3, [r2, #2]
    2354:	eaffff6a 	b	2104 <trace_path+0xe4>
	}
    2358:	e51b3038 	ldr	r3, [fp, #-56]
}
    235c:	e1a00003 	mov	r0, r3
    2360:	e24bd00c 	sub	sp, fp, #12	; 0xc
    2364:	e89da800 	ldm	sp, {fp, sp, pc}

00002368 <reserve_direntry>:
static
FRESULT reserve_direntry (	/* FR_OK: successful, FR_DENIED: no free entry, FR_RW_ERROR: a disk error occured */
	DIR *dj,				/* Target directory to create new entry */
	BYTE **dir				/* Pointer to pointer to created entry to retutn */
)
{
    2368:	e1a0c00d 	mov	ip, sp
    236c:	e92dd800 	push	{fp, ip, lr, pc}
    2370:	e24cb004 	sub	fp, ip, #4	; 0x4
    2374:	e24dd020 	sub	sp, sp, #32	; 0x20
    2378:	e50b0024 	str	r0, [fp, #-36]
    237c:	e50b1028 	str	r1, [fp, #-40]
	DWORD clust, sector;
	BYTE c, n, *dptr;
	FATFS *fs = dj->fs;
    2380:	e51b3024 	ldr	r3, [fp, #-36]
    2384:	e5933004 	ldr	r3, [r3, #4]
    2388:	e50b3010 	str	r3, [fp, #-16]


	/* Re-initialize directory object */
	clust = dj->sclust;
    238c:	e51b3024 	ldr	r3, [fp, #-36]
    2390:	e5933008 	ldr	r3, [r3, #8]
    2394:	e50b3020 	str	r3, [fp, #-32]
	if (clust != 0) {	/* Dyanmic directory table */
    2398:	e51b3020 	ldr	r3, [fp, #-32]
    239c:	e3530000 	cmp	r3, #0	; 0x0
    23a0:	0a000009 	beq	23cc <reserve_direntry+0x64>
		dj->clust = clust;
    23a4:	e51b2024 	ldr	r2, [fp, #-36]
    23a8:	e51b3020 	ldr	r3, [fp, #-32]
    23ac:	e582300c 	str	r3, [r2, #12]
		dj->sect = clust2sect(fs, clust);
    23b0:	e51b0010 	ldr	r0, [fp, #-16]
    23b4:	e51b1020 	ldr	r1, [fp, #-32]
    23b8:	ebfffdf4 	bl	1b90 <clust2sect>
    23bc:	e1a02000 	mov	r2, r0
    23c0:	e51b3024 	ldr	r3, [fp, #-36]
    23c4:	e5832010 	str	r2, [r3, #16]
    23c8:	ea000003 	b	23dc <reserve_direntry+0x74>
	} else {			/* Static directory table */
		dj->sect = fs->dirbase;
    23cc:	e51b3010 	ldr	r3, [fp, #-16]
    23d0:	e5932014 	ldr	r2, [r3, #20]
    23d4:	e51b3024 	ldr	r3, [fp, #-36]
    23d8:	e5832010 	str	r2, [r3, #16]
	}
	dj->index = 0;
    23dc:	e51b3024 	ldr	r3, [fp, #-36]
    23e0:	e3a02000 	mov	r2, #0	; 0x0
    23e4:	e1c320b2 	strh	r2, [r3, #2]

	do {
		if (!move_window(fs, dj->sect)) return FR_RW_ERROR;
    23e8:	e51b3024 	ldr	r3, [fp, #-36]
    23ec:	e5933010 	ldr	r3, [r3, #16]
    23f0:	e51b0010 	ldr	r0, [fp, #-16]
    23f4:	e1a01003 	mov	r1, r3
    23f8:	ebfffa08 	bl	c20 <move_window>
    23fc:	e1a03000 	mov	r3, r0
    2400:	e3530000 	cmp	r3, #0	; 0x0
    2404:	1a000002 	bne	2414 <reserve_direntry+0xac>
    2408:	e3a03008 	mov	r3, #8	; 0x8
    240c:	e50b302c 	str	r3, [fp, #-44]
    2410:	ea00006b 	b	25c4 <reserve_direntry+0x25c>
		dptr = &fs->win[(dj->index & ((SS(dj->fs) - 1) / 32)) * 32];	/* Pointer to the directory entry */
    2414:	e51b3010 	ldr	r3, [fp, #-16]
    2418:	e2832030 	add	r2, r3, #48	; 0x30
    241c:	e51b3024 	ldr	r3, [fp, #-36]
    2420:	e1d330b2 	ldrh	r3, [r3, #2]
    2424:	e203300f 	and	r3, r3, #15	; 0xf
    2428:	e1a03283 	lsl	r3, r3, #5
    242c:	e0823003 	add	r3, r2, r3
    2430:	e50b3014 	str	r3, [fp, #-20]
		c = dptr[DIR_Name];
    2434:	e51b3014 	ldr	r3, [fp, #-20]
    2438:	e5d33000 	ldrb	r3, [r3]
    243c:	e54b3016 	strb	r3, [fp, #-22]
		if (c == 0 || c == 0xE5) {		/* Found an empty entry */
    2440:	e55b3016 	ldrb	r3, [fp, #-22]
    2444:	e3530000 	cmp	r3, #0	; 0x0
    2448:	0a000002 	beq	2458 <reserve_direntry+0xf0>
    244c:	e55b3016 	ldrb	r3, [fp, #-22]
    2450:	e35300e5 	cmp	r3, #229	; 0xe5
    2454:	1a000005 	bne	2470 <reserve_direntry+0x108>
			*dir = dptr; return FR_OK;
    2458:	e51b2028 	ldr	r2, [fp, #-40]
    245c:	e51b3014 	ldr	r3, [fp, #-20]
    2460:	e5823000 	str	r3, [r2]
    2464:	e3a03000 	mov	r3, #0	; 0x0
    2468:	e50b302c 	str	r3, [fp, #-44]
    246c:	ea000054 	b	25c4 <reserve_direntry+0x25c>
		}
	} while (next_dir_entry(dj));		/* Next directory pointer */
    2470:	e51b0024 	ldr	r0, [fp, #-36]
    2474:	ebfffde4 	bl	1c0c <next_dir_entry>
    2478:	e1a03000 	mov	r3, r0
    247c:	e3530000 	cmp	r3, #0	; 0x0
    2480:	1affffd8 	bne	23e8 <reserve_direntry+0x80>
	/* Reached to end of the directory table */

	/* Abort when it is a static table or could not stretch dynamic table */
	if (clust == 0 || !(clust = create_chain(fs, dj->clust))) return FR_DENIED;
    2484:	e51b3020 	ldr	r3, [fp, #-32]
    2488:	e3530000 	cmp	r3, #0	; 0x0
    248c:	0a000009 	beq	24b8 <reserve_direntry+0x150>
    2490:	e51b3024 	ldr	r3, [fp, #-36]
    2494:	e593300c 	ldr	r3, [r3, #12]
    2498:	e51b0010 	ldr	r0, [fp, #-16]
    249c:	e1a01003 	mov	r1, r3
    24a0:	ebfffd3a 	bl	1990 <create_chain>
    24a4:	e1a03000 	mov	r3, r0
    24a8:	e50b3020 	str	r3, [fp, #-32]
    24ac:	e51b3020 	ldr	r3, [fp, #-32]
    24b0:	e3530000 	cmp	r3, #0	; 0x0
    24b4:	1a000002 	bne	24c4 <reserve_direntry+0x15c>
    24b8:	e3a03006 	mov	r3, #6	; 0x6
    24bc:	e50b302c 	str	r3, [fp, #-44]
    24c0:	ea00003f 	b	25c4 <reserve_direntry+0x25c>
	if (clust == 1 || !move_window(fs, 0)) return FR_RW_ERROR;
    24c4:	e51b3020 	ldr	r3, [fp, #-32]
    24c8:	e3530001 	cmp	r3, #1	; 0x1
    24cc:	0a000005 	beq	24e8 <reserve_direntry+0x180>
    24d0:	e51b0010 	ldr	r0, [fp, #-16]
    24d4:	e3a01000 	mov	r1, #0	; 0x0
    24d8:	ebfff9d0 	bl	c20 <move_window>
    24dc:	e1a03000 	mov	r3, r0
    24e0:	e3530000 	cmp	r3, #0	; 0x0
    24e4:	1a000002 	bne	24f4 <reserve_direntry+0x18c>
    24e8:	e3a03008 	mov	r3, #8	; 0x8
    24ec:	e50b302c 	str	r3, [fp, #-44]
    24f0:	ea000033 	b	25c4 <reserve_direntry+0x25c>

	/* Cleanup the expanded table */
	fs->winsect = sector = clust2sect(fs, clust);
    24f4:	e51b0010 	ldr	r0, [fp, #-16]
    24f8:	e51b1020 	ldr	r1, [fp, #-32]
    24fc:	ebfffda3 	bl	1b90 <clust2sect>
    2500:	e1a03000 	mov	r3, r0
    2504:	e50b301c 	str	r3, [fp, #-28]
    2508:	e51b2010 	ldr	r2, [fp, #-16]
    250c:	e51b301c 	ldr	r3, [fp, #-28]
    2510:	e5823004 	str	r3, [r2, #4]
	memset(fs->win, 0, SS(fs));
    2514:	e51b3010 	ldr	r3, [fp, #-16]
    2518:	e2833030 	add	r3, r3, #48	; 0x30
    251c:	e1a00003 	mov	r0, r3
    2520:	e3a01000 	mov	r1, #0	; 0x0
    2524:	e3a02c02 	mov	r2, #512	; 0x200
    2528:	eb001b47 	bl	924c <memset>
	for (n = fs->csize; n; n--) {
    252c:	e51b3010 	ldr	r3, [fp, #-16]
    2530:	e5d3302b 	ldrb	r3, [r3, #43]
    2534:	e54b3015 	strb	r3, [fp, #-21]
    2538:	ea000015 	b	2594 <reserve_direntry+0x22c>
		if (disk_write(fs->drive, fs->win, sector, 1) != RES_OK)
    253c:	e51b3010 	ldr	r3, [fp, #-16]
    2540:	e5d3302d 	ldrb	r3, [r3, #45]
    2544:	e1a02003 	mov	r2, r3
    2548:	e51b3010 	ldr	r3, [fp, #-16]
    254c:	e2833030 	add	r3, r3, #48	; 0x30
    2550:	e1a00002 	mov	r0, r2
    2554:	e1a01003 	mov	r1, r3
    2558:	e51b201c 	ldr	r2, [fp, #-28]
    255c:	e3a03001 	mov	r3, #1	; 0x1
    2560:	eb0009b7 	bl	4c44 <disk_write>
    2564:	e1a03000 	mov	r3, r0
    2568:	e3530000 	cmp	r3, #0	; 0x0
    256c:	0a000002 	beq	257c <reserve_direntry+0x214>
			return FR_RW_ERROR;
    2570:	e3a03008 	mov	r3, #8	; 0x8
    2574:	e50b302c 	str	r3, [fp, #-44]
    2578:	ea000011 	b	25c4 <reserve_direntry+0x25c>
		sector++;
    257c:	e51b301c 	ldr	r3, [fp, #-28]
    2580:	e2833001 	add	r3, r3, #1	; 0x1
    2584:	e50b301c 	str	r3, [fp, #-28]
	if (clust == 1 || !move_window(fs, 0)) return FR_RW_ERROR;

	/* Cleanup the expanded table */
	fs->winsect = sector = clust2sect(fs, clust);
	memset(fs->win, 0, SS(fs));
	for (n = fs->csize; n; n--) {
    2588:	e55b3015 	ldrb	r3, [fp, #-21]
    258c:	e2433001 	sub	r3, r3, #1	; 0x1
    2590:	e54b3015 	strb	r3, [fp, #-21]
    2594:	e55b3015 	ldrb	r3, [fp, #-21]
    2598:	e3530000 	cmp	r3, #0	; 0x0
    259c:	1affffe6 	bne	253c <reserve_direntry+0x1d4>
		if (disk_write(fs->drive, fs->win, sector, 1) != RES_OK)
			return FR_RW_ERROR;
		sector++;
	}
	fs->winflag = 1;
    25a0:	e51b2010 	ldr	r2, [fp, #-16]
    25a4:	e3a03001 	mov	r3, #1	; 0x1
    25a8:	e5c2302e 	strb	r3, [r2, #46]
	*dir = fs->win;
    25ac:	e51b3010 	ldr	r3, [fp, #-16]
    25b0:	e2832030 	add	r2, r3, #48	; 0x30
    25b4:	e51b3028 	ldr	r3, [fp, #-40]
    25b8:	e5832000 	str	r2, [r3]

	return FR_OK;
    25bc:	e3a03000 	mov	r3, #0	; 0x0
    25c0:	e50b302c 	str	r3, [fp, #-44]
    25c4:	e51b302c 	ldr	r3, [fp, #-44]
}
    25c8:	e1a00003 	mov	r0, r3
    25cc:	e24bd00c 	sub	sp, fp, #12	; 0xc
    25d0:	e89da800 	ldm	sp, {fp, sp, pc}

000025d4 <check_fs>:
static
BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record or error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    25d4:	e1a0c00d 	mov	ip, sp
    25d8:	e92dd800 	push	{fp, ip, lr, pc}
    25dc:	e24cb004 	sub	fp, ip, #4	; 0x4
    25e0:	e24dd00c 	sub	sp, sp, #12	; 0xc
    25e4:	e50b0010 	str	r0, [fp, #-16]
    25e8:	e50b1014 	str	r1, [fp, #-20]
	//xprintf(" fspass1 ");
	if (disk_read(fs->drive, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    25ec:	e51b3010 	ldr	r3, [fp, #-16]
    25f0:	e5d3302d 	ldrb	r3, [r3, #45]
    25f4:	e1a02003 	mov	r2, r3
    25f8:	e51b3010 	ldr	r3, [fp, #-16]
    25fc:	e2833030 	add	r3, r3, #48	; 0x30
    2600:	e1a00002 	mov	r0, r2
    2604:	e1a01003 	mov	r1, r3
    2608:	e51b2014 	ldr	r2, [fp, #-20]
    260c:	e3a03001 	mov	r3, #1	; 0x1
    2610:	eb000943 	bl	4b24 <disk_read>
    2614:	e1a03000 	mov	r3, r0
    2618:	e3530000 	cmp	r3, #0	; 0x0
    261c:	0a000002 	beq	262c <check_fs+0x58>
		return 2;
    2620:	e3a03002 	mov	r3, #2	; 0x2
    2624:	e50b3018 	str	r3, [fp, #-24]
    2628:	ea000038 	b	2710 <check_fs+0x13c>
	//xprintf(" fspass2 ");
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)				/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    262c:	e51b3010 	ldr	r3, [fp, #-16]
    2630:	e2833f8b 	add	r3, r3, #556	; 0x22c
    2634:	e2833003 	add	r3, r3, #3	; 0x3
    2638:	e5d33000 	ldrb	r3, [r3]
    263c:	e20330ff 	and	r3, r3, #255	; 0xff
    2640:	e1a03403 	lsl	r3, r3, #8
    2644:	e1a03803 	lsl	r3, r3, #16
    2648:	e1a02823 	lsr	r2, r3, #16
    264c:	e51b3010 	ldr	r3, [fp, #-16]
    2650:	e2833f8b 	add	r3, r3, #556	; 0x22c
    2654:	e2833002 	add	r3, r3, #2	; 0x2
    2658:	e5d33000 	ldrb	r3, [r3]
    265c:	e20330ff 	and	r3, r3, #255	; 0xff
    2660:	e1823003 	orr	r3, r2, r3
    2664:	e1a03803 	lsl	r3, r3, #16
    2668:	e1a03823 	lsr	r3, r3, #16
    266c:	e1a03803 	lsl	r3, r3, #16
    2670:	e1a02843 	asr	r2, r3, #16
    2674:	e3e03c55 	mvn	r3, #21760	; 0x5500
    2678:	e24330aa 	sub	r3, r3, #170	; 0xaa
    267c:	e1520003 	cmp	r2, r3
    2680:	0a000002 	beq	2690 <check_fs+0xbc>
		return 2;
    2684:	e3a03002 	mov	r3, #2	; 0x2
    2688:	e50b3018 	str	r3, [fp, #-24]
    268c:	ea00001f 	b	2710 <check_fs+0x13c>
	//xprintf(" fspass3 ");
	if (!memcmp(&fs->win[BS_FilSysType], "FAT", 3))			/* Check FAT signature */
    2690:	e51b3010 	ldr	r3, [fp, #-16]
    2694:	e2833066 	add	r3, r3, #102	; 0x66
    2698:	e1a00003 	mov	r0, r3
    269c:	e59f107c 	ldr	r1, [pc, #124]	; 2720 <check_fs+0x14c>
    26a0:	e3a02003 	mov	r2, #3	; 0x3
    26a4:	eb001a7e 	bl	90a4 <memcmp>
    26a8:	e1a03000 	mov	r3, r0
    26ac:	e3530000 	cmp	r3, #0	; 0x0
    26b0:	1a000002 	bne	26c0 <check_fs+0xec>
		return 0;
    26b4:	e3a03000 	mov	r3, #0	; 0x0
    26b8:	e50b3018 	str	r3, [fp, #-24]
    26bc:	ea000013 	b	2710 <check_fs+0x13c>
	//xprintf(" fspass4 ");
	if (!memcmp(&fs->win[BS_FilSysType32], "FAT32", 5) && !(fs->win[BPB_ExtFlags] & 0x80))
    26c0:	e51b3010 	ldr	r3, [fp, #-16]
    26c4:	e2833082 	add	r3, r3, #130	; 0x82
    26c8:	e1a00003 	mov	r0, r3
    26cc:	e59f1050 	ldr	r1, [pc, #80]	; 2724 <check_fs+0x150>
    26d0:	e3a02005 	mov	r2, #5	; 0x5
    26d4:	eb001a72 	bl	90a4 <memcmp>
    26d8:	e1a03000 	mov	r3, r0
    26dc:	e3530000 	cmp	r3, #0	; 0x0
    26e0:	1a000008 	bne	2708 <check_fs+0x134>
    26e4:	e51b3010 	ldr	r3, [fp, #-16]
    26e8:	e5d33058 	ldrb	r3, [r3, #88]
    26ec:	e1a03c03 	lsl	r3, r3, #24
    26f0:	e1a03c43 	asr	r3, r3, #24
    26f4:	e3530000 	cmp	r3, #0	; 0x0
    26f8:	ba000002 	blt	2708 <check_fs+0x134>
		return 0;
    26fc:	e3a03000 	mov	r3, #0	; 0x0
    2700:	e50b3018 	str	r3, [fp, #-24]
    2704:	ea000001 	b	2710 <check_fs+0x13c>

	return 1;
    2708:	e3a03001 	mov	r3, #1	; 0x1
    270c:	e50b3018 	str	r3, [fp, #-24]
    2710:	e51b3018 	ldr	r3, [fp, #-24]
}
    2714:	e1a00003 	mov	r0, r3
    2718:	e24bd00c 	sub	sp, fp, #12	; 0xc
    271c:	e89da800 	ldm	sp, {fp, sp, pc}
    2720:	00009534 	.word	0x00009534
    2724:	00009538 	.word	0x00009538

00002728 <auto_mount>:
FRESULT auto_mount (	/* FR_OK(0): successful, !=0: any error occured */
	const char **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
    2728:	e1a0c00d 	mov	ip, sp
    272c:	e92dd800 	push	{fp, ip, lr, pc}
    2730:	e24cb004 	sub	fp, ip, #4	; 0x4
    2734:	e24dd034 	sub	sp, sp, #52	; 0x34
    2738:	e50b0034 	str	r0, [fp, #-52]
    273c:	e50b1038 	str	r1, [fp, #-56]
    2740:	e1a03002 	mov	r3, r2
    2744:	e54b303c 	strb	r3, [fp, #-60]
	BYTE drv, fmt, *tbl;
	DSTATUS stat;
	DWORD bootsect, fatsize, totalsect, maxclust;
	const char *p = *path;
    2748:	e51b3034 	ldr	r3, [fp, #-52]
    274c:	e5933000 	ldr	r3, [r3]
    2750:	e50b3014 	str	r3, [fp, #-20]
    2754:	ea000002 	b	2764 <auto_mount+0x3c>
	FATFS *fs;

	//xprintf("pass3");
	/* Get drive number from the path name */
	while (*p == ' ') p++;		/* Strip leading spaces */
    2758:	e51b3014 	ldr	r3, [fp, #-20]
    275c:	e2833001 	add	r3, r3, #1	; 0x1
    2760:	e50b3014 	str	r3, [fp, #-20]
    2764:	e51b3014 	ldr	r3, [fp, #-20]
    2768:	e5d33000 	ldrb	r3, [r3]
    276c:	e3530020 	cmp	r3, #32	; 0x20
    2770:	0afffff8 	beq	2758 <auto_mount+0x30>
	drv = p[0] - '0';			/* Is there a drive number? */
    2774:	e51b3014 	ldr	r3, [fp, #-20]
    2778:	e5d33000 	ldrb	r3, [r3]
    277c:	e2433030 	sub	r3, r3, #48	; 0x30
    2780:	e54b302e 	strb	r3, [fp, #-46]
	if (drv <= 9 && p[1] == ':')
    2784:	e55b302e 	ldrb	r3, [fp, #-46]
    2788:	e3530009 	cmp	r3, #9	; 0x9
    278c:	8a000008 	bhi	27b4 <auto_mount+0x8c>
    2790:	e51b3014 	ldr	r3, [fp, #-20]
    2794:	e2833001 	add	r3, r3, #1	; 0x1
    2798:	e5d33000 	ldrb	r3, [r3]
    279c:	e353003a 	cmp	r3, #58	; 0x3a
    27a0:	1a000003 	bne	27b4 <auto_mount+0x8c>
		p += 2;				/* Found a drive number, get and strip it */
    27a4:	e51b3014 	ldr	r3, [fp, #-20]
    27a8:	e2833002 	add	r3, r3, #2	; 0x2
    27ac:	e50b3014 	str	r3, [fp, #-20]
    27b0:	ea000001 	b	27bc <auto_mount+0x94>
	else
		drv = 0;			/* No drive number is given, use drive number 0 as default */
    27b4:	e3a03000 	mov	r3, #0	; 0x0
    27b8:	e54b302e 	strb	r3, [fp, #-46]
	if (*p == '/') p++;		/* Strip heading slash */
    27bc:	e51b3014 	ldr	r3, [fp, #-20]
    27c0:	e5d33000 	ldrb	r3, [r3]
    27c4:	e353002f 	cmp	r3, #47	; 0x2f
    27c8:	1a000002 	bne	27d8 <auto_mount+0xb0>
    27cc:	e51b3014 	ldr	r3, [fp, #-20]
    27d0:	e2833001 	add	r3, r3, #1	; 0x1
    27d4:	e50b3014 	str	r3, [fp, #-20]
	*path = p;				/* Return pointer to the path name */
    27d8:	e51b3034 	ldr	r3, [fp, #-52]
    27dc:	e51b2014 	ldr	r2, [fp, #-20]
    27e0:	e5832000 	str	r2, [r3]
	//xprintf("pass4");
	/* Check if the drive number is valid or not */
	if (drv >= _DRIVES) return FR_INVALID_DRIVE;	/* Is the drive number valid? */
    27e4:	e55b302e 	ldrb	r3, [fp, #-46]
    27e8:	e3530000 	cmp	r3, #0	; 0x0
    27ec:	0a000002 	beq	27fc <auto_mount+0xd4>
    27f0:	e3a03005 	mov	r3, #5	; 0x5
    27f4:	e50b3040 	str	r3, [fp, #-64]
    27f8:	ea000239 	b	30e4 <auto_mount+0x9bc>
	*rfs = fs = FatFs[drv];					/* Return pointer to the corresponding file system object */
    27fc:	e55b202e 	ldrb	r2, [fp, #-46]
    2800:	e59f38ec 	ldr	r3, [pc, #2284]	; 30f4 <auto_mount+0x9cc>
    2804:	e7933102 	ldr	r3, [r3, r2, lsl #2]
    2808:	e50b3010 	str	r3, [fp, #-16]
    280c:	e51b2038 	ldr	r2, [fp, #-56]
    2810:	e51b3010 	ldr	r3, [fp, #-16]
    2814:	e5823000 	str	r3, [r2]
	if (!fs) return FR_NOT_ENABLED;			/* Is the file system object registered? */
    2818:	e51b3010 	ldr	r3, [fp, #-16]
    281c:	e3530000 	cmp	r3, #0	; 0x0
    2820:	1a000002 	bne	2830 <auto_mount+0x108>
    2824:	e3a0300a 	mov	r3, #10	; 0xa
    2828:	e50b3040 	str	r3, [fp, #-64]
    282c:	ea00022c 	b	30e4 <auto_mount+0x9bc>
	//xprintf("pass5");
	if (fs->fs_type) {						/* If the logical drive has been mounted */
    2830:	e51b3010 	ldr	r3, [fp, #-16]
    2834:	e5d3302a 	ldrb	r3, [r3, #42]
    2838:	e3530000 	cmp	r3, #0	; 0x0
    283c:	0a000016 	beq	289c <auto_mount+0x174>
		stat = disk_status(fs->drive);
    2840:	e51b3010 	ldr	r3, [fp, #-16]
    2844:	e5d3302d 	ldrb	r3, [r3, #45]
    2848:	e1a00003 	mov	r0, r3
    284c:	eb00089f 	bl	4ad0 <disk_status>
    2850:	e1a03000 	mov	r3, r0
    2854:	e54b3025 	strb	r3, [fp, #-37]
		if (!(stat & STA_NOINIT)) {			/* and physical drive is kept initialized (has not been changed), */
    2858:	e55b3025 	ldrb	r3, [fp, #-37]
    285c:	e2033001 	and	r3, r3, #1	; 0x1
    2860:	e3530000 	cmp	r3, #0	; 0x0
    2864:	1a00000c 	bne	289c <auto_mount+0x174>
#if !_FS_READONLY
			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
    2868:	e55b303c 	ldrb	r3, [fp, #-60]
    286c:	e3530000 	cmp	r3, #0	; 0x0
    2870:	0a000006 	beq	2890 <auto_mount+0x168>
    2874:	e55b3025 	ldrb	r3, [fp, #-37]
    2878:	e2033004 	and	r3, r3, #4	; 0x4
    287c:	e3530000 	cmp	r3, #0	; 0x0
    2880:	0a000002 	beq	2890 <auto_mount+0x168>
				return FR_WRITE_PROTECTED;
    2884:	e3a03009 	mov	r3, #9	; 0x9
    2888:	e50b3040 	str	r3, [fp, #-64]
    288c:	ea000214 	b	30e4 <auto_mount+0x9bc>
#endif
			return FR_OK;					/* The file system object is valid */
    2890:	e3a03000 	mov	r3, #0	; 0x0
    2894:	e50b3040 	str	r3, [fp, #-64]
    2898:	ea000211 	b	30e4 <auto_mount+0x9bc>
		}
	}
	//xprintf("pass6");
	/* The logical drive must be re-mounted. Following code attempts to mount the logical drive */

	memset(fs, 0, sizeof(FATFS));		/* Clean-up the file system object */
    289c:	e51b0010 	ldr	r0, [fp, #-16]
    28a0:	e3a01000 	mov	r1, #0	; 0x0
    28a4:	e3a02e23 	mov	r2, #560	; 0x230
    28a8:	eb001a67 	bl	924c <memset>
	fs->drive = LD2PD(drv);				/* Bind the logical drive and a physical drive */
    28ac:	e51b2010 	ldr	r2, [fp, #-16]
    28b0:	e55b302e 	ldrb	r3, [fp, #-46]
    28b4:	e5c2302d 	strb	r3, [r2, #45]
	stat = disk_initialize(fs->drive);	/* Initialize low level disk I/O layer */
    28b8:	e51b3010 	ldr	r3, [fp, #-16]
    28bc:	e5d3302d 	ldrb	r3, [r3, #45]
    28c0:	e1a00003 	mov	r0, r3
    28c4:	eb00083b 	bl	49b8 <disk_initialize>
    28c8:	e1a03000 	mov	r3, r0
    28cc:	e54b3025 	strb	r3, [fp, #-37]
	if (stat & STA_NOINIT)				/* Check if the drive is ready */
    28d0:	e55b3025 	ldrb	r3, [fp, #-37]
    28d4:	e2033001 	and	r3, r3, #1	; 0x1
    28d8:	e20330ff 	and	r3, r3, #255	; 0xff
    28dc:	e3530000 	cmp	r3, #0	; 0x0
    28e0:	0a000002 	beq	28f0 <auto_mount+0x1c8>
		return FR_NOT_READY;
    28e4:	e3a03001 	mov	r3, #1	; 0x1
    28e8:	e50b3040 	str	r3, [fp, #-64]
    28ec:	ea0001fc 	b	30e4 <auto_mount+0x9bc>
#if S_MAX_SIZ > 512						/* Get disk sector size if needed */
	if (disk_ioctl(drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > S_MAX_SIZ)
		return FR_NO_FILESYSTEM;
#endif
#if !_FS_READONLY
	if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
    28f0:	e55b303c 	ldrb	r3, [fp, #-60]
    28f4:	e3530000 	cmp	r3, #0	; 0x0
    28f8:	0a000006 	beq	2918 <auto_mount+0x1f0>
    28fc:	e55b3025 	ldrb	r3, [fp, #-37]
    2900:	e2033004 	and	r3, r3, #4	; 0x4
    2904:	e3530000 	cmp	r3, #0	; 0x0
    2908:	0a000002 	beq	2918 <auto_mount+0x1f0>
		return FR_WRITE_PROTECTED;
    290c:	e3a03009 	mov	r3, #9	; 0x9
    2910:	e50b3040 	str	r3, [fp, #-64]
    2914:	ea0001f2 	b	30e4 <auto_mount+0x9bc>
#endif
	//xprintf("pass7");
	/* Search FAT partition on the drive */
	fmt = check_fs(fs, bootsect = 0);	/* Check sector 0 as an SFD format */
    2918:	e3a03000 	mov	r3, #0	; 0x0
    291c:	e50b3024 	str	r3, [fp, #-36]
    2920:	e51b0010 	ldr	r0, [fp, #-16]
    2924:	e51b1024 	ldr	r1, [fp, #-36]
    2928:	ebffff29 	bl	25d4 <check_fs>
    292c:	e1a03000 	mov	r3, r0
    2930:	e54b302d 	strb	r3, [fp, #-45]

	//xprintf("pass8");
	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
    2934:	e55b302d 	ldrb	r3, [fp, #-45]
    2938:	e3530001 	cmp	r3, #1	; 0x1
    293c:	1a000024 	bne	29d4 <auto_mount+0x2ac>
		/* Check a partition listed in top of the partition table */
		tbl = &fs->win[MBR_Table + LD2PT(drv) * 16];	/* Partition table */
    2940:	e51b3010 	ldr	r3, [fp, #-16]
    2944:	e2833f7b 	add	r3, r3, #492	; 0x1ec
    2948:	e2833002 	add	r3, r3, #2	; 0x2
    294c:	e50b302c 	str	r3, [fp, #-44]
		if (tbl[4]) {									/* Is the partition existing? */
    2950:	e51b302c 	ldr	r3, [fp, #-44]
    2954:	e2833004 	add	r3, r3, #4	; 0x4
    2958:	e5d33000 	ldrb	r3, [r3]
    295c:	e3530000 	cmp	r3, #0	; 0x0
    2960:	0a00001b 	beq	29d4 <auto_mount+0x2ac>
			bootsect = LD_DWORD(&tbl[8]);				/* Partition offset in LBA */
    2964:	e51b302c 	ldr	r3, [fp, #-44]
    2968:	e283300b 	add	r3, r3, #11	; 0xb
    296c:	e5d33000 	ldrb	r3, [r3]
    2970:	e20330ff 	and	r3, r3, #255	; 0xff
    2974:	e1a02c03 	lsl	r2, r3, #24
    2978:	e51b302c 	ldr	r3, [fp, #-44]
    297c:	e283300a 	add	r3, r3, #10	; 0xa
    2980:	e5d33000 	ldrb	r3, [r3]
    2984:	e20330ff 	and	r3, r3, #255	; 0xff
    2988:	e1a03803 	lsl	r3, r3, #16
    298c:	e1822003 	orr	r2, r2, r3
    2990:	e51b302c 	ldr	r3, [fp, #-44]
    2994:	e2833009 	add	r3, r3, #9	; 0x9
    2998:	e5d33000 	ldrb	r3, [r3]
    299c:	e20330ff 	and	r3, r3, #255	; 0xff
    29a0:	e1a03403 	lsl	r3, r3, #8
    29a4:	e1822003 	orr	r2, r2, r3
    29a8:	e51b302c 	ldr	r3, [fp, #-44]
    29ac:	e2833008 	add	r3, r3, #8	; 0x8
    29b0:	e5d33000 	ldrb	r3, [r3]
    29b4:	e20330ff 	and	r3, r3, #255	; 0xff
    29b8:	e1823003 	orr	r3, r2, r3
    29bc:	e50b3024 	str	r3, [fp, #-36]
			fmt = check_fs(fs, bootsect);				/* Check the partition */
    29c0:	e51b0010 	ldr	r0, [fp, #-16]
    29c4:	e51b1024 	ldr	r1, [fp, #-36]
    29c8:	ebffff01 	bl	25d4 <check_fs>
    29cc:	e1a03000 	mov	r3, r0
    29d0:	e54b302d 	strb	r3, [fp, #-45]
		}
	}
	if (fmt || LD_WORD(&fs->win[BPB_BytsPerSec]) != SS(fs))	/* No valid FAT patition is found */
    29d4:	e55b302d 	ldrb	r3, [fp, #-45]
    29d8:	e3530000 	cmp	r3, #0	; 0x0
    29dc:	1a000011 	bne	2a28 <auto_mount+0x300>
    29e0:	e51b3010 	ldr	r3, [fp, #-16]
    29e4:	e283303c 	add	r3, r3, #60	; 0x3c
    29e8:	e5d33000 	ldrb	r3, [r3]
    29ec:	e20330ff 	and	r3, r3, #255	; 0xff
    29f0:	e1a03403 	lsl	r3, r3, #8
    29f4:	e1a03803 	lsl	r3, r3, #16
    29f8:	e1a02823 	lsr	r2, r3, #16
    29fc:	e51b3010 	ldr	r3, [fp, #-16]
    2a00:	e283303b 	add	r3, r3, #59	; 0x3b
    2a04:	e5d33000 	ldrb	r3, [r3]
    2a08:	e20330ff 	and	r3, r3, #255	; 0xff
    2a0c:	e1823003 	orr	r3, r2, r3
    2a10:	e1a03803 	lsl	r3, r3, #16
    2a14:	e1a03823 	lsr	r3, r3, #16
    2a18:	e1a03803 	lsl	r3, r3, #16
    2a1c:	e1a03843 	asr	r3, r3, #16
    2a20:	e3530c02 	cmp	r3, #512	; 0x200
    2a24:	0a000002 	beq	2a34 <auto_mount+0x30c>
		return FR_NO_FILESYSTEM;
    2a28:	e3a0300b 	mov	r3, #11	; 0xb
    2a2c:	e50b3040 	str	r3, [fp, #-64]
    2a30:	ea0001ab 	b	30e4 <auto_mount+0x9bc>
	/* Initialize the file system object */
	fatsize = LD_WORD(&fs->win[BPB_FATSz16]);			/* Number of sectors per FAT */
    2a34:	e51b3010 	ldr	r3, [fp, #-16]
    2a38:	e2833047 	add	r3, r3, #71	; 0x47
    2a3c:	e5d33000 	ldrb	r3, [r3]
    2a40:	e20330ff 	and	r3, r3, #255	; 0xff
    2a44:	e1a03403 	lsl	r3, r3, #8
    2a48:	e1a03803 	lsl	r3, r3, #16
    2a4c:	e1a02823 	lsr	r2, r3, #16
    2a50:	e51b3010 	ldr	r3, [fp, #-16]
    2a54:	e2833046 	add	r3, r3, #70	; 0x46
    2a58:	e5d33000 	ldrb	r3, [r3]
    2a5c:	e20330ff 	and	r3, r3, #255	; 0xff
    2a60:	e1823003 	orr	r3, r2, r3
    2a64:	e1a03803 	lsl	r3, r3, #16
    2a68:	e1a03823 	lsr	r3, r3, #16
    2a6c:	e1a03803 	lsl	r3, r3, #16
    2a70:	e1a03823 	lsr	r3, r3, #16
    2a74:	e50b3020 	str	r3, [fp, #-32]
	if (!fatsize) fatsize = LD_DWORD(&fs->win[BPB_FATSz32]);
    2a78:	e51b3020 	ldr	r3, [fp, #-32]
    2a7c:	e3530000 	cmp	r3, #0	; 0x0
    2a80:	1a000016 	bne	2ae0 <auto_mount+0x3b8>
    2a84:	e51b3010 	ldr	r3, [fp, #-16]
    2a88:	e2833057 	add	r3, r3, #87	; 0x57
    2a8c:	e5d33000 	ldrb	r3, [r3]
    2a90:	e20330ff 	and	r3, r3, #255	; 0xff
    2a94:	e1a02c03 	lsl	r2, r3, #24
    2a98:	e51b3010 	ldr	r3, [fp, #-16]
    2a9c:	e2833056 	add	r3, r3, #86	; 0x56
    2aa0:	e5d33000 	ldrb	r3, [r3]
    2aa4:	e20330ff 	and	r3, r3, #255	; 0xff
    2aa8:	e1a03803 	lsl	r3, r3, #16
    2aac:	e1822003 	orr	r2, r2, r3
    2ab0:	e51b3010 	ldr	r3, [fp, #-16]
    2ab4:	e2833055 	add	r3, r3, #85	; 0x55
    2ab8:	e5d33000 	ldrb	r3, [r3]
    2abc:	e20330ff 	and	r3, r3, #255	; 0xff
    2ac0:	e1a03403 	lsl	r3, r3, #8
    2ac4:	e1822003 	orr	r2, r2, r3
    2ac8:	e51b3010 	ldr	r3, [fp, #-16]
    2acc:	e2833054 	add	r3, r3, #84	; 0x54
    2ad0:	e5d33000 	ldrb	r3, [r3]
    2ad4:	e20330ff 	and	r3, r3, #255	; 0xff
    2ad8:	e1823003 	orr	r3, r2, r3
    2adc:	e50b3020 	str	r3, [fp, #-32]
	fs->sects_fat = fatsize;
    2ae0:	e51b2010 	ldr	r2, [fp, #-16]
    2ae4:	e51b3020 	ldr	r3, [fp, #-32]
    2ae8:	e5823008 	str	r3, [r2, #8]
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
    2aec:	e51b3010 	ldr	r3, [fp, #-16]
    2af0:	e5d33040 	ldrb	r3, [r3, #64]
    2af4:	e51b2010 	ldr	r2, [fp, #-16]
    2af8:	e5c2302c 	strb	r3, [r2, #44]
	fatsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
    2afc:	e51b3010 	ldr	r3, [fp, #-16]
    2b00:	e5d3302c 	ldrb	r3, [r3, #44]
    2b04:	e1a02003 	mov	r2, r3
    2b08:	e51b3020 	ldr	r3, [fp, #-32]
    2b0c:	e0030392 	mul	r3, r2, r3
    2b10:	e50b3020 	str	r3, [fp, #-32]
	fs->fatbase = bootsect + LD_WORD(&fs->win[BPB_RsvdSecCnt]); /* FAT start sector (lba) */
    2b14:	e51b3010 	ldr	r3, [fp, #-16]
    2b18:	e283303f 	add	r3, r3, #63	; 0x3f
    2b1c:	e5d33000 	ldrb	r3, [r3]
    2b20:	e20330ff 	and	r3, r3, #255	; 0xff
    2b24:	e1a03403 	lsl	r3, r3, #8
    2b28:	e1a03803 	lsl	r3, r3, #16
    2b2c:	e1a02823 	lsr	r2, r3, #16
    2b30:	e51b3010 	ldr	r3, [fp, #-16]
    2b34:	e283303e 	add	r3, r3, #62	; 0x3e
    2b38:	e5d33000 	ldrb	r3, [r3]
    2b3c:	e20330ff 	and	r3, r3, #255	; 0xff
    2b40:	e1823003 	orr	r3, r2, r3
    2b44:	e1a03803 	lsl	r3, r3, #16
    2b48:	e1a03823 	lsr	r3, r3, #16
    2b4c:	e1a03803 	lsl	r3, r3, #16
    2b50:	e1a03823 	lsr	r3, r3, #16
    2b54:	e1a02003 	mov	r2, r3
    2b58:	e51b3024 	ldr	r3, [fp, #-36]
    2b5c:	e0822003 	add	r2, r2, r3
    2b60:	e51b3010 	ldr	r3, [fp, #-16]
    2b64:	e5832010 	str	r2, [r3, #16]
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
    2b68:	e51b3010 	ldr	r3, [fp, #-16]
    2b6c:	e5d3303d 	ldrb	r3, [r3, #61]
    2b70:	e51b2010 	ldr	r2, [fp, #-16]
    2b74:	e5c2302b 	strb	r3, [r2, #43]
	fs->n_rootdir = LD_WORD(&fs->win[BPB_RootEntCnt]);	/* Nmuber of root directory entries */
    2b78:	e51b3010 	ldr	r3, [fp, #-16]
    2b7c:	e2833042 	add	r3, r3, #66	; 0x42
    2b80:	e5d33000 	ldrb	r3, [r3]
    2b84:	e20330ff 	and	r3, r3, #255	; 0xff
    2b88:	e1a03403 	lsl	r3, r3, #8
    2b8c:	e1a03803 	lsl	r3, r3, #16
    2b90:	e1a02823 	lsr	r2, r3, #16
    2b94:	e51b3010 	ldr	r3, [fp, #-16]
    2b98:	e2833041 	add	r3, r3, #65	; 0x41
    2b9c:	e5d33000 	ldrb	r3, [r3]
    2ba0:	e20330ff 	and	r3, r3, #255	; 0xff
    2ba4:	e1823003 	orr	r3, r2, r3
    2ba8:	e1a03803 	lsl	r3, r3, #16
    2bac:	e1a03823 	lsr	r3, r3, #16
    2bb0:	e1a03803 	lsl	r3, r3, #16
    2bb4:	e1a02823 	lsr	r2, r3, #16
    2bb8:	e51b3010 	ldr	r3, [fp, #-16]
    2bbc:	e1c320b2 	strh	r2, [r3, #2]
	totalsect = LD_WORD(&fs->win[BPB_TotSec16]);		/* Number of sectors on the file system */
    2bc0:	e51b3010 	ldr	r3, [fp, #-16]
    2bc4:	e2833044 	add	r3, r3, #68	; 0x44
    2bc8:	e5d33000 	ldrb	r3, [r3]
    2bcc:	e20330ff 	and	r3, r3, #255	; 0xff
    2bd0:	e1a03403 	lsl	r3, r3, #8
    2bd4:	e1a03803 	lsl	r3, r3, #16
    2bd8:	e1a02823 	lsr	r2, r3, #16
    2bdc:	e51b3010 	ldr	r3, [fp, #-16]
    2be0:	e2833043 	add	r3, r3, #67	; 0x43
    2be4:	e5d33000 	ldrb	r3, [r3]
    2be8:	e20330ff 	and	r3, r3, #255	; 0xff
    2bec:	e1823003 	orr	r3, r2, r3
    2bf0:	e1a03803 	lsl	r3, r3, #16
    2bf4:	e1a03823 	lsr	r3, r3, #16
    2bf8:	e1a03803 	lsl	r3, r3, #16
    2bfc:	e1a03823 	lsr	r3, r3, #16
    2c00:	e50b301c 	str	r3, [fp, #-28]
	if (!totalsect) totalsect = LD_DWORD(&fs->win[BPB_TotSec32]);
    2c04:	e51b301c 	ldr	r3, [fp, #-28]
    2c08:	e3530000 	cmp	r3, #0	; 0x0
    2c0c:	1a000016 	bne	2c6c <auto_mount+0x544>
    2c10:	e51b3010 	ldr	r3, [fp, #-16]
    2c14:	e2833053 	add	r3, r3, #83	; 0x53
    2c18:	e5d33000 	ldrb	r3, [r3]
    2c1c:	e20330ff 	and	r3, r3, #255	; 0xff
    2c20:	e1a02c03 	lsl	r2, r3, #24
    2c24:	e51b3010 	ldr	r3, [fp, #-16]
    2c28:	e2833052 	add	r3, r3, #82	; 0x52
    2c2c:	e5d33000 	ldrb	r3, [r3]
    2c30:	e20330ff 	and	r3, r3, #255	; 0xff
    2c34:	e1a03803 	lsl	r3, r3, #16
    2c38:	e1822003 	orr	r2, r2, r3
    2c3c:	e51b3010 	ldr	r3, [fp, #-16]
    2c40:	e2833051 	add	r3, r3, #81	; 0x51
    2c44:	e5d33000 	ldrb	r3, [r3]
    2c48:	e20330ff 	and	r3, r3, #255	; 0xff
    2c4c:	e1a03403 	lsl	r3, r3, #8
    2c50:	e1822003 	orr	r2, r2, r3
    2c54:	e51b3010 	ldr	r3, [fp, #-16]
    2c58:	e2833050 	add	r3, r3, #80	; 0x50
    2c5c:	e5d33000 	ldrb	r3, [r3]
    2c60:	e20330ff 	and	r3, r3, #255	; 0xff
    2c64:	e1823003 	orr	r3, r2, r3
    2c68:	e50b301c 	str	r3, [fp, #-28]
	fs->max_clust = maxclust = (totalsect				/* max_clust = Last cluster# + 1 */
    2c6c:	e51b3010 	ldr	r3, [fp, #-16]
    2c70:	e283303f 	add	r3, r3, #63	; 0x3f
    2c74:	e5d33000 	ldrb	r3, [r3]
    2c78:	e20330ff 	and	r3, r3, #255	; 0xff
    2c7c:	e1a03403 	lsl	r3, r3, #8
    2c80:	e1a03803 	lsl	r3, r3, #16
    2c84:	e1a02823 	lsr	r2, r3, #16
    2c88:	e51b3010 	ldr	r3, [fp, #-16]
    2c8c:	e283303e 	add	r3, r3, #62	; 0x3e
    2c90:	e5d33000 	ldrb	r3, [r3]
    2c94:	e20330ff 	and	r3, r3, #255	; 0xff
    2c98:	e1823003 	orr	r3, r2, r3
    2c9c:	e1a03803 	lsl	r3, r3, #16
    2ca0:	e1a03823 	lsr	r3, r3, #16
    2ca4:	e1a03803 	lsl	r3, r3, #16
    2ca8:	e1a03823 	lsr	r3, r3, #16
    2cac:	e1a02003 	mov	r2, r3
    2cb0:	e51b301c 	ldr	r3, [fp, #-28]
    2cb4:	e0622003 	rsb	r2, r2, r3
    2cb8:	e51b3020 	ldr	r3, [fp, #-32]
    2cbc:	e0632002 	rsb	r2, r3, r2
    2cc0:	e51b3010 	ldr	r3, [fp, #-16]
    2cc4:	e1d330b2 	ldrh	r3, [r3, #2]
    2cc8:	e1a03223 	lsr	r3, r3, #4
    2ccc:	e1a03803 	lsl	r3, r3, #16
    2cd0:	e1a03823 	lsr	r3, r3, #16
    2cd4:	e0632002 	rsb	r2, r3, r2
    2cd8:	e51b3010 	ldr	r3, [fp, #-16]
    2cdc:	e5d3302b 	ldrb	r3, [r3, #43]
    2ce0:	e1a00002 	mov	r0, r2
    2ce4:	e1a01003 	mov	r1, r3
    2ce8:	eb001999 	bl	9354 <__aeabi_uidiv>
    2cec:	e1a03000 	mov	r3, r0
    2cf0:	e2833002 	add	r3, r3, #2	; 0x2
    2cf4:	e50b3018 	str	r3, [fp, #-24]
    2cf8:	e51b2010 	ldr	r2, [fp, #-16]
    2cfc:	e51b3018 	ldr	r3, [fp, #-24]
    2d00:	e582300c 	str	r3, [r2, #12]
		- LD_WORD(&fs->win[BPB_RsvdSecCnt]) - fatsize - fs->n_rootdir / (SS(fs)/32)
		) / fs->csize + 2;
	fmt = FS_FAT12;										/* Determine the FAT sub type */
    2d04:	e3a03001 	mov	r3, #1	; 0x1
    2d08:	e54b302d 	strb	r3, [fp, #-45]
	if (maxclust >= 0xFF7) fmt = FS_FAT16;
    2d0c:	e51b2018 	ldr	r2, [fp, #-24]
    2d10:	e3a03eff 	mov	r3, #4080	; 0xff0
    2d14:	e2833006 	add	r3, r3, #6	; 0x6
    2d18:	e1520003 	cmp	r2, r3
    2d1c:	9a000001 	bls	2d28 <auto_mount+0x600>
    2d20:	e3a03002 	mov	r3, #2	; 0x2
    2d24:	e54b302d 	strb	r3, [fp, #-45]
	if (maxclust >= 0xFFF7) fmt = FS_FAT32;
    2d28:	e51b2018 	ldr	r2, [fp, #-24]
    2d2c:	e3a03cff 	mov	r3, #65280	; 0xff00
    2d30:	e28330f6 	add	r3, r3, #246	; 0xf6
    2d34:	e1520003 	cmp	r2, r3
    2d38:	9a000001 	bls	2d44 <auto_mount+0x61c>
    2d3c:	e3a03003 	mov	r3, #3	; 0x3
    2d40:	e54b302d 	strb	r3, [fp, #-45]

	if (fmt == FS_FAT32)
    2d44:	e55b302d 	ldrb	r3, [fp, #-45]
    2d48:	e3530003 	cmp	r3, #3	; 0x3
    2d4c:	1a000018 	bne	2db4 <auto_mount+0x68c>
		fs->dirbase = LD_DWORD(&fs->win[BPB_RootClus]);	/* Root directory start cluster */
    2d50:	e51b3010 	ldr	r3, [fp, #-16]
    2d54:	e283305f 	add	r3, r3, #95	; 0x5f
    2d58:	e5d33000 	ldrb	r3, [r3]
    2d5c:	e20330ff 	and	r3, r3, #255	; 0xff
    2d60:	e1a02c03 	lsl	r2, r3, #24
    2d64:	e51b3010 	ldr	r3, [fp, #-16]
    2d68:	e283305e 	add	r3, r3, #94	; 0x5e
    2d6c:	e5d33000 	ldrb	r3, [r3]
    2d70:	e20330ff 	and	r3, r3, #255	; 0xff
    2d74:	e1a03803 	lsl	r3, r3, #16
    2d78:	e1822003 	orr	r2, r2, r3
    2d7c:	e51b3010 	ldr	r3, [fp, #-16]
    2d80:	e283305d 	add	r3, r3, #93	; 0x5d
    2d84:	e5d33000 	ldrb	r3, [r3]
    2d88:	e20330ff 	and	r3, r3, #255	; 0xff
    2d8c:	e1a03403 	lsl	r3, r3, #8
    2d90:	e1822003 	orr	r2, r2, r3
    2d94:	e51b3010 	ldr	r3, [fp, #-16]
    2d98:	e283305c 	add	r3, r3, #92	; 0x5c
    2d9c:	e5d33000 	ldrb	r3, [r3]
    2da0:	e20330ff 	and	r3, r3, #255	; 0xff
    2da4:	e1822003 	orr	r2, r2, r3
    2da8:	e51b3010 	ldr	r3, [fp, #-16]
    2dac:	e5832014 	str	r2, [r3, #20]
    2db0:	ea000005 	b	2dcc <auto_mount+0x6a4>
	else
		fs->dirbase = fs->fatbase + fatsize;			/* Root directory start sector (lba) */
    2db4:	e51b3010 	ldr	r3, [fp, #-16]
    2db8:	e5932010 	ldr	r2, [r3, #16]
    2dbc:	e51b3020 	ldr	r3, [fp, #-32]
    2dc0:	e0822003 	add	r2, r2, r3
    2dc4:	e51b3010 	ldr	r3, [fp, #-16]
    2dc8:	e5832014 	str	r2, [r3, #20]
	fs->database = fs->fatbase + fatsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
    2dcc:	e51b3010 	ldr	r3, [fp, #-16]
    2dd0:	e5932010 	ldr	r2, [r3, #16]
    2dd4:	e51b3020 	ldr	r3, [fp, #-32]
    2dd8:	e0822003 	add	r2, r2, r3
    2ddc:	e51b3010 	ldr	r3, [fp, #-16]
    2de0:	e1d330b2 	ldrh	r3, [r3, #2]
    2de4:	e1a03223 	lsr	r3, r3, #4
    2de8:	e1a03803 	lsl	r3, r3, #16
    2dec:	e1a03823 	lsr	r3, r3, #16
    2df0:	e0822003 	add	r2, r2, r3
    2df4:	e51b3010 	ldr	r3, [fp, #-16]
    2df8:	e5832018 	str	r2, [r3, #24]
	//xprintf("pass9");
#if !_FS_READONLY
	/* Initialize allocation information */
	fs->free_clust = 0xFFFFFFFF;
    2dfc:	e51b2010 	ldr	r2, [fp, #-16]
    2e00:	e3e03000 	mvn	r3, #0	; 0x0
    2e04:	e5823020 	str	r3, [r2, #32]
#if _USE_FSINFO
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
    2e08:	e55b302d 	ldrb	r3, [fp, #-45]
    2e0c:	e3530003 	cmp	r3, #3	; 0x3
    2e10:	1a0000a3 	bne	30a4 <auto_mount+0x97c>
		fs->fsi_sector = bootsect + LD_WORD(&fs->win[BPB_FSInfo]);
    2e14:	e51b3010 	ldr	r3, [fp, #-16]
    2e18:	e2833061 	add	r3, r3, #97	; 0x61
    2e1c:	e5d33000 	ldrb	r3, [r3]
    2e20:	e20330ff 	and	r3, r3, #255	; 0xff
    2e24:	e1a03403 	lsl	r3, r3, #8
    2e28:	e1a03803 	lsl	r3, r3, #16
    2e2c:	e1a02823 	lsr	r2, r3, #16
    2e30:	e51b3010 	ldr	r3, [fp, #-16]
    2e34:	e2833060 	add	r3, r3, #96	; 0x60
    2e38:	e5d33000 	ldrb	r3, [r3]
    2e3c:	e20330ff 	and	r3, r3, #255	; 0xff
    2e40:	e1823003 	orr	r3, r2, r3
    2e44:	e1a03803 	lsl	r3, r3, #16
    2e48:	e1a03823 	lsr	r3, r3, #16
    2e4c:	e1a03803 	lsl	r3, r3, #16
    2e50:	e1a03823 	lsr	r3, r3, #16
    2e54:	e1a02003 	mov	r2, r3
    2e58:	e51b3024 	ldr	r3, [fp, #-36]
    2e5c:	e0822003 	add	r2, r2, r3
    2e60:	e51b3010 	ldr	r3, [fp, #-16]
    2e64:	e5832024 	str	r2, [r3, #36]
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
    2e68:	e51b3010 	ldr	r3, [fp, #-16]
    2e6c:	e5d3302d 	ldrb	r3, [r3, #45]
    2e70:	e1a02003 	mov	r2, r3
    2e74:	e51b3010 	ldr	r3, [fp, #-16]
    2e78:	e2831030 	add	r1, r3, #48	; 0x30
    2e7c:	e51b3010 	ldr	r3, [fp, #-16]
    2e80:	e5933024 	ldr	r3, [r3, #36]
    2e84:	e1a00002 	mov	r0, r2
    2e88:	e1a02003 	mov	r2, r3
    2e8c:	e3a03001 	mov	r3, #1	; 0x1
    2e90:	eb000723 	bl	4b24 <disk_read>
    2e94:	e1a03000 	mov	r3, r0
    2e98:	e3530000 	cmp	r3, #0	; 0x0
    2e9c:	1a000080 	bne	30a4 <auto_mount+0x97c>
    2ea0:	e51b3010 	ldr	r3, [fp, #-16]
    2ea4:	e2833f8b 	add	r3, r3, #556	; 0x22c
    2ea8:	e2833003 	add	r3, r3, #3	; 0x3
    2eac:	e5d33000 	ldrb	r3, [r3]
    2eb0:	e20330ff 	and	r3, r3, #255	; 0xff
    2eb4:	e1a03403 	lsl	r3, r3, #8
    2eb8:	e1a03803 	lsl	r3, r3, #16
    2ebc:	e1a02823 	lsr	r2, r3, #16
    2ec0:	e51b3010 	ldr	r3, [fp, #-16]
    2ec4:	e2833f8b 	add	r3, r3, #556	; 0x22c
    2ec8:	e2833002 	add	r3, r3, #2	; 0x2
    2ecc:	e5d33000 	ldrb	r3, [r3]
    2ed0:	e20330ff 	and	r3, r3, #255	; 0xff
    2ed4:	e1823003 	orr	r3, r2, r3
    2ed8:	e1a03803 	lsl	r3, r3, #16
    2edc:	e1a03823 	lsr	r3, r3, #16
    2ee0:	e1a03803 	lsl	r3, r3, #16
    2ee4:	e1a02843 	asr	r2, r3, #16
    2ee8:	e3e03c55 	mvn	r3, #21760	; 0x5500
    2eec:	e24330aa 	sub	r3, r3, #170	; 0xaa
    2ef0:	e1520003 	cmp	r2, r3
    2ef4:	1a00006a 	bne	30a4 <auto_mount+0x97c>
    2ef8:	e51b3010 	ldr	r3, [fp, #-16]
    2efc:	e2833033 	add	r3, r3, #51	; 0x33
    2f00:	e5d33000 	ldrb	r3, [r3]
    2f04:	e20330ff 	and	r3, r3, #255	; 0xff
    2f08:	e1a02c03 	lsl	r2, r3, #24
    2f0c:	e51b3010 	ldr	r3, [fp, #-16]
    2f10:	e2833032 	add	r3, r3, #50	; 0x32
    2f14:	e5d33000 	ldrb	r3, [r3]
    2f18:	e20330ff 	and	r3, r3, #255	; 0xff
    2f1c:	e1a03803 	lsl	r3, r3, #16
    2f20:	e1822003 	orr	r2, r2, r3
    2f24:	e51b3010 	ldr	r3, [fp, #-16]
    2f28:	e2833031 	add	r3, r3, #49	; 0x31
    2f2c:	e5d33000 	ldrb	r3, [r3]
    2f30:	e20330ff 	and	r3, r3, #255	; 0xff
    2f34:	e1a03403 	lsl	r3, r3, #8
    2f38:	e1822003 	orr	r2, r2, r3
    2f3c:	e51b3010 	ldr	r3, [fp, #-16]
    2f40:	e2833030 	add	r3, r3, #48	; 0x30
    2f44:	e5d33000 	ldrb	r3, [r3]
    2f48:	e20330ff 	and	r3, r3, #255	; 0xff
    2f4c:	e1822003 	orr	r2, r2, r3
    2f50:	e59f31a0 	ldr	r3, [pc, #416]	; 30f8 <auto_mount+0x9d0>
    2f54:	e1520003 	cmp	r2, r3
    2f58:	1a000051 	bne	30a4 <auto_mount+0x97c>
    2f5c:	e51b3010 	ldr	r3, [fp, #-16]
    2f60:	e2833f85 	add	r3, r3, #532	; 0x214
    2f64:	e2833003 	add	r3, r3, #3	; 0x3
    2f68:	e5d33000 	ldrb	r3, [r3]
    2f6c:	e20330ff 	and	r3, r3, #255	; 0xff
    2f70:	e1a02c03 	lsl	r2, r3, #24
    2f74:	e51b3010 	ldr	r3, [fp, #-16]
    2f78:	e2833f85 	add	r3, r3, #532	; 0x214
    2f7c:	e2833002 	add	r3, r3, #2	; 0x2
    2f80:	e5d33000 	ldrb	r3, [r3]
    2f84:	e20330ff 	and	r3, r3, #255	; 0xff
    2f88:	e1a03803 	lsl	r3, r3, #16
    2f8c:	e1822003 	orr	r2, r2, r3
    2f90:	e51b3010 	ldr	r3, [fp, #-16]
    2f94:	e2833f85 	add	r3, r3, #532	; 0x214
    2f98:	e2833001 	add	r3, r3, #1	; 0x1
    2f9c:	e5d33000 	ldrb	r3, [r3]
    2fa0:	e20330ff 	and	r3, r3, #255	; 0xff
    2fa4:	e1a03403 	lsl	r3, r3, #8
    2fa8:	e1822003 	orr	r2, r2, r3
    2fac:	e51b3010 	ldr	r3, [fp, #-16]
    2fb0:	e2833f85 	add	r3, r3, #532	; 0x214
    2fb4:	e5d33000 	ldrb	r3, [r3]
    2fb8:	e20330ff 	and	r3, r3, #255	; 0xff
    2fbc:	e1822003 	orr	r2, r2, r3
    2fc0:	e59f3134 	ldr	r3, [pc, #308]	; 30fc <auto_mount+0x9d4>
    2fc4:	e1520003 	cmp	r2, r3
    2fc8:	1a000035 	bne	30a4 <auto_mount+0x97c>
			LD_WORD(&fs->win[BS_55AA]) == 0xAA55 &&
			LD_DWORD(&fs->win[FSI_LeadSig]) == 0x41615252 &&
			LD_DWORD(&fs->win[FSI_StrucSig]) == 0x61417272) {
			fs->last_clust = LD_DWORD(&fs->win[FSI_Nxt_Free]);
    2fcc:	e51b3010 	ldr	r3, [fp, #-16]
    2fd0:	e2833f87 	add	r3, r3, #540	; 0x21c
    2fd4:	e2833003 	add	r3, r3, #3	; 0x3
    2fd8:	e5d33000 	ldrb	r3, [r3]
    2fdc:	e20330ff 	and	r3, r3, #255	; 0xff
    2fe0:	e1a02c03 	lsl	r2, r3, #24
    2fe4:	e51b3010 	ldr	r3, [fp, #-16]
    2fe8:	e2833f87 	add	r3, r3, #540	; 0x21c
    2fec:	e2833002 	add	r3, r3, #2	; 0x2
    2ff0:	e5d33000 	ldrb	r3, [r3]
    2ff4:	e20330ff 	and	r3, r3, #255	; 0xff
    2ff8:	e1a03803 	lsl	r3, r3, #16
    2ffc:	e1822003 	orr	r2, r2, r3
    3000:	e51b3010 	ldr	r3, [fp, #-16]
    3004:	e2833f87 	add	r3, r3, #540	; 0x21c
    3008:	e2833001 	add	r3, r3, #1	; 0x1
    300c:	e5d33000 	ldrb	r3, [r3]
    3010:	e20330ff 	and	r3, r3, #255	; 0xff
    3014:	e1a03403 	lsl	r3, r3, #8
    3018:	e1822003 	orr	r2, r2, r3
    301c:	e51b3010 	ldr	r3, [fp, #-16]
    3020:	e2833f87 	add	r3, r3, #540	; 0x21c
    3024:	e5d33000 	ldrb	r3, [r3]
    3028:	e20330ff 	and	r3, r3, #255	; 0xff
    302c:	e1822003 	orr	r2, r2, r3
    3030:	e51b3010 	ldr	r3, [fp, #-16]
    3034:	e583201c 	str	r2, [r3, #28]
			fs->free_clust = LD_DWORD(&fs->win[FSI_Free_Count]);
    3038:	e51b3010 	ldr	r3, [fp, #-16]
    303c:	e2833f86 	add	r3, r3, #536	; 0x218
    3040:	e2833003 	add	r3, r3, #3	; 0x3
    3044:	e5d33000 	ldrb	r3, [r3]
    3048:	e20330ff 	and	r3, r3, #255	; 0xff
    304c:	e1a02c03 	lsl	r2, r3, #24
    3050:	e51b3010 	ldr	r3, [fp, #-16]
    3054:	e2833f86 	add	r3, r3, #536	; 0x218
    3058:	e2833002 	add	r3, r3, #2	; 0x2
    305c:	e5d33000 	ldrb	r3, [r3]
    3060:	e20330ff 	and	r3, r3, #255	; 0xff
    3064:	e1a03803 	lsl	r3, r3, #16
    3068:	e1822003 	orr	r2, r2, r3
    306c:	e51b3010 	ldr	r3, [fp, #-16]
    3070:	e2833f86 	add	r3, r3, #536	; 0x218
    3074:	e2833001 	add	r3, r3, #1	; 0x1
    3078:	e5d33000 	ldrb	r3, [r3]
    307c:	e20330ff 	and	r3, r3, #255	; 0xff
    3080:	e1a03403 	lsl	r3, r3, #8
    3084:	e1822003 	orr	r2, r2, r3
    3088:	e51b3010 	ldr	r3, [fp, #-16]
    308c:	e2833f86 	add	r3, r3, #536	; 0x218
    3090:	e5d33000 	ldrb	r3, [r3]
    3094:	e20330ff 	and	r3, r3, #255	; 0xff
    3098:	e1822003 	orr	r2, r2, r3
    309c:	e51b3010 	ldr	r3, [fp, #-16]
    30a0:	e5832020 	str	r2, [r3, #32]
		}
	}
#endif
#endif
	//xprintf("pass10");
	fs->fs_type = fmt;			/* FAT syb-type */
    30a4:	e51b2010 	ldr	r2, [fp, #-16]
    30a8:	e55b302d 	ldrb	r3, [fp, #-45]
    30ac:	e5c2302a 	strb	r3, [r2, #42]
	fs->id = ++fsid;			/* File system mount ID */
    30b0:	e59f3048 	ldr	r3, [pc, #72]	; 3100 <auto_mount+0x9d8>
    30b4:	e1d330b0 	ldrh	r3, [r3]
    30b8:	e2833001 	add	r3, r3, #1	; 0x1
    30bc:	e1a03803 	lsl	r3, r3, #16
    30c0:	e1a02823 	lsr	r2, r3, #16
    30c4:	e59f3034 	ldr	r3, [pc, #52]	; 3100 <auto_mount+0x9d8>
    30c8:	e1c320b0 	strh	r2, [r3]
    30cc:	e59f302c 	ldr	r3, [pc, #44]	; 3100 <auto_mount+0x9d8>
    30d0:	e1d320b0 	ldrh	r2, [r3]
    30d4:	e51b3010 	ldr	r3, [fp, #-16]
    30d8:	e1c320b0 	strh	r2, [r3]
	return FR_OK;
    30dc:	e3a03000 	mov	r3, #0	; 0x0
    30e0:	e50b3040 	str	r3, [fp, #-64]
    30e4:	e51b3040 	ldr	r3, [fp, #-64]
}
    30e8:	e1a00003 	mov	r0, r3
    30ec:	e24bd00c 	sub	sp, fp, #12	; 0xc
    30f0:	e89da800 	ldm	sp, {fp, sp, pc}
    30f4:	40000700 	.word	0x40000700
    30f8:	41615252 	.word	0x41615252
    30fc:	61417272 	.word	0x61417272
    3100:	40000704 	.word	0x40000704

00003104 <validate>:
static
FRESULT validate (		/* FR_OK(0): The object is valid, !=0: Invalid */
	const FATFS *fs,	/* Pointer to the file system object */
	WORD id				/* Member id of the target object to be checked */
)
{
    3104:	e1a0c00d 	mov	ip, sp
    3108:	e92dd800 	push	{fp, ip, lr, pc}
    310c:	e24cb004 	sub	fp, ip, #4	; 0x4
    3110:	e24dd00c 	sub	sp, sp, #12	; 0xc
    3114:	e50b0010 	str	r0, [fp, #-16]
    3118:	e1a03001 	mov	r3, r1
    311c:	e14b31b4 	strh	r3, [fp, #-20]
	if (!fs || !fs->fs_type || fs->id != id)
    3120:	e51b3010 	ldr	r3, [fp, #-16]
    3124:	e3530000 	cmp	r3, #0	; 0x0
    3128:	0a000008 	beq	3150 <validate+0x4c>
    312c:	e51b3010 	ldr	r3, [fp, #-16]
    3130:	e5d3302a 	ldrb	r3, [r3, #42]
    3134:	e3530000 	cmp	r3, #0	; 0x0
    3138:	0a000004 	beq	3150 <validate+0x4c>
    313c:	e51b3010 	ldr	r3, [fp, #-16]
    3140:	e1d320b0 	ldrh	r2, [r3]
    3144:	e15b31b4 	ldrh	r3, [fp, #-20]
    3148:	e1530002 	cmp	r3, r2
    314c:	0a000002 	beq	315c <validate+0x58>
		return FR_INVALID_OBJECT;
    3150:	e3a0300c 	mov	r3, #12	; 0xc
    3154:	e50b3018 	str	r3, [fp, #-24]
    3158:	ea00000d 	b	3194 <validate+0x90>
	if (disk_status(fs->drive) & STA_NOINIT)
    315c:	e51b3010 	ldr	r3, [fp, #-16]
    3160:	e5d3302d 	ldrb	r3, [r3, #45]
    3164:	e1a00003 	mov	r0, r3
    3168:	eb000658 	bl	4ad0 <disk_status>
    316c:	e1a03000 	mov	r3, r0
    3170:	e2033001 	and	r3, r3, #1	; 0x1
    3174:	e20330ff 	and	r3, r3, #255	; 0xff
    3178:	e3530000 	cmp	r3, #0	; 0x0
    317c:	0a000002 	beq	318c <validate+0x88>
		return FR_NOT_READY;
    3180:	e3a03001 	mov	r3, #1	; 0x1
    3184:	e50b3018 	str	r3, [fp, #-24]
    3188:	ea000001 	b	3194 <validate+0x90>

	return FR_OK;
    318c:	e3a03000 	mov	r3, #0	; 0x0
    3190:	e50b3018 	str	r3, [fp, #-24]
    3194:	e51b3018 	ldr	r3, [fp, #-24]
}
    3198:	e1a00003 	mov	r0, r3
    319c:	e24bd00c 	sub	sp, fp, #12	; 0xc
    31a0:	e89da800 	ldm	sp, {fp, sp, pc}

000031a4 <f_mount>:

FRESULT f_mount (
	BYTE drv,		/* Logical drive number to be mounted/unmounted */
	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
)
{
    31a4:	e1a0c00d 	mov	ip, sp
    31a8:	e92dd800 	push	{fp, ip, lr, pc}
    31ac:	e24cb004 	sub	fp, ip, #4	; 0x4
    31b0:	e24dd00c 	sub	sp, sp, #12	; 0xc
    31b4:	e1a03000 	mov	r3, r0
    31b8:	e50b1014 	str	r1, [fp, #-20]
    31bc:	e54b3010 	strb	r3, [fp, #-16]
	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
    31c0:	e55b3010 	ldrb	r3, [fp, #-16]
    31c4:	e3530000 	cmp	r3, #0	; 0x0
    31c8:	0a000002 	beq	31d8 <f_mount+0x34>
    31cc:	e3a03005 	mov	r3, #5	; 0x5
    31d0:	e50b3018 	str	r3, [fp, #-24]
    31d4:	ea000015 	b	3230 <f_mount+0x8c>

	if (FatFs[drv]) FatFs[drv]->fs_type = 0;	/* Clear old object */
    31d8:	e55b3010 	ldrb	r3, [fp, #-16]
    31dc:	e59f205c 	ldr	r2, [pc, #92]	; 3240 <f_mount+0x9c>
    31e0:	e7923103 	ldr	r3, [r2, r3, lsl #2]
    31e4:	e3530000 	cmp	r3, #0	; 0x0
    31e8:	0a000004 	beq	3200 <f_mount+0x5c>
    31ec:	e55b2010 	ldrb	r2, [fp, #-16]
    31f0:	e59f3048 	ldr	r3, [pc, #72]	; 3240 <f_mount+0x9c>
    31f4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
    31f8:	e3a03000 	mov	r3, #0	; 0x0
    31fc:	e5c2302a 	strb	r3, [r2, #42]

	FatFs[drv] = fs;			/* Register and clear new object */
    3200:	e55b1010 	ldrb	r1, [fp, #-16]
    3204:	e59f2034 	ldr	r2, [pc, #52]	; 3240 <f_mount+0x9c>
    3208:	e51b3014 	ldr	r3, [fp, #-20]
    320c:	e7823101 	str	r3, [r2, r1, lsl #2]
	if (fs) fs->fs_type = 0;
    3210:	e51b3014 	ldr	r3, [fp, #-20]
    3214:	e3530000 	cmp	r3, #0	; 0x0
    3218:	0a000002 	beq	3228 <f_mount+0x84>
    321c:	e51b3014 	ldr	r3, [fp, #-20]
    3220:	e3a02000 	mov	r2, #0	; 0x0
    3224:	e5c3202a 	strb	r2, [r3, #42]

	return FR_OK;
    3228:	e3a03000 	mov	r3, #0	; 0x0
    322c:	e50b3018 	str	r3, [fp, #-24]
    3230:	e51b3018 	ldr	r3, [fp, #-24]
}
    3234:	e1a00003 	mov	r0, r3
    3238:	e24bd00c 	sub	sp, fp, #12	; 0xc
    323c:	e89da800 	ldm	sp, {fp, sp, pc}
    3240:	40000700 	.word	0x40000700

00003244 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const char *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    3244:	e1a0c00d 	mov	ip, sp
    3248:	e92dd800 	push	{fp, ip, lr, pc}
    324c:	e24cb004 	sub	fp, ip, #4	; 0x4
    3250:	e24dd040 	sub	sp, sp, #64	; 0x40
    3254:	e50b0040 	str	r0, [fp, #-64]
    3258:	e50b1044 	str	r1, [fp, #-68]
    325c:	e1a03002 	mov	r3, r2
    3260:	e54b3048 	strb	r3, [fp, #-72]
	DIR dj;
	BYTE *dir;
	char fn[8+3+1];


	fp->fs = NULL;		/* Clear file object */
    3264:	e51b2040 	ldr	r2, [fp, #-64]
    3268:	e3a03000 	mov	r3, #0	; 0x0
    326c:	e5823004 	str	r3, [r2, #4]
#if !_FS_READONLY
	mode &= (FA_READ|FA_WRITE|FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW);
    3270:	e55b3048 	ldrb	r3, [fp, #-72]
    3274:	e203301f 	and	r3, r3, #31	; 0x1f
    3278:	e54b3048 	strb	r3, [fp, #-72]
	res = auto_mount(&path, &dj.fs, (BYTE)(mode & (FA_WRITE|FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW)));
    327c:	e55b3048 	ldrb	r3, [fp, #-72]
    3280:	e203c01e 	and	ip, r3, #30	; 0x1e
    3284:	e24b2044 	sub	r2, fp, #68	; 0x44
    3288:	e24b302c 	sub	r3, fp, #44	; 0x2c
    328c:	e2833004 	add	r3, r3, #4	; 0x4
    3290:	e1a00002 	mov	r0, r2
    3294:	e1a01003 	mov	r1, r3
    3298:	e1a0200c 	mov	r2, ip
    329c:	ebfffd21 	bl	2728 <auto_mount>
    32a0:	e1a03000 	mov	r3, r0
    32a4:	e50b3018 	str	r3, [fp, #-24]
#else
	mode &= FA_READ;
	res = auto_mount(&path, &dj.fs, 0);
#endif
	if (res != FR_OK) return res;
    32a8:	e51b3018 	ldr	r3, [fp, #-24]
    32ac:	e3530000 	cmp	r3, #0	; 0x0
    32b0:	0a000002 	beq	32c0 <f_open+0x7c>
    32b4:	e51b3018 	ldr	r3, [fp, #-24]
    32b8:	e50b304c 	str	r3, [fp, #-76]
    32bc:	ea000151 	b	3808 <f_open+0x5c4>
	res = trace_path(&dj, fn, path, &dir);	/* Trace the file path */
    32c0:	e51be044 	ldr	lr, [fp, #-68]
    32c4:	e24b302c 	sub	r3, fp, #44	; 0x2c
    32c8:	e24b203c 	sub	r2, fp, #60	; 0x3c
    32cc:	e24bc030 	sub	ip, fp, #48	; 0x30
    32d0:	e1a00003 	mov	r0, r3
    32d4:	e1a01002 	mov	r1, r2
    32d8:	e1a0200e 	mov	r2, lr
    32dc:	e1a0300c 	mov	r3, ip
    32e0:	ebfffb4e 	bl	2020 <trace_path>
    32e4:	e1a03000 	mov	r3, r0
    32e8:	e50b3018 	str	r3, [fp, #-24]

#if !_FS_READONLY
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW)) {
    32ec:	e55b3048 	ldrb	r3, [fp, #-72]
    32f0:	e203301c 	and	r3, r3, #28	; 0x1c
    32f4:	e3530000 	cmp	r3, #0	; 0x0
    32f8:	0a0000ca 	beq	3628 <f_open+0x3e4>
		DWORD ps, rs;
		if (res != FR_OK) {		/* No file, create new */
    32fc:	e51b3018 	ldr	r3, [fp, #-24]
    3300:	e3530000 	cmp	r3, #0	; 0x0
    3304:	0a000025 	beq	33a0 <f_open+0x15c>
			if (res != FR_NO_FILE) return res;
    3308:	e51b3018 	ldr	r3, [fp, #-24]
    330c:	e3530002 	cmp	r3, #2	; 0x2
    3310:	0a000002 	beq	3320 <f_open+0xdc>
    3314:	e51b3018 	ldr	r3, [fp, #-24]
    3318:	e50b304c 	str	r3, [fp, #-76]
    331c:	ea000139 	b	3808 <f_open+0x5c4>
			res = reserve_direntry(&dj, &dir);
    3320:	e24b302c 	sub	r3, fp, #44	; 0x2c
    3324:	e24b2030 	sub	r2, fp, #48	; 0x30
    3328:	e1a00003 	mov	r0, r3
    332c:	e1a01002 	mov	r1, r2
    3330:	ebfffc0c 	bl	2368 <reserve_direntry>
    3334:	e1a03000 	mov	r3, r0
    3338:	e50b3018 	str	r3, [fp, #-24]
			if (res != FR_OK) return res;
    333c:	e51b3018 	ldr	r3, [fp, #-24]
    3340:	e3530000 	cmp	r3, #0	; 0x0
    3344:	0a000002 	beq	3354 <f_open+0x110>
    3348:	e51b3018 	ldr	r3, [fp, #-24]
    334c:	e50b304c 	str	r3, [fp, #-76]
    3350:	ea00012c 	b	3808 <f_open+0x5c4>
			memset(dir, 0, 32);		/* Initialize the new entry with open name */
    3354:	e51b3030 	ldr	r3, [fp, #-48]
    3358:	e1a00003 	mov	r0, r3
    335c:	e3a01000 	mov	r1, #0	; 0x0
    3360:	e3a02020 	mov	r2, #32	; 0x20
    3364:	eb0017b8 	bl	924c <memset>
			memcpy(&dir[DIR_Name], fn, 8+3);
    3368:	e51b3030 	ldr	r3, [fp, #-48]
    336c:	e24b203c 	sub	r2, fp, #60	; 0x3c
    3370:	e1a00003 	mov	r0, r3
    3374:	e1a01002 	mov	r1, r2
    3378:	e3a0200b 	mov	r2, #11	; 0xb
    337c:	eb001773 	bl	9150 <memcpy>
			dir[DIR_NTres] = fn[11];
    3380:	e51b3030 	ldr	r3, [fp, #-48]
    3384:	e283200c 	add	r2, r3, #12	; 0xc
    3388:	e55b3031 	ldrb	r3, [fp, #-49]
    338c:	e5c23000 	strb	r3, [r2]
			mode |= FA_CREATE_ALWAYS;
    3390:	e55b3048 	ldrb	r3, [fp, #-72]
    3394:	e3833008 	orr	r3, r3, #8	; 0x8
    3398:	e54b3048 	strb	r3, [fp, #-72]
    339c:	ea000074 	b	3574 <f_open+0x330>
		}
		else {					/* Any object is already existing */
			if (mode & FA_CREATE_NEW)			/* Cannot create new */
    33a0:	e55b3048 	ldrb	r3, [fp, #-72]
    33a4:	e2033004 	and	r3, r3, #4	; 0x4
    33a8:	e3530000 	cmp	r3, #0	; 0x0
    33ac:	0a000002 	beq	33bc <f_open+0x178>
				return FR_EXIST;
    33b0:	e3a03007 	mov	r3, #7	; 0x7
    33b4:	e50b304c 	str	r3, [fp, #-76]
    33b8:	ea000112 	b	3808 <f_open+0x5c4>
			if (!dir || (dir[DIR_Attr] & (AM_RDO|AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
    33bc:	e51b3030 	ldr	r3, [fp, #-48]
    33c0:	e3530000 	cmp	r3, #0	; 0x0
    33c4:	0a000005 	beq	33e0 <f_open+0x19c>
    33c8:	e51b3030 	ldr	r3, [fp, #-48]
    33cc:	e283300b 	add	r3, r3, #11	; 0xb
    33d0:	e5d33000 	ldrb	r3, [r3]
    33d4:	e2033011 	and	r3, r3, #17	; 0x11
    33d8:	e3530000 	cmp	r3, #0	; 0x0
    33dc:	0a000002 	beq	33ec <f_open+0x1a8>
				return FR_DENIED;
    33e0:	e3a03006 	mov	r3, #6	; 0x6
    33e4:	e50b304c 	str	r3, [fp, #-76]
    33e8:	ea000106 	b	3808 <f_open+0x5c4>
			if (mode & FA_CREATE_ALWAYS) {		/* Resize it to zero if needed */
    33ec:	e55b3048 	ldrb	r3, [fp, #-72]
    33f0:	e2033008 	and	r3, r3, #8	; 0x8
    33f4:	e3530000 	cmp	r3, #0	; 0x0
    33f8:	0a00005d 	beq	3574 <f_open+0x330>
				rs = ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);	/* Get start cluster */
    33fc:	e51b3030 	ldr	r3, [fp, #-48]
    3400:	e2833015 	add	r3, r3, #21	; 0x15
    3404:	e5d33000 	ldrb	r3, [r3]
    3408:	e20330ff 	and	r3, r3, #255	; 0xff
    340c:	e1a03403 	lsl	r3, r3, #8
    3410:	e1a03803 	lsl	r3, r3, #16
    3414:	e1a02823 	lsr	r2, r3, #16
    3418:	e51b3030 	ldr	r3, [fp, #-48]
    341c:	e2833014 	add	r3, r3, #20	; 0x14
    3420:	e5d33000 	ldrb	r3, [r3]
    3424:	e20330ff 	and	r3, r3, #255	; 0xff
    3428:	e1823003 	orr	r3, r2, r3
    342c:	e1a03803 	lsl	r3, r3, #16
    3430:	e1a03823 	lsr	r3, r3, #16
    3434:	e1a03803 	lsl	r3, r3, #16
    3438:	e1a03823 	lsr	r3, r3, #16
    343c:	e1a01803 	lsl	r1, r3, #16
    3440:	e51b3030 	ldr	r3, [fp, #-48]
    3444:	e283301b 	add	r3, r3, #27	; 0x1b
    3448:	e5d33000 	ldrb	r3, [r3]
    344c:	e20330ff 	and	r3, r3, #255	; 0xff
    3450:	e1a03403 	lsl	r3, r3, #8
    3454:	e1a03803 	lsl	r3, r3, #16
    3458:	e1a02823 	lsr	r2, r3, #16
    345c:	e51b3030 	ldr	r3, [fp, #-48]
    3460:	e283301a 	add	r3, r3, #26	; 0x1a
    3464:	e5d33000 	ldrb	r3, [r3]
    3468:	e20330ff 	and	r3, r3, #255	; 0xff
    346c:	e1823003 	orr	r3, r2, r3
    3470:	e1a03803 	lsl	r3, r3, #16
    3474:	e1a03823 	lsr	r3, r3, #16
    3478:	e1a03803 	lsl	r3, r3, #16
    347c:	e1a03823 	lsr	r3, r3, #16
    3480:	e1813003 	orr	r3, r1, r3
    3484:	e50b3010 	str	r3, [fp, #-16]
				ST_WORD(&dir[DIR_FstClusHI], 0);	/* cluster = 0 */
    3488:	e51b3030 	ldr	r3, [fp, #-48]
    348c:	e2832014 	add	r2, r3, #20	; 0x14
    3490:	e3a03000 	mov	r3, #0	; 0x0
    3494:	e5c23000 	strb	r3, [r2]
    3498:	e51b3030 	ldr	r3, [fp, #-48]
    349c:	e2832015 	add	r2, r3, #21	; 0x15
    34a0:	e3a03000 	mov	r3, #0	; 0x0
    34a4:	e5c23000 	strb	r3, [r2]
				ST_WORD(&dir[DIR_FstClusLO], 0);
    34a8:	e51b3030 	ldr	r3, [fp, #-48]
    34ac:	e283201a 	add	r2, r3, #26	; 0x1a
    34b0:	e3a03000 	mov	r3, #0	; 0x0
    34b4:	e5c23000 	strb	r3, [r2]
    34b8:	e51b3030 	ldr	r3, [fp, #-48]
    34bc:	e283201b 	add	r2, r3, #27	; 0x1b
    34c0:	e3a03000 	mov	r3, #0	; 0x0
    34c4:	e5c23000 	strb	r3, [r2]
				ST_DWORD(&dir[DIR_FileSize], 0);	/* size = 0 */
    34c8:	e51b3030 	ldr	r3, [fp, #-48]
    34cc:	e283201c 	add	r2, r3, #28	; 0x1c
    34d0:	e3a03000 	mov	r3, #0	; 0x0
    34d4:	e5c23000 	strb	r3, [r2]
    34d8:	e51b3030 	ldr	r3, [fp, #-48]
    34dc:	e283201d 	add	r2, r3, #29	; 0x1d
    34e0:	e3a03000 	mov	r3, #0	; 0x0
    34e4:	e5c23000 	strb	r3, [r2]
    34e8:	e51b3030 	ldr	r3, [fp, #-48]
    34ec:	e283201e 	add	r2, r3, #30	; 0x1e
    34f0:	e3a03000 	mov	r3, #0	; 0x0
    34f4:	e5c23000 	strb	r3, [r2]
    34f8:	e51b3030 	ldr	r3, [fp, #-48]
    34fc:	e283201f 	add	r2, r3, #31	; 0x1f
    3500:	e3a03000 	mov	r3, #0	; 0x0
    3504:	e5c23000 	strb	r3, [r2]
				dj.fs->winflag = 1;
    3508:	e51b2028 	ldr	r2, [fp, #-40]
    350c:	e3a03001 	mov	r3, #1	; 0x1
    3510:	e5c2302e 	strb	r3, [r2, #46]
				ps = dj.fs->winsect;			/* Remove the cluster chain */
    3514:	e51b3028 	ldr	r3, [fp, #-40]
    3518:	e5933004 	ldr	r3, [r3, #4]
    351c:	e50b3014 	str	r3, [fp, #-20]
				if (!remove_chain(dj.fs, rs) || !move_window(dj.fs, ps))
    3520:	e51b3028 	ldr	r3, [fp, #-40]
    3524:	e1a00003 	mov	r0, r3
    3528:	e51b1010 	ldr	r1, [fp, #-16]
    352c:	ebfff8df 	bl	18b0 <remove_chain>
    3530:	e1a03000 	mov	r3, r0
    3534:	e3530000 	cmp	r3, #0	; 0x0
    3538:	0a000006 	beq	3558 <f_open+0x314>
    353c:	e51b3028 	ldr	r3, [fp, #-40]
    3540:	e1a00003 	mov	r0, r3
    3544:	e51b1014 	ldr	r1, [fp, #-20]
    3548:	ebfff5b4 	bl	c20 <move_window>
    354c:	e1a03000 	mov	r3, r0
    3550:	e3530000 	cmp	r3, #0	; 0x0
    3554:	1a000002 	bne	3564 <f_open+0x320>
					return FR_RW_ERROR;
    3558:	e3a03008 	mov	r3, #8	; 0x8
    355c:	e50b304c 	str	r3, [fp, #-76]
    3560:	ea0000a8 	b	3808 <f_open+0x5c4>
				dj.fs->last_clust = rs - 1;		/* Reuse the cluster hole */
    3564:	e51b3028 	ldr	r3, [fp, #-40]
    3568:	e51b2010 	ldr	r2, [fp, #-16]
    356c:	e2422001 	sub	r2, r2, #1	; 0x1
    3570:	e583201c 	str	r2, [r3, #28]
			}
		}
		if (mode & FA_CREATE_ALWAYS) {
    3574:	e55b3048 	ldrb	r3, [fp, #-72]
    3578:	e2033008 	and	r3, r3, #8	; 0x8
    357c:	e3530000 	cmp	r3, #0	; 0x0
    3580:	0a000048 	beq	36a8 <f_open+0x464>
			dir[DIR_Attr] = 0;					/* Reset attribute */
    3584:	e51b3030 	ldr	r3, [fp, #-48]
    3588:	e283200b 	add	r2, r3, #11	; 0xb
    358c:	e3a03000 	mov	r3, #0	; 0x0
    3590:	e5c23000 	strb	r3, [r2]
			ps = get_fattime();
    3594:	eb0006bf 	bl	5098 <get_fattime>
    3598:	e1a03000 	mov	r3, r0
    359c:	e50b3014 	str	r3, [fp, #-20]
			ST_DWORD(&dir[DIR_CrtTime], ps);	/* Created time */
    35a0:	e51b3030 	ldr	r3, [fp, #-48]
    35a4:	e283200e 	add	r2, r3, #14	; 0xe
    35a8:	e51b3014 	ldr	r3, [fp, #-20]
    35ac:	e20330ff 	and	r3, r3, #255	; 0xff
    35b0:	e5c23000 	strb	r3, [r2]
    35b4:	e51b3030 	ldr	r3, [fp, #-48]
    35b8:	e283200f 	add	r2, r3, #15	; 0xf
    35bc:	e51b3014 	ldr	r3, [fp, #-20]
    35c0:	e1a03803 	lsl	r3, r3, #16
    35c4:	e1a03823 	lsr	r3, r3, #16
    35c8:	e1a03423 	lsr	r3, r3, #8
    35cc:	e1a03803 	lsl	r3, r3, #16
    35d0:	e1a03823 	lsr	r3, r3, #16
    35d4:	e20330ff 	and	r3, r3, #255	; 0xff
    35d8:	e5c23000 	strb	r3, [r2]
    35dc:	e51b3030 	ldr	r3, [fp, #-48]
    35e0:	e2832010 	add	r2, r3, #16	; 0x10
    35e4:	e51b3014 	ldr	r3, [fp, #-20]
    35e8:	e1a03823 	lsr	r3, r3, #16
    35ec:	e20330ff 	and	r3, r3, #255	; 0xff
    35f0:	e5c23000 	strb	r3, [r2]
    35f4:	e51b3030 	ldr	r3, [fp, #-48]
    35f8:	e2832011 	add	r2, r3, #17	; 0x11
    35fc:	e51b3014 	ldr	r3, [fp, #-20]
    3600:	e1a03c23 	lsr	r3, r3, #24
    3604:	e20330ff 	and	r3, r3, #255	; 0xff
    3608:	e5c23000 	strb	r3, [r2]
			dj.fs->winflag = 1;
    360c:	e51b2028 	ldr	r2, [fp, #-40]
    3610:	e3a03001 	mov	r3, #1	; 0x1
    3614:	e5c2302e 	strb	r3, [r2, #46]
			mode |= FA__WRITTEN;				/* Set file changed flag */
    3618:	e55b3048 	ldrb	r3, [fp, #-72]
    361c:	e3833020 	orr	r3, r3, #32	; 0x20
    3620:	e54b3048 	strb	r3, [fp, #-72]
    3624:	ea00001f 	b	36a8 <f_open+0x464>
		}
	}
	/* Open an existing file */
	else {
#endif /* !_FS_READONLY */
		if (res != FR_OK) return res;			/* Trace failed */
    3628:	e51b3018 	ldr	r3, [fp, #-24]
    362c:	e3530000 	cmp	r3, #0	; 0x0
    3630:	0a000002 	beq	3640 <f_open+0x3fc>
    3634:	e51b3018 	ldr	r3, [fp, #-24]
    3638:	e50b304c 	str	r3, [fp, #-76]
    363c:	ea000071 	b	3808 <f_open+0x5c4>
		if (!dir || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
    3640:	e51b3030 	ldr	r3, [fp, #-48]
    3644:	e3530000 	cmp	r3, #0	; 0x0
    3648:	0a000005 	beq	3664 <f_open+0x420>
    364c:	e51b3030 	ldr	r3, [fp, #-48]
    3650:	e283300b 	add	r3, r3, #11	; 0xb
    3654:	e5d33000 	ldrb	r3, [r3]
    3658:	e2033010 	and	r3, r3, #16	; 0x10
    365c:	e3530000 	cmp	r3, #0	; 0x0
    3660:	0a000002 	beq	3670 <f_open+0x42c>
			return FR_NO_FILE;
    3664:	e3a03002 	mov	r3, #2	; 0x2
    3668:	e50b304c 	str	r3, [fp, #-76]
    366c:	ea000065 	b	3808 <f_open+0x5c4>
#if !_FS_READONLY
		if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    3670:	e55b3048 	ldrb	r3, [fp, #-72]
    3674:	e2033002 	and	r3, r3, #2	; 0x2
    3678:	e3530000 	cmp	r3, #0	; 0x0
    367c:	0a000009 	beq	36a8 <f_open+0x464>
    3680:	e51b3030 	ldr	r3, [fp, #-48]
    3684:	e283300b 	add	r3, r3, #11	; 0xb
    3688:	e5d33000 	ldrb	r3, [r3]
    368c:	e2033001 	and	r3, r3, #1	; 0x1
    3690:	e20330ff 	and	r3, r3, #255	; 0xff
    3694:	e3530000 	cmp	r3, #0	; 0x0
    3698:	0a000002 	beq	36a8 <f_open+0x464>
			return FR_DENIED;
    369c:	e3a03006 	mov	r3, #6	; 0x6
    36a0:	e50b304c 	str	r3, [fp, #-76]
    36a4:	ea000057 	b	3808 <f_open+0x5c4>
	}
	fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
    36a8:	e51b3028 	ldr	r3, [fp, #-40]
    36ac:	e5932004 	ldr	r2, [r3, #4]
    36b0:	e51b3040 	ldr	r3, [fp, #-64]
    36b4:	e583201c 	str	r2, [r3, #28]
	fp->dir_ptr = dir;
    36b8:	e51b2030 	ldr	r2, [fp, #-48]
    36bc:	e51b3040 	ldr	r3, [fp, #-64]
    36c0:	e5832020 	str	r2, [r3, #32]
#endif
	fp->flag = mode;					/* File access mode */
    36c4:	e51b2040 	ldr	r2, [fp, #-64]
    36c8:	e55b3048 	ldrb	r3, [fp, #-72]
    36cc:	e5c23002 	strb	r3, [r2, #2]
	fp->org_clust =						/* File start cluster */
    36d0:	e51b3030 	ldr	r3, [fp, #-48]
    36d4:	e2833015 	add	r3, r3, #21	; 0x15
    36d8:	e5d33000 	ldrb	r3, [r3]
    36dc:	e20330ff 	and	r3, r3, #255	; 0xff
    36e0:	e1a03403 	lsl	r3, r3, #8
    36e4:	e1a03803 	lsl	r3, r3, #16
    36e8:	e1a02823 	lsr	r2, r3, #16
    36ec:	e51b3030 	ldr	r3, [fp, #-48]
    36f0:	e2833014 	add	r3, r3, #20	; 0x14
    36f4:	e5d33000 	ldrb	r3, [r3]
    36f8:	e20330ff 	and	r3, r3, #255	; 0xff
    36fc:	e1823003 	orr	r3, r2, r3
    3700:	e1a03803 	lsl	r3, r3, #16
    3704:	e1a03823 	lsr	r3, r3, #16
    3708:	e1a03803 	lsl	r3, r3, #16
    370c:	e1a03823 	lsr	r3, r3, #16
    3710:	e1a01803 	lsl	r1, r3, #16
    3714:	e51b3030 	ldr	r3, [fp, #-48]
    3718:	e283301b 	add	r3, r3, #27	; 0x1b
    371c:	e5d33000 	ldrb	r3, [r3]
    3720:	e20330ff 	and	r3, r3, #255	; 0xff
    3724:	e1a03403 	lsl	r3, r3, #8
    3728:	e1a03803 	lsl	r3, r3, #16
    372c:	e1a02823 	lsr	r2, r3, #16
    3730:	e51b3030 	ldr	r3, [fp, #-48]
    3734:	e283301a 	add	r3, r3, #26	; 0x1a
    3738:	e5d33000 	ldrb	r3, [r3]
    373c:	e20330ff 	and	r3, r3, #255	; 0xff
    3740:	e1823003 	orr	r3, r2, r3
    3744:	e1a03803 	lsl	r3, r3, #16
    3748:	e1a03823 	lsr	r3, r3, #16
    374c:	e1a03803 	lsl	r3, r3, #16
    3750:	e1a03823 	lsr	r3, r3, #16
    3754:	e1812003 	orr	r2, r1, r3
    3758:	e51b3040 	ldr	r3, [fp, #-64]
    375c:	e5832010 	str	r2, [r3, #16]
		((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);
	fp->fsize = LD_DWORD(&dir[DIR_FileSize]);	/* File size */
    3760:	e51b3030 	ldr	r3, [fp, #-48]
    3764:	e283301f 	add	r3, r3, #31	; 0x1f
    3768:	e5d33000 	ldrb	r3, [r3]
    376c:	e20330ff 	and	r3, r3, #255	; 0xff
    3770:	e1a02c03 	lsl	r2, r3, #24
    3774:	e51b3030 	ldr	r3, [fp, #-48]
    3778:	e283301e 	add	r3, r3, #30	; 0x1e
    377c:	e5d33000 	ldrb	r3, [r3]
    3780:	e20330ff 	and	r3, r3, #255	; 0xff
    3784:	e1a03803 	lsl	r3, r3, #16
    3788:	e1822003 	orr	r2, r2, r3
    378c:	e51b3030 	ldr	r3, [fp, #-48]
    3790:	e283301d 	add	r3, r3, #29	; 0x1d
    3794:	e5d33000 	ldrb	r3, [r3]
    3798:	e20330ff 	and	r3, r3, #255	; 0xff
    379c:	e1a03403 	lsl	r3, r3, #8
    37a0:	e1822003 	orr	r2, r2, r3
    37a4:	e51b3030 	ldr	r3, [fp, #-48]
    37a8:	e283301c 	add	r3, r3, #28	; 0x1c
    37ac:	e5d33000 	ldrb	r3, [r3]
    37b0:	e20330ff 	and	r3, r3, #255	; 0xff
    37b4:	e1822003 	orr	r2, r2, r3
    37b8:	e51b3040 	ldr	r3, [fp, #-64]
    37bc:	e583200c 	str	r2, [r3, #12]
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
    37c0:	e51b2040 	ldr	r2, [fp, #-64]
    37c4:	e3a03000 	mov	r3, #0	; 0x0
    37c8:	e5823008 	str	r3, [r2, #8]
    37cc:	e51b2040 	ldr	r2, [fp, #-64]
    37d0:	e3e03000 	mvn	r3, #0	; 0x0
    37d4:	e5c23003 	strb	r3, [r2, #3]
	fp->curr_sect = 0;
    37d8:	e51b2040 	ldr	r2, [fp, #-64]
    37dc:	e3a03000 	mov	r3, #0	; 0x0
    37e0:	e5823018 	str	r3, [r2, #24]
	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */
    37e4:	e51b2028 	ldr	r2, [fp, #-40]
    37e8:	e51b3040 	ldr	r3, [fp, #-64]
    37ec:	e5832004 	str	r2, [r3, #4]
    37f0:	e51b3028 	ldr	r3, [fp, #-40]
    37f4:	e1d320b0 	ldrh	r2, [r3]
    37f8:	e51b3040 	ldr	r3, [fp, #-64]
    37fc:	e1c320b0 	strh	r2, [r3]

	return FR_OK;
    3800:	e3a03000 	mov	r3, #0	; 0x0
    3804:	e50b304c 	str	r3, [fp, #-76]
    3808:	e51b304c 	ldr	r3, [fp, #-76]
}
    380c:	e1a00003 	mov	r0, r3
    3810:	e24bd00c 	sub	sp, fp, #12	; 0xc
    3814:	e89da800 	ldm	sp, {fp, sp, pc}

00003818 <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
    3818:	e1a0c00d 	mov	ip, sp
    381c:	e92dd800 	push	{fp, ip, lr, pc}
    3820:	e24cb004 	sub	fp, ip, #4	; 0x4
    3824:	e24dd02c 	sub	sp, sp, #44	; 0x2c
    3828:	e50b0028 	str	r0, [fp, #-40]
    382c:	e50b102c 	str	r1, [fp, #-44]
    3830:	e50b2030 	str	r2, [fp, #-48]
    3834:	e50b3034 	str	r3, [fp, #-52]
	FRESULT res;
	DWORD clust, sect;
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
    3838:	e51b302c 	ldr	r3, [fp, #-44]
    383c:	e50b3010 	str	r3, [fp, #-16]


	*bw = 0;
    3840:	e51b2034 	ldr	r2, [fp, #-52]
    3844:	e3a03000 	mov	r3, #0	; 0x0
    3848:	e5823000 	str	r3, [r2]
	res = validate(fp->fs, fp->id);					/* Check validity of the object */
    384c:	e51b3028 	ldr	r3, [fp, #-40]
    3850:	e5932004 	ldr	r2, [r3, #4]
    3854:	e51b3028 	ldr	r3, [fp, #-40]
    3858:	e1d330b0 	ldrh	r3, [r3]
    385c:	e1a00002 	mov	r0, r2
    3860:	e1a01003 	mov	r1, r3
    3864:	ebfffe26 	bl	3104 <validate>
    3868:	e1a03000 	mov	r3, r0
    386c:	e50b3024 	str	r3, [fp, #-36]
	if (res != FR_OK) return res;
    3870:	e51b3024 	ldr	r3, [fp, #-36]
    3874:	e3530000 	cmp	r3, #0	; 0x0
    3878:	0a000002 	beq	3888 <f_write+0x70>
    387c:	e51b3024 	ldr	r3, [fp, #-36]
    3880:	e50b3038 	str	r3, [fp, #-56]
    3884:	ea000120 	b	3d0c <f_write+0x4f4>
	if (fp->flag & FA__ERROR) return FR_RW_ERROR;	/* Check error flag */
    3888:	e51b3028 	ldr	r3, [fp, #-40]
    388c:	e5d33002 	ldrb	r3, [r3, #2]
    3890:	e1a03c03 	lsl	r3, r3, #24
    3894:	e1a03c43 	asr	r3, r3, #24
    3898:	e3530000 	cmp	r3, #0	; 0x0
    389c:	aa000002 	bge	38ac <f_write+0x94>
    38a0:	e3a03008 	mov	r3, #8	; 0x8
    38a4:	e50b3038 	str	r3, [fp, #-56]
    38a8:	ea000117 	b	3d0c <f_write+0x4f4>
	if (!(fp->flag & FA_WRITE)) return FR_DENIED;	/* Check access mode */
    38ac:	e51b3028 	ldr	r3, [fp, #-40]
    38b0:	e5d33002 	ldrb	r3, [r3, #2]
    38b4:	e2033002 	and	r3, r3, #2	; 0x2
    38b8:	e3530000 	cmp	r3, #0	; 0x0
    38bc:	1a000002 	bne	38cc <f_write+0xb4>
    38c0:	e3a03006 	mov	r3, #6	; 0x6
    38c4:	e50b3038 	str	r3, [fp, #-56]
    38c8:	ea00010f 	b	3d0c <f_write+0x4f4>
	if (fp->fsize + btw < fp->fsize) return FR_OK;	/* File size cannot reach 4GB */
    38cc:	e51b3028 	ldr	r3, [fp, #-40]
    38d0:	e593200c 	ldr	r2, [r3, #12]
    38d4:	e51b3030 	ldr	r3, [fp, #-48]
    38d8:	e0822003 	add	r2, r2, r3
    38dc:	e51b3028 	ldr	r3, [fp, #-40]
    38e0:	e593300c 	ldr	r3, [r3, #12]
    38e4:	e1520003 	cmp	r2, r3
    38e8:	2a0000e8 	bcs	3c90 <f_write+0x478>
    38ec:	e3a03000 	mov	r3, #0	; 0x0
    38f0:	e50b3038 	str	r3, [fp, #-56]
    38f4:	ea000104 	b	3d0c <f_write+0x4f4>

	for ( ;  btw;									/* Repeat until all data transferred */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
    38f8:	e51b3028 	ldr	r3, [fp, #-40]
    38fc:	e5933008 	ldr	r3, [r3, #8]
    3900:	e1a03b83 	lsl	r3, r3, #23
    3904:	e1a03ba3 	lsr	r3, r3, #23
    3908:	e3530000 	cmp	r3, #0	; 0x0
    390c:	1a0000ae 	bne	3bcc <f_write+0x3b4>
			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
    3910:	e51b3028 	ldr	r3, [fp, #-40]
    3914:	e5d32003 	ldrb	r2, [r3, #3]
    3918:	e51b3028 	ldr	r3, [fp, #-40]
    391c:	e5933004 	ldr	r3, [r3, #4]
    3920:	e5d3302b 	ldrb	r3, [r3, #43]
    3924:	e1520003 	cmp	r2, r3
    3928:	3a00002f 	bcc	39ec <f_write+0x1d4>
				if (fp->fptr == 0) {				/* On the top of the file? */
    392c:	e51b3028 	ldr	r3, [fp, #-40]
    3930:	e5933008 	ldr	r3, [r3, #8]
    3934:	e3530000 	cmp	r3, #0	; 0x0
    3938:	1a000010 	bne	3980 <f_write+0x168>
					clust = fp->org_clust;			/* Follow from the origin */
    393c:	e51b3028 	ldr	r3, [fp, #-40]
    3940:	e5933010 	ldr	r3, [r3, #16]
    3944:	e50b3020 	str	r3, [fp, #-32]
					if (clust == 0)					/* When there is no cluster chain, */
    3948:	e51b3020 	ldr	r3, [fp, #-32]
    394c:	e3530000 	cmp	r3, #0	; 0x0
    3950:	1a000013 	bne	39a4 <f_write+0x18c>
						fp->org_clust = clust = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    3954:	e51b3028 	ldr	r3, [fp, #-40]
    3958:	e5933004 	ldr	r3, [r3, #4]
    395c:	e1a00003 	mov	r0, r3
    3960:	e3a01000 	mov	r1, #0	; 0x0
    3964:	ebfff809 	bl	1990 <create_chain>
    3968:	e1a03000 	mov	r3, r0
    396c:	e50b3020 	str	r3, [fp, #-32]
    3970:	e51b2028 	ldr	r2, [fp, #-40]
    3974:	e51b3020 	ldr	r3, [fp, #-32]
    3978:	e5823010 	str	r3, [r2, #16]
    397c:	ea000008 	b	39a4 <f_write+0x18c>
				} else {							/* Middle or end of the file */
					clust = create_chain(fp->fs, fp->curr_clust);			/* Trace or streach cluster chain */
    3980:	e51b3028 	ldr	r3, [fp, #-40]
    3984:	e5932004 	ldr	r2, [r3, #4]
    3988:	e51b3028 	ldr	r3, [fp, #-40]
    398c:	e5933014 	ldr	r3, [r3, #20]
    3990:	e1a00002 	mov	r0, r2
    3994:	e1a01003 	mov	r1, r3
    3998:	ebfff7fc 	bl	1990 <create_chain>
    399c:	e1a03000 	mov	r3, r0
    39a0:	e50b3020 	str	r3, [fp, #-32]
				}
				if (clust == 0) break;				/* Could not allocate a new cluster (disk full) */
    39a4:	e51b3020 	ldr	r3, [fp, #-32]
    39a8:	e3530000 	cmp	r3, #0	; 0x0
    39ac:	0a0000ba 	beq	3c9c <f_write+0x484>
				if (clust == 1 || clust >= fp->fs->max_clust) goto fw_error;
    39b0:	e51b3020 	ldr	r3, [fp, #-32]
    39b4:	e3530001 	cmp	r3, #1	; 0x1
    39b8:	0a0000ca 	beq	3ce8 <f_write+0x4d0>
    39bc:	e51b3028 	ldr	r3, [fp, #-40]
    39c0:	e5933004 	ldr	r3, [r3, #4]
    39c4:	e593200c 	ldr	r2, [r3, #12]
    39c8:	e51b3020 	ldr	r3, [fp, #-32]
    39cc:	e1520003 	cmp	r2, r3
    39d0:	9a0000c4 	bls	3ce8 <f_write+0x4d0>
				fp->curr_clust = clust;				/* Update current cluster */
    39d4:	e51b2028 	ldr	r2, [fp, #-40]
    39d8:	e51b3020 	ldr	r3, [fp, #-32]
    39dc:	e5823014 	str	r3, [r2, #20]
				fp->csect = 0;						/* Reset sector address in the cluster */
    39e0:	e51b2028 	ldr	r2, [fp, #-40]
    39e4:	e3a03000 	mov	r3, #0	; 0x0
    39e8:	e5c23003 	strb	r3, [r2, #3]
			}
			sect = clust2sect(fp->fs, fp->curr_clust) + fp->csect;	/* Get current sector */
    39ec:	e51b3028 	ldr	r3, [fp, #-40]
    39f0:	e5932004 	ldr	r2, [r3, #4]
    39f4:	e51b3028 	ldr	r3, [fp, #-40]
    39f8:	e5933014 	ldr	r3, [r3, #20]
    39fc:	e1a00002 	mov	r0, r2
    3a00:	e1a01003 	mov	r1, r3
    3a04:	ebfff861 	bl	1b90 <clust2sect>
    3a08:	e1a02000 	mov	r2, r0
    3a0c:	e51b3028 	ldr	r3, [fp, #-40]
    3a10:	e5d33003 	ldrb	r3, [r3, #3]
    3a14:	e0823003 	add	r3, r2, r3
    3a18:	e50b301c 	str	r3, [fp, #-28]
			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
    3a1c:	e51b3030 	ldr	r3, [fp, #-48]
    3a20:	e1a034a3 	lsr	r3, r3, #9
    3a24:	e50b3014 	str	r3, [fp, #-20]
			if (cc) {								/* Write maximum contiguous sectors directly */
    3a28:	e51b3014 	ldr	r3, [fp, #-20]
    3a2c:	e3530000 	cmp	r3, #0	; 0x0
    3a30:	0a00002a 	beq	3ae0 <f_write+0x2c8>
				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    3a34:	e51b3028 	ldr	r3, [fp, #-40]
    3a38:	e5d33003 	ldrb	r3, [r3, #3]
    3a3c:	e1a02003 	mov	r2, r3
    3a40:	e51b3014 	ldr	r3, [fp, #-20]
    3a44:	e0822003 	add	r2, r2, r3
    3a48:	e51b3028 	ldr	r3, [fp, #-40]
    3a4c:	e5933004 	ldr	r3, [r3, #4]
    3a50:	e5d3302b 	ldrb	r3, [r3, #43]
    3a54:	e1520003 	cmp	r2, r3
    3a58:	9a000007 	bls	3a7c <f_write+0x264>
					cc = fp->fs->csize - fp->csect;
    3a5c:	e51b3028 	ldr	r3, [fp, #-40]
    3a60:	e5933004 	ldr	r3, [r3, #4]
    3a64:	e5d3302b 	ldrb	r3, [r3, #43]
    3a68:	e1a02003 	mov	r2, r3
    3a6c:	e51b3028 	ldr	r3, [fp, #-40]
    3a70:	e5d33003 	ldrb	r3, [r3, #3]
    3a74:	e0633002 	rsb	r3, r3, r2
    3a78:	e50b3014 	str	r3, [fp, #-20]
				if (disk_write(fp->fs->drive, wbuff, sect, (BYTE)cc) != RES_OK)
    3a7c:	e51b3028 	ldr	r3, [fp, #-40]
    3a80:	e5933004 	ldr	r3, [r3, #4]
    3a84:	e5d3302d 	ldrb	r3, [r3, #45]
    3a88:	e1a02003 	mov	r2, r3
    3a8c:	e51b3014 	ldr	r3, [fp, #-20]
    3a90:	e20330ff 	and	r3, r3, #255	; 0xff
    3a94:	e1a00002 	mov	r0, r2
    3a98:	e51b1010 	ldr	r1, [fp, #-16]
    3a9c:	e51b201c 	ldr	r2, [fp, #-28]
    3aa0:	eb000467 	bl	4c44 <disk_write>
    3aa4:	e1a03000 	mov	r3, r0
    3aa8:	e3530000 	cmp	r3, #0	; 0x0
    3aac:	1a00008d 	bne	3ce8 <f_write+0x4d0>
					goto fw_error;
				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
    3ab0:	e51b3028 	ldr	r3, [fp, #-40]
    3ab4:	e5d32003 	ldrb	r2, [r3, #3]
    3ab8:	e51b3014 	ldr	r3, [fp, #-20]
    3abc:	e20330ff 	and	r3, r3, #255	; 0xff
    3ac0:	e0823003 	add	r3, r2, r3
    3ac4:	e20330ff 	and	r3, r3, #255	; 0xff
    3ac8:	e51b2028 	ldr	r2, [fp, #-40]
    3acc:	e5c23003 	strb	r3, [r2, #3]
				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
    3ad0:	e51b3014 	ldr	r3, [fp, #-20]
    3ad4:	e1a03483 	lsl	r3, r3, #9
    3ad8:	e50b3018 	str	r3, [fp, #-24]
    3adc:	ea000057 	b	3c40 <f_write+0x428>
				continue;
			}
			if (sect != fp->curr_sect) {			/* Is window offset changed? */
    3ae0:	e51b3028 	ldr	r3, [fp, #-40]
    3ae4:	e5932018 	ldr	r2, [r3, #24]
    3ae8:	e51b301c 	ldr	r3, [fp, #-28]
    3aec:	e1520003 	cmp	r2, r3
    3af0:	0a00002f 	beq	3bb4 <f_write+0x39c>
				if (fp->flag & FA__DIRTY) {			/* Write back file I/O buffer if needed */
    3af4:	e51b3028 	ldr	r3, [fp, #-40]
    3af8:	e5d33002 	ldrb	r3, [r3, #2]
    3afc:	e2033040 	and	r3, r3, #64	; 0x40
    3b00:	e3530000 	cmp	r3, #0	; 0x0
    3b04:	0a000013 	beq	3b58 <f_write+0x340>
					if (disk_write(fp->fs->drive, fp->buffer, fp->curr_sect, 1) != RES_OK)
    3b08:	e51b3028 	ldr	r3, [fp, #-40]
    3b0c:	e5933004 	ldr	r3, [r3, #4]
    3b10:	e5d3302d 	ldrb	r3, [r3, #45]
    3b14:	e1a02003 	mov	r2, r3
    3b18:	e51b3028 	ldr	r3, [fp, #-40]
    3b1c:	e2831024 	add	r1, r3, #36	; 0x24
    3b20:	e51b3028 	ldr	r3, [fp, #-40]
    3b24:	e5933018 	ldr	r3, [r3, #24]
    3b28:	e1a00002 	mov	r0, r2
    3b2c:	e1a02003 	mov	r2, r3
    3b30:	e3a03001 	mov	r3, #1	; 0x1
    3b34:	eb000442 	bl	4c44 <disk_write>
    3b38:	e1a03000 	mov	r3, r0
    3b3c:	e3530000 	cmp	r3, #0	; 0x0
    3b40:	1a000068 	bne	3ce8 <f_write+0x4d0>
						goto fw_error;
					fp->flag &= (BYTE)~FA__DIRTY;
    3b44:	e51b3028 	ldr	r3, [fp, #-40]
    3b48:	e5d33002 	ldrb	r3, [r3, #2]
    3b4c:	e20330bf 	and	r3, r3, #191	; 0xbf
    3b50:	e51b2028 	ldr	r2, [fp, #-40]
    3b54:	e5c23002 	strb	r3, [r2, #2]
				}
				if (fp->fptr < fp->fsize &&  		/* Fill file I/O buffer with file data */
    3b58:	e51b3028 	ldr	r3, [fp, #-40]
    3b5c:	e5932008 	ldr	r2, [r3, #8]
    3b60:	e51b3028 	ldr	r3, [fp, #-40]
    3b64:	e593300c 	ldr	r3, [r3, #12]
    3b68:	e1520003 	cmp	r2, r3
    3b6c:	2a00000d 	bcs	3ba8 <f_write+0x390>
    3b70:	e51b3028 	ldr	r3, [fp, #-40]
    3b74:	e5933004 	ldr	r3, [r3, #4]
    3b78:	e5d3302d 	ldrb	r3, [r3, #45]
    3b7c:	e1a02003 	mov	r2, r3
    3b80:	e51b3028 	ldr	r3, [fp, #-40]
    3b84:	e2833024 	add	r3, r3, #36	; 0x24
    3b88:	e1a00002 	mov	r0, r2
    3b8c:	e1a01003 	mov	r1, r3
    3b90:	e51b201c 	ldr	r2, [fp, #-28]
    3b94:	e3a03001 	mov	r3, #1	; 0x1
    3b98:	eb0003e1 	bl	4b24 <disk_read>
    3b9c:	e1a03000 	mov	r3, r0
    3ba0:	e3530000 	cmp	r3, #0	; 0x0
    3ba4:	1a00004f 	bne	3ce8 <f_write+0x4d0>
					disk_read(fp->fs->drive, fp->buffer, sect, 1) != RES_OK)
						goto fw_error;
				fp->curr_sect = sect;
    3ba8:	e51b2028 	ldr	r2, [fp, #-40]
    3bac:	e51b301c 	ldr	r3, [fp, #-28]
    3bb0:	e5823018 	str	r3, [r2, #24]
			}
			fp->csect++;							/* Next sector address in the cluster */
    3bb4:	e51b3028 	ldr	r3, [fp, #-40]
    3bb8:	e5d33003 	ldrb	r3, [r3, #3]
    3bbc:	e2833001 	add	r3, r3, #1	; 0x1
    3bc0:	e20330ff 	and	r3, r3, #255	; 0xff
    3bc4:	e51b2028 	ldr	r2, [fp, #-40]
    3bc8:	e5c23003 	strb	r3, [r2, #3]
		}
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Put partial sector into file I/O buffer */
    3bcc:	e51b3028 	ldr	r3, [fp, #-40]
    3bd0:	e5933008 	ldr	r3, [r3, #8]
    3bd4:	e1a03b83 	lsl	r3, r3, #23
    3bd8:	e1a03ba3 	lsr	r3, r3, #23
    3bdc:	e2633c02 	rsb	r3, r3, #512	; 0x200
    3be0:	e50b3018 	str	r3, [fp, #-24]
		if (wcnt > btw) wcnt = btw;
    3be4:	e51b2018 	ldr	r2, [fp, #-24]
    3be8:	e51b3030 	ldr	r3, [fp, #-48]
    3bec:	e1520003 	cmp	r2, r3
    3bf0:	9a000001 	bls	3bfc <f_write+0x3e4>
    3bf4:	e51b3030 	ldr	r3, [fp, #-48]
    3bf8:	e50b3018 	str	r3, [fp, #-24]
		memcpy(&fp->buffer[fp->fptr % SS(fp->fs)], wbuff, wcnt);
    3bfc:	e51b3028 	ldr	r3, [fp, #-40]
    3c00:	e2832024 	add	r2, r3, #36	; 0x24
    3c04:	e51b3028 	ldr	r3, [fp, #-40]
    3c08:	e5933008 	ldr	r3, [r3, #8]
    3c0c:	e1a03b83 	lsl	r3, r3, #23
    3c10:	e1a03ba3 	lsr	r3, r3, #23
    3c14:	e0823003 	add	r3, r2, r3
    3c18:	e1a00003 	mov	r0, r3
    3c1c:	e51b1010 	ldr	r1, [fp, #-16]
    3c20:	e51b2018 	ldr	r2, [fp, #-24]
    3c24:	eb001549 	bl	9150 <memcpy>
		fp->flag |= FA__DIRTY;
    3c28:	e51b3028 	ldr	r3, [fp, #-40]
    3c2c:	e5d33002 	ldrb	r3, [r3, #2]
    3c30:	e3833040 	orr	r3, r3, #64	; 0x40
    3c34:	e20330ff 	and	r3, r3, #255	; 0xff
    3c38:	e51b2028 	ldr	r2, [fp, #-40]
    3c3c:	e5c23002 	strb	r3, [r2, #2]
	if (fp->flag & FA__ERROR) return FR_RW_ERROR;	/* Check error flag */
	if (!(fp->flag & FA_WRITE)) return FR_DENIED;	/* Check access mode */
	if (fp->fsize + btw < fp->fsize) return FR_OK;	/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    3c40:	e51b2010 	ldr	r2, [fp, #-16]
    3c44:	e51b3018 	ldr	r3, [fp, #-24]
    3c48:	e0823003 	add	r3, r2, r3
    3c4c:	e50b3010 	str	r3, [fp, #-16]
    3c50:	e51b3028 	ldr	r3, [fp, #-40]
    3c54:	e5932008 	ldr	r2, [r3, #8]
    3c58:	e51b3018 	ldr	r3, [fp, #-24]
    3c5c:	e0822003 	add	r2, r2, r3
    3c60:	e51b3028 	ldr	r3, [fp, #-40]
    3c64:	e5832008 	str	r2, [r3, #8]
    3c68:	e51b3034 	ldr	r3, [fp, #-52]
    3c6c:	e5932000 	ldr	r2, [r3]
    3c70:	e51b3018 	ldr	r3, [fp, #-24]
    3c74:	e0822003 	add	r2, r2, r3
    3c78:	e51b3034 	ldr	r3, [fp, #-52]
    3c7c:	e5832000 	str	r2, [r3]
    3c80:	e51b2030 	ldr	r2, [fp, #-48]
    3c84:	e51b3018 	ldr	r3, [fp, #-24]
    3c88:	e0633002 	rsb	r3, r3, r2
    3c8c:	e50b3030 	str	r3, [fp, #-48]
	if (res != FR_OK) return res;
	if (fp->flag & FA__ERROR) return FR_RW_ERROR;	/* Check error flag */
	if (!(fp->flag & FA_WRITE)) return FR_DENIED;	/* Check access mode */
	if (fp->fsize + btw < fp->fsize) return FR_OK;	/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
    3c90:	e51b3030 	ldr	r3, [fp, #-48]
    3c94:	e3530000 	cmp	r3, #0	; 0x0
    3c98:	1affff16 	bne	38f8 <f_write+0xe0>
		if (wcnt > btw) wcnt = btw;
		memcpy(&fp->buffer[fp->fptr % SS(fp->fs)], wbuff, wcnt);
		fp->flag |= FA__DIRTY;
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    3c9c:	e51b3028 	ldr	r3, [fp, #-40]
    3ca0:	e5932008 	ldr	r2, [r3, #8]
    3ca4:	e51b3028 	ldr	r3, [fp, #-40]
    3ca8:	e593300c 	ldr	r3, [r3, #12]
    3cac:	e1520003 	cmp	r2, r3
    3cb0:	9a000003 	bls	3cc4 <f_write+0x4ac>
    3cb4:	e51b3028 	ldr	r3, [fp, #-40]
    3cb8:	e5932008 	ldr	r2, [r3, #8]
    3cbc:	e51b3028 	ldr	r3, [fp, #-40]
    3cc0:	e583200c 	str	r2, [r3, #12]
	fp->flag |= FA__WRITTEN;						/* Set file changed flag */
    3cc4:	e51b3028 	ldr	r3, [fp, #-40]
    3cc8:	e5d33002 	ldrb	r3, [r3, #2]
    3ccc:	e3833020 	orr	r3, r3, #32	; 0x20
    3cd0:	e20330ff 	and	r3, r3, #255	; 0xff
    3cd4:	e51b2028 	ldr	r2, [fp, #-40]
    3cd8:	e5c23002 	strb	r3, [r2, #2]
	return FR_OK;
    3cdc:	e3a03000 	mov	r3, #0	; 0x0
    3ce0:	e50b3038 	str	r3, [fp, #-56]
    3ce4:	ea000008 	b	3d0c <f_write+0x4f4>

fw_error:	/* Abort this file due to an unrecoverable error */
	fp->flag |= FA__ERROR;
    3ce8:	e51b3028 	ldr	r3, [fp, #-40]
    3cec:	e5d33002 	ldrb	r3, [r3, #2]
    3cf0:	e1e03c83 	mvn	r3, r3, lsl #25
    3cf4:	e1e03ca3 	mvn	r3, r3, lsr #25
    3cf8:	e20330ff 	and	r3, r3, #255	; 0xff
    3cfc:	e51b2028 	ldr	r2, [fp, #-40]
    3d00:	e5c23002 	strb	r3, [r2, #2]
	return FR_RW_ERROR;
    3d04:	e3a03008 	mov	r3, #8	; 0x8
    3d08:	e50b3038 	str	r3, [fp, #-56]
    3d0c:	e51b3038 	ldr	r3, [fp, #-56]
}
    3d10:	e1a00003 	mov	r0, r3
    3d14:	e24bd00c 	sub	sp, fp, #12	; 0xc
    3d18:	e89da800 	ldm	sp, {fp, sp, pc}

00003d1c <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
    3d1c:	e1a0c00d 	mov	ip, sp
    3d20:	e92dd800 	push	{fp, ip, lr, pc}
    3d24:	e24cb004 	sub	fp, ip, #4	; 0x4
    3d28:	e24dd014 	sub	sp, sp, #20	; 0x14
    3d2c:	e50b001c 	str	r0, [fp, #-28]
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    3d30:	e51b301c 	ldr	r3, [fp, #-28]
    3d34:	e5932004 	ldr	r2, [r3, #4]
    3d38:	e51b301c 	ldr	r3, [fp, #-28]
    3d3c:	e1d330b0 	ldrh	r3, [r3]
    3d40:	e1a00002 	mov	r0, r2
    3d44:	e1a01003 	mov	r1, r3
    3d48:	ebfffced 	bl	3104 <validate>
    3d4c:	e1a03000 	mov	r3, r0
    3d50:	e50b3018 	str	r3, [fp, #-24]
	if (res == FR_OK) {
    3d54:	e51b3018 	ldr	r3, [fp, #-24]
    3d58:	e3530000 	cmp	r3, #0	; 0x0
    3d5c:	1a0000a4 	bne	3ff4 <f_sync+0x2d8>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    3d60:	e51b301c 	ldr	r3, [fp, #-28]
    3d64:	e5d33002 	ldrb	r3, [r3, #2]
    3d68:	e2033020 	and	r3, r3, #32	; 0x20
    3d6c:	e3530000 	cmp	r3, #0	; 0x0
    3d70:	0a00009f 	beq	3ff4 <f_sync+0x2d8>
			/* Write back data buffer if needed */
			if (fp->flag & FA__DIRTY) {
    3d74:	e51b301c 	ldr	r3, [fp, #-28]
    3d78:	e5d33002 	ldrb	r3, [r3, #2]
    3d7c:	e2033040 	and	r3, r3, #64	; 0x40
    3d80:	e3530000 	cmp	r3, #0	; 0x0
    3d84:	0a000016 	beq	3de4 <f_sync+0xc8>
				if (disk_write(fp->fs->drive, fp->buffer, fp->curr_sect, 1) != RES_OK)
    3d88:	e51b301c 	ldr	r3, [fp, #-28]
    3d8c:	e5933004 	ldr	r3, [r3, #4]
    3d90:	e5d3302d 	ldrb	r3, [r3, #45]
    3d94:	e1a02003 	mov	r2, r3
    3d98:	e51b301c 	ldr	r3, [fp, #-28]
    3d9c:	e2831024 	add	r1, r3, #36	; 0x24
    3da0:	e51b301c 	ldr	r3, [fp, #-28]
    3da4:	e5933018 	ldr	r3, [r3, #24]
    3da8:	e1a00002 	mov	r0, r2
    3dac:	e1a02003 	mov	r2, r3
    3db0:	e3a03001 	mov	r3, #1	; 0x1
    3db4:	eb0003a2 	bl	4c44 <disk_write>
    3db8:	e1a03000 	mov	r3, r0
    3dbc:	e3530000 	cmp	r3, #0	; 0x0
    3dc0:	0a000002 	beq	3dd0 <f_sync+0xb4>
					return FR_RW_ERROR;
    3dc4:	e3a03008 	mov	r3, #8	; 0x8
    3dc8:	e50b3020 	str	r3, [fp, #-32]
    3dcc:	ea00008a 	b	3ffc <f_sync+0x2e0>
				fp->flag &= (BYTE)~FA__DIRTY;
    3dd0:	e51b301c 	ldr	r3, [fp, #-28]
    3dd4:	e5d33002 	ldrb	r3, [r3, #2]
    3dd8:	e20330bf 	and	r3, r3, #191	; 0xbf
    3ddc:	e51b201c 	ldr	r2, [fp, #-28]
    3de0:	e5c23002 	strb	r3, [r2, #2]
			}
			/* Update the directory entry */
			if (!move_window(fp->fs, fp->dir_sect))
    3de4:	e51b301c 	ldr	r3, [fp, #-28]
    3de8:	e5932004 	ldr	r2, [r3, #4]
    3dec:	e51b301c 	ldr	r3, [fp, #-28]
    3df0:	e593301c 	ldr	r3, [r3, #28]
    3df4:	e1a00002 	mov	r0, r2
    3df8:	e1a01003 	mov	r1, r3
    3dfc:	ebfff387 	bl	c20 <move_window>
    3e00:	e1a03000 	mov	r3, r0
    3e04:	e3530000 	cmp	r3, #0	; 0x0
    3e08:	1a000002 	bne	3e18 <f_sync+0xfc>
				return FR_RW_ERROR;
    3e0c:	e3a03008 	mov	r3, #8	; 0x8
    3e10:	e50b3020 	str	r3, [fp, #-32]
    3e14:	ea000078 	b	3ffc <f_sync+0x2e0>
			dir = fp->dir_ptr;
    3e18:	e51b301c 	ldr	r3, [fp, #-28]
    3e1c:	e5933020 	ldr	r3, [r3, #32]
    3e20:	e50b3010 	str	r3, [fp, #-16]
			dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
    3e24:	e51b3010 	ldr	r3, [fp, #-16]
    3e28:	e283200b 	add	r2, r3, #11	; 0xb
    3e2c:	e51b3010 	ldr	r3, [fp, #-16]
    3e30:	e283300b 	add	r3, r3, #11	; 0xb
    3e34:	e5d33000 	ldrb	r3, [r3]
    3e38:	e3833020 	orr	r3, r3, #32	; 0x20
    3e3c:	e20330ff 	and	r3, r3, #255	; 0xff
    3e40:	e5c23000 	strb	r3, [r2]
			ST_DWORD(&dir[DIR_FileSize], fp->fsize);		/* Update file size */
    3e44:	e51b3010 	ldr	r3, [fp, #-16]
    3e48:	e283201c 	add	r2, r3, #28	; 0x1c
    3e4c:	e51b301c 	ldr	r3, [fp, #-28]
    3e50:	e593300c 	ldr	r3, [r3, #12]
    3e54:	e20330ff 	and	r3, r3, #255	; 0xff
    3e58:	e5c23000 	strb	r3, [r2]
    3e5c:	e51b3010 	ldr	r3, [fp, #-16]
    3e60:	e283201d 	add	r2, r3, #29	; 0x1d
    3e64:	e51b301c 	ldr	r3, [fp, #-28]
    3e68:	e593300c 	ldr	r3, [r3, #12]
    3e6c:	e1a03803 	lsl	r3, r3, #16
    3e70:	e1a03823 	lsr	r3, r3, #16
    3e74:	e1a03423 	lsr	r3, r3, #8
    3e78:	e1a03803 	lsl	r3, r3, #16
    3e7c:	e1a03823 	lsr	r3, r3, #16
    3e80:	e20330ff 	and	r3, r3, #255	; 0xff
    3e84:	e5c23000 	strb	r3, [r2]
    3e88:	e51b3010 	ldr	r3, [fp, #-16]
    3e8c:	e283201e 	add	r2, r3, #30	; 0x1e
    3e90:	e51b301c 	ldr	r3, [fp, #-28]
    3e94:	e593300c 	ldr	r3, [r3, #12]
    3e98:	e1a03823 	lsr	r3, r3, #16
    3e9c:	e20330ff 	and	r3, r3, #255	; 0xff
    3ea0:	e5c23000 	strb	r3, [r2]
    3ea4:	e51b3010 	ldr	r3, [fp, #-16]
    3ea8:	e283201f 	add	r2, r3, #31	; 0x1f
    3eac:	e51b301c 	ldr	r3, [fp, #-28]
    3eb0:	e593300c 	ldr	r3, [r3, #12]
    3eb4:	e1a03c23 	lsr	r3, r3, #24
    3eb8:	e20330ff 	and	r3, r3, #255	; 0xff
    3ebc:	e5c23000 	strb	r3, [r2]
			ST_WORD(&dir[DIR_FstClusLO], fp->org_clust);	/* Update start cluster */
    3ec0:	e51b3010 	ldr	r3, [fp, #-16]
    3ec4:	e283201a 	add	r2, r3, #26	; 0x1a
    3ec8:	e51b301c 	ldr	r3, [fp, #-28]
    3ecc:	e5933010 	ldr	r3, [r3, #16]
    3ed0:	e20330ff 	and	r3, r3, #255	; 0xff
    3ed4:	e5c23000 	strb	r3, [r2]
    3ed8:	e51b3010 	ldr	r3, [fp, #-16]
    3edc:	e283201b 	add	r2, r3, #27	; 0x1b
    3ee0:	e51b301c 	ldr	r3, [fp, #-28]
    3ee4:	e5933010 	ldr	r3, [r3, #16]
    3ee8:	e1a03803 	lsl	r3, r3, #16
    3eec:	e1a03823 	lsr	r3, r3, #16
    3ef0:	e1a03423 	lsr	r3, r3, #8
    3ef4:	e1a03803 	lsl	r3, r3, #16
    3ef8:	e1a03823 	lsr	r3, r3, #16
    3efc:	e20330ff 	and	r3, r3, #255	; 0xff
    3f00:	e5c23000 	strb	r3, [r2]
			ST_WORD(&dir[DIR_FstClusHI], fp->org_clust >> 16);
    3f04:	e51b3010 	ldr	r3, [fp, #-16]
    3f08:	e2832014 	add	r2, r3, #20	; 0x14
    3f0c:	e51b301c 	ldr	r3, [fp, #-28]
    3f10:	e5933010 	ldr	r3, [r3, #16]
    3f14:	e1a03823 	lsr	r3, r3, #16
    3f18:	e20330ff 	and	r3, r3, #255	; 0xff
    3f1c:	e5c23000 	strb	r3, [r2]
    3f20:	e51b3010 	ldr	r3, [fp, #-16]
    3f24:	e2832015 	add	r2, r3, #21	; 0x15
    3f28:	e51b301c 	ldr	r3, [fp, #-28]
    3f2c:	e5933010 	ldr	r3, [r3, #16]
    3f30:	e1a03823 	lsr	r3, r3, #16
    3f34:	e1a03803 	lsl	r3, r3, #16
    3f38:	e1a03823 	lsr	r3, r3, #16
    3f3c:	e1a03423 	lsr	r3, r3, #8
    3f40:	e1a03803 	lsl	r3, r3, #16
    3f44:	e1a03823 	lsr	r3, r3, #16
    3f48:	e20330ff 	and	r3, r3, #255	; 0xff
    3f4c:	e5c23000 	strb	r3, [r2]
			tim = get_fattime();					/* Updated time */
    3f50:	eb000450 	bl	5098 <get_fattime>
    3f54:	e1a03000 	mov	r3, r0
    3f58:	e50b3014 	str	r3, [fp, #-20]
			ST_DWORD(&dir[DIR_WrtTime], tim);
    3f5c:	e51b3010 	ldr	r3, [fp, #-16]
    3f60:	e2832016 	add	r2, r3, #22	; 0x16
    3f64:	e51b3014 	ldr	r3, [fp, #-20]
    3f68:	e20330ff 	and	r3, r3, #255	; 0xff
    3f6c:	e5c23000 	strb	r3, [r2]
    3f70:	e51b3010 	ldr	r3, [fp, #-16]
    3f74:	e2832017 	add	r2, r3, #23	; 0x17
    3f78:	e51b3014 	ldr	r3, [fp, #-20]
    3f7c:	e1a03803 	lsl	r3, r3, #16
    3f80:	e1a03823 	lsr	r3, r3, #16
    3f84:	e1a03423 	lsr	r3, r3, #8
    3f88:	e1a03803 	lsl	r3, r3, #16
    3f8c:	e1a03823 	lsr	r3, r3, #16
    3f90:	e20330ff 	and	r3, r3, #255	; 0xff
    3f94:	e5c23000 	strb	r3, [r2]
    3f98:	e51b3010 	ldr	r3, [fp, #-16]
    3f9c:	e2832018 	add	r2, r3, #24	; 0x18
    3fa0:	e51b3014 	ldr	r3, [fp, #-20]
    3fa4:	e1a03823 	lsr	r3, r3, #16
    3fa8:	e20330ff 	and	r3, r3, #255	; 0xff
    3fac:	e5c23000 	strb	r3, [r2]
    3fb0:	e51b3010 	ldr	r3, [fp, #-16]
    3fb4:	e2832019 	add	r2, r3, #25	; 0x19
    3fb8:	e51b3014 	ldr	r3, [fp, #-20]
    3fbc:	e1a03c23 	lsr	r3, r3, #24
    3fc0:	e20330ff 	and	r3, r3, #255	; 0xff
    3fc4:	e5c23000 	strb	r3, [r2]
			fp->flag &= (BYTE)~FA__WRITTEN;
    3fc8:	e51b301c 	ldr	r3, [fp, #-28]
    3fcc:	e5d33002 	ldrb	r3, [r3, #2]
    3fd0:	e20330df 	and	r3, r3, #223	; 0xdf
    3fd4:	e51b201c 	ldr	r2, [fp, #-28]
    3fd8:	e5c23002 	strb	r3, [r2, #2]
			res = sync(fp->fs);
    3fdc:	e51b301c 	ldr	r3, [fp, #-28]
    3fe0:	e5933004 	ldr	r3, [r3, #4]
    3fe4:	e1a00003 	mov	r0, r3
    3fe8:	ebfff36d 	bl	da4 <sync>
    3fec:	e1a03000 	mov	r3, r0
    3ff0:	e50b3018 	str	r3, [fp, #-24]
		}
	}
	return res;
    3ff4:	e51b3018 	ldr	r3, [fp, #-24]
    3ff8:	e50b3020 	str	r3, [fp, #-32]
    3ffc:	e51b3020 	ldr	r3, [fp, #-32]
}
    4000:	e1a00003 	mov	r0, r3
    4004:	e24bd00c 	sub	sp, fp, #12	; 0xc
    4008:	e89da800 	ldm	sp, {fp, sp, pc}

0000400c <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    400c:	e1a0c00d 	mov	ip, sp
    4010:	e92dd800 	push	{fp, ip, lr, pc}
    4014:	e24cb004 	sub	fp, ip, #4	; 0x4
    4018:	e24dd008 	sub	sp, sp, #8	; 0x8
    401c:	e50b0014 	str	r0, [fp, #-20]
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);
    4020:	e51b0014 	ldr	r0, [fp, #-20]
    4024:	ebffff3c 	bl	3d1c <f_sync>
    4028:	e1a03000 	mov	r3, r0
    402c:	e50b3010 	str	r3, [fp, #-16]
#else
	res = validate(fp->fs, fp->id);
#endif
	if (res == FR_OK) fp->fs = NULL;
    4030:	e51b3010 	ldr	r3, [fp, #-16]
    4034:	e3530000 	cmp	r3, #0	; 0x0
    4038:	1a000002 	bne	4048 <f_close+0x3c>
    403c:	e51b2014 	ldr	r2, [fp, #-20]
    4040:	e3a03000 	mov	r3, #0	; 0x0
    4044:	e5823004 	str	r3, [r2, #4]
	return res;
    4048:	e51b3010 	ldr	r3, [fp, #-16]
}
    404c:	e1a00003 	mov	r0, r3
    4050:	e24bd00c 	sub	sp, fp, #12	; 0xc
    4054:	e89da800 	ldm	sp, {fp, sp, pc}

00004058 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const char *path		/* Pointer to the file or directory path */
)
{
    4058:	e1a0c00d 	mov	ip, sp
    405c:	e92dd800 	push	{fp, ip, lr, pc}
    4060:	e24cb004 	sub	fp, ip, #4	; 0x4
    4064:	e24dd03c 	sub	sp, sp, #60	; 0x3c
    4068:	e50b0044 	str	r0, [fp, #-68]
	BYTE *dir, *sdir;
	DWORD dclust, dsect;
	char fn[8+3+1];

	//xprintf("pass2");
	res = auto_mount(&path, &dj.fs, 1);
    406c:	e24b2044 	sub	r2, fp, #68	; 0x44
    4070:	e24b3030 	sub	r3, fp, #48	; 0x30
    4074:	e2833004 	add	r3, r3, #4	; 0x4
    4078:	e1a00002 	mov	r0, r2
    407c:	e1a01003 	mov	r1, r3
    4080:	e3a02001 	mov	r2, #1	; 0x1
    4084:	ebfff9a7 	bl	2728 <auto_mount>
    4088:	e1a03000 	mov	r3, r0
    408c:	e50b301c 	str	r3, [fp, #-28]
	if (res != FR_OK) return res;
    4090:	e51b301c 	ldr	r3, [fp, #-28]
    4094:	e3530000 	cmp	r3, #0	; 0x0
    4098:	0a000002 	beq	40a8 <f_unlink+0x50>
    409c:	e51b301c 	ldr	r3, [fp, #-28]
    40a0:	e50b3048 	str	r3, [fp, #-72]
    40a4:	ea00009e 	b	4324 <f_unlink+0x2cc>
	res = trace_path(&dj, fn, path, &dir);	/* Trace the file path */
    40a8:	e51be044 	ldr	lr, [fp, #-68]
    40ac:	e24b3030 	sub	r3, fp, #48	; 0x30
    40b0:	e24b2040 	sub	r2, fp, #64	; 0x40
    40b4:	e24bc034 	sub	ip, fp, #52	; 0x34
    40b8:	e1a00003 	mov	r0, r3
    40bc:	e1a01002 	mov	r1, r2
    40c0:	e1a0200e 	mov	r2, lr
    40c4:	e1a0300c 	mov	r3, ip
    40c8:	ebfff7d4 	bl	2020 <trace_path>
    40cc:	e1a03000 	mov	r3, r0
    40d0:	e50b301c 	str	r3, [fp, #-28]
	if (res != FR_OK) return res;			/* Trace failed */
    40d4:	e51b301c 	ldr	r3, [fp, #-28]
    40d8:	e3530000 	cmp	r3, #0	; 0x0
    40dc:	0a000002 	beq	40ec <f_unlink+0x94>
    40e0:	e51b301c 	ldr	r3, [fp, #-28]
    40e4:	e50b3048 	str	r3, [fp, #-72]
    40e8:	ea00008d 	b	4324 <f_unlink+0x2cc>
	if (!dir) return FR_INVALID_NAME;		/* It is the root directory */
    40ec:	e51b3034 	ldr	r3, [fp, #-52]
    40f0:	e3530000 	cmp	r3, #0	; 0x0
    40f4:	1a000002 	bne	4104 <f_unlink+0xac>
    40f8:	e3a03004 	mov	r3, #4	; 0x4
    40fc:	e50b3048 	str	r3, [fp, #-72]
    4100:	ea000087 	b	4324 <f_unlink+0x2cc>
	if (dir[DIR_Attr] & AM_RDO) return FR_DENIED;	/* It is a R/O object */
    4104:	e51b3034 	ldr	r3, [fp, #-52]
    4108:	e283300b 	add	r3, r3, #11	; 0xb
    410c:	e5d33000 	ldrb	r3, [r3]
    4110:	e2033001 	and	r3, r3, #1	; 0x1
    4114:	e20330ff 	and	r3, r3, #255	; 0xff
    4118:	e3530000 	cmp	r3, #0	; 0x0
    411c:	0a000002 	beq	412c <f_unlink+0xd4>
    4120:	e3a03006 	mov	r3, #6	; 0x6
    4124:	e50b3048 	str	r3, [fp, #-72]
    4128:	ea00007d 	b	4324 <f_unlink+0x2cc>
	dsect = dj.fs->winsect;
    412c:	e51b302c 	ldr	r3, [fp, #-44]
    4130:	e5933004 	ldr	r3, [r3, #4]
    4134:	e50b3010 	str	r3, [fp, #-16]
	dclust = ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);
    4138:	e51b3034 	ldr	r3, [fp, #-52]
    413c:	e2833015 	add	r3, r3, #21	; 0x15
    4140:	e5d33000 	ldrb	r3, [r3]
    4144:	e20330ff 	and	r3, r3, #255	; 0xff
    4148:	e1a03403 	lsl	r3, r3, #8
    414c:	e1a03803 	lsl	r3, r3, #16
    4150:	e1a02823 	lsr	r2, r3, #16
    4154:	e51b3034 	ldr	r3, [fp, #-52]
    4158:	e2833014 	add	r3, r3, #20	; 0x14
    415c:	e5d33000 	ldrb	r3, [r3]
    4160:	e20330ff 	and	r3, r3, #255	; 0xff
    4164:	e1823003 	orr	r3, r2, r3
    4168:	e1a03803 	lsl	r3, r3, #16
    416c:	e1a03823 	lsr	r3, r3, #16
    4170:	e1a03803 	lsl	r3, r3, #16
    4174:	e1a03823 	lsr	r3, r3, #16
    4178:	e1a01803 	lsl	r1, r3, #16
    417c:	e51b3034 	ldr	r3, [fp, #-52]
    4180:	e283301b 	add	r3, r3, #27	; 0x1b
    4184:	e5d33000 	ldrb	r3, [r3]
    4188:	e20330ff 	and	r3, r3, #255	; 0xff
    418c:	e1a03403 	lsl	r3, r3, #8
    4190:	e1a03803 	lsl	r3, r3, #16
    4194:	e1a02823 	lsr	r2, r3, #16
    4198:	e51b3034 	ldr	r3, [fp, #-52]
    419c:	e283301a 	add	r3, r3, #26	; 0x1a
    41a0:	e5d33000 	ldrb	r3, [r3]
    41a4:	e20330ff 	and	r3, r3, #255	; 0xff
    41a8:	e1823003 	orr	r3, r2, r3
    41ac:	e1a03803 	lsl	r3, r3, #16
    41b0:	e1a03823 	lsr	r3, r3, #16
    41b4:	e1a03803 	lsl	r3, r3, #16
    41b8:	e1a03823 	lsr	r3, r3, #16
    41bc:	e1813003 	orr	r3, r1, r3
    41c0:	e50b3014 	str	r3, [fp, #-20]
	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
    41c4:	e51b3034 	ldr	r3, [fp, #-52]
    41c8:	e283300b 	add	r3, r3, #11	; 0xb
    41cc:	e5d33000 	ldrb	r3, [r3]
    41d0:	e2033010 	and	r3, r3, #16	; 0x10
    41d4:	e3530000 	cmp	r3, #0	; 0x0
    41d8:	0a000032 	beq	42a8 <f_unlink+0x250>
		dj.clust = dclust;					/* Check if the sub-dir is empty or not */
    41dc:	e51b3014 	ldr	r3, [fp, #-20]
    41e0:	e50b3024 	str	r3, [fp, #-36]
		dj.sect = clust2sect(dj.fs, dclust);
    41e4:	e51b302c 	ldr	r3, [fp, #-44]
    41e8:	e1a00003 	mov	r0, r3
    41ec:	e51b1014 	ldr	r1, [fp, #-20]
    41f0:	ebfff666 	bl	1b90 <clust2sect>
    41f4:	e1a03000 	mov	r3, r0
    41f8:	e50b3020 	str	r3, [fp, #-32]
		dj.index = 2;
    41fc:	e3a03002 	mov	r3, #2	; 0x2
    4200:	e14b32be 	strh	r3, [fp, #-46]
		do {
			if (!move_window(dj.fs, dj.sect)) return FR_RW_ERROR;
    4204:	e51b302c 	ldr	r3, [fp, #-44]
    4208:	e51b2020 	ldr	r2, [fp, #-32]
    420c:	e1a00003 	mov	r0, r3
    4210:	e1a01002 	mov	r1, r2
    4214:	ebfff281 	bl	c20 <move_window>
    4218:	e1a03000 	mov	r3, r0
    421c:	e3530000 	cmp	r3, #0	; 0x0
    4220:	1a000002 	bne	4230 <f_unlink+0x1d8>
    4224:	e3a03008 	mov	r3, #8	; 0x8
    4228:	e50b3048 	str	r3, [fp, #-72]
    422c:	ea00003c 	b	4324 <f_unlink+0x2cc>
			sdir = &dj.fs->win[(dj.index & ((SS(dj.fs) - 1) >> 5)) * 32];
    4230:	e51b302c 	ldr	r3, [fp, #-44]
    4234:	e2832030 	add	r2, r3, #48	; 0x30
    4238:	e15b32be 	ldrh	r3, [fp, #-46]
    423c:	e203300f 	and	r3, r3, #15	; 0xf
    4240:	e1a03283 	lsl	r3, r3, #5
    4244:	e0823003 	add	r3, r2, r3
    4248:	e50b3018 	str	r3, [fp, #-24]
			if (sdir[DIR_Name] == 0) break;
    424c:	e51b3018 	ldr	r3, [fp, #-24]
    4250:	e5d33000 	ldrb	r3, [r3]
    4254:	e3530000 	cmp	r3, #0	; 0x0
    4258:	0a000012 	beq	42a8 <f_unlink+0x250>
			if (sdir[DIR_Name] != 0xE5 && !(sdir[DIR_Attr] & AM_VOL))
    425c:	e51b3018 	ldr	r3, [fp, #-24]
    4260:	e5d33000 	ldrb	r3, [r3]
    4264:	e35300e5 	cmp	r3, #229	; 0xe5
    4268:	0a000008 	beq	4290 <f_unlink+0x238>
    426c:	e51b3018 	ldr	r3, [fp, #-24]
    4270:	e283300b 	add	r3, r3, #11	; 0xb
    4274:	e5d33000 	ldrb	r3, [r3]
    4278:	e2033008 	and	r3, r3, #8	; 0x8
    427c:	e3530000 	cmp	r3, #0	; 0x0
    4280:	1a000002 	bne	4290 <f_unlink+0x238>
				return FR_DENIED;	/* The directory is not empty */
    4284:	e3a03006 	mov	r3, #6	; 0x6
    4288:	e50b3048 	str	r3, [fp, #-72]
    428c:	ea000024 	b	4324 <f_unlink+0x2cc>
		} while (next_dir_entry(&dj));
    4290:	e24b3030 	sub	r3, fp, #48	; 0x30
    4294:	e1a00003 	mov	r0, r3
    4298:	ebfff65b 	bl	1c0c <next_dir_entry>
    429c:	e1a03000 	mov	r3, r0
    42a0:	e3530000 	cmp	r3, #0	; 0x0
    42a4:	1affffd6 	bne	4204 <f_unlink+0x1ac>
	}
	if (!move_window(dj.fs, dsect)) return FR_RW_ERROR;	/* Mark the directory entry 'deleted' */
    42a8:	e51b302c 	ldr	r3, [fp, #-44]
    42ac:	e1a00003 	mov	r0, r3
    42b0:	e51b1010 	ldr	r1, [fp, #-16]
    42b4:	ebfff259 	bl	c20 <move_window>
    42b8:	e1a03000 	mov	r3, r0
    42bc:	e3530000 	cmp	r3, #0	; 0x0
    42c0:	1a000002 	bne	42d0 <f_unlink+0x278>
    42c4:	e3a03008 	mov	r3, #8	; 0x8
    42c8:	e50b3048 	str	r3, [fp, #-72]
    42cc:	ea000014 	b	4324 <f_unlink+0x2cc>
	dir[DIR_Name] = 0xE5;
    42d0:	e51b2034 	ldr	r2, [fp, #-52]
    42d4:	e3e0301a 	mvn	r3, #26	; 0x1a
    42d8:	e5c23000 	strb	r3, [r2]
	dj.fs->winflag = 1;
    42dc:	e51b202c 	ldr	r2, [fp, #-44]
    42e0:	e3a03001 	mov	r3, #1	; 0x1
    42e4:	e5c2302e 	strb	r3, [r2, #46]
	if (!remove_chain(dj.fs, dclust)) return FR_RW_ERROR;	/* Remove the cluster chain */
    42e8:	e51b302c 	ldr	r3, [fp, #-44]
    42ec:	e1a00003 	mov	r0, r3
    42f0:	e51b1014 	ldr	r1, [fp, #-20]
    42f4:	ebfff56d 	bl	18b0 <remove_chain>
    42f8:	e1a03000 	mov	r3, r0
    42fc:	e3530000 	cmp	r3, #0	; 0x0
    4300:	1a000002 	bne	4310 <f_unlink+0x2b8>
    4304:	e3a03008 	mov	r3, #8	; 0x8
    4308:	e50b3048 	str	r3, [fp, #-72]
    430c:	ea000004 	b	4324 <f_unlink+0x2cc>

	return sync(dj.fs);
    4310:	e51b302c 	ldr	r3, [fp, #-44]
    4314:	e1a00003 	mov	r0, r3
    4318:	ebfff2a1 	bl	da4 <sync>
    431c:	e1a03000 	mov	r3, r0
    4320:	e50b3048 	str	r3, [fp, #-72]
    4324:	e51b3048 	ldr	r3, [fp, #-72]
}
    4328:	e1a00003 	mov	r0, r3
    432c:	e24bd00c 	sub	sp, fp, #12	; 0xc
    4330:	e89da800 	ldm	sp, {fp, sp, pc}

00004334 <SELECT>:
	return ( st & ( 1<<8 ) ) ? 1 : 0;
}

// state to trans (SD Card State Diagram: V2.2 P4-7)
static void SELECT(void)
{
    4334:	e1a0c00d 	mov	ip, sp
    4338:	e92dd800 	push	{fp, ip, lr, pc}
    433c:	e24cb004 	sub	fp, ip, #4	; 0x4
    4340:	e24dd00c 	sub	sp, sp, #12	; 0xc
	DWORD currst, st;
	dump_status("before select");

	Timer2 = 1000;
    4344:	e59f205c 	ldr	r2, [pc, #92]	; 43a8 <SELECT+0x74>
    4348:	e3a03ffa 	mov	r3, #1000	; 0x3e8
    434c:	e5823000 	str	r3, [r2]
	do {
		// cmd7 until state is trans
		st = MCI_Send_Status();
    4350:	eb0009c8 	bl	6a78 <MCI_Send_Status>
    4354:	e1a03000 	mov	r3, r0
    4358:	e50b3010 	str	r3, [fp, #-16]
		currst = currstate_from_status(st);
    435c:	e51b0010 	ldr	r0, [fp, #-16]
    4360:	eb000011 	bl	43ac <currstate_from_status>
    4364:	e1a03000 	mov	r3, r0
    4368:	e50b3014 	str	r3, [fp, #-20]
		if ( currst != CURR_STATE_TRAN ) {
    436c:	e51b3014 	ldr	r3, [fp, #-20]
    4370:	e3530004 	cmp	r3, #4	; 0x4
    4374:	0a000000 	beq	437c <SELECT+0x48>
			if ( MCI_Select_Card() == FALSE ) {
    4378:	eb000968 	bl	6920 <MCI_Select_Card>
				diskio_printf("SELECT Select_Card failed - retry\n");
			}
		}
	} while ( ( currst != CURR_STATE_TRAN ) && Timer2 );
    437c:	e51b3014 	ldr	r3, [fp, #-20]
    4380:	e3530004 	cmp	r3, #4	; 0x4
    4384:	0a000003 	beq	4398 <SELECT+0x64>
    4388:	e59f3018 	ldr	r3, [pc, #24]	; 43a8 <SELECT+0x74>
    438c:	e5933000 	ldr	r3, [r3]
    4390:	e3530000 	cmp	r3, #0	; 0x0
    4394:	1affffed 	bne	4350 <SELECT+0x1c>

	if ( Timer2 == 0 ) {
    4398:	e59f3008 	ldr	r3, [pc, #8]	; 43a8 <SELECT+0x74>
    439c:	e5933000 	ldr	r3, [r3]
		diskio_printf("SELECT timeout changeing to trans\n");
	}
	dump_status("after select");
}
    43a0:	e24bd00c 	sub	sp, fp, #12	; 0xc
    43a4:	e89da800 	ldm	sp, {fp, sp, pc}
    43a8:	40000708 	.word	0x40000708

000043ac <currstate_from_status>:
#else 
#define dump_status(s__)
#endif

static INLINE USHORT currstate_from_status( DWORD st )
{
    43ac:	e1a0c00d 	mov	ip, sp
    43b0:	e92dd800 	push	{fp, ip, lr, pc}
    43b4:	e24cb004 	sub	fp, ip, #4	; 0x4
    43b8:	e24dd004 	sub	sp, sp, #4	; 0x4
    43bc:	e50b0010 	str	r0, [fp, #-16]
	return ( (st >> 9 ) & 0xff );
    43c0:	e51b3010 	ldr	r3, [fp, #-16]
    43c4:	e1a034a3 	lsr	r3, r3, #9
    43c8:	e1a03803 	lsl	r3, r3, #16
    43cc:	e1a03823 	lsr	r3, r3, #16
    43d0:	e20330ff 	and	r3, r3, #255	; 0xff
}
    43d4:	e1a00003 	mov	r0, r3
    43d8:	e89da808 	ldm	sp, {r3, fp, sp, pc}

000043dc <DESELECT>:
	dump_status("after select");
}

// state to stby
static void DESELECT(void)
{
    43dc:	e1a0c00d 	mov	ip, sp
    43e0:	e92dd800 	push	{fp, ip, lr, pc}
    43e4:	e24cb004 	sub	fp, ip, #4	; 0x4
    43e8:	e24dd00c 	sub	sp, sp, #12	; 0xc
	DWORD cardtype_save, st, currst;

	Timer2 = 500;
    43ec:	e59f2094 	ldr	r2, [pc, #148]	; 4488 <DESELECT+0xac>
    43f0:	e3a03f7d 	mov	r3, #500	; 0x1f4
    43f4:	e5823000 	str	r3, [r2]
	do {
		st = MCI_Send_Status();
    43f8:	eb00099e 	bl	6a78 <MCI_Send_Status>
    43fc:	e1a03000 	mov	r3, r0
    4400:	e50b3014 	str	r3, [fp, #-20]
		
		currst = currstate_from_status(st);
    4404:	e51b0014 	ldr	r0, [fp, #-20]
    4408:	ebffffe7 	bl	43ac <currstate_from_status>
    440c:	e1a03000 	mov	r3, r0
    4410:	e50b3010 	str	r3, [fp, #-16]
	} while ( ( currst != CURR_STATE_TRAN ) && 
	          ( currst != CURR_STATE_STBY  ) && 
	          Timer2 );
    4414:	e51b3010 	ldr	r3, [fp, #-16]
    4418:	e3530004 	cmp	r3, #4	; 0x4
    441c:	0a000006 	beq	443c <DESELECT+0x60>
    4420:	e51b3010 	ldr	r3, [fp, #-16]
    4424:	e3530003 	cmp	r3, #3	; 0x3
    4428:	0a000003 	beq	443c <DESELECT+0x60>
    442c:	e59f3054 	ldr	r3, [pc, #84]	; 4488 <DESELECT+0xac>
    4430:	e5933000 	ldr	r3, [r3]
    4434:	e3530000 	cmp	r3, #0	; 0x0
    4438:	1affffee 	bne	43f8 <DESELECT+0x1c>

	if ( Timer2 == 0 ) {
    443c:	e59f3044 	ldr	r3, [pc, #68]	; 4488 <DESELECT+0xac>
    4440:	e5933000 	ldr	r3, [r3]
    4444:	e3530000 	cmp	r3, #0	; 0x0
    4448:	0a00000c 	beq	4480 <DESELECT+0xa4>
		diskio_printf("DESELCT timeout waiting trans or stby\n");
	}
	else if ( currst == CURR_STATE_TRAN ) {
    444c:	e51b3010 	ldr	r3, [fp, #-16]
    4450:	e3530004 	cmp	r3, #4	; 0x4
    4454:	1a000009 	bne	4480 <DESELECT+0xa4>
		cardtype_save = MCI_CardType;
    4458:	e59f302c 	ldr	r3, [pc, #44]	; 448c <DESELECT+0xb0>
    445c:	e5933000 	ldr	r3, [r3]
    4460:	e50b3018 	str	r3, [fp, #-24]
		// CMD7: trans to stby (RCA 0) / de-select
		MCI_CardType = 0;
    4464:	e59f2020 	ldr	r2, [pc, #32]	; 448c <DESELECT+0xb0>
    4468:	e3a03000 	mov	r3, #0	; 0x0
    446c:	e5823000 	str	r3, [r2]
		if ( MCI_Select_Card() == FALSE ) {
    4470:	eb00092a 	bl	6920 <MCI_Select_Card>
			diskio_printf("DESELECT failed\n");
		}
		MCI_CardType = cardtype_save;
    4474:	e59f2010 	ldr	r2, [pc, #16]	; 448c <DESELECT+0xb0>
    4478:	e51b3018 	ldr	r3, [fp, #-24]
    447c:	e5823000 	str	r3, [r2]
	else {
		//diskio_printf("DSELECT already in stby\n");
	}
	
	return;
}
    4480:	e24bd00c 	sub	sp, fp, #12	; 0xc
    4484:	e89da800 	ldm	sp, {fp, sp, pc}
    4488:	40000708 	.word	0x40000708
    448c:	40000050 	.word	0x40000050

00004490 <wait_ready>:

// wait for stby or trans with timeout
static BYTE wait_ready( void ) 
{
    4490:	e1a0c00d 	mov	ip, sp
    4494:	e92dd800 	push	{fp, ip, lr, pc}
    4498:	e24cb004 	sub	fp, ip, #4	; 0x4
    449c:	e24dd00c 	sub	sp, sp, #12	; 0xc
	BYTE res;
	DWORD st;
	// DWORD currst;

	res = 0xaa;
    44a0:	e3e03055 	mvn	r3, #85	; 0x55
    44a4:	e54b3011 	strb	r3, [fp, #-17]
	Timer2 = 500;	/* Wait for ready in timeout of 500ms */
    44a8:	e59f206c 	ldr	r2, [pc, #108]	; 451c <wait_ready+0x8c>
    44ac:	e3a03f7d 	mov	r3, #500	; 0x1f4
    44b0:	e5823000 	str	r3, [r2]
	do {
		st = MCI_Send_Status();
    44b4:	eb00096f 	bl	6a78 <MCI_Send_Status>
    44b8:	e1a03000 	mov	r3, r0
    44bc:	e50b3010 	str	r3, [fp, #-16]
		if ( st == INVALID_RESPONSE ) {
    44c0:	e51b3010 	ldr	r3, [fp, #-16]
    44c4:	e3730001 	cmn	r3, #1	; 0x1
    44c8:	0a000006 	beq	44e8 <wait_ready+0x58>
			diskio_printf("wait_ready: Send_Status INVALID_RESPONSE\n");
		}
		else {
			// currst = currstate_from_status(st);
			// if ( currst == 3 /* stby */ || currst == 4 /* trans */) {
			if ( status_ready_bit( st ) ) {
    44cc:	e51b0010 	ldr	r0, [fp, #-16]
    44d0:	eb000012 	bl	4520 <status_ready_bit>
    44d4:	e1a03000 	mov	r3, r0
    44d8:	e3530000 	cmp	r3, #0	; 0x0
    44dc:	0a000001 	beq	44e8 <wait_ready+0x58>
				res = 0xff;
    44e0:	e3e03000 	mvn	r3, #0	; 0x0
    44e4:	e54b3011 	strb	r3, [fp, #-17]
			}
		}
	}
	while ( (res != 0xFF) && Timer2 );
    44e8:	e55b3011 	ldrb	r3, [fp, #-17]
    44ec:	e35300ff 	cmp	r3, #255	; 0xff
    44f0:	0a000003 	beq	4504 <wait_ready+0x74>
    44f4:	e59f3020 	ldr	r3, [pc, #32]	; 451c <wait_ready+0x8c>
    44f8:	e5933000 	ldr	r3, [r3]
    44fc:	e3530000 	cmp	r3, #0	; 0x0
    4500:	1affffeb 	bne	44b4 <wait_ready+0x24>

	if ( Timer2 == 0 ) {
    4504:	e59f3010 	ldr	r3, [pc, #16]	; 451c <wait_ready+0x8c>
    4508:	e5933000 	ldr	r3, [r3]
		diskio_printf("wait_ready: timeout stby or trans\n");
	}

	return res;
    450c:	e55b3011 	ldrb	r3, [fp, #-17]
}
    4510:	e1a00003 	mov	r0, r3
    4514:	e24bd00c 	sub	sp, fp, #12	; 0xc
    4518:	e89da800 	ldm	sp, {fp, sp, pc}
    451c:	40000708 	.word	0x40000708

00004520 <status_ready_bit>:
{
	return ( (st >> 9 ) & 0xff );
}

static INLINE BYTE status_ready_bit( DWORD st )
{
    4520:	e1a0c00d 	mov	ip, sp
    4524:	e92dd800 	push	{fp, ip, lr, pc}
    4528:	e24cb004 	sub	fp, ip, #4	; 0x4
    452c:	e24dd004 	sub	sp, sp, #4	; 0x4
    4530:	e50b0010 	str	r0, [fp, #-16]
	return ( st & ( 1<<8 ) ) ? 1 : 0;
    4534:	e51b3010 	ldr	r3, [fp, #-16]
    4538:	e2033c01 	and	r3, r3, #256	; 0x100
    453c:	e3530000 	cmp	r3, #0	; 0x0
    4540:	03a03000 	moveq	r3, #0	; 0x0
    4544:	13a03001 	movne	r3, #1	; 0x1
}
    4548:	e1a00003 	mov	r0, r3
    454c:	e89da808 	ldm	sp, {r3, fp, sp, pc}

00004550 <release_spi>:
}

// well, no SPI used here but will keep the interface compatible with
// Chan's examples
static void release_spi(void)
{
    4550:	e1a0c00d 	mov	ip, sp
    4554:	e92dd800 	push	{fp, ip, lr, pc}
    4558:	e24cb004 	sub	fp, ip, #4	; 0x4
	DESELECT();
    455c:	ebffff9e 	bl	43dc <DESELECT>
}
    4560:	e89da800 	ldm	sp, {fp, sp, pc}

00004564 <power_off>:

static void power_off (void)
{
    4564:	e1a0c00d 	mov	ip, sp
    4568:	e92dd800 	push	{fp, ip, lr, pc}
    456c:	e24cb004 	sub	fp, ip, #4	; 0x4
	SELECT();
    4570:	ebffff6f 	bl	4334 <SELECT>
	wait_ready();
    4574:	ebffffc5 	bl	4490 <wait_ready>
	release_spi();
    4578:	ebfffff4 	bl	4550 <release_spi>

	MCI_Power_Off();
    457c:	eb000cda 	bl	78ec <MCI_Power_Off>

	Stat |= STA_NOINIT;		/* Set STA_NOINIT */
    4580:	e59f3018 	ldr	r3, [pc, #24]	; 45a0 <power_off+0x3c>
    4584:	e5d33000 	ldrb	r3, [r3]
    4588:	e20330ff 	and	r3, r3, #255	; 0xff
    458c:	e3833001 	orr	r3, r3, #1	; 0x1
    4590:	e20330ff 	and	r3, r3, #255	; 0xff
    4594:	e59f2004 	ldr	r2, [pc, #4]	; 45a0 <power_off+0x3c>
    4598:	e5c23000 	strb	r3, [r2]
}
    459c:	e89da800 	ldm	sp, {fp, sp, pc}
    45a0:	40000000 	.word	0x40000000

000045a4 <MCI_get_sd_status>:


// must be in trans state - only used during init
// reads the SD Status ( do not confuse with Status Register )
static DWORD MCI_get_sd_status(void)
{
    45a4:	e1a0c00d 	mov	ip, sp
    45a8:	e92dd800 	push	{fp, ip, lr, pc}
    45ac:	e24cb004 	sub	fp, ip, #4	; 0x4
    45b0:	e24dd008 	sub	sp, sp, #8	; 0x8
	DWORD i;
#ifdef DISKIO_DEBUG
	DWORD j;
#endif

	if ( MCI_Set_BlockLen( SD_BLOCK_LENGTH ) == FALSE )
    45b4:	e3a00040 	mov	r0, #64	; 0x40
    45b8:	eb00096e 	bl	6b78 <MCI_Set_BlockLen>
    45bc:	e1a03000 	mov	r3, r0
    45c0:	e3530000 	cmp	r3, #0	; 0x0
    45c4:	1a000002 	bne	45d4 <MCI_get_sd_status+0x30>
	{
		diskio_printf("get_sd_status: Set_BlockLen SD_STATUS failed\n");
		return FALSE;
    45c8:	e3a03000 	mov	r3, #0	; 0x0
    45cc:	e50b3014 	str	r3, [fp, #-20]
    45d0:	ea00002c 	b	4688 <MCI_get_sd_status+0xe4>
	}
	
	if ( MCI_Sd_Status() == FALSE ) {
    45d4:	eb000c2b 	bl	7688 <MCI_Sd_Status>
    45d8:	e1a03000 	mov	r3, r0
    45dc:	e3530000 	cmp	r3, #0	; 0x0
    45e0:	1a000002 	bne	45f0 <MCI_get_sd_status+0x4c>
		diskio_printf("get_sd_status: MCI_Sd_Status failed\n");
		return FALSE;
    45e4:	e3a03000 	mov	r3, #0	; 0x0
    45e8:	e50b3014 	str	r3, [fp, #-20]
    45ec:	ea000025 	b	4688 <MCI_get_sd_status+0xe4>
	}
	
	Timer2 = 2000;
    45f0:	e59f20a0 	ldr	r2, [pc, #160]	; 4698 <MCI_get_sd_status+0xf4>
    45f4:	e3a03e7d 	mov	r3, #2000	; 0x7d0
    45f8:	e5823000 	str	r3, [r2]
	while ( MCI_Block_End_Flag == 1 && Timer2 ) { ; }
    45fc:	e59f3098 	ldr	r3, [pc, #152]	; 469c <MCI_get_sd_status+0xf8>
    4600:	e5933000 	ldr	r3, [r3]
    4604:	e3530001 	cmp	r3, #1	; 0x1
    4608:	1a000003 	bne	461c <MCI_get_sd_status+0x78>
    460c:	e59f3084 	ldr	r3, [pc, #132]	; 4698 <MCI_get_sd_status+0xf4>
    4610:	e5933000 	ldr	r3, [r3]
    4614:	e3530000 	cmp	r3, #0	; 0x0
    4618:	1afffff7 	bne	45fc <MCI_get_sd_status+0x58>
	if ( Timer2 == 0 ) {
    461c:	e59f3074 	ldr	r3, [pc, #116]	; 4698 <MCI_get_sd_status+0xf4>
    4620:	e5933000 	ldr	r3, [r3]
    4624:	e3530000 	cmp	r3, #0	; 0x0
    4628:	1a000002 	bne	4638 <MCI_get_sd_status+0x94>
		diskio_printf("get_sd_status: timeout waiting for data");
		return FALSE;
    462c:	e3a03000 	mov	r3, #0	; 0x0
    4630:	e50b3014 	str	r3, [fp, #-20]
    4634:	ea000013 	b	4688 <MCI_get_sd_status+0xe4>
			break;
	}
	diskio_printf("\n");
#endif

	for ( i=0; i<16; i++ ) {
    4638:	e3a03000 	mov	r3, #0	; 0x0
    463c:	e50b3010 	str	r3, [fp, #-16]
    4640:	ea00000b 	b	4674 <MCI_get_sd_status+0xd0>
		sd_status[i] = ReadBlock[i];
    4644:	e51b1010 	ldr	r1, [fp, #-16]
    4648:	e59f3050 	ldr	r3, [pc, #80]	; 46a0 <MCI_get_sd_status+0xfc>
    464c:	e5932000 	ldr	r2, [r3]
    4650:	e51b3010 	ldr	r3, [fp, #-16]
    4654:	e0823003 	add	r3, r2, r3
    4658:	e5d33000 	ldrb	r3, [r3]
    465c:	e20330ff 	and	r3, r3, #255	; 0xff
    4660:	e59f203c 	ldr	r2, [pc, #60]	; 46a4 <MCI_get_sd_status+0x100>
    4664:	e7c23001 	strb	r3, [r2, r1]
			break;
	}
	diskio_printf("\n");
#endif

	for ( i=0; i<16; i++ ) {
    4668:	e51b3010 	ldr	r3, [fp, #-16]
    466c:	e2833001 	add	r3, r3, #1	; 0x1
    4670:	e50b3010 	str	r3, [fp, #-16]
    4674:	e51b3010 	ldr	r3, [fp, #-16]
    4678:	e353000f 	cmp	r3, #15	; 0xf
    467c:	9afffff0 	bls	4644 <MCI_get_sd_status+0xa0>
		sd_status[i] = ReadBlock[i];
	}
	
	return TRUE;
    4680:	e3a03001 	mov	r3, #1	; 0x1
    4684:	e50b3014 	str	r3, [fp, #-20]
    4688:	e51b3014 	ldr	r3, [fp, #-20]
}
    468c:	e1a00003 	mov	r0, r3
    4690:	e24bd00c 	sub	sp, fp, #12	; 0xc
    4694:	e89da800 	ldm	sp, {fp, sp, pc}
    4698:	40000708 	.word	0x40000708
    469c:	40000770 	.word	0x40000770
    46a0:	40000008 	.word	0x40000008
    46a4:	40000720 	.word	0x40000720

000046a8 <MCI_disk_initialize>:

static int MCI_disk_initialize(void)
{
    46a8:	e1a0c00d 	mov	ip, sp
    46ac:	e92dd800 	push	{fp, ip, lr, pc}
    46b0:	e24cb004 	sub	fp, ip, #4	; 0x4
    46b4:	e24dd018 	sub	sp, sp, #24	; 0x18
	int err = 0, i;
    46b8:	e3a03000 	mov	r3, #0	; 0x0
    46bc:	e50b3014 	str	r3, [fp, #-20]

	diskio_printf("\n");
#if MCI_DMA_ENABLED
	/* on DMA channel 0, source is memory, destination is MCI FIFO. */
	/* On DMA channel 1, source is MCI FIFO, destination is memory. */
	DMA_Init();
    46c0:	eb000d10 	bl	7b08 <DMA_Init>
	diskio_printf("MCI DMA enabled\n");
#endif

	if ( MCI_Init() != TRUE )
    46c4:	eb0004aa 	bl	5974 <MCI_Init>
    46c8:	e1a03000 	mov	r3, r0
    46cc:	e3530001 	cmp	r3, #1	; 0x1
    46d0:	0a000002 	beq	46e0 <MCI_disk_initialize+0x38>
	{
		diskio_printf("MCI_Init failed\n");
		err++; /* fatal error */
    46d4:	e51b3014 	ldr	r3, [fp, #-20]
    46d8:	e2833001 	add	r3, r3, #1	; 0x1
    46dc:	e50b3014 	str	r3, [fp, #-20]
	}
	
	if ( !err ) 
    46e0:	e51b3014 	ldr	r3, [fp, #-20]
    46e4:	e3530000 	cmp	r3, #0	; 0x0
    46e8:	1a00000a 	bne	4718 <MCI_disk_initialize+0x70>
	{
		MCI_CardType = MCI_CardInit();
    46ec:	eb000769 	bl	6498 <MCI_CardInit>
    46f0:	e1a02000 	mov	r2, r0
    46f4:	e59f32b4 	ldr	r3, [pc, #692]	; 49b0 <MCI_disk_initialize+0x308>
    46f8:	e5832000 	str	r2, [r3]
		if ( MCI_CardType == CARD_UNKNOWN )
    46fc:	e59f32ac 	ldr	r3, [pc, #684]	; 49b0 <MCI_disk_initialize+0x308>
    4700:	e5933000 	ldr	r3, [r3]
    4704:	e3530000 	cmp	r3, #0	; 0x0
    4708:	1a000002 	bne	4718 <MCI_disk_initialize+0x70>
		{
			diskio_printf("unknown card\n");
			err++; /* fatal error */
    470c:	e51b3014 	ldr	r3, [fp, #-20]
    4710:	e2833001 	add	r3, r3, #1	; 0x1
    4714:	e50b3014 	str	r3, [fp, #-20]
		}
	}

	if ( err || MCI_Check_CID() == FALSE )
    4718:	e51b3014 	ldr	r3, [fp, #-20]
    471c:	e3530000 	cmp	r3, #0	; 0x0
    4720:	1a000003 	bne	4734 <MCI_disk_initialize+0x8c>
    4724:	eb0007ab 	bl	65d8 <MCI_Check_CID>
    4728:	e1a03000 	mov	r3, r0
    472c:	e3530000 	cmp	r3, #0	; 0x0
    4730:	1a000002 	bne	4740 <MCI_disk_initialize+0x98>
	{
		diskio_printf("Check_CID failed\n");
		err++; /* fatal error */
    4734:	e51b3014 	ldr	r3, [fp, #-20]
    4738:	e2833001 	add	r3, r3, #1	; 0x1
    473c:	e50b3014 	str	r3, [fp, #-20]
	}
	
	if ( err || MCI_Set_Address() == FALSE )
    4740:	e51b3014 	ldr	r3, [fp, #-20]
    4744:	e3530000 	cmp	r3, #0	; 0x0
    4748:	1a000003 	bne	475c <MCI_disk_initialize+0xb4>
    474c:	eb0007d0 	bl	6694 <MCI_Set_Address>
    4750:	e1a03000 	mov	r3, r0
    4754:	e3530000 	cmp	r3, #0	; 0x0
    4758:	1a000002 	bne	4768 <MCI_disk_initialize+0xc0>
	{
		diskio_printf("Set_Address failed\n");
		err++; /* fatal error */
    475c:	e51b3014 	ldr	r3, [fp, #-20]
    4760:	e2833001 	add	r3, r3, #1	; 0x1
    4764:	e50b3014 	str	r3, [fp, #-20]
	}
	
	if ( err || MCI_Send_CSD( csddw ) == FALSE )
    4768:	e51b3014 	ldr	r3, [fp, #-20]
    476c:	e3530000 	cmp	r3, #0	; 0x0
    4770:	1a000005 	bne	478c <MCI_disk_initialize+0xe4>
    4774:	e24b3024 	sub	r3, fp, #36	; 0x24
    4778:	e1a00003 	mov	r0, r3
    477c:	eb000809 	bl	67a8 <MCI_Send_CSD>
    4780:	e1a03000 	mov	r3, r0
    4784:	e3530000 	cmp	r3, #0	; 0x0
    4788:	1a000003 	bne	479c <MCI_disk_initialize+0xf4>
	{
		diskio_printf("Send_CSD failed\n");
		err++;
    478c:	e51b3014 	ldr	r3, [fp, #-20]
    4790:	e2833001 	add	r3, r3, #1	; 0x1
    4794:	e50b3014 	str	r3, [fp, #-20]
    4798:	ea000048 	b	48c0 <MCI_disk_initialize+0x218>
	}
	else 
	{
		diskio_printf("diskio: CSD %08x %08x %08x %08x\n",
			csddw[0], csddw[1], csddw[2], csddw[3]);
		for ( i=0; i<4; i++ ) {
    479c:	e3a03000 	mov	r3, #0	; 0x0
    47a0:	e50b3010 	str	r3, [fp, #-16]
    47a4:	ea000042 	b	48b4 <MCI_disk_initialize+0x20c>
			DWORD_TO_BYTES( &csd[i*4], csddw[i] );
    47a8:	e51b3010 	ldr	r3, [fp, #-16]
    47ac:	e1a03103 	lsl	r3, r3, #2
    47b0:	e1a02003 	mov	r2, r3
    47b4:	e59f31f8 	ldr	r3, [pc, #504]	; 49b4 <MCI_disk_initialize+0x30c>
    47b8:	e0821003 	add	r1, r2, r3
    47bc:	e51b3010 	ldr	r3, [fp, #-16]
    47c0:	e3e02017 	mvn	r2, #23	; 0x17
    47c4:	e1a03103 	lsl	r3, r3, #2
    47c8:	e24b000c 	sub	r0, fp, #12	; 0xc
    47cc:	e0803003 	add	r3, r0, r3
    47d0:	e0833002 	add	r3, r3, r2
    47d4:	e5933000 	ldr	r3, [r3]
    47d8:	e1a03c23 	lsr	r3, r3, #24
    47dc:	e20330ff 	and	r3, r3, #255	; 0xff
    47e0:	e5c13000 	strb	r3, [r1]
    47e4:	e51b3010 	ldr	r3, [fp, #-16]
    47e8:	e1a03103 	lsl	r3, r3, #2
    47ec:	e2832001 	add	r2, r3, #1	; 0x1
    47f0:	e59f31bc 	ldr	r3, [pc, #444]	; 49b4 <MCI_disk_initialize+0x30c>
    47f4:	e0821003 	add	r1, r2, r3
    47f8:	e51b3010 	ldr	r3, [fp, #-16]
    47fc:	e3e02017 	mvn	r2, #23	; 0x17
    4800:	e1a03103 	lsl	r3, r3, #2
    4804:	e24b000c 	sub	r0, fp, #12	; 0xc
    4808:	e0803003 	add	r3, r0, r3
    480c:	e0833002 	add	r3, r3, r2
    4810:	e5933000 	ldr	r3, [r3]
    4814:	e1a03823 	lsr	r3, r3, #16
    4818:	e20330ff 	and	r3, r3, #255	; 0xff
    481c:	e5c13000 	strb	r3, [r1]
    4820:	e51b3010 	ldr	r3, [fp, #-16]
    4824:	e1a03083 	lsl	r3, r3, #1
    4828:	e2833001 	add	r3, r3, #1	; 0x1
    482c:	e1a02083 	lsl	r2, r3, #1
    4830:	e59f317c 	ldr	r3, [pc, #380]	; 49b4 <MCI_disk_initialize+0x30c>
    4834:	e0821003 	add	r1, r2, r3
    4838:	e51b3010 	ldr	r3, [fp, #-16]
    483c:	e3e02017 	mvn	r2, #23	; 0x17
    4840:	e1a03103 	lsl	r3, r3, #2
    4844:	e24b000c 	sub	r0, fp, #12	; 0xc
    4848:	e0803003 	add	r3, r0, r3
    484c:	e0833002 	add	r3, r3, r2
    4850:	e5933000 	ldr	r3, [r3]
    4854:	e1a03803 	lsl	r3, r3, #16
    4858:	e1a03823 	lsr	r3, r3, #16
    485c:	e1a03423 	lsr	r3, r3, #8
    4860:	e1a03803 	lsl	r3, r3, #16
    4864:	e1a03823 	lsr	r3, r3, #16
    4868:	e20330ff 	and	r3, r3, #255	; 0xff
    486c:	e5c13000 	strb	r3, [r1]
    4870:	e51b3010 	ldr	r3, [fp, #-16]
    4874:	e1a03103 	lsl	r3, r3, #2
    4878:	e2832003 	add	r2, r3, #3	; 0x3
    487c:	e59f3130 	ldr	r3, [pc, #304]	; 49b4 <MCI_disk_initialize+0x30c>
    4880:	e0821003 	add	r1, r2, r3
    4884:	e51b3010 	ldr	r3, [fp, #-16]
    4888:	e3e02017 	mvn	r2, #23	; 0x17
    488c:	e1a03103 	lsl	r3, r3, #2
    4890:	e24b000c 	sub	r0, fp, #12	; 0xc
    4894:	e0803003 	add	r3, r0, r3
    4898:	e0833002 	add	r3, r3, r2
    489c:	e5933000 	ldr	r3, [r3]
    48a0:	e20330ff 	and	r3, r3, #255	; 0xff
    48a4:	e5c13000 	strb	r3, [r1]
	}
	else 
	{
		diskio_printf("diskio: CSD %08x %08x %08x %08x\n",
			csddw[0], csddw[1], csddw[2], csddw[3]);
		for ( i=0; i<4; i++ ) {
    48a8:	e51b3010 	ldr	r3, [fp, #-16]
    48ac:	e2833001 	add	r3, r3, #1	; 0x1
    48b0:	e50b3010 	str	r3, [fp, #-16]
    48b4:	e51b3010 	ldr	r3, [fp, #-16]
    48b8:	e3530003 	cmp	r3, #3	; 0x3
    48bc:	daffffb9 	ble	47a8 <MCI_disk_initialize+0x100>
			DWORD_TO_BYTES( &csd[i*4], csddw[i] );
		}
	}
	
	if ( err || MCI_Select_Card() == FALSE )
    48c0:	e51b3014 	ldr	r3, [fp, #-20]
    48c4:	e3530000 	cmp	r3, #0	; 0x0
    48c8:	1a000003 	bne	48dc <MCI_disk_initialize+0x234>
    48cc:	eb000813 	bl	6920 <MCI_Select_Card>
    48d0:	e1a03000 	mov	r3, r0
    48d4:	e3530000 	cmp	r3, #0	; 0x0
    48d8:	1a000002 	bne	48e8 <MCI_disk_initialize+0x240>
	{
		diskio_printf("Select_Card failed\n");
		err++;
    48dc:	e51b3014 	ldr	r3, [fp, #-20]
    48e0:	e2833001 	add	r3, r3, #1	; 0x1
    48e4:	e50b3014 	str	r3, [fp, #-20]
	}
	
	if ( !err ) 
    48e8:	e51b3014 	ldr	r3, [fp, #-20]
    48ec:	e3530000 	cmp	r3, #0	; 0x0
    48f0:	1a000011 	bne	493c <MCI_disk_initialize+0x294>
	{
		if ( ( MCI_CardType == SD_CARD ) || 
    48f4:	e59f30b4 	ldr	r3, [pc, #180]	; 49b0 <MCI_disk_initialize+0x308>
    48f8:	e5933000 	ldr	r3, [r3]
    48fc:	e3530002 	cmp	r3, #2	; 0x2
    4900:	0a000003 	beq	4914 <MCI_disk_initialize+0x26c>
    4904:	e59f30a4 	ldr	r3, [pc, #164]	; 49b0 <MCI_disk_initialize+0x308>
    4908:	e5933000 	ldr	r3, [r3]
    490c:	e3530004 	cmp	r3, #4	; 0x4
    4910:	1a000009 	bne	493c <MCI_disk_initialize+0x294>
		     ( MCI_CardType == SDHC_CARD ) )
		{
			MCI_Set_MCIClock( NORMAL_RATE );
    4914:	e3a00002 	mov	r0, #2	; 0x2
    4918:	eb0003aa 	bl	57c8 <MCI_Set_MCIClock>
			if (SD_Set_BusWidth( SD_4_BIT ) != TRUE )
    491c:	e3a00001 	mov	r0, #1	; 0x1
    4920:	eb0003db 	bl	5894 <SD_Set_BusWidth>
    4924:	e1a03000 	mov	r3, r0
    4928:	e3530001 	cmp	r3, #1	; 0x1
    492c:	0a000002 	beq	493c <MCI_disk_initialize+0x294>
			{
				diskio_printf("set 4 bit mode failed\n");
				err++;
    4930:	e51b3014 	ldr	r3, [fp, #-20]
    4934:	e2833001 	add	r3, r3, #1	; 0x1
    4938:	e50b3014 	str	r3, [fp, #-20]
			}
		}
	}
	
	if ( !err && ( MCI_CardType == SDHC_CARD ) )
    493c:	e51b3014 	ldr	r3, [fp, #-20]
    4940:	e3530000 	cmp	r3, #0	; 0x0
    4944:	1a00000a 	bne	4974 <MCI_disk_initialize+0x2cc>
    4948:	e59f3060 	ldr	r3, [pc, #96]	; 49b0 <MCI_disk_initialize+0x308>
    494c:	e5933000 	ldr	r3, [r3]
    4950:	e3530004 	cmp	r3, #4	; 0x4
    4954:	1a000006 	bne	4974 <MCI_disk_initialize+0x2cc>
// 	     ( ( MCI_CardType == SDHC_CARD ) ||
//	       ( MCI_CardType == SD_CARD ) ) )
	{
		if ( MCI_get_sd_status() == FALSE ) 
    4958:	ebffff11 	bl	45a4 <MCI_get_sd_status>
    495c:	e1a03000 	mov	r3, r0
    4960:	e3530000 	cmp	r3, #0	; 0x0
    4964:	1a000002 	bne	4974 <MCI_disk_initialize+0x2cc>
		{
			diskio_printf("get_sd_status failed\n");
			err++;
    4968:	e51b3014 	ldr	r3, [fp, #-20]
    496c:	e2833001 	add	r3, r3, #1	; 0x1
    4970:	e50b3014 	str	r3, [fp, #-20]
		}
	}
	
	if ( err || MCI_Set_BlockLen( BLOCK_LENGTH ) == FALSE )
    4974:	e51b3014 	ldr	r3, [fp, #-20]
    4978:	e3530000 	cmp	r3, #0	; 0x0
    497c:	1a000004 	bne	4994 <MCI_disk_initialize+0x2ec>
    4980:	e3a00c02 	mov	r0, #512	; 0x200
    4984:	eb00087b 	bl	6b78 <MCI_Set_BlockLen>
    4988:	e1a03000 	mov	r3, r0
    498c:	e3530000 	cmp	r3, #0	; 0x0
    4990:	1a000002 	bne	49a0 <MCI_disk_initialize+0x2f8>
	{
		diskio_printf("Set_BlockLen failed\n");
		err++;
    4994:	e51b3014 	ldr	r3, [fp, #-20]
    4998:	e2833001 	add	r3, r3, #1	; 0x1
    499c:	e50b3014 	str	r3, [fp, #-20]
	}
	diskio_printf("Set_BlockLen o.k.\n");

	if (!err) diskio_printf("MMC_disk_initialize ok\n");

	return err;
    49a0:	e51b3014 	ldr	r3, [fp, #-20]
}
    49a4:	e1a00003 	mov	r0, r3
    49a8:	e24bd00c 	sub	sp, fp, #12	; 0xc
    49ac:	e89da800 	ldm	sp, {fp, sp, pc}
    49b0:	40000050 	.word	0x40000050
    49b4:	40000710 	.word	0x40000710

000049b8 <disk_initialize>:
/* Initialize a Drive                                                    */

DSTATUS disk_initialize (
	BYTE drv				/* Physical drive nmuber (0..) */
)
{
    49b8:	e1a0c00d 	mov	ip, sp
    49bc:	e92dd800 	push	{fp, ip, lr, pc}
    49c0:	e24cb004 	sub	fp, ip, #4	; 0x4
    49c4:	e24dd00c 	sub	sp, sp, #12	; 0xc
    49c8:	e1a03000 	mov	r3, r0
    49cc:	e54b3010 	strb	r3, [fp, #-16]
	if ( drv != 0 ) return STA_NOINIT;
    49d0:	e55b3010 	ldrb	r3, [fp, #-16]
    49d4:	e3530000 	cmp	r3, #0	; 0x0
    49d8:	0a000002 	beq	49e8 <disk_initialize+0x30>
    49dc:	e3a03001 	mov	r3, #1	; 0x1
    49e0:	e50b3018 	str	r3, [fp, #-24]
    49e4:	ea000032 	b	4ab4 <disk_initialize+0xfc>
	if ( MCI_disk_initialize() ) {
    49e8:	ebffff2e 	bl	46a8 <MCI_disk_initialize>
    49ec:	e1a03000 	mov	r3, r0
    49f0:	e3530000 	cmp	r3, #0	; 0x0
    49f4:	0a000008 	beq	4a1c <disk_initialize+0x64>
		// error occured 
		diskio_printf("mci error\n");
		Stat |= STA_NOINIT;
    49f8:	e59f30c4 	ldr	r3, [pc, #196]	; 4ac4 <disk_initialize+0x10c>
    49fc:	e5d33000 	ldrb	r3, [r3]
    4a00:	e20330ff 	and	r3, r3, #255	; 0xff
    4a04:	e3833001 	orr	r3, r3, #1	; 0x1
    4a08:	e20330ff 	and	r3, r3, #255	; 0xff
    4a0c:	e59f20b0 	ldr	r2, [pc, #176]	; 4ac4 <disk_initialize+0x10c>
    4a10:	e5c23000 	strb	r3, [r2]
		power_off();
    4a14:	ebfffed2 	bl	4564 <power_off>
    4a18:	ea000021 	b	4aa4 <disk_initialize+0xec>
	}
	else {
		Stat &= ~STA_NOINIT;
    4a1c:	e59f30a0 	ldr	r3, [pc, #160]	; 4ac4 <disk_initialize+0x10c>
    4a20:	e5d33000 	ldrb	r3, [r3]
    4a24:	e20330ff 	and	r3, r3, #255	; 0xff
    4a28:	e20330fe 	and	r3, r3, #254	; 0xfe
    4a2c:	e59f2090 	ldr	r2, [pc, #144]	; 4ac4 <disk_initialize+0x10c>
    4a30:	e5c23000 	strb	r3, [r2]
		// cardtype mci.h to chan cardtype - (maybe redundant)
		switch ( MCI_CardType ) {
    4a34:	e59f308c 	ldr	r3, [pc, #140]	; 4ac8 <disk_initialize+0x110>
    4a38:	e5933000 	ldr	r3, [r3]
    4a3c:	e50b3014 	str	r3, [fp, #-20]
    4a40:	e51b3014 	ldr	r3, [fp, #-20]
    4a44:	e3530002 	cmp	r3, #2	; 0x2
    4a48:	0a00000e 	beq	4a88 <disk_initialize+0xd0>
    4a4c:	e51b3014 	ldr	r3, [fp, #-20]
    4a50:	e3530004 	cmp	r3, #4	; 0x4
    4a54:	0a000003 	beq	4a68 <disk_initialize+0xb0>
    4a58:	e51b3014 	ldr	r3, [fp, #-20]
    4a5c:	e3530001 	cmp	r3, #1	; 0x1
    4a60:	0a000004 	beq	4a78 <disk_initialize+0xc0>
    4a64:	ea00000b 	b	4a98 <disk_initialize+0xe0>
		case SDHC_CARD :
			CardType = 4;
    4a68:	e59f205c 	ldr	r2, [pc, #92]	; 4acc <disk_initialize+0x114>
    4a6c:	e3a03004 	mov	r3, #4	; 0x4
    4a70:	e5823000 	str	r3, [r2]
    4a74:	ea00000a 	b	4aa4 <disk_initialize+0xec>
			break;
		case MMC_CARD :
			CardType = 1;
    4a78:	e59f204c 	ldr	r2, [pc, #76]	; 4acc <disk_initialize+0x114>
    4a7c:	e3a03001 	mov	r3, #1	; 0x1
    4a80:	e5823000 	str	r3, [r2]
    4a84:	ea000006 	b	4aa4 <disk_initialize+0xec>
			break;
		case SD_CARD :
			CardType = 2;
    4a88:	e59f203c 	ldr	r2, [pc, #60]	; 4acc <disk_initialize+0x114>
    4a8c:	e3a03002 	mov	r3, #2	; 0x2
    4a90:	e5823000 	str	r3, [r2]
    4a94:	ea000002 	b	4aa4 <disk_initialize+0xec>
			break;
		default :
			CardType = 0;
    4a98:	e59f202c 	ldr	r2, [pc, #44]	; 4acc <disk_initialize+0x114>
    4a9c:	e3a03000 	mov	r3, #0	; 0x0
    4aa0:	e5823000 	str	r3, [r2]
		}
	}
	
	return Stat;
    4aa4:	e59f3018 	ldr	r3, [pc, #24]	; 4ac4 <disk_initialize+0x10c>
    4aa8:	e5d33000 	ldrb	r3, [r3]
    4aac:	e20330ff 	and	r3, r3, #255	; 0xff
    4ab0:	e50b3018 	str	r3, [fp, #-24]
    4ab4:	e51b3018 	ldr	r3, [fp, #-24]
}
    4ab8:	e1a00003 	mov	r0, r3
    4abc:	e24bd00c 	sub	sp, fp, #12	; 0xc
    4ac0:	e89da800 	ldm	sp, {fp, sp, pc}
    4ac4:	40000000 	.word	0x40000000
    4ac8:	40000050 	.word	0x40000050
    4acc:	4000070c 	.word	0x4000070c

00004ad0 <disk_status>:
/* Return Disk Status                                                    */

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0..) */
)
{
    4ad0:	e1a0c00d 	mov	ip, sp
    4ad4:	e92dd800 	push	{fp, ip, lr, pc}
    4ad8:	e24cb004 	sub	fp, ip, #4	; 0x4
    4adc:	e24dd008 	sub	sp, sp, #8	; 0x8
    4ae0:	e1a03000 	mov	r3, r0
    4ae4:	e54b3010 	strb	r3, [fp, #-16]
	if ( drv != 0 ) return STA_NOINIT;
    4ae8:	e55b3010 	ldrb	r3, [fp, #-16]
    4aec:	e3530000 	cmp	r3, #0	; 0x0
    4af0:	0a000002 	beq	4b00 <disk_status+0x30>
    4af4:	e3a03001 	mov	r3, #1	; 0x1
    4af8:	e50b3014 	str	r3, [fp, #-20]
    4afc:	ea000003 	b	4b10 <disk_status+0x40>

	return Stat;
    4b00:	e59f3018 	ldr	r3, [pc, #24]	; 4b20 <disk_status+0x50>
    4b04:	e5d33000 	ldrb	r3, [r3]
    4b08:	e20330ff 	and	r3, r3, #255	; 0xff
    4b0c:	e50b3014 	str	r3, [fp, #-20]
    4b10:	e51b3014 	ldr	r3, [fp, #-20]
}
    4b14:	e1a00003 	mov	r0, r3
    4b18:	e24bd00c 	sub	sp, fp, #12	; 0xc
    4b1c:	e89da800 	ldm	sp, {fp, sp, pc}
    4b20:	40000000 	.word	0x40000000

00004b24 <disk_read>:
	BYTE drv,		/* Physical drive number (0..) */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector number (LBA) */
	BYTE count		/* Sector count (1..255) */
)
{
    4b24:	e1a0c00d 	mov	ip, sp
    4b28:	e92dd800 	push	{fp, ip, lr, pc}
    4b2c:	e24cb004 	sub	fp, ip, #4	; 0x4
    4b30:	e24dd014 	sub	sp, sp, #20	; 0x14
    4b34:	e50b1014 	str	r1, [fp, #-20]
    4b38:	e50b2018 	str	r2, [fp, #-24]
    4b3c:	e1a02003 	mov	r2, r3
    4b40:	e1a03000 	mov	r3, r0
    4b44:	e54b3010 	strb	r3, [fp, #-16]
    4b48:	e1a03002 	mov	r3, r2
    4b4c:	e54b301c 	strb	r3, [fp, #-28]
	// DRESULT res;
	//WORD k;

	if (drv || !count) return RES_PARERR;
    4b50:	e55b3010 	ldrb	r3, [fp, #-16]
    4b54:	e3530000 	cmp	r3, #0	; 0x0
    4b58:	1a000002 	bne	4b68 <disk_read+0x44>
    4b5c:	e55b301c 	ldrb	r3, [fp, #-28]
    4b60:	e3530000 	cmp	r3, #0	; 0x0
    4b64:	1a000002 	bne	4b74 <disk_read+0x50>
    4b68:	e3a03004 	mov	r3, #4	; 0x4
    4b6c:	e50b3020 	str	r3, [fp, #-32]
    4b70:	ea00002c 	b	4c28 <disk_read+0x104>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
    4b74:	e59f30bc 	ldr	r3, [pc, #188]	; 4c38 <disk_read+0x114>
    4b78:	e5d33000 	ldrb	r3, [r3]
    4b7c:	e20330ff 	and	r3, r3, #255	; 0xff
    4b80:	e2033001 	and	r3, r3, #1	; 0x1
    4b84:	e20330ff 	and	r3, r3, #255	; 0xff
    4b88:	e3530000 	cmp	r3, #0	; 0x0
    4b8c:	0a000002 	beq	4b9c <disk_read+0x78>
    4b90:	e3a03003 	mov	r3, #3	; 0x3
    4b94:	e50b3020 	str	r3, [fp, #-32]
    4b98:	ea000022 	b	4c28 <disk_read+0x104>

	// done in MCI driver if (!(CardType & 4)) sector *= 512;	/* Convert to byte address if needed */

	/* Select the card and wait for ready */
	/* mthomas - not sure if this is needed for SD */
	DESELECT();
    4b9c:	ebfffe0e 	bl	43dc <DESELECT>
	//if (wait_ready() != 0xFF) return (DRESULT)(0xFF);
	SELECT();
    4ba0:	ebfffde3 	bl	4334 <SELECT>

	// TODO: Multi-block
	do {
		diskio_printfr("Read_Block start...\n");
		if ( MCI_Read_Block( sector ) != TRUE ) {
    4ba4:	e51b0018 	ldr	r0, [fp, #-24]
    4ba8:	eb000a5b 	bl	751c <MCI_Read_Block>
    4bac:	e1a03000 	mov	r3, r0
    4bb0:	e3530001 	cmp	r3, #1	; 0x1
    4bb4:	1a000015 	bne	4c10 <disk_read+0xec>
		}
		else {
			
			diskio_printfr("Read_Block wait...\n");
			/* When MCI_Block_End_Flag is clear, it indicates RX is done */
			while ( MCI_Block_End_Flag == 1 ) { ; }
    4bb8:	e59f307c 	ldr	r3, [pc, #124]	; 4c3c <disk_read+0x118>
    4bbc:	e5933000 	ldr	r3, [r3]
    4bc0:	e3530001 	cmp	r3, #1	; 0x1
    4bc4:	0afffffb 	beq	4bb8 <disk_read+0x94>
			diskio_printfr("Read_Block end wait\n");
			// laebi: memcpy is faster than the for-Loop
			// TODO: avoid copy
			memcpy(buff, ReadBlock, 512);
    4bc8:	e59f3070 	ldr	r3, [pc, #112]	; 4c40 <disk_read+0x11c>
    4bcc:	e5933000 	ldr	r3, [r3]
    4bd0:	e51b0014 	ldr	r0, [fp, #-20]
    4bd4:	e1a01003 	mov	r1, r3
    4bd8:	e3a02c02 	mov	r2, #512	; 0x200
    4bdc:	eb00115b 	bl	9150 <memcpy>
			// mziegert 20090823: Bugfix, memcpy does not increase buff pointer
			buff = &buff[512];
    4be0:	e51b3014 	ldr	r3, [fp, #-20]
    4be4:	e2833c02 	add	r3, r3, #512	; 0x200
    4be8:	e50b3014 	str	r3, [fp, #-20]
			sector++;
    4bec:	e51b3018 	ldr	r3, [fp, #-24]
    4bf0:	e2833001 	add	r3, r3, #1	; 0x1
    4bf4:	e50b3018 	str	r3, [fp, #-24]
		}
	} while ( --count );
    4bf8:	e55b301c 	ldrb	r3, [fp, #-28]
    4bfc:	e2433001 	sub	r3, r3, #1	; 0x1
    4c00:	e54b301c 	strb	r3, [fp, #-28]
    4c04:	e55b301c 	ldrb	r3, [fp, #-28]
    4c08:	e3530000 	cmp	r3, #0	; 0x0
    4c0c:	1affffe4 	bne	4ba4 <disk_read+0x80>
	
	release_spi();
    4c10:	ebfffe4e 	bl	4550 <release_spi>

	return count ? RES_ERROR : RES_OK;
    4c14:	e55b301c 	ldrb	r3, [fp, #-28]
    4c18:	e3530000 	cmp	r3, #0	; 0x0
    4c1c:	03a03000 	moveq	r3, #0	; 0x0
    4c20:	13a03001 	movne	r3, #1	; 0x1
    4c24:	e50b3020 	str	r3, [fp, #-32]
    4c28:	e51b3020 	ldr	r3, [fp, #-32]
}
    4c2c:	e1a00003 	mov	r0, r3
    4c30:	e24bd00c 	sub	sp, fp, #12	; 0xc
    4c34:	e89da800 	ldm	sp, {fp, sp, pc}
    4c38:	40000000 	.word	0x40000000
    4c3c:	40000770 	.word	0x40000770
    4c40:	40000008 	.word	0x40000008

00004c44 <disk_write>:
	BYTE drv,			/* Physical drive number (0..) */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
    4c44:	e1a0c00d 	mov	ip, sp
    4c48:	e92dd800 	push	{fp, ip, lr, pc}
    4c4c:	e24cb004 	sub	fp, ip, #4	; 0x4
    4c50:	e24dd014 	sub	sp, sp, #20	; 0x14
    4c54:	e50b1014 	str	r1, [fp, #-20]
    4c58:	e50b2018 	str	r2, [fp, #-24]
    4c5c:	e1a02003 	mov	r2, r3
    4c60:	e1a03000 	mov	r3, r0
    4c64:	e54b3010 	strb	r3, [fp, #-16]
    4c68:	e1a03002 	mov	r3, r2
    4c6c:	e54b301c 	strb	r3, [fp, #-28]
	//WORD k;

	if (drv || !count)
    4c70:	e55b3010 	ldrb	r3, [fp, #-16]
    4c74:	e3530000 	cmp	r3, #0	; 0x0
    4c78:	1a000002 	bne	4c88 <disk_write+0x44>
    4c7c:	e55b301c 	ldrb	r3, [fp, #-28]
    4c80:	e3530000 	cmp	r3, #0	; 0x0
    4c84:	1a000002 	bne	4c94 <disk_write+0x50>
		return RES_PARERR;
    4c88:	e3a03004 	mov	r3, #4	; 0x4
    4c8c:	e50b3020 	str	r3, [fp, #-32]
    4c90:	ea00003b 	b	4d84 <disk_write+0x140>
	if (Stat & STA_NOINIT)
    4c94:	e59f30f8 	ldr	r3, [pc, #248]	; 4d94 <disk_write+0x150>
    4c98:	e5d33000 	ldrb	r3, [r3]
    4c9c:	e20330ff 	and	r3, r3, #255	; 0xff
    4ca0:	e2033001 	and	r3, r3, #1	; 0x1
    4ca4:	e20330ff 	and	r3, r3, #255	; 0xff
    4ca8:	e3530000 	cmp	r3, #0	; 0x0
    4cac:	0a000002 	beq	4cbc <disk_write+0x78>
		return RES_NOTRDY;
    4cb0:	e3a03003 	mov	r3, #3	; 0x3
    4cb4:	e50b3020 	str	r3, [fp, #-32]
    4cb8:	ea000031 	b	4d84 <disk_write+0x140>
	if (Stat & STA_PROTECT)
    4cbc:	e59f30d0 	ldr	r3, [pc, #208]	; 4d94 <disk_write+0x150>
    4cc0:	e5d33000 	ldrb	r3, [r3]
    4cc4:	e20330ff 	and	r3, r3, #255	; 0xff
    4cc8:	e2033004 	and	r3, r3, #4	; 0x4
    4ccc:	e3530000 	cmp	r3, #0	; 0x0
    4cd0:	0a000002 	beq	4ce0 <disk_write+0x9c>
		return RES_WRPRT;
    4cd4:	e3a03002 	mov	r3, #2	; 0x2
    4cd8:	e50b3020 	str	r3, [fp, #-32]
    4cdc:	ea000028 	b	4d84 <disk_write+0x140>

	// done in mci-driver: if (!(CardType & 4)) sector *= 512;	/* Convert to byte address if needed */

	/* Select the card and wait for ready */
	/* mthomas - not sure if this is needed for SD */
	DESELECT();
    4ce0:	ebfffdbd 	bl	43dc <DESELECT>
	//if (wait_ready() != 0xFF) return (DRESULT)0xFF;
	SELECT();
    4ce4:	ebfffd92 	bl	4334 <SELECT>

	//do {
	diskio_printfw("Write_Block %d start...\n", sector );
	if (count > 1) {
    4ce8:	e55b301c 	ldrb	r3, [fp, #-28]
    4cec:	e3530001 	cmp	r3, #1	; 0x1
    4cf0:	9a00000f 	bls	4d34 <disk_write+0xf0>
		// Multi Block Write
		if (MCI_Write_Multiple_Block(sector, count, buff) != TRUE) {
    4cf4:	e55b301c 	ldrb	r3, [fp, #-28]
    4cf8:	e51b0018 	ldr	r0, [fp, #-24]
    4cfc:	e1a01003 	mov	r1, r3
    4d00:	e51b2014 	ldr	r2, [fp, #-20]
    4d04:	eb000974 	bl	72dc <MCI_Write_Multiple_Block>
    4d08:	e1a03000 	mov	r3, r0
    4d0c:	e3530001 	cmp	r3, #1	; 0x1
    4d10:	0a000002 	beq	4d20 <disk_write+0xdc>
			diskio_printf("MCI_Write_Multiple_Block failed\n");
			return RES_ERROR;
    4d14:	e3a03001 	mov	r3, #1	; 0x1
    4d18:	e50b3020 	str	r3, [fp, #-32]
    4d1c:	ea000018 	b	4d84 <disk_write+0x140>
			//break;
		} else {
			diskio_printfw("Write_Block Multi wait...\n");
			/* When MCI_Block_End_Flag is clear, it indicates TX is done */
			while (MCI_Block_End_Flag == 1) {
    4d20:	e59f3070 	ldr	r3, [pc, #112]	; 4d98 <disk_write+0x154>
    4d24:	e5933000 	ldr	r3, [r3]
    4d28:	e3530001 	cmp	r3, #1	; 0x1
    4d2c:	0afffffb 	beq	4d20 <disk_write+0xdc>
    4d30:	ea000011 	b	4d7c <disk_write+0x138>
			diskio_printfw("Write_Block Multi end wait\n");
		}
	} else {
		// Single Block write
		// TODO: avoid copy
		memcpy(WriteBlock, buff, 512);
    4d34:	e59f3060 	ldr	r3, [pc, #96]	; 4d9c <disk_write+0x158>
    4d38:	e5933000 	ldr	r3, [r3]
    4d3c:	e1a00003 	mov	r0, r3
    4d40:	e51b1014 	ldr	r1, [fp, #-20]
    4d44:	e3a02c02 	mov	r2, #512	; 0x200
    4d48:	eb001100 	bl	9150 <memcpy>
		if (MCI_Write_Block(sector) != TRUE) {
    4d4c:	e51b0018 	ldr	r0, [fp, #-24]
    4d50:	eb000905 	bl	716c <MCI_Write_Block>
    4d54:	e1a03000 	mov	r3, r0
    4d58:	e3530001 	cmp	r3, #1	; 0x1
    4d5c:	0a000002 	beq	4d6c <disk_write+0x128>
			diskio_printf("MCI_Write_Block failed\n");
			return RES_ERROR;
    4d60:	e3a03001 	mov	r3, #1	; 0x1
    4d64:	e50b3020 	str	r3, [fp, #-32]
    4d68:	ea000005 	b	4d84 <disk_write+0x140>
			//break;
		} else {
			diskio_printfw("Write_Block wait...\n");
			/* When MCI_Block_End_Flag is clear, it indicates TX is done */
			while (MCI_Block_End_Flag == 1) {
    4d6c:	e59f3024 	ldr	r3, [pc, #36]	; 4d98 <disk_write+0x154>
    4d70:	e5933000 	ldr	r3, [r3]
    4d74:	e3530001 	cmp	r3, #1	; 0x1
    4d78:	0afffffb 	beq	4d6c <disk_write+0x128>

	// laebi: not necessary
	//release_spi();

	//return count ? RES_ERROR : RES_OK;
	return RES_OK;
    4d7c:	e3a03000 	mov	r3, #0	; 0x0
    4d80:	e50b3020 	str	r3, [fp, #-32]
    4d84:	e51b3020 	ldr	r3, [fp, #-32]
}
    4d88:	e1a00003 	mov	r0, r3
    4d8c:	e24bd00c 	sub	sp, fp, #12	; 0xc
    4d90:	e89da800 	ldm	sp, {fp, sp, pc}
    4d94:	40000000 	.word	0x40000000
    4d98:	40000770 	.word	0x40000770
    4d9c:	40000004 	.word	0x40000004

00004da0 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0..) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
    4da0:	e1a0c00d 	mov	ip, sp
    4da4:	e92dd800 	push	{fp, ip, lr, pc}
    4da8:	e24cb004 	sub	fp, ip, #4	; 0x4
    4dac:	e24dd01c 	sub	sp, sp, #28	; 0x1c
    4db0:	e1a03000 	mov	r3, r0
    4db4:	e50b2024 	str	r2, [fp, #-36]
    4db8:	e54b301c 	strb	r3, [fp, #-28]
    4dbc:	e1a03001 	mov	r3, r1
    4dc0:	e54b3020 	strb	r3, [fp, #-32]
	DRESULT res;
	BYTE n; // buffered csd[16];
	DWORD csize;

	if (drv) return RES_PARERR;
    4dc4:	e55b301c 	ldrb	r3, [fp, #-28]
    4dc8:	e3530000 	cmp	r3, #0	; 0x0
    4dcc:	0a000002 	beq	4ddc <disk_ioctl+0x3c>
    4dd0:	e3a03004 	mov	r3, #4	; 0x4
    4dd4:	e50b3028 	str	r3, [fp, #-40]
    4dd8:	ea0000a6 	b	5078 <disk_ioctl+0x2d8>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
    4ddc:	e59f32a4 	ldr	r3, [pc, #676]	; 5088 <disk_ioctl+0x2e8>
    4de0:	e5d33000 	ldrb	r3, [r3]
    4de4:	e20330ff 	and	r3, r3, #255	; 0xff
    4de8:	e2033001 	and	r3, r3, #1	; 0x1
    4dec:	e20330ff 	and	r3, r3, #255	; 0xff
    4df0:	e3530000 	cmp	r3, #0	; 0x0
    4df4:	0a000002 	beq	4e04 <disk_ioctl+0x64>
    4df8:	e3a03003 	mov	r3, #3	; 0x3
    4dfc:	e50b3028 	str	r3, [fp, #-40]
    4e00:	ea00009c 	b	5078 <disk_ioctl+0x2d8>

	res = RES_ERROR;
    4e04:	e3a03001 	mov	r3, #1	; 0x1
    4e08:	e50b3018 	str	r3, [fp, #-24]

	switch (ctrl) {
    4e0c:	e55b3020 	ldrb	r3, [fp, #-32]
    4e10:	e3530003 	cmp	r3, #3	; 0x3
    4e14:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    4e18:	ea000091 	b	5064 <disk_ioctl+0x2c4>
    4e1c:	00004e2c 	.word	0x00004e2c
    4e20:	00004e64 	.word	0x00004e64
    4e24:	00004e4c 	.word	0x00004e4c
    4e28:	00004f64 	.word	0x00004f64

		case CTRL_SYNC :	/* Flush dirty buffer if present */
			SELECT();
    4e2c:	ebfffd40 	bl	4334 <SELECT>
			if (wait_ready() == 0xFF) {
    4e30:	ebfffd96 	bl	4490 <wait_ready>
    4e34:	e1a03000 	mov	r3, r0
    4e38:	e35300ff 	cmp	r3, #255	; 0xff
    4e3c:	1a00008a 	bne	506c <disk_ioctl+0x2cc>
				res = RES_OK;
    4e40:	e3a03000 	mov	r3, #0	; 0x0
    4e44:	e50b3018 	str	r3, [fp, #-24]
    4e48:	ea000087 	b	506c <disk_ioctl+0x2cc>
			}
			break;

		case GET_SECTOR_SIZE :	/* Get sectors on the disk (WORD) */
			*(WORD*)buff = 512;
    4e4c:	e51b2024 	ldr	r2, [fp, #-36]
    4e50:	e3a03c02 	mov	r3, #512	; 0x200
    4e54:	e1c230b0 	strh	r3, [r2]
			res = RES_OK;
    4e58:	e3a03000 	mov	r3, #0	; 0x0
    4e5c:	e50b3018 	str	r3, [fp, #-24]
    4e60:	ea000081 	b	506c <disk_ioctl+0x2cc>
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (WORD) */
			if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
    4e64:	e59f3220 	ldr	r3, [pc, #544]	; 508c <disk_ioctl+0x2ec>
    4e68:	e5d33000 	ldrb	r3, [r3]
    4e6c:	e1a03323 	lsr	r3, r3, #6
    4e70:	e20330ff 	and	r3, r3, #255	; 0xff
    4e74:	e3530001 	cmp	r3, #1	; 0x1
    4e78:	1a00000d 	bne	4eb4 <disk_ioctl+0x114>
				csize = csd[9] + ((WORD)csd[8] << 8) + 1;
    4e7c:	e59f3208 	ldr	r3, [pc, #520]	; 508c <disk_ioctl+0x2ec>
    4e80:	e5d33009 	ldrb	r3, [r3, #9]
    4e84:	e1a02003 	mov	r2, r3
    4e88:	e59f31fc 	ldr	r3, [pc, #508]	; 508c <disk_ioctl+0x2ec>
    4e8c:	e5d33008 	ldrb	r3, [r3, #8]
    4e90:	e1a03403 	lsl	r3, r3, #8
    4e94:	e0823003 	add	r3, r2, r3
    4e98:	e2833001 	add	r3, r3, #1	; 0x1
    4e9c:	e50b3010 	str	r3, [fp, #-16]
				*(DWORD*)buff = (DWORD)csize << 10;
    4ea0:	e51b2024 	ldr	r2, [fp, #-36]
    4ea4:	e51b3010 	ldr	r3, [fp, #-16]
    4ea8:	e1a03503 	lsl	r3, r3, #10
    4eac:	e5823000 	str	r3, [r2]
    4eb0:	ea000028 	b	4f58 <disk_ioctl+0x1b8>
			} 
			else {					/* MMC or SDC ver 1.XX */
				n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
    4eb4:	e59f31d0 	ldr	r3, [pc, #464]	; 508c <disk_ioctl+0x2ec>
    4eb8:	e5d33005 	ldrb	r3, [r3, #5]
    4ebc:	e1a02003 	mov	r2, r3
    4ec0:	e202200f 	and	r2, r2, #15	; 0xf
    4ec4:	e59f31c0 	ldr	r3, [pc, #448]	; 508c <disk_ioctl+0x2ec>
    4ec8:	e5d3300a 	ldrb	r3, [r3, #10]
    4ecc:	e1a033a3 	lsr	r3, r3, #7
    4ed0:	e20330ff 	and	r3, r3, #255	; 0xff
    4ed4:	e0823003 	add	r3, r2, r3
    4ed8:	e20320ff 	and	r2, r3, #255	; 0xff
    4edc:	e59f31a8 	ldr	r3, [pc, #424]	; 508c <disk_ioctl+0x2ec>
    4ee0:	e5d33009 	ldrb	r3, [r3, #9]
    4ee4:	e2033003 	and	r3, r3, #3	; 0x3
    4ee8:	e1a03083 	lsl	r3, r3, #1
    4eec:	e20330ff 	and	r3, r3, #255	; 0xff
    4ef0:	e0823003 	add	r3, r2, r3
    4ef4:	e20330ff 	and	r3, r3, #255	; 0xff
    4ef8:	e2833002 	add	r3, r3, #2	; 0x2
    4efc:	e54b3011 	strb	r3, [fp, #-17]
				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
    4f00:	e59f3184 	ldr	r3, [pc, #388]	; 508c <disk_ioctl+0x2ec>
    4f04:	e5d33008 	ldrb	r3, [r3, #8]
    4f08:	e1a03323 	lsr	r3, r3, #6
    4f0c:	e20330ff 	and	r3, r3, #255	; 0xff
    4f10:	e1a02003 	mov	r2, r3
    4f14:	e59f3170 	ldr	r3, [pc, #368]	; 508c <disk_ioctl+0x2ec>
    4f18:	e5d33007 	ldrb	r3, [r3, #7]
    4f1c:	e1a03103 	lsl	r3, r3, #2
    4f20:	e0822003 	add	r2, r2, r3
    4f24:	e59f3160 	ldr	r3, [pc, #352]	; 508c <disk_ioctl+0x2ec>
    4f28:	e5d33006 	ldrb	r3, [r3, #6]
    4f2c:	e2033003 	and	r3, r3, #3	; 0x3
    4f30:	e1a03503 	lsl	r3, r3, #10
    4f34:	e0823003 	add	r3, r2, r3
    4f38:	e2833001 	add	r3, r3, #1	; 0x1
    4f3c:	e50b3010 	str	r3, [fp, #-16]
				*(DWORD*)buff = (DWORD)csize << (n - 9);
    4f40:	e51b1024 	ldr	r1, [fp, #-36]
    4f44:	e55b3011 	ldrb	r3, [fp, #-17]
    4f48:	e2432009 	sub	r2, r3, #9	; 0x9
    4f4c:	e51b3010 	ldr	r3, [fp, #-16]
    4f50:	e1a03213 	lsl	r3, r3, r2
    4f54:	e5813000 	str	r3, [r1]
			}
			res = RES_OK;
    4f58:	e3a03000 	mov	r3, #0	; 0x0
    4f5c:	e50b3018 	str	r3, [fp, #-24]
    4f60:	ea000041 	b	506c <disk_ioctl+0x2cc>
			break;

		
		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sectors (DWORD) */
			if (CardType & 4) {   /* SDC ver 2.00 - use cached  Read SD status */
    4f64:	e59f3124 	ldr	r3, [pc, #292]	; 5090 <disk_ioctl+0x2f0>
    4f68:	e5933000 	ldr	r3, [r3]
    4f6c:	e2033004 	and	r3, r3, #4	; 0x4
    4f70:	e3530000 	cmp	r3, #0	; 0x0
    4f74:	0a00000b 	beq	4fa8 <disk_ioctl+0x208>
				// TODO - untested!
				*(DWORD*)buff = 16UL << (sd_status[10] >> 4);
    4f78:	e51b1024 	ldr	r1, [fp, #-36]
    4f7c:	e59f3110 	ldr	r3, [pc, #272]	; 5094 <disk_ioctl+0x2f4>
    4f80:	e5d3300a 	ldrb	r3, [r3, #10]
    4f84:	e1a03223 	lsr	r3, r3, #4
    4f88:	e20330ff 	and	r3, r3, #255	; 0xff
    4f8c:	e1a02003 	mov	r2, r3
    4f90:	e3a03010 	mov	r3, #16	; 0x10
    4f94:	e1a03213 	lsl	r3, r3, r2
    4f98:	e5813000 	str	r3, [r1]
				res = RES_OK;
    4f9c:	e3a03000 	mov	r3, #0	; 0x0
    4fa0:	e50b3018 	str	r3, [fp, #-24]
    4fa4:	ea000030 	b	506c <disk_ioctl+0x2cc>
			} 
			else {   /* SDC ver 1.XX or MMC */
				if (CardType & 2) {			/* SDC ver 1.XX */
    4fa8:	e59f30e0 	ldr	r3, [pc, #224]	; 5090 <disk_ioctl+0x2f0>
    4fac:	e5933000 	ldr	r3, [r3]
    4fb0:	e2033002 	and	r3, r3, #2	; 0x2
    4fb4:	e3530000 	cmp	r3, #0	; 0x0
    4fb8:	0a000012 	beq	5008 <disk_ioctl+0x268>
					*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
    4fbc:	e51b1024 	ldr	r1, [fp, #-36]
    4fc0:	e59f30c4 	ldr	r3, [pc, #196]	; 508c <disk_ioctl+0x2ec>
    4fc4:	e5d3300a 	ldrb	r3, [r3, #10]
    4fc8:	e203303f 	and	r3, r3, #63	; 0x3f
    4fcc:	e1a02083 	lsl	r2, r3, #1
    4fd0:	e59f30b4 	ldr	r3, [pc, #180]	; 508c <disk_ioctl+0x2ec>
    4fd4:	e5d3300b 	ldrb	r3, [r3, #11]
    4fd8:	e1a033a3 	lsr	r3, r3, #7
    4fdc:	e20330ff 	and	r3, r3, #255	; 0xff
    4fe0:	e0823003 	add	r3, r2, r3
    4fe4:	e2832001 	add	r2, r3, #1	; 0x1
    4fe8:	e59f309c 	ldr	r3, [pc, #156]	; 508c <disk_ioctl+0x2ec>
    4fec:	e5d3300d 	ldrb	r3, [r3, #13]
    4ff0:	e1a03323 	lsr	r3, r3, #6
    4ff4:	e20330ff 	and	r3, r3, #255	; 0xff
    4ff8:	e2433001 	sub	r3, r3, #1	; 0x1
    4ffc:	e1a03312 	lsl	r3, r2, r3
    5000:	e5813000 	str	r3, [r1]
    5004:	ea000013 	b	5058 <disk_ioctl+0x2b8>
				} else {					/* MMC */
					*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
    5008:	e51b1024 	ldr	r1, [fp, #-36]
    500c:	e59f3078 	ldr	r3, [pc, #120]	; 508c <disk_ioctl+0x2ec>
    5010:	e5d3300a 	ldrb	r3, [r3, #10]
    5014:	e203307c 	and	r3, r3, #124	; 0x7c
    5018:	e1a03143 	asr	r3, r3, #2
    501c:	e1a03803 	lsl	r3, r3, #16
    5020:	e1a03823 	lsr	r3, r3, #16
    5024:	e2830001 	add	r0, r3, #1	; 0x1
    5028:	e59f305c 	ldr	r3, [pc, #92]	; 508c <disk_ioctl+0x2ec>
    502c:	e5d3300b 	ldrb	r3, [r3, #11]
    5030:	e2033003 	and	r3, r3, #3	; 0x3
    5034:	e1a02183 	lsl	r2, r3, #3
    5038:	e59f304c 	ldr	r3, [pc, #76]	; 508c <disk_ioctl+0x2ec>
    503c:	e5d3300b 	ldrb	r3, [r3, #11]
    5040:	e1a032a3 	lsr	r3, r3, #5
    5044:	e20330ff 	and	r3, r3, #255	; 0xff
    5048:	e0823003 	add	r3, r2, r3
    504c:	e2833001 	add	r3, r3, #1	; 0x1
    5050:	e0030390 	mul	r3, r0, r3
    5054:	e5813000 	str	r3, [r1]
				}
				res = RES_OK;
    5058:	e3a03000 	mov	r3, #0	; 0x0
    505c:	e50b3018 	str	r3, [fp, #-24]
    5060:	ea000001 	b	506c <disk_ioctl+0x2cc>
			}
			break;

		default:
			res = RES_PARERR;
    5064:	e3a03004 	mov	r3, #4	; 0x4
    5068:	e50b3018 	str	r3, [fp, #-24]
	}

	release_spi(); 
    506c:	ebfffd37 	bl	4550 <release_spi>

	return res;
    5070:	e51b3018 	ldr	r3, [fp, #-24]
    5074:	e50b3028 	str	r3, [fp, #-40]
    5078:	e51b3028 	ldr	r3, [fp, #-40]
}
    507c:	e1a00003 	mov	r0, r3
    5080:	e24bd00c 	sub	sp, fp, #12	; 0xc
    5084:	e89da800 	ldm	sp, {fp, sp, pc}
    5088:	40000000 	.word	0x40000000
    508c:	40000710 	.word	0x40000710
    5090:	4000070c 	.word	0x4000070c
    5094:	40000720 	.word	0x40000720

00005098 <get_fattime>:
#include "type.h"
#include "rtc.h"

DWORD get_fattime (void); /* avoid warning */
DWORD get_fattime (void)
{
    5098:	e1a0c00d 	mov	ip, sp
    509c:	e92dd800 	push	{fp, ip, lr, pc}
    50a0:	e24cb004 	sub	fp, ip, #4	; 0x4
    50a4:	e24dd024 	sub	sp, sp, #36	; 0x24
	RTCTime t;
	DWORD res;

	RTCGetTime( &t );
    50a8:	e24b3030 	sub	r3, fp, #48	; 0x30
    50ac:	e1a00003 	mov	r0, r3
    50b0:	ebffeec2 	bl	bc0 <RTCGetTime>
	res = (
    50b4:	e51b3030 	ldr	r3, [fp, #-48]
    50b8:	e1a020a3 	lsr	r2, r3, #1
    50bc:	e51b302c 	ldr	r3, [fp, #-44]
    50c0:	e1a03283 	lsl	r3, r3, #5
    50c4:	e1822003 	orr	r2, r2, r3
    50c8:	e51b3028 	ldr	r3, [fp, #-40]
    50cc:	e1a03583 	lsl	r3, r3, #11
    50d0:	e1822003 	orr	r2, r2, r3
    50d4:	e51b3024 	ldr	r3, [fp, #-36]
    50d8:	e1a03803 	lsl	r3, r3, #16
    50dc:	e1822003 	orr	r2, r2, r3
    50e0:	e51b3020 	ldr	r3, [fp, #-32]
    50e4:	e1a03a83 	lsl	r3, r3, #21
    50e8:	e1822003 	orr	r2, r2, r3
    50ec:	e51b301c 	ldr	r3, [fp, #-28]
    50f0:	e2433e7b 	sub	r3, r3, #1968	; 0x7b0
    50f4:	e243300c 	sub	r3, r3, #12	; 0xc
    50f8:	e1a03c83 	lsl	r3, r3, #25
    50fc:	e1823003 	orr	r3, r2, r3
    5100:	e50b3010 	str	r3, [fp, #-16]
		(( t.RTC_Mday )        << 16UL ) |
		(( t.RTC_Mon )         << 21UL ) |
		(( t.RTC_Year-1980 )   << 25UL )
	);

	return res;
    5104:	e51b3010 	ldr	r3, [fp, #-16]
}
    5108:	e1a00003 	mov	r0, r3
    510c:	e24bd00c 	sub	sp, fp, #12	; 0xc
    5110:	e89da800 	ldm	sp, {fp, sp, pc}

00005114 <MCI_TXEnable>:
 **
 ** parameters:			None
 ** Returned value:		None
 ** 
 ******************************************************************************/
void MCI_TXEnable(void) {
    5114:	e1a0c00d 	mov	ip, sp
    5118:	e92dd800 	push	{fp, ip, lr, pc}
    511c:	e24cb004 	sub	fp, ip, #4	; 0x4
#if MCI_DMA_ENABLED
	MCI_MASK0 |= ((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
    5120:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    5124:	e2822923 	add	r2, r2, #573440	; 0x8c000
    5128:	e282203c 	add	r2, r2, #60	; 0x3c
    512c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5130:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5134:	e283303c 	add	r3, r3, #60	; 0x3c
    5138:	e5933000 	ldr	r3, [r3]
    513c:	e3833e71 	orr	r3, r3, #1808	; 0x710
    5140:	e383300a 	orr	r3, r3, #10	; 0xa
    5144:	e5823000 	str	r3, [r2]
	/* Enable TX interrupts only */
	MCI_MASK1 |= ((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
    5148:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    514c:	e2822923 	add	r2, r2, #573440	; 0x8c000
    5150:	e2822040 	add	r2, r2, #64	; 0x40
    5154:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5158:	e2833923 	add	r3, r3, #573440	; 0x8c000
    515c:	e2833040 	add	r3, r3, #64	; 0x40
    5160:	e5933000 	ldr	r3, [r3]
    5164:	e3833e71 	orr	r3, r3, #1808	; 0x710
    5168:	e383300a 	orr	r3, r3, #10	; 0xa
    516c:	e5823000 	str	r3, [r2]
#else
	MCI_MASK0 |= ((FIFO_TX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_TX_INT_MASK)); /* FIFO TX interrupts only */
	MCI_MASK1 |= ((FIFO_TX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_TX_INT_MASK)); /* FIFO TX interrupts only */
#endif
	return;
}
    5170:	e89da800 	ldm	sp, {fp, sp, pc}

00005174 <MCI_TXDisable>:
/*****************************************************************/

void MCI_TXDisable(void) {
    5174:	e1a0c00d 	mov	ip, sp
    5178:	e92dd800 	push	{fp, ip, lr, pc}
    517c:	e24cb004 	sub	fp, ip, #4	; 0x4
#if MCI_DMA_ENABLED
	MCI_MASK0 &= ~((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
    5180:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    5184:	e2822923 	add	r2, r2, #573440	; 0x8c000
    5188:	e282203c 	add	r2, r2, #60	; 0x3c
    518c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5190:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5194:	e283303c 	add	r3, r3, #60	; 0x3c
    5198:	e5933000 	ldr	r3, [r3]
    519c:	e3c33e71 	bic	r3, r3, #1808	; 0x710
    51a0:	e3c3300a 	bic	r3, r3, #10	; 0xa
    51a4:	e5823000 	str	r3, [r2]
	/* Enable TX interrupts only */
	MCI_MASK1 &= ~((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
    51a8:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    51ac:	e2822923 	add	r2, r2, #573440	; 0x8c000
    51b0:	e2822040 	add	r2, r2, #64	; 0x40
    51b4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    51b8:	e2833923 	add	r3, r3, #573440	; 0x8c000
    51bc:	e2833040 	add	r3, r3, #64	; 0x40
    51c0:	e5933000 	ldr	r3, [r3]
    51c4:	e3c33e71 	bic	r3, r3, #1808	; 0x710
    51c8:	e3c3300a 	bic	r3, r3, #10	; 0xa
    51cc:	e5823000 	str	r3, [r2]
#else
	MCI_MASK0 &= ~((FIFO_TX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_TX_INT_MASK)); /* FIFO TX interrupts only */
	MCI_MASK1 &= ~((FIFO_TX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_TX_INT_MASK)); /* FIFO TX interrupts only */
#endif
	return;
}
    51d0:	e89da800 	ldm	sp, {fp, sp, pc}

000051d4 <MCI_RXEnable>:
/*****************************************************************/

void MCI_RXEnable(void) {
    51d4:	e1a0c00d 	mov	ip, sp
    51d8:	e92dd800 	push	{fp, ip, lr, pc}
    51dc:	e24cb004 	sub	fp, ip, #4	; 0x4
	//myprintf("inside MCI_RXEnable");
#if MCI_DMA_ENABLED
	MCI_MASK0 |= ((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));
    51e0:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    51e4:	e2822923 	add	r2, r2, #573440	; 0x8c000
    51e8:	e282203c 	add	r2, r2, #60	; 0x3c
    51ec:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    51f0:	e2833923 	add	r3, r3, #573440	; 0x8c000
    51f4:	e283303c 	add	r3, r3, #60	; 0x3c
    51f8:	e5933000 	ldr	r3, [r3]
    51fc:	e3833e72 	orr	r3, r3, #1824	; 0x720
    5200:	e383300a 	orr	r3, r3, #10	; 0xa
    5204:	e5823000 	str	r3, [r2]
	/* Enable RX interrupts only */
	MCI_MASK1 |= ((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));
    5208:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    520c:	e2822923 	add	r2, r2, #573440	; 0x8c000
    5210:	e2822040 	add	r2, r2, #64	; 0x40
    5214:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5218:	e2833923 	add	r3, r3, #573440	; 0x8c000
    521c:	e2833040 	add	r3, r3, #64	; 0x40
    5220:	e5933000 	ldr	r3, [r3]
    5224:	e3833e72 	orr	r3, r3, #1824	; 0x720
    5228:	e383300a 	orr	r3, r3, #10	; 0xa
    522c:	e5823000 	str	r3, [r2]
#else
	MCI_MASK0 |= ((FIFO_RX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_RX_INT_MASK)); /* FIFO RX interrupts only */
	MCI_MASK1 |= ((FIFO_RX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_RX_INT_MASK)); /* FIFO RX interrupts only */
#endif
	return;
}
    5230:	e89da800 	ldm	sp, {fp, sp, pc}

00005234 <MCI_CheckStatus>:
 **
 ** parameters:			None
 ** Returned value:		TRUE or FALSE
 ** 
 ******************************************************************************/
DWORD MCI_CheckStatus(void) {
    5234:	e1a0c00d 	mov	ip, sp
    5238:	e92dd800 	push	{fp, ip, lr, pc}
    523c:	e24cb004 	sub	fp, ip, #4	; 0x4
    5240:	e24dd008 	sub	sp, sp, #8	; 0x8
	DWORD respValue;

	while ( 1) // mthomas TODO: possible deadlock
	{
		if ( (respValue = MCI_Send_Status()) == INVALID_RESPONSE) {
    5244:	eb00060b 	bl	6a78 <MCI_Send_Status>
    5248:	e1a03000 	mov	r3, r0
    524c:	e50b3010 	str	r3, [fp, #-16]
    5250:	e51b3010 	ldr	r3, [fp, #-16]
    5254:	e3730001 	cmn	r3, #1	; 0x1
    5258:	0a000006 	beq	5278 <MCI_CheckStatus+0x44>
		} else {
			/* The only valid state is TRANS per MMC and SD state diagram.
			 RCV state may be seen, but, I have found that it happens
			 only when TX_ACTIVE or RX_ACTIVE occurs before the WRITE_BLOCK and 
			 READ_BLOCK cmds are being sent, which is not a valid sequence. */
			if ( (respValue & (0x0F << 8)) == 0x0900) {
    525c:	e51b3010 	ldr	r3, [fp, #-16]
    5260:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    5264:	e3530c09 	cmp	r3, #2304	; 0x900
    5268:	1afffff5 	bne	5244 <MCI_CheckStatus+0x10>
				return ( TRUE );
    526c:	e3a03001 	mov	r3, #1	; 0x1
    5270:	e50b3014 	str	r3, [fp, #-20]
    5274:	ea000001 	b	5280 <MCI_CheckStatus+0x4c>
			}
		}
	}

	return ( FALSE );
    5278:	e3a03000 	mov	r3, #0	; 0x0
    527c:	e50b3014 	str	r3, [fp, #-20]
    5280:	e51b3014 	ldr	r3, [fp, #-20]
}
    5284:	e1a00003 	mov	r0, r3
    5288:	e24bd00c 	sub	sp, fp, #12	; 0xc
    528c:	e89da800 	ldm	sp, {fp, sp, pc}

00005290 <MCI_CmdProcess>:
 ** parameters:			None
 ** Returned value:		None
 ** 
 ******************************************************************************/
// mthomas - static
static void MCI_CmdProcess(void) {
    5290:	e1a0c00d 	mov	ip, sp
    5294:	e92dd800 	push	{fp, ip, lr, pc}
    5298:	e24cb004 	sub	fp, ip, #4	; 0x4
    529c:	e24dd004 	sub	sp, sp, #4	; 0x4
	DWORD MCIStatus;

	MCIStatus = MCI_STATUS;
    52a0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    52a4:	e2833923 	add	r3, r3, #573440	; 0x8c000
    52a8:	e2833034 	add	r3, r3, #52	; 0x34
    52ac:	e5933000 	ldr	r3, [r3]
    52b0:	e50b3010 	str	r3, [fp, #-16]

	if (MCIStatus & MCI_CMD_CRC_FAIL) {
    52b4:	e51b3010 	ldr	r3, [fp, #-16]
    52b8:	e2033001 	and	r3, r3, #1	; 0x1
    52bc:	e20330ff 	and	r3, r3, #255	; 0xff
    52c0:	e3530000 	cmp	r3, #0	; 0x0
    52c4:	0a000009 	beq	52f0 <MCI_CmdProcess+0x60>
		CmdCRCErrCount++;
    52c8:	e59f3104 	ldr	r3, [pc, #260]	; 53d4 <MCI_CmdProcess+0x144>
    52cc:	e5933000 	ldr	r3, [r3]
    52d0:	e2832001 	add	r2, r3, #1	; 0x1
    52d4:	e59f30f8 	ldr	r3, [pc, #248]	; 53d4 <MCI_CmdProcess+0x144>
    52d8:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_CMD_CRC_FAIL;
    52dc:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    52e0:	e2833923 	add	r3, r3, #573440	; 0x8c000
    52e4:	e2833038 	add	r3, r3, #56	; 0x38
    52e8:	e3a02001 	mov	r2, #1	; 0x1
    52ec:	e5832000 	str	r2, [r3]
	}
	if (MCIStatus & MCI_CMD_TIMEOUT) {
    52f0:	e51b3010 	ldr	r3, [fp, #-16]
    52f4:	e2033004 	and	r3, r3, #4	; 0x4
    52f8:	e3530000 	cmp	r3, #0	; 0x0
    52fc:	0a000009 	beq	5328 <MCI_CmdProcess+0x98>
		CmdTimeoutErrCount++;
    5300:	e59f30d0 	ldr	r3, [pc, #208]	; 53d8 <MCI_CmdProcess+0x148>
    5304:	e5933000 	ldr	r3, [r3]
    5308:	e2832001 	add	r2, r3, #1	; 0x1
    530c:	e59f30c4 	ldr	r3, [pc, #196]	; 53d8 <MCI_CmdProcess+0x148>
    5310:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_CMD_TIMEOUT;
    5314:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5318:	e2833923 	add	r3, r3, #573440	; 0x8c000
    531c:	e2833038 	add	r3, r3, #56	; 0x38
    5320:	e3a02004 	mov	r2, #4	; 0x4
    5324:	e5832000 	str	r2, [r3]
	}
	/* Cmd Resp End or Cmd Sent */
	if (MCIStatus & MCI_CMD_RESP_END) {
    5328:	e51b3010 	ldr	r3, [fp, #-16]
    532c:	e2033040 	and	r3, r3, #64	; 0x40
    5330:	e3530000 	cmp	r3, #0	; 0x0
    5334:	0a000009 	beq	5360 <MCI_CmdProcess+0xd0>
		CmdRespEndCount++;
    5338:	e59f309c 	ldr	r3, [pc, #156]	; 53dc <MCI_CmdProcess+0x14c>
    533c:	e5933000 	ldr	r3, [r3]
    5340:	e2832001 	add	r2, r3, #1	; 0x1
    5344:	e59f3090 	ldr	r3, [pc, #144]	; 53dc <MCI_CmdProcess+0x14c>
    5348:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_CMD_RESP_END;
    534c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5350:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5354:	e2833038 	add	r3, r3, #56	; 0x38
    5358:	e3a02040 	mov	r2, #64	; 0x40
    535c:	e5832000 	str	r2, [r3]
	}
	if (MCIStatus & MCI_CMD_SENT) {
    5360:	e51b3010 	ldr	r3, [fp, #-16]
    5364:	e2033080 	and	r3, r3, #128	; 0x80
    5368:	e3530000 	cmp	r3, #0	; 0x0
    536c:	0a000009 	beq	5398 <MCI_CmdProcess+0x108>
		CmdSentCount++;
    5370:	e59f3068 	ldr	r3, [pc, #104]	; 53e0 <MCI_CmdProcess+0x150>
    5374:	e5933000 	ldr	r3, [r3]
    5378:	e2832001 	add	r2, r3, #1	; 0x1
    537c:	e59f305c 	ldr	r3, [pc, #92]	; 53e0 <MCI_CmdProcess+0x150>
    5380:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_CMD_SENT;
    5384:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5388:	e2833923 	add	r3, r3, #573440	; 0x8c000
    538c:	e2833038 	add	r3, r3, #56	; 0x38
    5390:	e3a02080 	mov	r2, #128	; 0x80
    5394:	e5832000 	str	r2, [r3]
	}
	if (MCIStatus & MCI_CMD_ACTIVE) {
    5398:	e51b3010 	ldr	r3, [fp, #-16]
    539c:	e2033b02 	and	r3, r3, #2048	; 0x800
    53a0:	e3530000 	cmp	r3, #0	; 0x0
    53a4:	0a000009 	beq	53d0 <MCI_CmdProcess+0x140>
		CmdActiveCount++;
    53a8:	e59f3034 	ldr	r3, [pc, #52]	; 53e4 <MCI_CmdProcess+0x154>
    53ac:	e5933000 	ldr	r3, [r3]
    53b0:	e2832001 	add	r2, r3, #1	; 0x1
    53b4:	e59f3028 	ldr	r3, [pc, #40]	; 53e4 <MCI_CmdProcess+0x154>
    53b8:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_CMD_ACTIVE;
    53bc:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    53c0:	e2833923 	add	r3, r3, #573440	; 0x8c000
    53c4:	e2833038 	add	r3, r3, #56	; 0x38
    53c8:	e3a02b02 	mov	r2, #2048	; 0x800
    53cc:	e5832000 	str	r2, [r3]
	}
	return;
}
    53d0:	e89da808 	ldm	sp, {r3, fp, sp, pc}
    53d4:	40000740 	.word	0x40000740
    53d8:	40000744 	.word	0x40000744
    53dc:	40000748 	.word	0x40000748
    53e0:	4000074c 	.word	0x4000074c
    53e4:	40000750 	.word	0x40000750

000053e8 <MCI_DataErrorProcess>:
 ** parameters:			None
 ** Returned value:		None
 ** 
 ******************************************************************************/
// mthomas - static
static void MCI_DataErrorProcess(void) {
    53e8:	e1a0c00d 	mov	ip, sp
    53ec:	e92dd800 	push	{fp, ip, lr, pc}
    53f0:	e24cb004 	sub	fp, ip, #4	; 0x4
    53f4:	e24dd004 	sub	sp, sp, #4	; 0x4
	DWORD MCIStatus;

	MCIStatus = MCI_STATUS;
    53f8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    53fc:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5400:	e2833034 	add	r3, r3, #52	; 0x34
    5404:	e5933000 	ldr	r3, [r3]
    5408:	e50b3010 	str	r3, [fp, #-16]

	if (MCIStatus & MCI_DATA_CRC_FAIL) {
    540c:	e51b3010 	ldr	r3, [fp, #-16]
    5410:	e2033002 	and	r3, r3, #2	; 0x2
    5414:	e3530000 	cmp	r3, #0	; 0x0
    5418:	0a000009 	beq	5444 <MCI_DataErrorProcess+0x5c>
		DataCRCErrCount++;
    541c:	e59f3104 	ldr	r3, [pc, #260]	; 5528 <MCI_DataErrorProcess+0x140>
    5420:	e5933000 	ldr	r3, [r3]
    5424:	e2832001 	add	r2, r3, #1	; 0x1
    5428:	e59f30f8 	ldr	r3, [pc, #248]	; 5528 <MCI_DataErrorProcess+0x140>
    542c:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_DATA_CRC_FAIL;
    5430:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5434:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5438:	e2833038 	add	r3, r3, #56	; 0x38
    543c:	e3a02002 	mov	r2, #2	; 0x2
    5440:	e5832000 	str	r2, [r3]
	}
	if (MCIStatus & MCI_DATA_TIMEOUT) {
    5444:	e51b3010 	ldr	r3, [fp, #-16]
    5448:	e2033008 	and	r3, r3, #8	; 0x8
    544c:	e3530000 	cmp	r3, #0	; 0x0
    5450:	0a000009 	beq	547c <MCI_DataErrorProcess+0x94>
		DataTimeoutErrCount++;
    5454:	e59f30d0 	ldr	r3, [pc, #208]	; 552c <MCI_DataErrorProcess+0x144>
    5458:	e5933000 	ldr	r3, [r3]
    545c:	e2832001 	add	r2, r3, #1	; 0x1
    5460:	e59f30c4 	ldr	r3, [pc, #196]	; 552c <MCI_DataErrorProcess+0x144>
    5464:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_DATA_TIMEOUT;
    5468:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    546c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5470:	e2833038 	add	r3, r3, #56	; 0x38
    5474:	e3a02008 	mov	r2, #8	; 0x8
    5478:	e5832000 	str	r2, [r3]
	}
	/* Underrun or overrun */
	if (MCIStatus & MCI_TX_UNDERRUN) {
    547c:	e51b3010 	ldr	r3, [fp, #-16]
    5480:	e2033010 	and	r3, r3, #16	; 0x10
    5484:	e3530000 	cmp	r3, #0	; 0x0
    5488:	0a000009 	beq	54b4 <MCI_DataErrorProcess+0xcc>
		DataTxUnderrunErrCount++;
    548c:	e59f309c 	ldr	r3, [pc, #156]	; 5530 <MCI_DataErrorProcess+0x148>
    5490:	e5933000 	ldr	r3, [r3]
    5494:	e2832001 	add	r2, r3, #1	; 0x1
    5498:	e59f3090 	ldr	r3, [pc, #144]	; 5530 <MCI_DataErrorProcess+0x148>
    549c:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_TX_UNDERRUN;
    54a0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    54a4:	e2833923 	add	r3, r3, #573440	; 0x8c000
    54a8:	e2833038 	add	r3, r3, #56	; 0x38
    54ac:	e3a02010 	mov	r2, #16	; 0x10
    54b0:	e5832000 	str	r2, [r3]
	}
	if (MCIStatus & MCI_RX_OVERRUN) {
    54b4:	e51b3010 	ldr	r3, [fp, #-16]
    54b8:	e2033020 	and	r3, r3, #32	; 0x20
    54bc:	e3530000 	cmp	r3, #0	; 0x0
    54c0:	0a000009 	beq	54ec <MCI_DataErrorProcess+0x104>
		DataRxOverrunErrCount++;
    54c4:	e59f3068 	ldr	r3, [pc, #104]	; 5534 <MCI_DataErrorProcess+0x14c>
    54c8:	e5933000 	ldr	r3, [r3]
    54cc:	e2832001 	add	r2, r3, #1	; 0x1
    54d0:	e59f305c 	ldr	r3, [pc, #92]	; 5534 <MCI_DataErrorProcess+0x14c>
    54d4:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_RX_OVERRUN;
    54d8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    54dc:	e2833923 	add	r3, r3, #573440	; 0x8c000
    54e0:	e2833038 	add	r3, r3, #56	; 0x38
    54e4:	e3a02020 	mov	r2, #32	; 0x20
    54e8:	e5832000 	str	r2, [r3]
	}
	/* Start bit error on data signal */
	if (MCIStatus & MCI_START_BIT_ERR) {
    54ec:	e51b3010 	ldr	r3, [fp, #-16]
    54f0:	e2033c02 	and	r3, r3, #512	; 0x200
    54f4:	e3530000 	cmp	r3, #0	; 0x0
    54f8:	0a000009 	beq	5524 <MCI_DataErrorProcess+0x13c>
		DataStartbitErrCount++;
    54fc:	e59f3034 	ldr	r3, [pc, #52]	; 5538 <MCI_DataErrorProcess+0x150>
    5500:	e5933000 	ldr	r3, [r3]
    5504:	e2832001 	add	r2, r3, #1	; 0x1
    5508:	e59f3028 	ldr	r3, [pc, #40]	; 5538 <MCI_DataErrorProcess+0x150>
    550c:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_START_BIT_ERR;
    5510:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5514:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5518:	e2833038 	add	r3, r3, #56	; 0x38
    551c:	e3a02c02 	mov	r2, #512	; 0x200
    5520:	e5832000 	str	r2, [r3]
	}
	return;
}
    5524:	e89da808 	ldm	sp, {r3, fp, sp, pc}
    5528:	40000754 	.word	0x40000754
    552c:	40000758 	.word	0x40000758
    5530:	4000075c 	.word	0x4000075c
    5534:	40000760 	.word	0x40000760
    5538:	40000764 	.word	0x40000764

0000553c <MCI_DATA_END_InterruptService>:
 ** parameters:			None
 ** Returned value:		None
 ** 
 ******************************************************************************/
// mthomas - static
static void MCI_DATA_END_InterruptService(void) {
    553c:	e1a0c00d 	mov	ip, sp
    5540:	e92dd800 	push	{fp, ip, lr, pc}
    5544:	e24cb004 	sub	fp, ip, #4	; 0x4
    5548:	e24dd004 	sub	sp, sp, #4	; 0x4
	DWORD MCIStatus;

	MCIStatus = MCI_STATUS;
    554c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5550:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5554:	e2833034 	add	r3, r3, #52	; 0x34
    5558:	e5933000 	ldr	r3, [r3]
    555c:	e50b3010 	str	r3, [fp, #-16]

	if (MCIStatus & MCI_DATA_END) /* Data end, and Data block end  */
    5560:	e51b3010 	ldr	r3, [fp, #-16]
    5564:	e2033c01 	and	r3, r3, #256	; 0x100
    5568:	e3530000 	cmp	r3, #0	; 0x0
    556c:	0a00000a 	beq	559c <MCI_DATA_END_InterruptService+0x60>
	{
		DataEndCount++;
    5570:	e59f30bc 	ldr	r3, [pc, #188]	; 5634 <MCI_DATA_END_InterruptService+0xf8>
    5574:	e5933000 	ldr	r3, [r3]
    5578:	e2832001 	add	r2, r3, #1	; 0x1
    557c:	e59f30b0 	ldr	r3, [pc, #176]	; 5634 <MCI_DATA_END_InterruptService+0xf8>
    5580:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_DATA_END;
    5584:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5588:	e2833923 	add	r3, r3, #573440	; 0x8c000
    558c:	e2833038 	add	r3, r3, #56	; 0x38
    5590:	e3a02c01 	mov	r2, #256	; 0x100
    5594:	e5832000 	str	r2, [r3]
    5598:	ea000024 	b	5630 <MCI_DATA_END_InterruptService+0xf4>
		return;
	}
	if (MCIStatus & MCI_DATA_BLK_END) {
    559c:	e51b3010 	ldr	r3, [fp, #-16]
    55a0:	e2033b01 	and	r3, r3, #1024	; 0x400
    55a4:	e3530000 	cmp	r3, #0	; 0x0
    55a8:	0a00000e 	beq	55e8 <MCI_DATA_END_InterruptService+0xac>
		DataBlockEndCount++;
    55ac:	e59f3084 	ldr	r3, [pc, #132]	; 5638 <MCI_DATA_END_InterruptService+0xfc>
    55b0:	e5933000 	ldr	r3, [r3]
    55b4:	e2832001 	add	r2, r3, #1	; 0x1
    55b8:	e59f3078 	ldr	r3, [pc, #120]	; 5638 <MCI_DATA_END_InterruptService+0xfc>
    55bc:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_DATA_BLK_END;
    55c0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    55c4:	e2833923 	add	r3, r3, #573440	; 0x8c000
    55c8:	e2833038 	add	r3, r3, #56	; 0x38
    55cc:	e3a02b01 	mov	r2, #1024	; 0x400
    55d0:	e5832000 	str	r2, [r3]
		MCI_TXDisable();
    55d4:	ebfffee6 	bl	5174 <MCI_TXDisable>
		MCI_Block_End_Flag = 0;
    55d8:	e59f205c 	ldr	r2, [pc, #92]	; 563c <MCI_DATA_END_InterruptService+0x100>
    55dc:	e3a03000 	mov	r3, #0	; 0x0
    55e0:	e5823000 	str	r3, [r2]
    55e4:	ea000011 	b	5630 <MCI_DATA_END_InterruptService+0xf4>
		return;
	}

	/* Tx active  */
	if (MCIStatus & MCI_TX_ACTIVE) {
    55e8:	e51b3010 	ldr	r3, [fp, #-16]
    55ec:	e2033a01 	and	r3, r3, #4096	; 0x1000
    55f0:	e3530000 	cmp	r3, #0	; 0x0
    55f4:	0a000004 	beq	560c <MCI_DATA_END_InterruptService+0xd0>
		DataTxActiveCount++;
    55f8:	e59f3040 	ldr	r3, [pc, #64]	; 5640 <MCI_DATA_END_InterruptService+0x104>
    55fc:	e5933000 	ldr	r3, [r3]
    5600:	e2832001 	add	r2, r3, #1	; 0x1
    5604:	e59f3034 	ldr	r3, [pc, #52]	; 5640 <MCI_DATA_END_InterruptService+0x104>
    5608:	e5832000 	str	r2, [r3]
	}
	/* Rx active  */
	if (MCIStatus & MCI_RX_ACTIVE) {
    560c:	e51b3010 	ldr	r3, [fp, #-16]
    5610:	e2033a02 	and	r3, r3, #8192	; 0x2000
    5614:	e3530000 	cmp	r3, #0	; 0x0
    5618:	0a000004 	beq	5630 <MCI_DATA_END_InterruptService+0xf4>
		DataRxActiveCount++;
    561c:	e59f3020 	ldr	r3, [pc, #32]	; 5644 <MCI_DATA_END_InterruptService+0x108>
    5620:	e5933000 	ldr	r3, [r3]
    5624:	e2832001 	add	r2, r3, #1	; 0x1
    5628:	e59f3014 	ldr	r3, [pc, #20]	; 5644 <MCI_DATA_END_InterruptService+0x108>
    562c:	e5832000 	str	r2, [r3]
	}

	return;
}
    5630:	e89da808 	ldm	sp, {r3, fp, sp, pc}
    5634:	40000768 	.word	0x40000768
    5638:	4000076c 	.word	0x4000076c
    563c:	40000770 	.word	0x40000770
    5640:	40000774 	.word	0x40000774
    5644:	40000778 	.word	0x40000778

00005648 <MCI_FIFOInterruptService>:
 ** parameters:			None
 ** Returned value:		None
 ** 
 ******************************************************************************/
// mthomas - static
static void MCI_FIFOInterruptService(void) {
    5648:	e1a0c00d 	mov	ip, sp
    564c:	e92dd800 	push	{fp, ip, lr, pc}
    5650:	e24cb004 	sub	fp, ip, #4	; 0x4
		}
		// mthomas end
	}
#endif

	DataFIFOCount++;
    5654:	e59f3010 	ldr	r3, [pc, #16]	; 566c <MCI_FIFOInterruptService+0x24>
    5658:	e5933000 	ldr	r3, [r3]
    565c:	e2832001 	add	r2, r3, #1	; 0x1
    5660:	e59f3004 	ldr	r3, [pc, #4]	; 566c <MCI_FIFOInterruptService+0x24>
    5664:	e5832000 	str	r2, [r3]
	return;
}
    5668:	e89da800 	ldm	sp, {fp, sp, pc}
    566c:	4000077c 	.word	0x4000077c

00005670 <MCI_IRQHandler>:
 ** 
 ******************************************************************************/
// mthomas - avoid warning missing prototype
void MCI_IRQHandler(void)  __attribute__((interrupt("IRQ")));
void MCI_IRQHandler(void)
{
    5670:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
    5674:	e1a0c00d 	mov	ip, sp
    5678:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
    567c:	e24cb004 	sub	fp, ip, #4	; 0x4
    5680:	e24dd004 	sub	sp, sp, #4	; 0x4
	//myprintf("MCI_INTERRUPT_HANDLER");
	DWORD MCI_Status;

	MCI_Status = MCI_STATUS;
    5684:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5688:	e2833923 	add	r3, r3, #573440	; 0x8c000
    568c:	e2833034 	add	r3, r3, #52	; 0x34
    5690:	e5933000 	ldr	r3, [r3]
    5694:	e50b3020 	str	r3, [fp, #-32]

	//myprintf("calling MCI_IRQHandler\r\n");

	/* handle MCI_STATUS interrupt */
	if ( MCI_Status & DATA_ERR_INT_MASK )
    5698:	e51b3020 	ldr	r3, [fp, #-32]
    569c:	e3c33f71 	bic	r3, r3, #452	; 0x1c4
    56a0:	e3c33001 	bic	r3, r3, #1	; 0x1
    56a4:	e1a03b03 	lsl	r3, r3, #22
    56a8:	e1a03b23 	lsr	r3, r3, #22
    56ac:	e3530000 	cmp	r3, #0	; 0x0
    56b0:	0a000009 	beq	56dc <MCI_IRQHandler+0x6c>
	{
		MCI_DataErrorProcess();
    56b4:	ebffff4b 	bl	53e8 <MCI_DataErrorProcess>
		MCI_DataErrorProcess_count++;
    56b8:	e59f30f8 	ldr	r3, [pc, #248]	; 57b8 <MCI_IRQHandler+0x148>
    56bc:	e5933000 	ldr	r3, [r3]
    56c0:	e2832001 	add	r2, r3, #1	; 0x1
    56c4:	e59f30ec 	ldr	r3, [pc, #236]	; 57b8 <MCI_IRQHandler+0x148>
    56c8:	e5832000 	str	r2, [r3]
		VICVectAddr = 0; /* Acknowledge Interrupt */
    56cc:	e3e020ff 	mvn	r2, #255	; 0xff
    56d0:	e3a03000 	mov	r3, #0	; 0x0
    56d4:	e5823000 	str	r3, [r2]
    56d8:	ea000032 	b	57a8 <MCI_IRQHandler+0x138>
		return;
	}
	if ( MCI_Status & DATA_END_INT_MASK )
    56dc:	e51b3020 	ldr	r3, [fp, #-32]
    56e0:	e2033c05 	and	r3, r3, #1280	; 0x500
    56e4:	e3530000 	cmp	r3, #0	; 0x0
    56e8:	0a000009 	beq	5714 <MCI_IRQHandler+0xa4>
	{
		MCI_DATA_END_InterruptService();
    56ec:	ebffff92 	bl	553c <MCI_DATA_END_InterruptService>
		MCI_DATA_END_InterruptService_count++;
    56f0:	e59f30c4 	ldr	r3, [pc, #196]	; 57bc <MCI_IRQHandler+0x14c>
    56f4:	e5933000 	ldr	r3, [r3]
    56f8:	e2832001 	add	r2, r3, #1	; 0x1
    56fc:	e59f30b8 	ldr	r3, [pc, #184]	; 57bc <MCI_IRQHandler+0x14c>
    5700:	e5832000 	str	r2, [r3]
		VICVectAddr = 0; /* Acknowledge Interrupt */
    5704:	e3e020ff 	mvn	r2, #255	; 0xff
    5708:	e3a03000 	mov	r3, #0	; 0x0
    570c:	e5823000 	str	r3, [r2]
    5710:	ea000024 	b	57a8 <MCI_IRQHandler+0x138>
		return;
	}
	else if ( MCI_Status & FIFO_INT_MASK )
    5714:	e51b3020 	ldr	r3, [fp, #-32]
    5718:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
    571c:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
    5720:	e3c33def 	bic	r3, r3, #15296	; 0x3bc0
    5724:	e3c3303f 	bic	r3, r3, #63	; 0x3f
    5728:	e3530000 	cmp	r3, #0	; 0x0
    572c:	0a000009 	beq	5758 <MCI_IRQHandler+0xe8>
	{
		MCI_FIFOInterruptService();
    5730:	ebffffc4 	bl	5648 <MCI_FIFOInterruptService>
		MCI_FIFOInterruptService_count++;
    5734:	e59f3084 	ldr	r3, [pc, #132]	; 57c0 <MCI_IRQHandler+0x150>
    5738:	e5933000 	ldr	r3, [r3]
    573c:	e2832001 	add	r2, r3, #1	; 0x1
    5740:	e59f3078 	ldr	r3, [pc, #120]	; 57c0 <MCI_IRQHandler+0x150>
    5744:	e5832000 	str	r2, [r3]
		VICVectAddr = 0; /* Acknowledge Interrupt */
    5748:	e3e020ff 	mvn	r2, #255	; 0xff
    574c:	e3a03000 	mov	r3, #0	; 0x0
    5750:	e5823000 	str	r3, [r2]
    5754:	ea000013 	b	57a8 <MCI_IRQHandler+0x138>
		return;
	}
	else if ( MCI_Status & CMD_INT_MASK )
    5758:	e51b3020 	ldr	r3, [fp, #-32]
    575c:	e3c33e73 	bic	r3, r3, #1840	; 0x730
    5760:	e3c3300a 	bic	r3, r3, #10	; 0xa
    5764:	e1a03a03 	lsl	r3, r3, #20
    5768:	e1a03a23 	lsr	r3, r3, #20
    576c:	e3530000 	cmp	r3, #0	; 0x0
    5770:	0a000009 	beq	579c <MCI_IRQHandler+0x12c>
	{
		MCI_CmdProcess();
    5774:	ebfffec5 	bl	5290 <MCI_CmdProcess>
		MCI_CmdProcess_count++;
    5778:	e59f3044 	ldr	r3, [pc, #68]	; 57c4 <MCI_IRQHandler+0x154>
    577c:	e5933000 	ldr	r3, [r3]
    5780:	e2832001 	add	r2, r3, #1	; 0x1
    5784:	e59f3038 	ldr	r3, [pc, #56]	; 57c4 <MCI_IRQHandler+0x154>
    5788:	e5832000 	str	r2, [r3]
		VICVectAddr = 0; /* Acknowledge Interrupt */
    578c:	e3e020ff 	mvn	r2, #255	; 0xff
    5790:	e3a03000 	mov	r3, #0	; 0x0
    5794:	e5823000 	str	r3, [r2]
    5798:	ea000002 	b	57a8 <MCI_IRQHandler+0x138>
		return;
	}

	VICVectAddr = 0; /* Acknowledge Interrupt */
    579c:	e3e020ff 	mvn	r2, #255	; 0xff
    57a0:	e3a03000 	mov	r3, #0	; 0x0
    57a4:	e5823000 	str	r3, [r2]
	return;
}
    57a8:	e24bd01c 	sub	sp, fp, #28	; 0x1c
    57ac:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
    57b0:	e8bd1000 	pop	{ip}
    57b4:	e25ef004 	subs	pc, lr, #4	; 0x4
    57b8:	40000730 	.word	0x40000730
    57bc:	40000734 	.word	0x40000734
    57c0:	40000738 	.word	0x40000738
    57c4:	4000073c 	.word	0x4000073c

000057c8 <MCI_Set_MCIClock>:
 **
 ** parameters:			Clock rate to be set
 ** Returned value:		None
 ** 
 ******************************************************************************/
void MCI_Set_MCIClock(DWORD ClockRate) {
    57c8:	e1a0c00d 	mov	ip, sp
    57cc:	e92dd800 	push	{fp, ip, lr, pc}
    57d0:	e24cb004 	sub	fp, ip, #4	; 0x4
    57d4:	e24dd00c 	sub	sp, sp, #12	; 0xc
    57d8:	e50b0018 	str	r0, [fp, #-24]
	volatile DWORD i; // mthomas volatile
	DWORD ClkValue = 0;
    57dc:	e3a03000 	mov	r3, #0	; 0x0
    57e0:	e50b3010 	str	r3, [fp, #-16]

	if (ClockRate == SLOW_RATE) {
    57e4:	e51b3018 	ldr	r3, [fp, #-24]
    57e8:	e3530001 	cmp	r3, #1	; 0x1
    57ec:	1a000003 	bne	5800 <MCI_Set_MCIClock+0x38>
		ClkValue |= MCLKDIV_SLOW; /* slow clock */
    57f0:	e51b3010 	ldr	r3, [fp, #-16]
    57f4:	e383303d 	orr	r3, r3, #61	; 0x3d
    57f8:	e50b3010 	str	r3, [fp, #-16]
    57fc:	ea000009 	b	5828 <MCI_Set_MCIClock+0x60>
	} else if (ClockRate == NORMAL_RATE) {
    5800:	e51b3018 	ldr	r3, [fp, #-24]
    5804:	e3530002 	cmp	r3, #2	; 0x2
    5808:	1a000003 	bne	581c <MCI_Set_MCIClock+0x54>
		ClkValue |= MCLKDIV_NORMAL;/* normal clock */
    580c:	e51b3010 	ldr	r3, [fp, #-16]
    5810:	e3833001 	orr	r3, r3, #1	; 0x1
    5814:	e50b3010 	str	r3, [fp, #-16]
    5818:	ea000002 	b	5828 <MCI_Set_MCIClock+0x60>
	} else {
		// mthomas - added default - low
		ClkValue |= MCLKDIV_SLOW;
    581c:	e51b3010 	ldr	r3, [fp, #-16]
    5820:	e383303d 	orr	r3, r3, #61	; 0x3d
    5824:	e50b3010 	str	r3, [fp, #-16]
	}

	MCI_CLOCK &= ~(0xFF);
    5828:	e3a0224e 	mov	r2, #-536870908	; 0xe0000004
    582c:	e2822923 	add	r2, r2, #573440	; 0x8c000
    5830:	e3a0324e 	mov	r3, #-536870908	; 0xe0000004
    5834:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5838:	e5933000 	ldr	r3, [r3]
    583c:	e3c330ff 	bic	r3, r3, #255	; 0xff
    5840:	e5823000 	str	r3, [r2]
	/* clear clock divider */
	// laebi: Disable MCI clock output when bus is idle (bit 9)
	MCI_CLOCK |= (1 << 8) | (1 << 9) | ClkValue;
    5844:	e3a0224e 	mov	r2, #-536870908	; 0xe0000004
    5848:	e2822923 	add	r2, r2, #573440	; 0x8c000
    584c:	e3a0324e 	mov	r3, #-536870908	; 0xe0000004
    5850:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5854:	e5931000 	ldr	r1, [r3]
    5858:	e51b3010 	ldr	r3, [fp, #-16]
    585c:	e1813003 	orr	r3, r1, r3
    5860:	e3833c03 	orr	r3, r3, #768	; 0x300
    5864:	e5823000 	str	r3, [r2]
	for (i = 0; i < 0x100; i++)
    5868:	e3a03000 	mov	r3, #0	; 0x0
    586c:	e50b3014 	str	r3, [fp, #-20]
    5870:	ea000002 	b	5880 <MCI_Set_MCIClock+0xb8>
    5874:	e51b3014 	ldr	r3, [fp, #-20]
    5878:	e2833001 	add	r3, r3, #1	; 0x1
    587c:	e50b3014 	str	r3, [fp, #-20]
    5880:	e51b3014 	ldr	r3, [fp, #-20]
    5884:	e35300ff 	cmp	r3, #255	; 0xff
    5888:	9afffff9 	bls	5874 <MCI_Set_MCIClock+0xac>
		; /* delay 3MCLK + 2PCLK before next write */

	return;
}
    588c:	e24bd00c 	sub	sp, fp, #12	; 0xc
    5890:	e89da800 	ldm	sp, {fp, sp, pc}

00005894 <SD_Set_BusWidth>:
 ** Returned value:		TRUE or FALSE
 **
 ** modified by Martin Thomas: do not set 4 bit if 
 ** parameter is SD_1_BIT
 ******************************************************************************/
DWORD SD_Set_BusWidth(DWORD width) {
    5894:	e1a0c00d 	mov	ip, sp
    5898:	e92dd800 	push	{fp, ip, lr, pc}
    589c:	e24cb004 	sub	fp, ip, #4	; 0x4
    58a0:	e24dd00c 	sub	sp, sp, #12	; 0xc
    58a4:	e50b0014 	str	r0, [fp, #-20]
	volatile DWORD i; // mthomas - volatile

	for (i = 0; i < 0x10; i++)
    58a8:	e3a03000 	mov	r3, #0	; 0x0
    58ac:	e50b3010 	str	r3, [fp, #-16]
    58b0:	ea000002 	b	58c0 <SD_Set_BusWidth+0x2c>
    58b4:	e51b3010 	ldr	r3, [fp, #-16]
    58b8:	e2833001 	add	r3, r3, #1	; 0x1
    58bc:	e50b3010 	str	r3, [fp, #-16]
    58c0:	e51b3010 	ldr	r3, [fp, #-16]
    58c4:	e353000f 	cmp	r3, #15	; 0xf
    58c8:	9afffff9 	bls	58b4 <SD_Set_BusWidth+0x20>
		; /* delay 3MCLK + 2PCLK  */

	if (width == SD_1_BIT) {
    58cc:	e51b3014 	ldr	r3, [fp, #-20]
    58d0:	e3530000 	cmp	r3, #0	; 0x0
    58d4:	1a000007 	bne	58f8 <SD_Set_BusWidth+0x64>
		MCI_CLOCK &= ~(1 << 11);
    58d8:	e3a0224e 	mov	r2, #-536870908	; 0xe0000004
    58dc:	e2822923 	add	r2, r2, #573440	; 0x8c000
    58e0:	e3a0324e 	mov	r3, #-536870908	; 0xe0000004
    58e4:	e2833923 	add	r3, r3, #573440	; 0x8c000
    58e8:	e5933000 	ldr	r3, [r3]
    58ec:	e3c33b02 	bic	r3, r3, #2048	; 0x800
    58f0:	e5823000 	str	r3, [r2]
    58f4:	ea000018 	b	595c <SD_Set_BusWidth+0xc8>
		/* 1 bit bus */
	} else if (width == SD_4_BIT) {
    58f8:	e51b3014 	ldr	r3, [fp, #-20]
    58fc:	e3530001 	cmp	r3, #1	; 0x1
    5900:	1a00000e 	bne	5940 <SD_Set_BusWidth+0xac>
		MCI_CLOCK |= (1 << 11);
    5904:	e3a0224e 	mov	r2, #-536870908	; 0xe0000004
    5908:	e2822923 	add	r2, r2, #573440	; 0x8c000
    590c:	e3a0324e 	mov	r3, #-536870908	; 0xe0000004
    5910:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5914:	e5933000 	ldr	r3, [r3]
    5918:	e3833b02 	orr	r3, r3, #2048	; 0x800
    591c:	e5823000 	str	r3, [r2]
		/* 4 bit bus */
		// mthomas - moved this here from below
		if (MCI_Send_ACMD_Bus_Width( BUS_WIDTH_4BITS) == FALSE) {
    5920:	e3a0000a 	mov	r0, #10	; 0xa
    5924:	eb0004cf 	bl	6c68 <MCI_Send_ACMD_Bus_Width>
    5928:	e1a03000 	mov	r3, r0
    592c:	e3530000 	cmp	r3, #0	; 0x0
    5930:	1a000009 	bne	595c <SD_Set_BusWidth+0xc8>
			mci_debug_printf("setting 4bit width failed\n");
			return ( FALSE );
    5934:	e3a03000 	mov	r3, #0	; 0x0
    5938:	e50b3018 	str	r3, [fp, #-24]
    593c:	ea000008 	b	5964 <SD_Set_BusWidth+0xd0>
		}mci_debug_printf("setting 4bit width success\n");
	} else {
		// mthomas - added default
		MCI_CLOCK &= ~(1 << 11);
    5940:	e3a0224e 	mov	r2, #-536870908	; 0xe0000004
    5944:	e2822923 	add	r2, r2, #573440	; 0x8c000
    5948:	e3a0324e 	mov	r3, #-536870908	; 0xe0000004
    594c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5950:	e5933000 	ldr	r3, [r3]
    5954:	e3c33b02 	bic	r3, r3, #2048	; 0x800
    5958:	e5823000 	str	r3, [r2]
	{
		return( FALSE );
	}
#endif

	return ( TRUE );
    595c:	e3a03001 	mov	r3, #1	; 0x1
    5960:	e50b3018 	str	r3, [fp, #-24]
    5964:	e51b3018 	ldr	r3, [fp, #-24]
}
    5968:	e1a00003 	mov	r0, r3
    596c:	e24bd00c 	sub	sp, fp, #12	; 0xc
    5970:	e89da800 	ldm	sp, {fp, sp, pc}

00005974 <MCI_Init>:
 ** Returned value:		true or false, if VIC table is full, return false
 **
 ** modified by Martin Thomas to avoid that the
 ** hard-coded pinsel-values disable other functions
 ******************************************************************************/
DWORD MCI_Init(void) {
    5974:	e1a0c00d 	mov	ip, sp
    5978:	e92dd800 	push	{fp, ip, lr, pc}
    597c:	e24cb004 	sub	fp, ip, #4	; 0x4
    5980:	e24dd008 	sub	sp, sp, #8	; 0x8
	volatile DWORD i; // mthomas - volatile

	PCONP |= ( 1 << 28 );
    5984:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    5988:	e282297f 	add	r2, r2, #2080768	; 0x1fc000
    598c:	e28220c4 	add	r2, r2, #196	; 0xc4
    5990:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5994:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    5998:	e28330c4 	add	r3, r3, #196	; 0xc4
    599c:	e5933000 	ldr	r3, [r3]
    59a0:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
    59a4:	e5823000 	str	r3, [r2]
	/* Enable clock to the MCI block */

	if ( MCI_CLOCK & (1 << 8)) {
    59a8:	e3a0324e 	mov	r3, #-536870908	; 0xe0000004
    59ac:	e2833923 	add	r3, r3, #573440	; 0x8c000
    59b0:	e5933000 	ldr	r3, [r3]
    59b4:	e2033c01 	and	r3, r3, #256	; 0x100
    59b8:	e3530000 	cmp	r3, #0	; 0x0
    59bc:	0a000006 	beq	59dc <MCI_Init+0x68>
		MCI_CLOCK &= ~(1 << 8);
    59c0:	e3a0224e 	mov	r2, #-536870908	; 0xe0000004
    59c4:	e2822923 	add	r2, r2, #573440	; 0x8c000
    59c8:	e3a0324e 	mov	r3, #-536870908	; 0xe0000004
    59cc:	e2833923 	add	r3, r3, #573440	; 0x8c000
    59d0:	e5933000 	ldr	r3, [r3]
    59d4:	e3c33c01 	bic	r3, r3, #256	; 0x100
    59d8:	e5823000 	str	r3, [r2]
	}
	if ( MCI_POWER & 0x02) {
    59dc:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    59e0:	e2833923 	add	r3, r3, #573440	; 0x8c000
    59e4:	e5933000 	ldr	r3, [r3]
    59e8:	e2033002 	and	r3, r3, #2	; 0x2
    59ec:	e3530000 	cmp	r3, #0	; 0x0
    59f0:	0a000003 	beq	5a04 <MCI_Init+0x90>
		MCI_POWER = 0x00;
    59f4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    59f8:	e2833923 	add	r3, r3, #573440	; 0x8c000
    59fc:	e3a02000 	mov	r2, #0	; 0x0
    5a00:	e5832000 	str	r2, [r3]
	}
	for (i = 0; i < 0x1000; i++)
    5a04:	e3a03000 	mov	r3, #0	; 0x0
    5a08:	e50b3010 	str	r3, [fp, #-16]
    5a0c:	ea000002 	b	5a1c <MCI_Init+0xa8>
    5a10:	e51b3010 	ldr	r3, [fp, #-16]
    5a14:	e2833001 	add	r3, r3, #1	; 0x1
    5a18:	e50b3010 	str	r3, [fp, #-16]
    5a1c:	e51b2010 	ldr	r2, [fp, #-16]
    5a20:	e3a03eff 	mov	r3, #4080	; 0xff0
    5a24:	e283300f 	add	r3, r3, #15	; 0xf
    5a28:	e1520003 	cmp	r2, r3
    5a2c:	9afffff7 	bls	5a10 <MCI_Init+0x9c>
		;

	/* Disable all interrupts for now */
	MCI_MASK0 = 0;
    5a30:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5a34:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5a38:	e283303c 	add	r3, r3, #60	; 0x3c
    5a3c:	e3a02000 	mov	r2, #0	; 0x0
    5a40:	e5832000 	str	r2, [r3]
	MCI_MASK1 = MCI_MASK0;
    5a44:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    5a48:	e2822923 	add	r2, r2, #573440	; 0x8c000
    5a4c:	e2822040 	add	r2, r2, #64	; 0x40
    5a50:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5a54:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5a58:	e283303c 	add	r3, r3, #60	; 0x3c
    5a5c:	e5933000 	ldr	r3, [r3]
    5a60:	e5823000 	str	r3, [r2]
#warning EA,OMX23/Keil23
/*	PINSEL1 = ( PINSEL1 & ~( (3<<6)|(3<<8)|(3<<10)|(3<<12) ) )
	| ((2<<6)|(2<<8)|(2<<10)|(2<<12));
	PINSEL4 = ( PINSEL4 & ~((3<<22)|(3<<24)|(3<<26) ) )
	| ((2<<22)|(2<<24)|(2<<26) );*/
	  PINSEL1 = 0x2A80;	/*Sets Clock, command,DAT0+ Power*/
    5a64:	e3a0324e 	mov	r3, #-536870908	; 0xe0000004
    5a68:	e283390b 	add	r3, r3, #180224	; 0x2c000
    5a6c:	e3a02daa 	mov	r2, #10880	; 0x2a80
    5a70:	e5832000 	str	r2, [r3]

	  PINSEL2 &=0xFD7F7FFF;
    5a74:	e3a0228e 	mov	r2, #-536870904	; 0xe0000008
    5a78:	e282290b 	add	r2, r2, #180224	; 0x2c000
    5a7c:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
    5a80:	e283390b 	add	r3, r3, #180224	; 0x2c000
    5a84:	e5933000 	ldr	r3, [r3]
    5a88:	e3c3350a 	bic	r3, r3, #41943040	; 0x2800000
    5a8c:	e3c33902 	bic	r3, r3, #32768	; 0x8000
    5a90:	e5823000 	str	r3, [r2]
	  PINSEL2 |=0x02808000;
    5a94:	e3a0228e 	mov	r2, #-536870904	; 0xe0000008
    5a98:	e282290b 	add	r2, r2, #180224	; 0x2c000
    5a9c:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
    5aa0:	e283390b 	add	r3, r3, #180224	; 0x2c000
    5aa4:	e5933000 	ldr	r3, [r3]
    5aa8:	e383350a 	orr	r3, r3, #41943040	; 0x2800000
    5aac:	e3833902 	orr	r3, r3, #32768	; 0x8000
    5ab0:	e5823000 	str	r3, [r2]
	IODIR0 = 1 << 21; /* MCI_PWR as GPIO output */
	IOCLR0 = 1 << 21;
#endif
#else
	// #warning SCS MCIPWR active level low
	SCS &= ~0x08;
    5ab4:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    5ab8:	e282297f 	add	r2, r2, #2080768	; 0x1fc000
    5abc:	e2822e1a 	add	r2, r2, #416	; 0x1a0
    5ac0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5ac4:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    5ac8:	e2833e1a 	add	r3, r3, #416	; 0x1a0
    5acc:	e5933000 	ldr	r3, [r3]
    5ad0:	e3c33008 	bic	r3, r3, #8	; 0x8
    5ad4:	e5823000 	str	r3, [r2]
	PINSEL4 = 0x0A800000;
#endif
#endif

	/*set up clocking default mode, clear any registers as needed */
	MCI_COMMAND = 0;
    5ad8:	e3a032ce 	mov	r3, #-536870900	; 0xe000000c
    5adc:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5ae0:	e3a02000 	mov	r2, #0	; 0x0
    5ae4:	e5832000 	str	r2, [r3]
	MCI_DATA_CTRL = 0;
    5ae8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5aec:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5af0:	e283302c 	add	r3, r3, #44	; 0x2c
    5af4:	e3a02000 	mov	r2, #0	; 0x0
    5af8:	e5832000 	str	r2, [r3]
	MCI_CLEAR = 0x7FF;
    5afc:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    5b00:	e2822923 	add	r2, r2, #573440	; 0x8c000
    5b04:	e2822038 	add	r2, r2, #56	; 0x38
    5b08:	e3a03e7f 	mov	r3, #2032	; 0x7f0
    5b0c:	e283300f 	add	r3, r3, #15	; 0xf
    5b10:	e5823000 	str	r3, [r2]
	/* clear all pending interrupts */

	MCI_POWER = 0x02;
    5b14:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5b18:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5b1c:	e3a02002 	mov	r2, #2	; 0x2
    5b20:	e5832000 	str	r2, [r3]
	/* power up */
	while ( !(MCI_POWER & 0x02)) {
    5b24:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5b28:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5b2c:	e5933000 	ldr	r3, [r3]
    5b30:	e2033002 	and	r3, r3, #2	; 0x2
    5b34:	e3530000 	cmp	r3, #0	; 0x0
    5b38:	0afffff9 	beq	5b24 <MCI_Init+0x1b0>
		;
	}
	for (i = 0; i < 0x100; i++) {
    5b3c:	e3a03000 	mov	r3, #0	; 0x0
    5b40:	e50b3010 	str	r3, [fp, #-16]
    5b44:	ea000002 	b	5b54 <MCI_Init+0x1e0>
    5b48:	e51b3010 	ldr	r3, [fp, #-16]
    5b4c:	e2833001 	add	r3, r3, #1	; 0x1
    5b50:	e50b3010 	str	r3, [fp, #-16]
    5b54:	e51b3010 	ldr	r3, [fp, #-16]
    5b58:	e35300ff 	cmp	r3, #255	; 0xff
    5b5c:	9afffff9 	bls	5b48 <MCI_Init+0x1d4>
	}

	/* During identification phase, the clock should be less than
	 400Khz. Once we pass this phase, the normal clock can be set up
	 to 25Mhz on SD card and 20Mhz on MMC card. */
	MCI_Set_MCIClock( SLOW_RATE);
    5b60:	e3a00001 	mov	r0, #1	; 0x1
    5b64:	ebffff17 	bl	57c8 <MCI_Set_MCIClock>
	MCI_POWER |= 0x01;
    5b68:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    5b6c:	e2822923 	add	r2, r2, #573440	; 0x8c000
    5b70:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5b74:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5b78:	e5933000 	ldr	r3, [r3]
    5b7c:	e3833001 	orr	r3, r3, #1	; 0x1
    5b80:	e5823000 	str	r3, [r2]
	/* bit 1 is set already, from power up to power on */

	for (i = 0; i < 0x2000; i++) {
    5b84:	e3a03000 	mov	r3, #0	; 0x0
    5b88:	e50b3010 	str	r3, [fp, #-16]
    5b8c:	ea000002 	b	5b9c <MCI_Init+0x228>
    5b90:	e51b3010 	ldr	r3, [fp, #-16]
    5b94:	e2833001 	add	r3, r3, #1	; 0x1
    5b98:	e50b3010 	str	r3, [fp, #-16]
    5b9c:	e51b2010 	ldr	r2, [fp, #-16]
    5ba0:	e3a03d7f 	mov	r3, #8128	; 0x1fc0
    5ba4:	e283303f 	add	r3, r3, #63	; 0x3f
    5ba8:	e1520003 	cmp	r2, r3
    5bac:	9afffff7 	bls	5b90 <MCI_Init+0x21c>
		;
	}
	if (install_irq( MCI_INT, (void *)MCI_IRQHandler, HIGHEST_PRIORITY+1) == FALSE) {
    5bb0:	e3a00018 	mov	r0, #24	; 0x18
    5bb4:	e59f1034 	ldr	r1, [pc, #52]	; 5bf0 <MCI_Init+0x27c>
    5bb8:	e3a02002 	mov	r2, #2	; 0x2
    5bbc:	ebffebf0 	bl	b84 <install_irq>
    5bc0:	e1a03000 	mov	r3, r0
    5bc4:	e3530000 	cmp	r3, #0	; 0x0
    5bc8:	1a000002 	bne	5bd8 <MCI_Init+0x264>
		return ( FALSE );
    5bcc:	e3a03000 	mov	r3, #0	; 0x0
    5bd0:	e50b3014 	str	r3, [fp, #-20]
    5bd4:	ea000001 	b	5be0 <MCI_Init+0x26c>
	 disabled after the data block has been written and read. Please also note,
	 before WRITE_BLOCK only TX related data interrupts are enabled, and before
	 READ_BLOCK only RX related data interrupts are enabled. */

	mci_debug_printf("MCI_INIT ok\n");
	return ( TRUE );
    5bd8:	e3a03001 	mov	r3, #1	; 0x1
    5bdc:	e50b3014 	str	r3, [fp, #-20]
    5be0:	e51b3014 	ldr	r3, [fp, #-20]
}
    5be4:	e1a00003 	mov	r0, r3
    5be8:	e24bd00c 	sub	sp, fp, #12	; 0xc
    5bec:	e89da800 	ldm	sp, {fp, sp, pc}
    5bf0:	00005670 	.word	0x00005670

00005bf4 <MCI_SendCmd>:
 ** parameters:			CmdIndex, Argument, ExpectResp Flag, AllowTimeout flag
 ** Returned value:		None
 ** 
 ******************************************************************************/
void MCI_SendCmd(DWORD CmdIndex, DWORD Argument, DWORD ExpectResp,
		DWORD AllowTimeout) {
    5bf4:	e1a0c00d 	mov	ip, sp
    5bf8:	e92dd800 	push	{fp, ip, lr, pc}
    5bfc:	e24cb004 	sub	fp, ip, #4	; 0x4
    5c00:	e24dd01c 	sub	sp, sp, #28	; 0x1c
    5c04:	e50b001c 	str	r0, [fp, #-28]
    5c08:	e50b1020 	str	r1, [fp, #-32]
    5c0c:	e50b2024 	str	r2, [fp, #-36]
    5c10:	e50b3028 	str	r3, [fp, #-40]
	volatile DWORD i; // mthomas - volatile
	DWORD CmdData = 0;
    5c14:	e3a03000 	mov	r3, #0	; 0x0
    5c18:	e50b3014 	str	r3, [fp, #-20]
    5c1c:	ea000009 	b	5c48 <MCI_SendCmd+0x54>

	/* the command engine must be disabled when we modify the argument
	 or the peripheral resends */
	while ( (CmdStatus = MCI_STATUS) & MCI_CMD_ACTIVE) /* Command in progress. */
	{
		MCI_COMMAND = 0;
    5c20:	e3a032ce 	mov	r3, #-536870900	; 0xe000000c
    5c24:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5c28:	e3a02000 	mov	r2, #0	; 0x0
    5c2c:	e5832000 	str	r2, [r3]
		MCI_CLEAR = CmdStatus | MCI_CMD_ACTIVE;
    5c30:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5c34:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5c38:	e2833038 	add	r3, r3, #56	; 0x38
    5c3c:	e51b2010 	ldr	r2, [fp, #-16]
    5c40:	e3822b02 	orr	r2, r2, #2048	; 0x800
    5c44:	e5832000 	str	r2, [r3]
	DWORD CmdData = 0;
	DWORD CmdStatus;

	/* the command engine must be disabled when we modify the argument
	 or the peripheral resends */
	while ( (CmdStatus = MCI_STATUS) & MCI_CMD_ACTIVE) /* Command in progress. */
    5c48:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5c4c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5c50:	e2833034 	add	r3, r3, #52	; 0x34
    5c54:	e5933000 	ldr	r3, [r3]
    5c58:	e50b3010 	str	r3, [fp, #-16]
    5c5c:	e51b3010 	ldr	r3, [fp, #-16]
    5c60:	e2033b02 	and	r3, r3, #2048	; 0x800
    5c64:	e3530000 	cmp	r3, #0	; 0x0
    5c68:	1affffec 	bne	5c20 <MCI_SendCmd+0x2c>
	{
		MCI_COMMAND = 0;
		MCI_CLEAR = CmdStatus | MCI_CMD_ACTIVE;
	}
	for (i = 0; i < 0x100; i++) {
    5c6c:	e3a03000 	mov	r3, #0	; 0x0
    5c70:	e50b3018 	str	r3, [fp, #-24]
    5c74:	ea000002 	b	5c84 <MCI_SendCmd+0x90>
    5c78:	e51b3018 	ldr	r3, [fp, #-24]
    5c7c:	e2833001 	add	r3, r3, #1	; 0x1
    5c80:	e50b3018 	str	r3, [fp, #-24]
    5c84:	e51b3018 	ldr	r3, [fp, #-24]
    5c88:	e35300ff 	cmp	r3, #255	; 0xff
    5c8c:	9afffff9 	bls	5c78 <MCI_SendCmd+0x84>
		;
	}

	/*set the command details, the CmdIndex should 0 through 0x3F only */
	CmdData |= (CmdIndex & 0x3F); /* bit 0 through 5 only */
    5c90:	e51b301c 	ldr	r3, [fp, #-28]
    5c94:	e203203f 	and	r2, r3, #63	; 0x3f
    5c98:	e51b3014 	ldr	r3, [fp, #-20]
    5c9c:	e1833002 	orr	r3, r3, r2
    5ca0:	e50b3014 	str	r3, [fp, #-20]
	if (ExpectResp == EXPECT_NO_RESP) /* no response */
    5ca4:	e51b3024 	ldr	r3, [fp, #-36]
    5ca8:	e3530000 	cmp	r3, #0	; 0x0
    5cac:	1a000003 	bne	5cc0 <MCI_SendCmd+0xcc>
	{
		CmdData &= ~((1 << 6) | (1 << 7)); /* Clear long response bit as well */
    5cb0:	e51b3014 	ldr	r3, [fp, #-20]
    5cb4:	e3c330c0 	bic	r3, r3, #192	; 0xc0
    5cb8:	e50b3014 	str	r3, [fp, #-20]
    5cbc:	ea00000c 	b	5cf4 <MCI_SendCmd+0x100>
	} else if (ExpectResp == EXPECT_SHORT_RESP) /* expect short response */
    5cc0:	e51b3024 	ldr	r3, [fp, #-36]
    5cc4:	e3530001 	cmp	r3, #1	; 0x1
    5cc8:	1a000003 	bne	5cdc <MCI_SendCmd+0xe8>
	{
		CmdData |= (1 << 6);
    5ccc:	e51b3014 	ldr	r3, [fp, #-20]
    5cd0:	e3833040 	orr	r3, r3, #64	; 0x40
    5cd4:	e50b3014 	str	r3, [fp, #-20]
    5cd8:	ea000005 	b	5cf4 <MCI_SendCmd+0x100>
	} else if (ExpectResp == EXPECT_LONG_RESP) /* expect long response */
    5cdc:	e51b3024 	ldr	r3, [fp, #-36]
    5ce0:	e3530002 	cmp	r3, #2	; 0x2
    5ce4:	1a000002 	bne	5cf4 <MCI_SendCmd+0x100>
	{
		CmdData |= (1 << 6) | (1 << 7);
    5ce8:	e51b3014 	ldr	r3, [fp, #-20]
    5cec:	e38330c0 	orr	r3, r3, #192	; 0xc0
    5cf0:	e50b3014 	str	r3, [fp, #-20]
	}

	if (AllowTimeout) /* allow timeout or not */
    5cf4:	e51b3028 	ldr	r3, [fp, #-40]
    5cf8:	e3530000 	cmp	r3, #0	; 0x0
    5cfc:	0a000003 	beq	5d10 <MCI_SendCmd+0x11c>
	{
		CmdData |= (1 << 8);
    5d00:	e51b3014 	ldr	r3, [fp, #-20]
    5d04:	e3833c01 	orr	r3, r3, #256	; 0x100
    5d08:	e50b3014 	str	r3, [fp, #-20]
    5d0c:	ea000002 	b	5d1c <MCI_SendCmd+0x128>
	} else {
		CmdData &= ~(1 << 8);
    5d10:	e51b3014 	ldr	r3, [fp, #-20]
    5d14:	e3c33c01 	bic	r3, r3, #256	; 0x100
    5d18:	e50b3014 	str	r3, [fp, #-20]
	}

	/*send the command*/
	CmdData |= (1 << 10); /* This bit needs to be set last. */
    5d1c:	e51b3014 	ldr	r3, [fp, #-20]
    5d20:	e3833b01 	orr	r3, r3, #1024	; 0x400
    5d24:	e50b3014 	str	r3, [fp, #-20]
	MCI_ARGUMENT = Argument;
    5d28:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
    5d2c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5d30:	e51b2020 	ldr	r2, [fp, #-32]
    5d34:	e5832000 	str	r2, [r3]
	/* Set the argument first, finally command */
	MCI_COMMAND = CmdData;
    5d38:	e3a032ce 	mov	r3, #-536870900	; 0xe000000c
    5d3c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5d40:	e51b2014 	ldr	r2, [fp, #-20]
    5d44:	e5832000 	str	r2, [r3]

	return;
}
    5d48:	e24bd00c 	sub	sp, fp, #12	; 0xc
    5d4c:	e89da800 	ldm	sp, {fp, sp, pc}

00005d50 <MCI_GetCmdResp>:
 **						non-zero, no need to check the response field, just resend
 **						command or bailout. 
 ** Returned value:		Response status, 0 is valid response. 
 ** 
 ******************************************************************************/
DWORD MCI_GetCmdResp(DWORD ExpectCmdData, DWORD ExpectResp, DWORD *CmdResp) {
    5d50:	e1a0c00d 	mov	ip, sp
    5d54:	e92dd800 	push	{fp, ip, lr, pc}
    5d58:	e24cb004 	sub	fp, ip, #4	; 0x4
    5d5c:	e24dd018 	sub	sp, sp, #24	; 0x18
    5d60:	e50b0018 	str	r0, [fp, #-24]
    5d64:	e50b101c 	str	r1, [fp, #-28]
    5d68:	e50b2020 	str	r2, [fp, #-32]
	DWORD CmdRespStatus = 0;
    5d6c:	e3a03000 	mov	r3, #0	; 0x0
    5d70:	e50b3014 	str	r3, [fp, #-20]
	DWORD LastCmdIndex;

	if (ExpectResp == EXPECT_NO_RESP) {
    5d74:	e51b301c 	ldr	r3, [fp, #-28]
    5d78:	e3530000 	cmp	r3, #0	; 0x0
    5d7c:	1a000002 	bne	5d8c <MCI_GetCmdResp+0x3c>
		return ( 0 );
    5d80:	e3a03000 	mov	r3, #0	; 0x0
    5d84:	e50b3024 	str	r3, [fp, #-36]
    5d88:	ea00008b 	b	5fbc <MCI_GetCmdResp+0x26c>
	}

	while ( 1) {
		CmdRespStatus = MCI_STATUS;
    5d8c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5d90:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5d94:	e2833034 	add	r3, r3, #52	; 0x34
    5d98:	e5933000 	ldr	r3, [r3]
    5d9c:	e50b3014 	str	r3, [fp, #-20]
		if (CmdRespStatus & (MCI_CMD_TIMEOUT)) {
    5da0:	e51b3014 	ldr	r3, [fp, #-20]
    5da4:	e2033004 	and	r3, r3, #4	; 0x4
    5da8:	e3530000 	cmp	r3, #0	; 0x0
    5dac:	0a000010 	beq	5df4 <MCI_GetCmdResp+0xa4>
			MCI_CLEAR = CmdRespStatus | MCI_CMD_TIMEOUT;
    5db0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5db4:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5db8:	e2833038 	add	r3, r3, #56	; 0x38
    5dbc:	e51b2014 	ldr	r2, [fp, #-20]
    5dc0:	e3822004 	orr	r2, r2, #4	; 0x4
    5dc4:	e5832000 	str	r2, [r3]
			MCI_COMMAND = 0;
    5dc8:	e3a032ce 	mov	r3, #-536870900	; 0xe000000c
    5dcc:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5dd0:	e3a02000 	mov	r2, #0	; 0x0
    5dd4:	e5832000 	str	r2, [r3]
			MCI_ARGUMENT = 0xFFFFFFFF;
    5dd8:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
    5ddc:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5de0:	e3e02000 	mvn	r2, #0	; 0x0
    5de4:	e5832000 	str	r2, [r3]
			return (CmdRespStatus );
    5de8:	e51b3014 	ldr	r3, [fp, #-20]
    5dec:	e50b3024 	str	r3, [fp, #-36]
    5df0:	ea000071 	b	5fbc <MCI_GetCmdResp+0x26c>
		}
		if (CmdRespStatus & MCI_CMD_CRC_FAIL) {
    5df4:	e51b3014 	ldr	r3, [fp, #-20]
    5df8:	e2033001 	and	r3, r3, #1	; 0x1
    5dfc:	e20330ff 	and	r3, r3, #255	; 0xff
    5e00:	e3530000 	cmp	r3, #0	; 0x0
    5e04:	0a00001f 	beq	5e88 <MCI_GetCmdResp+0x138>
			MCI_CLEAR = CmdRespStatus | MCI_CMD_CRC_FAIL;
    5e08:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5e0c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5e10:	e2833038 	add	r3, r3, #56	; 0x38
    5e14:	e51b2014 	ldr	r2, [fp, #-20]
    5e18:	e3822001 	orr	r2, r2, #1	; 0x1
    5e1c:	e5832000 	str	r2, [r3]
			LastCmdIndex = MCI_COMMAND & 0x003F;
    5e20:	e3a032ce 	mov	r3, #-536870900	; 0xe000000c
    5e24:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5e28:	e5933000 	ldr	r3, [r3]
    5e2c:	e203303f 	and	r3, r3, #63	; 0x3f
    5e30:	e50b3010 	str	r3, [fp, #-16]
			if ( (LastCmdIndex == SEND_OP_COND) || (LastCmdIndex
    5e34:	e51b3010 	ldr	r3, [fp, #-16]
    5e38:	e3530001 	cmp	r3, #1	; 0x1
    5e3c:	0a000005 	beq	5e58 <MCI_GetCmdResp+0x108>
    5e40:	e51b3010 	ldr	r3, [fp, #-16]
    5e44:	e3530029 	cmp	r3, #41	; 0x29
    5e48:	0a000002 	beq	5e58 <MCI_GetCmdResp+0x108>
    5e4c:	e51b3010 	ldr	r3, [fp, #-16]
    5e50:	e353000c 	cmp	r3, #12	; 0xc
    5e54:	1a000008 	bne	5e7c <MCI_GetCmdResp+0x12c>
					== SEND_APP_OP_COND) || (LastCmdIndex == STOP_TRANSMISSION)) {
				MCI_COMMAND = 0;
    5e58:	e3a032ce 	mov	r3, #-536870900	; 0xe000000c
    5e5c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5e60:	e3a02000 	mov	r2, #0	; 0x0
    5e64:	e5832000 	str	r2, [r3]
				MCI_ARGUMENT = 0xFFFFFFFF;
    5e68:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
    5e6c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5e70:	e3e02000 	mvn	r2, #0	; 0x0
    5e74:	e5832000 	str	r2, [r3]
    5e78:	ea00000c 	b	5eb0 <MCI_GetCmdResp+0x160>
				break; /* ignore CRC error if it's a resp for SEND_OP_COND 
				 or STOP_TRANSMISSION. */
			} else {
				mci_debug_printf("*** CRCfail");
				return (CmdRespStatus );
    5e7c:	e51b3014 	ldr	r3, [fp, #-20]
    5e80:	e50b3024 	str	r3, [fp, #-36]
    5e84:	ea00004c 	b	5fbc <MCI_GetCmdResp+0x26c>
			}
		} else if (CmdRespStatus & MCI_CMD_RESP_END) {
    5e88:	e51b3014 	ldr	r3, [fp, #-20]
    5e8c:	e2033040 	and	r3, r3, #64	; 0x40
    5e90:	e3530000 	cmp	r3, #0	; 0x0
    5e94:	0affffbc 	beq	5d8c <MCI_GetCmdResp+0x3c>
			MCI_CLEAR = CmdRespStatus | MCI_CMD_RESP_END;
    5e98:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5e9c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5ea0:	e2833038 	add	r3, r3, #56	; 0x38
    5ea4:	e51b2014 	ldr	r2, [fp, #-20]
    5ea8:	e3822040 	orr	r2, r2, #64	; 0x40
    5eac:	e5832000 	str	r2, [r3]
			break; /* cmd response is received, expecting response */
		}
	}

	if ( (MCI_RESP_CMD & 0x3F) != ExpectCmdData) {
    5eb0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5eb4:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5eb8:	e2833010 	add	r3, r3, #16	; 0x10
    5ebc:	e5933000 	ldr	r3, [r3]
    5ec0:	e203203f 	and	r2, r3, #63	; 0x3f
    5ec4:	e51b3018 	ldr	r3, [fp, #-24]
    5ec8:	e1520003 	cmp	r2, r3
    5ecc:	0a000010 	beq	5f14 <MCI_GetCmdResp+0x1c4>
		/* If the response is not R1, in the response field, the Expected Cmd data
		 won't be the same as the CMD data in SendCmd(). Below four cmds have
		 R2 or R3 response. We don't need to check if MCI_RESP_CMD is the same
		 as the Expected or not. */
		if ( (ExpectCmdData != SEND_OP_COND) && (ExpectCmdData
    5ed0:	e51b3018 	ldr	r3, [fp, #-24]
    5ed4:	e3530001 	cmp	r3, #1	; 0x1
    5ed8:	0a00000d 	beq	5f14 <MCI_GetCmdResp+0x1c4>
    5edc:	e51b3018 	ldr	r3, [fp, #-24]
    5ee0:	e3530029 	cmp	r3, #41	; 0x29
    5ee4:	0a00000a 	beq	5f14 <MCI_GetCmdResp+0x1c4>
    5ee8:	e51b3018 	ldr	r3, [fp, #-24]
    5eec:	e3530002 	cmp	r3, #2	; 0x2
    5ef0:	0a000007 	beq	5f14 <MCI_GetCmdResp+0x1c4>
    5ef4:	e51b3018 	ldr	r3, [fp, #-24]
    5ef8:	e3530009 	cmp	r3, #9	; 0x9
    5efc:	0a000004 	beq	5f14 <MCI_GetCmdResp+0x1c4>
				!= SEND_APP_OP_COND) && (ExpectCmdData != ALL_SEND_CID)
				&& (ExpectCmdData != SEND_CSD)) {
			CmdRespStatus = INVALID_RESPONSE; /* Reuse error status */
    5f00:	e3e03000 	mvn	r3, #0	; 0x0
    5f04:	e50b3014 	str	r3, [fp, #-20]
			return ( INVALID_RESPONSE );
    5f08:	e3e03000 	mvn	r3, #0	; 0x0
    5f0c:	e50b3024 	str	r3, [fp, #-36]
    5f10:	ea000029 	b	5fbc <MCI_GetCmdResp+0x26c>
		}
	}

	if (ExpectResp == EXPECT_SHORT_RESP) {
    5f14:	e51b301c 	ldr	r3, [fp, #-28]
    5f18:	e3530001 	cmp	r3, #1	; 0x1
    5f1c:	1a000006 	bne	5f3c <MCI_GetCmdResp+0x1ec>
		*CmdResp = MCI_RESP0;
    5f20:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5f24:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5f28:	e2833014 	add	r3, r3, #20	; 0x14
    5f2c:	e5932000 	ldr	r2, [r3]
    5f30:	e51b3020 	ldr	r3, [fp, #-32]
    5f34:	e5832000 	str	r2, [r3]
    5f38:	ea00001d 	b	5fb4 <MCI_GetCmdResp+0x264>
	} else if (ExpectResp == EXPECT_LONG_RESP) {
    5f3c:	e51b301c 	ldr	r3, [fp, #-28]
    5f40:	e3530002 	cmp	r3, #2	; 0x2
    5f44:	1a00001a 	bne	5fb4 <MCI_GetCmdResp+0x264>
		*CmdResp = MCI_RESP0;
    5f48:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5f4c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5f50:	e2833014 	add	r3, r3, #20	; 0x14
    5f54:	e5932000 	ldr	r2, [r3]
    5f58:	e51b3020 	ldr	r3, [fp, #-32]
    5f5c:	e5832000 	str	r2, [r3]
		*(CmdResp+1) = MCI_RESP1;
    5f60:	e51b3020 	ldr	r3, [fp, #-32]
    5f64:	e2832004 	add	r2, r3, #4	; 0x4
    5f68:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5f6c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5f70:	e2833018 	add	r3, r3, #24	; 0x18
    5f74:	e5933000 	ldr	r3, [r3]
    5f78:	e5823000 	str	r3, [r2]
		*(CmdResp+2) = MCI_RESP2;
    5f7c:	e51b3020 	ldr	r3, [fp, #-32]
    5f80:	e2832008 	add	r2, r3, #8	; 0x8
    5f84:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5f88:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5f8c:	e283301c 	add	r3, r3, #28	; 0x1c
    5f90:	e5933000 	ldr	r3, [r3]
    5f94:	e5823000 	str	r3, [r2]
		*(CmdResp+3) = MCI_RESP3;
    5f98:	e51b3020 	ldr	r3, [fp, #-32]
    5f9c:	e283200c 	add	r2, r3, #12	; 0xc
    5fa0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5fa4:	e2833923 	add	r3, r3, #573440	; 0x8c000
    5fa8:	e2833020 	add	r3, r3, #32	; 0x20
    5fac:	e5933000 	ldr	r3, [r3]
    5fb0:	e5823000 	str	r3, [r2]
	}
	return ( 0 ); /* Read MCI_RESP0 register assuming it's not long response. */
    5fb4:	e3a03000 	mov	r3, #0	; 0x0
    5fb8:	e50b3024 	str	r3, [fp, #-36]
    5fbc:	e51b3024 	ldr	r3, [fp, #-36]
}
    5fc0:	e1a00003 	mov	r0, r3
    5fc4:	e24bd00c 	sub	sp, fp, #12	; 0xc
    5fc8:	e89da800 	ldm	sp, {fp, sp, pc}

00005fcc <MCI_Go_Idle_State>:
 **
 ** parameters:			None
 ** Returned value:		true or false, true if card has been initialized.
 ** 
 ******************************************************************************/
DWORD MCI_Go_Idle_State(void) {
    5fcc:	e1a0c00d 	mov	ip, sp
    5fd0:	e92dd800 	push	{fp, ip, lr, pc}
    5fd4:	e24cb004 	sub	fp, ip, #4	; 0x4
    5fd8:	e24dd01c 	sub	sp, sp, #28	; 0x1c
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
    5fdc:	e3a03020 	mov	r3, #32	; 0x20
    5fe0:	e50b3014 	str	r3, [fp, #-20]
    5fe4:	ea000011 	b	6030 <MCI_Go_Idle_State+0x64>
	while (retryCount > 0) {
		/* Send CMD0 command repeatedly until the response is back correctly */
		MCI_SendCmd( GO_IDLE_STATE, 0x00000000, EXPECT_NO_RESP, 0);
    5fe8:	e3a00000 	mov	r0, #0	; 0x0
    5fec:	e3a01000 	mov	r1, #0	; 0x0
    5ff0:	e3a02000 	mov	r2, #0	; 0x0
    5ff4:	e3a03000 	mov	r3, #0	; 0x0
    5ff8:	ebfffefd 	bl	5bf4 <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( GO_IDLE_STATE, EXPECT_NO_RESP, (DWORD *)respValue);
    5ffc:	e24b3024 	sub	r3, fp, #36	; 0x24
    6000:	e3a00000 	mov	r0, #0	; 0x0
    6004:	e3a01000 	mov	r1, #0	; 0x0
    6008:	e1a02003 	mov	r2, r3
    600c:	ebffff4f 	bl	5d50 <MCI_GetCmdResp>
    6010:	e1a03000 	mov	r3, r0
    6014:	e50b3010 	str	r3, [fp, #-16]
		if (respStatus == 0) {
    6018:	e51b3010 	ldr	r3, [fp, #-16]
    601c:	e3530000 	cmp	r3, #0	; 0x0
    6020:	0a000005 	beq	603c <MCI_Go_Idle_State+0x70>
			break;
		}
		retryCount--;
    6024:	e51b3014 	ldr	r3, [fp, #-20]
    6028:	e2433001 	sub	r3, r3, #1	; 0x1
    602c:	e50b3014 	str	r3, [fp, #-20]
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
    6030:	e51b3014 	ldr	r3, [fp, #-20]
    6034:	e3530000 	cmp	r3, #0	; 0x0
    6038:	1affffea 	bne	5fe8 <MCI_Go_Idle_State+0x1c>
			break;
		}
		retryCount--;
	}

	if (respStatus != 0) /* timeout, give up */
    603c:	e51b3010 	ldr	r3, [fp, #-16]
    6040:	e3530000 	cmp	r3, #0	; 0x0
    6044:	0a000002 	beq	6054 <MCI_Go_Idle_State+0x88>
	{
		mci_debug_printf("Timeout go idle\n");
		return ( FALSE );
    6048:	e3a03000 	mov	r3, #0	; 0x0
    604c:	e50b3028 	str	r3, [fp, #-40]
    6050:	ea000001 	b	605c <MCI_Go_Idle_State+0x90>
	}
	return ( TRUE );
    6054:	e3a03001 	mov	r3, #1	; 0x1
    6058:	e50b3028 	str	r3, [fp, #-40]
    605c:	e51b3028 	ldr	r3, [fp, #-40]
}
    6060:	e1a00003 	mov	r0, r3
    6064:	e24bd00c 	sub	sp, fp, #12	; 0xc
    6068:	e89da800 	ldm	sp, {fp, sp, pc}

0000606c <MCI_Send_OP_Cond>:
 ** Returned value:		true or false, true if card has response back before
 **						timeout, false is timeout on the command.
 ** 
 ******************************************************************************/
// mthomas - static
static DWORD MCI_Send_OP_Cond(void) {
    606c:	e1a0c00d 	mov	ip, sp
    6070:	e92dd800 	push	{fp, ip, lr, pc}
    6074:	e24cb004 	sub	fp, ip, #4	; 0x4
    6078:	e24dd020 	sub	sp, sp, #32	; 0x20
	volatile DWORD i; // mthomas - volatile
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x200; /* reset retry counter */
    607c:	e3a03c02 	mov	r3, #512	; 0x200
    6080:	e50b3014 	str	r3, [fp, #-20]
    6084:	ea000022 	b	6114 <MCI_Send_OP_Cond+0xa8>
	while (retryCount > 0) {
		/* Send CMD1 command repeatedly until the response is back correctly */
		MCI_SendCmd( SEND_OP_COND, OCR_INDEX, EXPECT_SHORT_RESP, 0);
    6088:	e3a00001 	mov	r0, #1	; 0x1
    608c:	e3a018ff 	mov	r1, #16711680	; 0xff0000
    6090:	e2811902 	add	r1, r1, #32768	; 0x8000
    6094:	e3a02001 	mov	r2, #1	; 0x1
    6098:	e3a03000 	mov	r3, #0	; 0x0
    609c:	ebfffed4 	bl	5bf4 <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SEND_OP_COND, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    60a0:	e24b3028 	sub	r3, fp, #40	; 0x28
    60a4:	e3a00001 	mov	r0, #1	; 0x1
    60a8:	e3a01001 	mov	r1, #1	; 0x1
    60ac:	e1a02003 	mov	r2, r3
    60b0:	ebffff26 	bl	5d50 <MCI_GetCmdResp>
    60b4:	e1a03000 	mov	r3, r0
    60b8:	e50b3010 	str	r3, [fp, #-16]
		/* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
		if ( !(respStatus & MCI_CMD_TIMEOUT) && (respValue[0] & 0x80000000)) {
    60bc:	e51b3010 	ldr	r3, [fp, #-16]
    60c0:	e2033004 	and	r3, r3, #4	; 0x4
    60c4:	e3530000 	cmp	r3, #0	; 0x0
    60c8:	1a000005 	bne	60e4 <MCI_Send_OP_Cond+0x78>
    60cc:	e51b3028 	ldr	r3, [fp, #-40]
    60d0:	e3530000 	cmp	r3, #0	; 0x0
    60d4:	aa000002 	bge	60e4 <MCI_Send_OP_Cond+0x78>
			return ( TRUE ); /* response is back and correct. */
    60d8:	e3a03001 	mov	r3, #1	; 0x1
    60dc:	e50b302c 	str	r3, [fp, #-44]
    60e0:	ea000010 	b	6128 <MCI_Send_OP_Cond+0xbc>
		}
		for (i = 0; i < 0x20; i++)
    60e4:	e3a03000 	mov	r3, #0	; 0x0
    60e8:	e50b3018 	str	r3, [fp, #-24]
    60ec:	ea000002 	b	60fc <MCI_Send_OP_Cond+0x90>
    60f0:	e51b3018 	ldr	r3, [fp, #-24]
    60f4:	e2833001 	add	r3, r3, #1	; 0x1
    60f8:	e50b3018 	str	r3, [fp, #-24]
    60fc:	e51b3018 	ldr	r3, [fp, #-24]
    6100:	e353001f 	cmp	r3, #31	; 0x1f
    6104:	9afffff9 	bls	60f0 <MCI_Send_OP_Cond+0x84>
			;
		retryCount--;
    6108:	e51b3014 	ldr	r3, [fp, #-20]
    610c:	e2433001 	sub	r3, r3, #1	; 0x1
    6110:	e50b3014 	str	r3, [fp, #-20]
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x200; /* reset retry counter */
	while (retryCount > 0) {
    6114:	e51b3014 	ldr	r3, [fp, #-20]
    6118:	e3530000 	cmp	r3, #0	; 0x0
    611c:	1affffd9 	bne	6088 <MCI_Send_OP_Cond+0x1c>
		}
		for (i = 0; i < 0x20; i++)
			;
		retryCount--;
	}
	return ( FALSE );
    6120:	e3a03000 	mov	r3, #0	; 0x0
    6124:	e50b302c 	str	r3, [fp, #-44]
    6128:	e51b302c 	ldr	r3, [fp, #-44]
}
    612c:	e1a00003 	mov	r0, r3
    6130:	e24bd00c 	sub	sp, fp, #12	; 0xc
    6134:	e89da800 	ldm	sp, {fp, sp, pc}

00006138 <MCI_Send_ACMD>:
 ** Returned value:		true or false, true if card has responded before timeout.
 **						false is timeout.
 ** 
 ******************************************************************************/
// mthomas - static
static DWORD MCI_Send_ACMD(void) {
    6138:	e1a0c00d 	mov	ip, sp
    613c:	e92dd800 	push	{fp, ip, lr, pc}
    6140:	e24cb004 	sub	fp, ip, #4	; 0x4
    6144:	e24dd024 	sub	sp, sp, #36	; 0x24

	// mthomas - warning: MCI_CardType may be set from
	// extern to other than UNKOWN and this
	// will fail on init (workaround: added MCI_CardType = UNKNOWN below)
	// laebi: add CardType SDHC_CARD, otherwise it wouldnt work
	if (MCI_CardType == SD_CARD || MCI_CardType == SDHC_CARD) {
    6148:	e59f30e8 	ldr	r3, [pc, #232]	; 6238 <MCI_Send_ACMD+0x100>
    614c:	e5933000 	ldr	r3, [r3]
    6150:	e3530002 	cmp	r3, #2	; 0x2
    6154:	0a000003 	beq	6168 <MCI_Send_ACMD+0x30>
    6158:	e59f30d8 	ldr	r3, [pc, #216]	; 6238 <MCI_Send_ACMD+0x100>
    615c:	e5933000 	ldr	r3, [r3]
    6160:	e3530004 	cmp	r3, #4	; 0x4
    6164:	1a000003 	bne	6178 <MCI_Send_ACMD+0x40>
		CmdArgument = CardRCA; /* Use the address from SET_RELATIVE_ADDR cmd */
    6168:	e59f30cc 	ldr	r3, [pc, #204]	; 623c <MCI_Send_ACMD+0x104>
    616c:	e5933000 	ldr	r3, [r3]
    6170:	e50b3014 	str	r3, [fp, #-20]
    6174:	ea000001 	b	6180 <MCI_Send_ACMD+0x48>
	} else /* if MMC or unknown card type, use 0x0. */
	{
		CmdArgument = 0x00000000;
    6178:	e3a03000 	mov	r3, #0	; 0x0
    617c:	e50b3014 	str	r3, [fp, #-20]
	}

	retryCount = 20;
    6180:	e3a03014 	mov	r3, #20	; 0x14
    6184:	e50b3018 	str	r3, [fp, #-24]
    6188:	ea000021 	b	6214 <MCI_Send_ACMD+0xdc>
	while (retryCount > 0) {
		/* Send CMD55 command followed by an ACMD */
		MCI_SendCmd( APP_CMD, CmdArgument, EXPECT_SHORT_RESP, 0);
    618c:	e3a00037 	mov	r0, #55	; 0x37
    6190:	e51b1014 	ldr	r1, [fp, #-20]
    6194:	e3a02001 	mov	r2, #1	; 0x1
    6198:	e3a03000 	mov	r3, #0	; 0x0
    619c:	ebfffe94 	bl	5bf4 <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( APP_CMD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    61a0:	e24b302c 	sub	r3, fp, #44	; 0x2c
    61a4:	e3a00037 	mov	r0, #55	; 0x37
    61a8:	e3a01001 	mov	r1, #1	; 0x1
    61ac:	e1a02003 	mov	r2, r3
    61b0:	ebfffee6 	bl	5d50 <MCI_GetCmdResp>
    61b4:	e1a03000 	mov	r3, r0
    61b8:	e50b3010 	str	r3, [fp, #-16]
		if ( !respStatus && (respValue[0] & CARD_STATUS_ACMD_ENABLE)) /* Check if APP_CMD enabled */
    61bc:	e51b3010 	ldr	r3, [fp, #-16]
    61c0:	e3530000 	cmp	r3, #0	; 0x0
    61c4:	1a000006 	bne	61e4 <MCI_Send_ACMD+0xac>
    61c8:	e51b302c 	ldr	r3, [fp, #-44]
    61cc:	e2033020 	and	r3, r3, #32	; 0x20
    61d0:	e3530000 	cmp	r3, #0	; 0x0
    61d4:	0a000002 	beq	61e4 <MCI_Send_ACMD+0xac>
		{
			return ( TRUE );
    61d8:	e3a03001 	mov	r3, #1	; 0x1
    61dc:	e50b3030 	str	r3, [fp, #-48]
    61e0:	ea000010 	b	6228 <MCI_Send_ACMD+0xf0>
		}
		for (i = 0; i < 0x20; i++) {
    61e4:	e3a03000 	mov	r3, #0	; 0x0
    61e8:	e50b301c 	str	r3, [fp, #-28]
    61ec:	ea000002 	b	61fc <MCI_Send_ACMD+0xc4>
    61f0:	e51b301c 	ldr	r3, [fp, #-28]
    61f4:	e2833001 	add	r3, r3, #1	; 0x1
    61f8:	e50b301c 	str	r3, [fp, #-28]
    61fc:	e51b301c 	ldr	r3, [fp, #-28]
    6200:	e353001f 	cmp	r3, #31	; 0x1f
    6204:	9afffff9 	bls	61f0 <MCI_Send_ACMD+0xb8>
			;
		}
		retryCount--;
    6208:	e51b3018 	ldr	r3, [fp, #-24]
    620c:	e2433001 	sub	r3, r3, #1	; 0x1
    6210:	e50b3018 	str	r3, [fp, #-24]
	{
		CmdArgument = 0x00000000;
	}

	retryCount = 20;
	while (retryCount > 0) {
    6214:	e51b3018 	ldr	r3, [fp, #-24]
    6218:	e3530000 	cmp	r3, #0	; 0x0
    621c:	1affffda 	bne	618c <MCI_Send_ACMD+0x54>
		for (i = 0; i < 0x20; i++) {
			;
		}
		retryCount--;
	}
	return ( FALSE );
    6220:	e3a03000 	mov	r3, #0	; 0x0
    6224:	e50b3030 	str	r3, [fp, #-48]
    6228:	e51b3030 	ldr	r3, [fp, #-48]
}
    622c:	e1a00003 	mov	r0, r3
    6230:	e24bd00c 	sub	sp, fp, #12	; 0xc
    6234:	e89da800 	ldm	sp, {fp, sp, pc}
    6238:	40000050 	.word	0x40000050
    623c:	4000004c 	.word	0x4000004c

00006240 <MCI_Send_ACMD_OP_Cond>:
 **						respValue[0] in resp0
 ** 
 ** modified by Martin Thomas (in: arg, out resp0)
 ******************************************************************************/
// mthomas - static
static DWORD MCI_Send_ACMD_OP_Cond(DWORD acmd41_arg, DWORD *resp0) {
    6240:	e1a0c00d 	mov	ip, sp
    6244:	e92dd800 	push	{fp, ip, lr, pc}
    6248:	e24cb004 	sub	fp, ip, #4	; 0x4
    624c:	e24dd028 	sub	sp, sp, #40	; 0x28
    6250:	e50b002c 	str	r0, [fp, #-44]
    6254:	e50b1030 	str	r1, [fp, #-48]
	DWORD respValue[4];

	/* timeout on SEND_OP_COND command on MMC, now, try SEND_APP_OP_COND 
	 command to SD */
	// mthomas - less retries retryCount = 0x200;			/* reset retry counter */
	retryCount = 0x50;
    6258:	e3a03050 	mov	r3, #80	; 0x50
    625c:	e50b3014 	str	r3, [fp, #-20]
    6260:	ea000041 	b	636c <MCI_Send_ACMD_OP_Cond+0x12c>
	while (retryCount > 0) {
		MCI_POWER &= ~(1 << 6 );
    6264:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    6268:	e2822923 	add	r2, r2, #573440	; 0x8c000
    626c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    6270:	e2833923 	add	r3, r3, #573440	; 0x8c000
    6274:	e5933000 	ldr	r3, [r3]
    6278:	e3c33040 	bic	r3, r3, #64	; 0x40
    627c:	e5823000 	str	r3, [r2]
		/* Clear Open Drain output control for SD */
		for (i = 0; i < 0x3000; i++) {
    6280:	e3a03000 	mov	r3, #0	; 0x0
    6284:	e50b3018 	str	r3, [fp, #-24]
    6288:	ea000002 	b	6298 <MCI_Send_ACMD_OP_Cond+0x58>
    628c:	e51b3018 	ldr	r3, [fp, #-24]
    6290:	e2833001 	add	r3, r3, #1	; 0x1
    6294:	e50b3018 	str	r3, [fp, #-24]
    6298:	e51b2018 	ldr	r2, [fp, #-24]
    629c:	e3a03dbf 	mov	r3, #12224	; 0x2fc0
    62a0:	e283303f 	add	r3, r3, #63	; 0x3f
    62a4:	e1520003 	cmp	r2, r3
    62a8:	9afffff7 	bls	628c <MCI_Send_ACMD_OP_Cond+0x4c>
			;
		}

		if (MCI_Send_ACMD() == FALSE) {
    62ac:	ebffffa1 	bl	6138 <MCI_Send_ACMD>
    62b0:	e1a03000 	mov	r3, r0
    62b4:	e3530000 	cmp	r3, #0	; 0x0
    62b8:	1a000003 	bne	62cc <MCI_Send_ACMD_OP_Cond+0x8c>
			retryCount--; // mthomas - line added
    62bc:	e51b3014 	ldr	r3, [fp, #-20]
    62c0:	e2433001 	sub	r3, r3, #1	; 0x1
    62c4:	e50b3014 	str	r3, [fp, #-20]
    62c8:	ea000027 	b	636c <MCI_Send_ACMD_OP_Cond+0x12c>
			continue;
		}

		/* Send ACMD41 command repeatedly until the response is back correctly */
		// MCI_SendCmd( SEND_APP_OP_COND, OCR_INDEX, EXPECT_SHORT_RESP, 0 );
		MCI_SendCmd( SEND_APP_OP_COND, acmd41_arg, EXPECT_SHORT_RESP, 0);
    62cc:	e3a00029 	mov	r0, #41	; 0x29
    62d0:	e51b102c 	ldr	r1, [fp, #-44]
    62d4:	e3a02001 	mov	r2, #1	; 0x1
    62d8:	e3a03000 	mov	r3, #0	; 0x0
    62dc:	ebfffe44 	bl	5bf4 <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SEND_APP_OP_COND, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    62e0:	e24b3028 	sub	r3, fp, #40	; 0x28
    62e4:	e3a00029 	mov	r0, #41	; 0x29
    62e8:	e3a01001 	mov	r1, #1	; 0x1
    62ec:	e1a02003 	mov	r2, r3
    62f0:	ebfffe96 	bl	5d50 <MCI_GetCmdResp>
    62f4:	e1a03000 	mov	r3, r0
    62f8:	e50b3010 	str	r3, [fp, #-16]
		if ( !(respStatus & MCI_CMD_TIMEOUT) && (respValue[0] & 0x80000000)) {
    62fc:	e51b3010 	ldr	r3, [fp, #-16]
    6300:	e2033004 	and	r3, r3, #4	; 0x4
    6304:	e3530000 	cmp	r3, #0	; 0x0
    6308:	1a00000b 	bne	633c <MCI_Send_ACMD_OP_Cond+0xfc>
    630c:	e51b3028 	ldr	r3, [fp, #-40]
    6310:	e3530000 	cmp	r3, #0	; 0x0
    6314:	aa000008 	bge	633c <MCI_Send_ACMD_OP_Cond+0xfc>
			if (resp0 != NULL) {
    6318:	e51b3030 	ldr	r3, [fp, #-48]
    631c:	e3530000 	cmp	r3, #0	; 0x0
    6320:	0a000002 	beq	6330 <MCI_Send_ACMD_OP_Cond+0xf0>
				*resp0 = respValue[0];
    6324:	e51b2028 	ldr	r2, [fp, #-40]
    6328:	e51b3030 	ldr	r3, [fp, #-48]
    632c:	e5832000 	str	r2, [r3]
			}
			return ( TRUE ); /* response is back and correct. */
    6330:	e3a03001 	mov	r3, #1	; 0x1
    6334:	e50b3034 	str	r3, [fp, #-52]
    6338:	ea000010 	b	6380 <MCI_Send_ACMD_OP_Cond+0x140>
		}
		for (i = 0; i < 0x20; i++) {
    633c:	e3a03000 	mov	r3, #0	; 0x0
    6340:	e50b3018 	str	r3, [fp, #-24]
    6344:	ea000002 	b	6354 <MCI_Send_ACMD_OP_Cond+0x114>
    6348:	e51b3018 	ldr	r3, [fp, #-24]
    634c:	e2833001 	add	r3, r3, #1	; 0x1
    6350:	e50b3018 	str	r3, [fp, #-24]
    6354:	e51b3018 	ldr	r3, [fp, #-24]
    6358:	e353001f 	cmp	r3, #31	; 0x1f
    635c:	9afffff9 	bls	6348 <MCI_Send_ACMD_OP_Cond+0x108>
			;
		}
		retryCount--;
    6360:	e51b3014 	ldr	r3, [fp, #-20]
    6364:	e2433001 	sub	r3, r3, #1	; 0x1
    6368:	e50b3014 	str	r3, [fp, #-20]

	/* timeout on SEND_OP_COND command on MMC, now, try SEND_APP_OP_COND 
	 command to SD */
	// mthomas - less retries retryCount = 0x200;			/* reset retry counter */
	retryCount = 0x50;
	while (retryCount > 0) {
    636c:	e51b3014 	ldr	r3, [fp, #-20]
    6370:	e3530000 	cmp	r3, #0	; 0x0
    6374:	1affffba 	bne	6264 <MCI_Send_ACMD_OP_Cond+0x24>
		for (i = 0; i < 0x20; i++) {
			;
		}
		retryCount--;
	}
	return ( FALSE );
    6378:	e3a03000 	mov	r3, #0	; 0x0
    637c:	e50b3034 	str	r3, [fp, #-52]
    6380:	e51b3034 	ldr	r3, [fp, #-52]
}
    6384:	e1a00003 	mov	r0, r3
    6388:	e24bd00c 	sub	sp, fp, #12	; 0xc
    638c:	e89da800 	ldm	sp, {fp, sp, pc}

00006390 <MCI_Send_IF_Cond>:
 **
 ** added by Martin Thomas with information from Juri Haberland, Chan and
 ** the SanDisk Product Manuals V2.2
 ******************************************************************************/
// mthomas - static
static DWORD MCI_Send_IF_Cond(void) {
    6390:	e1a0c00d 	mov	ip, sp
    6394:	e92dd800 	push	{fp, ip, lr, pc}
    6398:	e24cb004 	sub	fp, ip, #4	; 0x4
    639c:	e24dd020 	sub	sp, sp, #32	; 0x20
	volatile DWORD i; // mthomas - volatile
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 20; /* reset retry counter */
    63a0:	e3a03014 	mov	r3, #20	; 0x14
    63a4:	e50b3014 	str	r3, [fp, #-20]
    63a8:	ea000031 	b	6474 <MCI_Send_IF_Cond+0xe4>
	while (retryCount > 0) {
		MCI_POWER &= ~(1 << 6 );
    63ac:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    63b0:	e2822923 	add	r2, r2, #573440	; 0x8c000
    63b4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    63b8:	e2833923 	add	r3, r3, #573440	; 0x8c000
    63bc:	e5933000 	ldr	r3, [r3]
    63c0:	e3c33040 	bic	r3, r3, #64	; 0x40
    63c4:	e5823000 	str	r3, [r2]
		/* Clear Open Drain output control for SD */
		for (i = 0; i < 0x3000; i++) {
    63c8:	e3a03000 	mov	r3, #0	; 0x0
    63cc:	e50b3018 	str	r3, [fp, #-24]
    63d0:	ea000002 	b	63e0 <MCI_Send_IF_Cond+0x50>
    63d4:	e51b3018 	ldr	r3, [fp, #-24]
    63d8:	e2833001 	add	r3, r3, #1	; 0x1
    63dc:	e50b3018 	str	r3, [fp, #-24]
    63e0:	e51b2018 	ldr	r2, [fp, #-24]
    63e4:	e3a03dbf 	mov	r3, #12224	; 0x2fc0
    63e8:	e283303f 	add	r3, r3, #63	; 0x3f
    63ec:	e1520003 	cmp	r2, r3
    63f0:	9afffff7 	bls	63d4 <MCI_Send_IF_Cond+0x44>
			;
		}

		/* Send CMD8 command repeatedly until the response is back correctly or timeout */
		MCI_SendCmd( SEND_IF_COND, SEND_IF_COND_ARG , EXPECT_SHORT_RESP, 0);
    63f4:	e3a00008 	mov	r0, #8	; 0x8
    63f8:	e3a01f6a 	mov	r1, #424	; 0x1a8
    63fc:	e2811002 	add	r1, r1, #2	; 0x2
    6400:	e3a02001 	mov	r2, #1	; 0x1
    6404:	e3a03000 	mov	r3, #0	; 0x0
    6408:	ebfffdf9 	bl	5bf4 <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SEND_IF_COND, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    640c:	e24b3028 	sub	r3, fp, #40	; 0x28
    6410:	e3a00008 	mov	r0, #8	; 0x8
    6414:	e3a01001 	mov	r1, #1	; 0x1
    6418:	e1a02003 	mov	r2, r3
    641c:	ebfffe4b 	bl	5d50 <MCI_GetCmdResp>
    6420:	e1a03000 	mov	r3, r0
    6424:	e50b3010 	str	r3, [fp, #-16]
		/* mthomas TODO: check result bits - for now just check if no timeout */
		if ( !(respStatus & MCI_CMD_TIMEOUT)) {
    6428:	e51b3010 	ldr	r3, [fp, #-16]
    642c:	e2033004 	and	r3, r3, #4	; 0x4
    6430:	e3530000 	cmp	r3, #0	; 0x0
    6434:	1a000002 	bne	6444 <MCI_Send_IF_Cond+0xb4>
			return ( TRUE ); /* response is back and correct. */
    6438:	e3a03001 	mov	r3, #1	; 0x1
    643c:	e50b302c 	str	r3, [fp, #-44]
    6440:	ea000010 	b	6488 <MCI_Send_IF_Cond+0xf8>
		}
		for (i = 0; i < 0x20; i++)
    6444:	e3a03000 	mov	r3, #0	; 0x0
    6448:	e50b3018 	str	r3, [fp, #-24]
    644c:	ea000002 	b	645c <MCI_Send_IF_Cond+0xcc>
    6450:	e51b3018 	ldr	r3, [fp, #-24]
    6454:	e2833001 	add	r3, r3, #1	; 0x1
    6458:	e50b3018 	str	r3, [fp, #-24]
    645c:	e51b3018 	ldr	r3, [fp, #-24]
    6460:	e353001f 	cmp	r3, #31	; 0x1f
    6464:	9afffff9 	bls	6450 <MCI_Send_IF_Cond+0xc0>
			;
		retryCount--;
    6468:	e51b3014 	ldr	r3, [fp, #-20]
    646c:	e2433001 	sub	r3, r3, #1	; 0x1
    6470:	e50b3014 	str	r3, [fp, #-20]
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 20; /* reset retry counter */
	while (retryCount > 0) {
    6474:	e51b3014 	ldr	r3, [fp, #-20]
    6478:	e3530000 	cmp	r3, #0	; 0x0
    647c:	1affffca 	bne	63ac <MCI_Send_IF_Cond+0x1c>
		}
		for (i = 0; i < 0x20; i++)
			;
		retryCount--;
	}
	return ( FALSE );
    6480:	e3a03000 	mov	r3, #0	; 0x0
    6484:	e50b302c 	str	r3, [fp, #-44]
    6488:	e51b302c 	ldr	r3, [fp, #-44]
}
    648c:	e1a00003 	mov	r0, r3
    6490:	e24bd00c 	sub	sp, fp, #12	; 0xc
    6494:	e89da800 	ldm	sp, {fp, sp, pc}

00006498 <MCI_CardInit>:
 ** 
 ** extended by Martin Thomas with information from Juri Haberland,
 ** public available Information for SDHC, Chan's fat-code and 
 ** the SanDisk SD-Card manual V2.2
 ******************************************************************************/
DWORD MCI_CardInit(void) {
    6498:	e1a0c00d 	mov	ip, sp
    649c:	e92dd800 	push	{fp, ip, lr, pc}
    64a0:	e24cb004 	sub	fp, ip, #4	; 0x4
    64a4:	e24dd014 	sub	sp, sp, #20	; 0x14
	volatile DWORD i;
	DWORD CardType= CARD_UNKNOWN;
    64a8:	e3a03000 	mov	r3, #0	; 0x0
    64ac:	e50b3014 	str	r3, [fp, #-20]
	DWORD acmd41_arg;
	DWORD resp0;

	MCI_CardType = CARD_UNKNOWN;
    64b0:	e59f211c 	ldr	r2, [pc, #284]	; 65d4 <MCI_CardInit+0x13c>
    64b4:	e3a03000 	mov	r3, #0	; 0x0
    64b8:	e5823000 	str	r3, [r2]

	if (MCI_Go_Idle_State() == FALSE) {
    64bc:	ebfffec2 	bl	5fcc <MCI_Go_Idle_State>
    64c0:	e1a03000 	mov	r3, r0
    64c4:	e3530000 	cmp	r3, #0	; 0x0
    64c8:	1a000002 	bne	64d8 <MCI_CardInit+0x40>
		mci_debug_printf("Init Go Idle failed\n");
		return ( CARD_UNKNOWN );
    64cc:	e3a03000 	mov	r3, #0	; 0x0
    64d0:	e50b3020 	str	r3, [fp, #-32]
    64d4:	ea00003a 	b	65c4 <MCI_CardInit+0x12c>
	}

	if (MCI_Send_IF_Cond() == TRUE) {
    64d8:	ebffffac 	bl	6390 <MCI_Send_IF_Cond>
    64dc:	e1a03000 	mov	r3, r0
    64e0:	e3530001 	cmp	r3, #1	; 0x1
    64e4:	1a000005 	bne	6500 <MCI_CardInit+0x68>
		mci_debug_printf("no timeout on CMD8 -> SD-Card>=Version 2.0\n");
		CardType = SDV2_CARD;
    64e8:	e3a03008 	mov	r3, #8	; 0x8
    64ec:	e50b3014 	str	r3, [fp, #-20]
		acmd41_arg = OCR_CARD_HIGH_CAPACITY | OCR_HIGH_VOLTAGE_RANGE;
    64f0:	e3a03441 	mov	r3, #1090519040	; 0x41000000
    64f4:	e2433902 	sub	r3, r3, #32768	; 0x8000
    64f8:	e50b3010 	str	r3, [fp, #-16]
    64fc:	ea000002 	b	650c <MCI_CardInit+0x74>
	} else {
		mci_debug_printf("timout CMD8 -> SD-Card<Version 2.0 or MMC\n");
		acmd41_arg = OCR_HIGH_VOLTAGE_RANGE;
    6500:	e3a038ff 	mov	r3, #16711680	; 0xff0000
    6504:	e2833902 	add	r3, r3, #32768	; 0x8000
    6508:	e50b3010 	str	r3, [fp, #-16]
	}

	if (MCI_Send_ACMD_OP_Cond(acmd41_arg, &resp0) == TRUE) {
    650c:	e24b301c 	sub	r3, fp, #28	; 0x1c
    6510:	e51b0010 	ldr	r0, [fp, #-16]
    6514:	e1a01003 	mov	r1, r3
    6518:	ebffff48 	bl	6240 <MCI_Send_ACMD_OP_Cond>
    651c:	e1a03000 	mov	r3, r0
    6520:	e3530001 	cmp	r3, #1	; 0x1
    6524:	1a000009 	bne	6550 <MCI_CardInit+0xb8>
		mci_debug_printf("ACMD41 success -> SD-Card SC or HC\n");
		if (resp0 & OCR_CARD_HIGH_CAPACITY) {
    6528:	e51b301c 	ldr	r3, [fp, #-28]
    652c:	e2033101 	and	r3, r3, #1073741824	; 0x40000000
    6530:	e3530000 	cmp	r3, #0	; 0x0
    6534:	0a000002 	beq	6544 <MCI_CardInit+0xac>
			mci_debug_printf("SDHC detected - EXPERIMENTAL!\n");
			CardType = SDHC_CARD;
    6538:	e3a03004 	mov	r3, #4	; 0x4
    653c:	e50b3014 	str	r3, [fp, #-20]
    6540:	ea00001a 	b	65b0 <MCI_CardInit+0x118>
		} else {
			mci_debug_printf("SDSC detected\n");
			CardType = SDSC_CARD;
    6544:	e3a03002 	mov	r3, #2	; 0x2
    6548:	e50b3014 	str	r3, [fp, #-20]
    654c:	ea000017 	b	65b0 <MCI_CardInit+0x118>
		}
	} else {
		mci_debug_printf("MCI_Send_ACMD failed -> MMC, invalid power-range or no card\n");
		MCI_POWER |= (1 << 6 );
    6550:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    6554:	e2822923 	add	r2, r2, #573440	; 0x8c000
    6558:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    655c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    6560:	e5933000 	ldr	r3, [r3]
    6564:	e3833040 	orr	r3, r3, #64	; 0x40
    6568:	e5823000 	str	r3, [r2]
		/* Set Open Drain output control for MMC */
		for (i = 0; i < 0x3000; i++) {
    656c:	e3a03000 	mov	r3, #0	; 0x0
    6570:	e50b3018 	str	r3, [fp, #-24]
    6574:	ea000002 	b	6584 <MCI_CardInit+0xec>
    6578:	e51b3018 	ldr	r3, [fp, #-24]
    657c:	e2833001 	add	r3, r3, #1	; 0x1
    6580:	e50b3018 	str	r3, [fp, #-24]
    6584:	e51b2018 	ldr	r2, [fp, #-24]
    6588:	e3a03dbf 	mov	r3, #12224	; 0x2fc0
    658c:	e283303f 	add	r3, r3, #63	; 0x3f
    6590:	e1520003 	cmp	r2, r3
    6594:	9afffff7 	bls	6578 <MCI_CardInit+0xe0>
			;
		}
		/* try CMD1 of MMC */
		if (MCI_Send_OP_Cond() == TRUE) {
    6598:	ebfffeb3 	bl	606c <MCI_Send_OP_Cond>
    659c:	e1a03000 	mov	r3, r0
    65a0:	e3530001 	cmp	r3, #1	; 0x1
    65a4:	1a000001 	bne	65b0 <MCI_CardInit+0x118>
			CardType = MMC_CARD;
    65a8:	e3a03001 	mov	r3, #1	; 0x1
    65ac:	e50b3014 	str	r3, [fp, #-20]
		}
	}

	MCI_CardType = CardType;
    65b0:	e59f201c 	ldr	r2, [pc, #28]	; 65d4 <MCI_CardInit+0x13c>
    65b4:	e51b3014 	ldr	r3, [fp, #-20]
    65b8:	e5823000 	str	r3, [r2]

	return (CardType );
    65bc:	e51b3014 	ldr	r3, [fp, #-20]
    65c0:	e50b3020 	str	r3, [fp, #-32]
    65c4:	e51b3020 	ldr	r3, [fp, #-32]
}
    65c8:	e1a00003 	mov	r0, r3
    65cc:	e24bd00c 	sub	sp, fp, #12	; 0xc
    65d0:	e89da800 	ldm	sp, {fp, sp, pc}
    65d4:	40000050 	.word	0x40000050

000065d8 <MCI_Check_CID>:
 **
 ** parameters:			None
 ** Returned value:		If not timeout, return true.
 ** 
 ******************************************************************************/
DWORD MCI_Check_CID(void) {
    65d8:	e1a0c00d 	mov	ip, sp
    65dc:	e92dd800 	push	{fp, ip, lr, pc}
    65e0:	e24cb004 	sub	fp, ip, #4	; 0x4
    65e4:	e24dd020 	sub	sp, sp, #32	; 0x20
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	/* This command is normally after CMD1(MMC) or ACMD41(SD). */
	retryCount = 0x20; /* reset retry counter */
    65e8:	e3a03020 	mov	r3, #32	; 0x20
    65ec:	e50b3014 	str	r3, [fp, #-20]
    65f0:	ea00001e 	b	6670 <MCI_Check_CID+0x98>
	while (retryCount > 0) {
		/* Send CMD2 command repeatedly until the response is back correctly */
		MCI_SendCmd( ALL_SEND_CID, 0, EXPECT_LONG_RESP, 0);
    65f4:	e3a00002 	mov	r0, #2	; 0x2
    65f8:	e3a01000 	mov	r1, #0	; 0x0
    65fc:	e3a02002 	mov	r2, #2	; 0x2
    6600:	e3a03000 	mov	r3, #0	; 0x0
    6604:	ebfffd7a 	bl	5bf4 <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( ALL_SEND_CID, EXPECT_LONG_RESP, (DWORD *)&respValue[0]);
    6608:	e24b3028 	sub	r3, fp, #40	; 0x28
    660c:	e3a00002 	mov	r0, #2	; 0x2
    6610:	e3a01002 	mov	r1, #2	; 0x2
    6614:	e1a02003 	mov	r2, r3
    6618:	ebfffdcc 	bl	5d50 <MCI_GetCmdResp>
    661c:	e1a03000 	mov	r3, r0
    6620:	e50b3010 	str	r3, [fp, #-16]
		/* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
		if ( !(respStatus & MCI_CMD_TIMEOUT )) {
    6624:	e51b3010 	ldr	r3, [fp, #-16]
    6628:	e2033004 	and	r3, r3, #4	; 0x4
    662c:	e3530000 	cmp	r3, #0	; 0x0
    6630:	1a000002 	bne	6640 <MCI_Check_CID+0x68>
			return ( TRUE ); /* response is back and correct. */
    6634:	e3a03001 	mov	r3, #1	; 0x1
    6638:	e50b302c 	str	r3, [fp, #-44]
    663c:	ea000010 	b	6684 <MCI_Check_CID+0xac>
		}
		for (i = 0; i < 0x20; i++) {
    6640:	e3a03000 	mov	r3, #0	; 0x0
    6644:	e50b3018 	str	r3, [fp, #-24]
    6648:	ea000002 	b	6658 <MCI_Check_CID+0x80>
    664c:	e51b3018 	ldr	r3, [fp, #-24]
    6650:	e2833001 	add	r3, r3, #1	; 0x1
    6654:	e50b3018 	str	r3, [fp, #-24]
    6658:	e51b3018 	ldr	r3, [fp, #-24]
    665c:	e353001f 	cmp	r3, #31	; 0x1f
    6660:	9afffff9 	bls	664c <MCI_Check_CID+0x74>
			;
		}
		retryCount--;
    6664:	e51b3014 	ldr	r3, [fp, #-20]
    6668:	e2433001 	sub	r3, r3, #1	; 0x1
    666c:	e50b3014 	str	r3, [fp, #-20]
	DWORD respStatus;
	DWORD respValue[4];

	/* This command is normally after CMD1(MMC) or ACMD41(SD). */
	retryCount = 0x20; /* reset retry counter */
	while (retryCount > 0) {
    6670:	e51b3014 	ldr	r3, [fp, #-20]
    6674:	e3530000 	cmp	r3, #0	; 0x0
    6678:	1affffdd 	bne	65f4 <MCI_Check_CID+0x1c>
		for (i = 0; i < 0x20; i++) {
			;
		}
		retryCount--;
	}
	return ( FALSE );
    667c:	e3a03000 	mov	r3, #0	; 0x0
    6680:	e50b302c 	str	r3, [fp, #-44]
    6684:	e51b302c 	ldr	r3, [fp, #-44]
}
    6688:	e1a00003 	mov	r0, r3
    668c:	e24bd00c 	sub	sp, fp, #12	; 0xc
    6690:	e89da800 	ldm	sp, {fp, sp, pc}

00006694 <MCI_Set_Address>:
 ** parameters:			None
 ** Returned value:		TRUE if response is back before timeout.
 ** 
 ** modified by mthomas
 ******************************************************************************/
DWORD MCI_Set_Address(void) {
    6694:	e1a0c00d 	mov	ip, sp
    6698:	e92dd800 	push	{fp, ip, lr, pc}
    669c:	e24cb004 	sub	fp, ip, #4	; 0x4
    66a0:	e24dd024 	sub	sp, sp, #36	; 0x24
	/* If it's a SD card, SET_RELATIVE_ADDR is to get the address
	 from the card and use this value in RCA, if it's a MMC, set default
	 RCA addr. 0x00010000. */
#if 1
	// mthomas:
	if (MCI_CardType & MMC_CARD) {
    66a4:	e59f30f4 	ldr	r3, [pc, #244]	; 67a0 <MCI_Set_Address+0x10c>
    66a8:	e5933000 	ldr	r3, [r3]
    66ac:	e2033001 	and	r3, r3, #1	; 0x1
    66b0:	e20330ff 	and	r3, r3, #255	; 0xff
    66b4:	e3530000 	cmp	r3, #0	; 0x0
    66b8:	0a000002 	beq	66c8 <MCI_Set_Address+0x34>
		/* If it's unknown or MMC_CARD, fix the RCA address */
		CmdArgument = 0x00010000;
    66bc:	e3a03801 	mov	r3, #65536	; 0x10000
    66c0:	e50b3010 	str	r3, [fp, #-16]
    66c4:	ea000001 	b	66d0 <MCI_Set_Address+0x3c>
	} else {
		CmdArgument = 0;
    66c8:	e3a03000 	mov	r3, #0	; 0x0
    66cc:	e50b3010 	str	r3, [fp, #-16]
	{
		CmdArgument = 0x00010000;
	}
#endif

	retryCount = 0x20; /* reset retry counter */
    66d0:	e3a03020 	mov	r3, #32	; 0x20
    66d4:	e50b3018 	str	r3, [fp, #-24]
    66d8:	ea000027 	b	677c <MCI_Set_Address+0xe8>
	while (retryCount > 0) {
		/* Send CMD3 command repeatedly until the response is back correctly */
		MCI_SendCmd( SET_RELATIVE_ADDR, CmdArgument, EXPECT_SHORT_RESP, 0);
    66dc:	e3a00003 	mov	r0, #3	; 0x3
    66e0:	e51b1010 	ldr	r1, [fp, #-16]
    66e4:	e3a02001 	mov	r2, #1	; 0x1
    66e8:	e3a03000 	mov	r3, #0	; 0x0
    66ec:	ebfffd40 	bl	5bf4 <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SET_RELATIVE_ADDR, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    66f0:	e24b302c 	sub	r3, fp, #44	; 0x2c
    66f4:	e3a00003 	mov	r0, #3	; 0x3
    66f8:	e3a01001 	mov	r1, #1	; 0x1
    66fc:	e1a02003 	mov	r2, r3
    6700:	ebfffd92 	bl	5d50 <MCI_GetCmdResp>
    6704:	e1a03000 	mov	r3, r0
    6708:	e50b3014 	str	r3, [fp, #-20]
		/* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
		/* It should go to IDEN state and bit 8 should be 1 */
		if ( !(respStatus & MCI_CMD_TIMEOUT) && ((respValue[0] & (0x0F << 8))
    670c:	e51b3014 	ldr	r3, [fp, #-20]
    6710:	e2033004 	and	r3, r3, #4	; 0x4
    6714:	e3530000 	cmp	r3, #0	; 0x0
    6718:	1a00000b 	bne	674c <MCI_Set_Address+0xb8>
    671c:	e51b302c 	ldr	r3, [fp, #-44]
    6720:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    6724:	e3530c05 	cmp	r3, #1280	; 0x500
    6728:	1a000007 	bne	674c <MCI_Set_Address+0xb8>
				== 0x0500)) {
			CardRCA = respValue[0] & 0xFFFF0000; /* Save the RCA value from SD card */
    672c:	e51b302c 	ldr	r3, [fp, #-44]
    6730:	e1a03823 	lsr	r3, r3, #16
    6734:	e1a03803 	lsl	r3, r3, #16
    6738:	e59f2064 	ldr	r2, [pc, #100]	; 67a4 <MCI_Set_Address+0x110>
    673c:	e5823000 	str	r3, [r2]
			return ( TRUE ); /* response is back and correct. */
    6740:	e3a03001 	mov	r3, #1	; 0x1
    6744:	e50b3030 	str	r3, [fp, #-48]
    6748:	ea000010 	b	6790 <MCI_Set_Address+0xfc>
		}
		for (i = 0; i < 0x20; i++) {
    674c:	e3a03000 	mov	r3, #0	; 0x0
    6750:	e50b301c 	str	r3, [fp, #-28]
    6754:	ea000002 	b	6764 <MCI_Set_Address+0xd0>
    6758:	e51b301c 	ldr	r3, [fp, #-28]
    675c:	e2833001 	add	r3, r3, #1	; 0x1
    6760:	e50b301c 	str	r3, [fp, #-28]
    6764:	e51b301c 	ldr	r3, [fp, #-28]
    6768:	e353001f 	cmp	r3, #31	; 0x1f
    676c:	9afffff9 	bls	6758 <MCI_Set_Address+0xc4>
			;
		}
		retryCount--;
    6770:	e51b3018 	ldr	r3, [fp, #-24]
    6774:	e2433001 	sub	r3, r3, #1	; 0x1
    6778:	e50b3018 	str	r3, [fp, #-24]
		CmdArgument = 0x00010000;
	}
#endif

	retryCount = 0x20; /* reset retry counter */
	while (retryCount > 0) {
    677c:	e51b3018 	ldr	r3, [fp, #-24]
    6780:	e3530000 	cmp	r3, #0	; 0x0
    6784:	1affffd4 	bne	66dc <MCI_Set_Address+0x48>
		for (i = 0; i < 0x20; i++) {
			;
		}
		retryCount--;
	}
	return ( FALSE );
    6788:	e3a03000 	mov	r3, #0	; 0x0
    678c:	e50b3030 	str	r3, [fp, #-48]
    6790:	e51b3030 	ldr	r3, [fp, #-48]
}
    6794:	e1a00003 	mov	r0, r3
    6798:	e24bd00c 	sub	sp, fp, #12	; 0xc
    679c:	e89da800 	ldm	sp, {fp, sp, pc}
    67a0:	40000050 	.word	0x40000050
    67a4:	4000004c 	.word	0x4000004c

000067a8 <MCI_Send_CSD>:
 ** parameters:			None
 ** Returned value:		Response value
 ** 
 ******************************************************************************/
// DWORD MCI_Send_CSD( void )
DWORD MCI_Send_CSD(DWORD *csd) {
    67a8:	e1a0c00d 	mov	ip, sp
    67ac:	e92dd800 	push	{fp, ip, lr, pc}
    67b0:	e24cb004 	sub	fp, ip, #4	; 0x4
    67b4:	e24dd028 	sub	sp, sp, #40	; 0x28
    67b8:	e50b0030 	str	r0, [fp, #-48]
	DWORD respValue[4];
	DWORD CmdArgument;

#if 1
	// mthomas:
	if (MCI_CardType & MMC_CARD) {
    67bc:	e59f3154 	ldr	r3, [pc, #340]	; 6918 <MCI_Send_CSD+0x170>
    67c0:	e5933000 	ldr	r3, [r3]
    67c4:	e2033001 	and	r3, r3, #1	; 0x1
    67c8:	e20330ff 	and	r3, r3, #255	; 0xff
    67cc:	e3530000 	cmp	r3, #0	; 0x0
    67d0:	0a000002 	beq	67e0 <MCI_Send_CSD+0x38>
		/* If it's unknown or MMC_CARD, fix the RCA address */
		CmdArgument = 0x00010000;
    67d4:	e3a03801 	mov	r3, #65536	; 0x10000
    67d8:	e50b3010 	str	r3, [fp, #-16]
    67dc:	ea000002 	b	67ec <MCI_Send_CSD+0x44>
	} else {
		CmdArgument = CardRCA;
    67e0:	e59f3134 	ldr	r3, [pc, #308]	; 691c <MCI_Send_CSD+0x174>
    67e4:	e5933000 	ldr	r3, [r3]
    67e8:	e50b3010 	str	r3, [fp, #-16]
	{
		CmdArgument = 0x00010000;
	}
#endif

	retryCount = 0x20;
    67ec:	e3a03020 	mov	r3, #32	; 0x20
    67f0:	e50b3018 	str	r3, [fp, #-24]
    67f4:	ea00003e 	b	68f4 <MCI_Send_CSD+0x14c>
	while (retryCount > 0) {
		/* Send SET_BLOCK_LEN command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    67f8:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    67fc:	e2822923 	add	r2, r2, #573440	; 0x8c000
    6800:	e2822038 	add	r2, r2, #56	; 0x38
    6804:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    6808:	e2833923 	add	r3, r3, #573440	; 0x8c000
    680c:	e2833038 	add	r3, r3, #56	; 0x38
    6810:	e5933000 	ldr	r3, [r3]
    6814:	e3833045 	orr	r3, r3, #69	; 0x45
    6818:	e5823000 	str	r3, [r2]
		MCI_SendCmd( SEND_CSD, CmdArgument, EXPECT_LONG_RESP, 0);
    681c:	e3a00009 	mov	r0, #9	; 0x9
    6820:	e51b1010 	ldr	r1, [fp, #-16]
    6824:	e3a02002 	mov	r2, #2	; 0x2
    6828:	e3a03000 	mov	r3, #0	; 0x0
    682c:	ebfffcf0 	bl	5bf4 <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SEND_CSD, EXPECT_LONG_RESP, (DWORD *)&respValue[0]);
    6830:	e24b302c 	sub	r3, fp, #44	; 0x2c
    6834:	e3a00009 	mov	r0, #9	; 0x9
    6838:	e3a01002 	mov	r1, #2	; 0x2
    683c:	e1a02003 	mov	r2, r3
    6840:	ebfffd42 	bl	5d50 <MCI_GetCmdResp>
    6844:	e1a03000 	mov	r3, r0
    6848:	e50b3014 	str	r3, [fp, #-20]
		if ( !respStatus) {
    684c:	e51b3014 	ldr	r3, [fp, #-20]
    6850:	e3530000 	cmp	r3, #0	; 0x0
    6854:	1a00001a 	bne	68c4 <MCI_Send_CSD+0x11c>
			mci_debug_printf("MCI_Send_CSD result: %08x %08x %08x %08x\n",
					respValue[0], respValue[1],
					respValue[2], respValue[3]
			);

			if (csd) {
    6858:	e51b3030 	ldr	r3, [fp, #-48]
    685c:	e3530000 	cmp	r3, #0	; 0x0
    6860:	0a000014 	beq	68b8 <MCI_Send_CSD+0x110>
				for (i = 0; i < 4; i++) {
    6864:	e3a03000 	mov	r3, #0	; 0x0
    6868:	e50b301c 	str	r3, [fp, #-28]
    686c:	ea00000e 	b	68ac <MCI_Send_CSD+0x104>
					csd[i] = respValue[i];
    6870:	e51b301c 	ldr	r3, [fp, #-28]
    6874:	e1a02103 	lsl	r2, r3, #2
    6878:	e51b3030 	ldr	r3, [fp, #-48]
    687c:	e0831002 	add	r1, r3, r2
    6880:	e51b301c 	ldr	r3, [fp, #-28]
    6884:	e3e0201f 	mvn	r2, #31	; 0x1f
    6888:	e1a03103 	lsl	r3, r3, #2
    688c:	e24b000c 	sub	r0, fp, #12	; 0xc
    6890:	e0803003 	add	r3, r0, r3
    6894:	e0833002 	add	r3, r3, r2
    6898:	e5933000 	ldr	r3, [r3]
    689c:	e5813000 	str	r3, [r1]
					respValue[0], respValue[1],
					respValue[2], respValue[3]
			);

			if (csd) {
				for (i = 0; i < 4; i++) {
    68a0:	e51b301c 	ldr	r3, [fp, #-28]
    68a4:	e2833001 	add	r3, r3, #1	; 0x1
    68a8:	e50b301c 	str	r3, [fp, #-28]
    68ac:	e51b301c 	ldr	r3, [fp, #-28]
    68b0:	e3530003 	cmp	r3, #3	; 0x3
    68b4:	9affffed 	bls	6870 <MCI_Send_CSD+0xc8>
					csd[i] = respValue[i];
				}
			}
			return ( TRUE );
    68b8:	e3a03001 	mov	r3, #1	; 0x1
    68bc:	e50b3034 	str	r3, [fp, #-52]
    68c0:	ea000010 	b	6908 <MCI_Send_CSD+0x160>
		}
		for (i = 0; i < 0x20; i++) {
    68c4:	e3a03000 	mov	r3, #0	; 0x0
    68c8:	e50b301c 	str	r3, [fp, #-28]
    68cc:	ea000002 	b	68dc <MCI_Send_CSD+0x134>
    68d0:	e51b301c 	ldr	r3, [fp, #-28]
    68d4:	e2833001 	add	r3, r3, #1	; 0x1
    68d8:	e50b301c 	str	r3, [fp, #-28]
    68dc:	e51b301c 	ldr	r3, [fp, #-28]
    68e0:	e353001f 	cmp	r3, #31	; 0x1f
    68e4:	9afffff9 	bls	68d0 <MCI_Send_CSD+0x128>
			;
		}
		retryCount--;
    68e8:	e51b3018 	ldr	r3, [fp, #-24]
    68ec:	e2433001 	sub	r3, r3, #1	; 0x1
    68f0:	e50b3018 	str	r3, [fp, #-24]
		CmdArgument = 0x00010000;
	}
#endif

	retryCount = 0x20;
	while (retryCount > 0) {
    68f4:	e51b3018 	ldr	r3, [fp, #-24]
    68f8:	e3530000 	cmp	r3, #0	; 0x0
    68fc:	1affffbd 	bne	67f8 <MCI_Send_CSD+0x50>
		for (i = 0; i < 0x20; i++) {
			;
		}
		retryCount--;
	}
	return ( FALSE );
    6900:	e3a00000 	mov	r0, #0	; 0x0
    6904:	e50b0034 	str	r0, [fp, #-52]
    6908:	e51b3034 	ldr	r3, [fp, #-52]
}
    690c:	e1a00003 	mov	r0, r3
    6910:	e24bd00c 	sub	sp, fp, #12	; 0xc
    6914:	e89da800 	ldm	sp, {fp, sp, pc}
    6918:	40000050 	.word	0x40000050
    691c:	4000004c 	.word	0x4000004c

00006920 <MCI_Select_Card>:
 ** parameters:			None
 ** Returned value:		return false if response times out.
 ** 
 ** modified by Martin Thomas for unselect (RCA 0)
 ******************************************************************************/
DWORD MCI_Select_Card(void) {
    6920:	e1a0c00d 	mov	ip, sp
    6924:	e92dd800 	push	{fp, ip, lr, pc}
    6928:	e24cb004 	sub	fp, ip, #4	; 0x4
    692c:	e24dd024 	sub	sp, sp, #36	; 0x24
	DWORD respValue[4];
	DWORD CmdArgument;

#if 1
	// mthomas:
	if (MCI_CardType == CARD_UNKNOWN) {
    6930:	e59f3138 	ldr	r3, [pc, #312]	; 6a70 <MCI_Select_Card+0x150>
    6934:	e5933000 	ldr	r3, [r3]
    6938:	e3530000 	cmp	r3, #0	; 0x0
    693c:	1a000002 	bne	694c <MCI_Select_Card+0x2c>
		CmdArgument = 0; // RCA = 0 -> de-select -> trans to stby
    6940:	e3a03000 	mov	r3, #0	; 0x0
    6944:	e50b3010 	str	r3, [fp, #-16]
    6948:	ea00000b 	b	697c <MCI_Select_Card+0x5c>
	} else if (MCI_CardType & MMC_CARD) {
    694c:	e59f311c 	ldr	r3, [pc, #284]	; 6a70 <MCI_Select_Card+0x150>
    6950:	e5933000 	ldr	r3, [r3]
    6954:	e2033001 	and	r3, r3, #1	; 0x1
    6958:	e20330ff 	and	r3, r3, #255	; 0xff
    695c:	e3530000 	cmp	r3, #0	; 0x0
    6960:	0a000002 	beq	6970 <MCI_Select_Card+0x50>
		/* If it's unknown or MMC_CARD, fix the RCA address */
		CmdArgument = 0x00010000;
    6964:	e3a03801 	mov	r3, #65536	; 0x10000
    6968:	e50b3010 	str	r3, [fp, #-16]
    696c:	ea000002 	b	697c <MCI_Select_Card+0x5c>
	} else {
		CmdArgument = CardRCA;
    6970:	e59f30fc 	ldr	r3, [pc, #252]	; 6a74 <MCI_Select_Card+0x154>
    6974:	e5933000 	ldr	r3, [r3]
    6978:	e50b3010 	str	r3, [fp, #-16]
	{
		CmdArgument = 0x00010000;
	}
#endif

	retryCount = 0x20;
    697c:	e3a03020 	mov	r3, #32	; 0x20
    6980:	e50b3018 	str	r3, [fp, #-24]
    6984:	ea000030 	b	6a4c <MCI_Select_Card+0x12c>
	while (retryCount > 0) {
#if 1
		// mthomas:
		/* Send SELECT_CARD command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    6988:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    698c:	e2822923 	add	r2, r2, #573440	; 0x8c000
    6990:	e2822038 	add	r2, r2, #56	; 0x38
    6994:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    6998:	e2833923 	add	r3, r3, #573440	; 0x8c000
    699c:	e2833038 	add	r3, r3, #56	; 0x38
    69a0:	e5933000 	ldr	r3, [r3]
    69a4:	e3833045 	orr	r3, r3, #69	; 0x45
    69a8:	e5823000 	str	r3, [r2]
		MCI_SendCmd( SELECT_CARD, CmdArgument, EXPECT_SHORT_RESP, 0);
    69ac:	e3a00007 	mov	r0, #7	; 0x7
    69b0:	e51b1010 	ldr	r1, [fp, #-16]
    69b4:	e3a02001 	mov	r2, #1	; 0x1
    69b8:	e3a03000 	mov	r3, #0	; 0x0
    69bc:	ebfffc8c 	bl	5bf4 <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SELECT_CARD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    69c0:	e24b302c 	sub	r3, fp, #44	; 0x2c
    69c4:	e3a00007 	mov	r0, #7	; 0x7
    69c8:	e3a01001 	mov	r1, #1	; 0x1
    69cc:	e1a02003 	mov	r2, r3
    69d0:	ebfffcde 	bl	5d50 <MCI_GetCmdResp>
    69d4:	e1a03000 	mov	r3, r0
    69d8:	e50b3014 	str	r3, [fp, #-20]

		if (CmdArgument) {
    69dc:	e51b3010 	ldr	r3, [fp, #-16]
    69e0:	e3530000 	cmp	r3, #0	; 0x0
    69e4:	0a00000c 	beq	6a1c <MCI_Select_Card+0xfc>
			// select card
			if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0700 )) { /* Should be in STANDBY state now and ready */
    69e8:	e51b3014 	ldr	r3, [fp, #-20]
    69ec:	e3530000 	cmp	r3, #0	; 0x0
    69f0:	1a000006 	bne	6a10 <MCI_Select_Card+0xf0>
    69f4:	e51b302c 	ldr	r3, [fp, #-44]
    69f8:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    69fc:	e3530c07 	cmp	r3, #1792	; 0x700
    6a00:	1a000002 	bne	6a10 <MCI_Select_Card+0xf0>
				/* mthomas: repsValue 0 is the card-status V2.2 p3-20
				 READ_FOR_DATA: ready, CURRENT_STATE=3->stby */
				return ( TRUE );
    6a04:	e3a03001 	mov	r3, #1	; 0x1
    6a08:	e50b3030 	str	r3, [fp, #-48]
    6a0c:	ea000013 	b	6a60 <MCI_Select_Card+0x140>
		{ /* Should be in STANDBY state now and ready */
			/* mthomas: READ_FOR_DATA: ready, CURRENT_STATE=3->stby */
			return ( TRUE );
		}
#endif
		for (i = 0; i < 0x20; i++) {
    6a10:	e3a03000 	mov	r3, #0	; 0x0
    6a14:	e50b301c 	str	r3, [fp, #-28]
    6a18:	ea000005 	b	6a34 <MCI_Select_Card+0x114>
				 READ_FOR_DATA: ready, CURRENT_STATE=3->stby */
				return ( TRUE );
			}
		} else {
			// TODO: Timeouts - maybe because not card is selected
			return ( TRUE );
    6a1c:	e3a03001 	mov	r3, #1	; 0x1
    6a20:	e50b3030 	str	r3, [fp, #-48]
    6a24:	ea00000d 	b	6a60 <MCI_Select_Card+0x140>
		{ /* Should be in STANDBY state now and ready */
			/* mthomas: READ_FOR_DATA: ready, CURRENT_STATE=3->stby */
			return ( TRUE );
		}
#endif
		for (i = 0; i < 0x20; i++) {
    6a28:	e51b301c 	ldr	r3, [fp, #-28]
    6a2c:	e2833001 	add	r3, r3, #1	; 0x1
    6a30:	e50b301c 	str	r3, [fp, #-28]
    6a34:	e51b301c 	ldr	r3, [fp, #-28]
    6a38:	e353001f 	cmp	r3, #31	; 0x1f
    6a3c:	9afffff9 	bls	6a28 <MCI_Select_Card+0x108>
			;
		}mci_debug_printf(" Select_Card: arg:%08x respStatus: %08x resp0:%08x resp1:%08x\n",
				CmdArgument, respStatus, respValue[0], respValue[1]);
		retryCount--;
    6a40:	e51b3018 	ldr	r3, [fp, #-24]
    6a44:	e2433001 	sub	r3, r3, #1	; 0x1
    6a48:	e50b3018 	str	r3, [fp, #-24]
		CmdArgument = 0x00010000;
	}
#endif

	retryCount = 0x20;
	while (retryCount > 0) {
    6a4c:	e51b3018 	ldr	r3, [fp, #-24]
    6a50:	e3530000 	cmp	r3, #0	; 0x0
    6a54:	1affffcb 	bne	6988 <MCI_Select_Card+0x68>
			;
		}mci_debug_printf(" Select_Card: arg:%08x respStatus: %08x resp0:%08x resp1:%08x\n",
				CmdArgument, respStatus, respValue[0], respValue[1]);
		retryCount--;
	} /* while retry */
	return ( FALSE );
    6a58:	e3a03000 	mov	r3, #0	; 0x0
    6a5c:	e50b3030 	str	r3, [fp, #-48]
    6a60:	e51b3030 	ldr	r3, [fp, #-48]
}
    6a64:	e1a00003 	mov	r0, r3
    6a68:	e24bd00c 	sub	sp, fp, #12	; 0xc
    6a6c:	e89da800 	ldm	sp, {fp, sp, pc}
    6a70:	40000050 	.word	0x40000050
    6a74:	4000004c 	.word	0x4000004c

00006a78 <MCI_Send_Status>:
 **						is set in the card status register, if timeout, return 
 **						INVALID_RESPONSE 0xFFFFFFFF.
 ** 
 ** modified by mthomas
 ******************************************************************************/
DWORD MCI_Send_Status(void) {
    6a78:	e1a0c00d 	mov	ip, sp
    6a7c:	e92dd800 	push	{fp, ip, lr, pc}
    6a80:	e24cb004 	sub	fp, ip, #4	; 0x4
    6a84:	e24dd020 	sub	sp, sp, #32	; 0x20
	DWORD respValue[4];
	DWORD CmdArgument;

#if 1
	// mthomas:
	if (MCI_CardType & MMC_CARD) {
    6a88:	e59f30e0 	ldr	r3, [pc, #224]	; 6b70 <MCI_Send_Status+0xf8>
    6a8c:	e5933000 	ldr	r3, [r3]
    6a90:	e2033001 	and	r3, r3, #1	; 0x1
    6a94:	e20330ff 	and	r3, r3, #255	; 0xff
    6a98:	e3530000 	cmp	r3, #0	; 0x0
    6a9c:	0a000002 	beq	6aac <MCI_Send_Status+0x34>
		/* If it's unknown or MMC_CARD, fix the RCA address */
		CmdArgument = 0x00010000;
    6aa0:	e3a03801 	mov	r3, #65536	; 0x10000
    6aa4:	e50b3010 	str	r3, [fp, #-16]
    6aa8:	ea000002 	b	6ab8 <MCI_Send_Status+0x40>
	} else {
		CmdArgument = CardRCA;
    6aac:	e59f30c0 	ldr	r3, [pc, #192]	; 6b74 <MCI_Send_Status+0xfc>
    6ab0:	e5933000 	ldr	r3, [r3]
    6ab4:	e50b3010 	str	r3, [fp, #-16]
	}
#endif

	/* Note that, since it's called after the block write and read, this timeout 
	 is important based on the clock you set for the data communication. */
	retryCount = 0x2000;
    6ab8:	e3a03a02 	mov	r3, #8192	; 0x2000
    6abc:	e50b3018 	str	r3, [fp, #-24]
    6ac0:	ea000021 	b	6b4c <MCI_Send_Status+0xd4>
	while (retryCount > 0) {
		/* Send SELECT_CARD command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    6ac4:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    6ac8:	e2822923 	add	r2, r2, #573440	; 0x8c000
    6acc:	e2822038 	add	r2, r2, #56	; 0x38
    6ad0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    6ad4:	e2833923 	add	r3, r3, #573440	; 0x8c000
    6ad8:	e2833038 	add	r3, r3, #56	; 0x38
    6adc:	e5933000 	ldr	r3, [r3]
    6ae0:	e3833045 	orr	r3, r3, #69	; 0x45
    6ae4:	e5823000 	str	r3, [r2]
		MCI_SendCmd( SEND_STATUS, CmdArgument, EXPECT_SHORT_RESP, 0);
    6ae8:	e3a0000d 	mov	r0, #13	; 0xd
    6aec:	e51b1010 	ldr	r1, [fp, #-16]
    6af0:	e3a02001 	mov	r2, #1	; 0x1
    6af4:	e3a03000 	mov	r3, #0	; 0x0
    6af8:	ebfffc3d 	bl	5bf4 <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SEND_STATUS, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    6afc:	e24b3028 	sub	r3, fp, #40	; 0x28
    6b00:	e3a0000d 	mov	r0, #13	; 0xd
    6b04:	e3a01001 	mov	r1, #1	; 0x1
    6b08:	e1a02003 	mov	r2, r3
    6b0c:	ebfffc8f 	bl	5d50 <MCI_GetCmdResp>
    6b10:	e1a03000 	mov	r3, r0
    6b14:	e50b3014 	str	r3, [fp, #-20]
		if ( !respStatus && (respValue[0] & (1 << 8))) { /* The ready bit should be set, it should be in either TRAN or RCV state now */
    6b18:	e51b3014 	ldr	r3, [fp, #-20]
    6b1c:	e3530000 	cmp	r3, #0	; 0x0
    6b20:	1a000006 	bne	6b40 <MCI_Send_Status+0xc8>
    6b24:	e51b3028 	ldr	r3, [fp, #-40]
    6b28:	e2033c01 	and	r3, r3, #256	; 0x100
    6b2c:	e3530000 	cmp	r3, #0	; 0x0
    6b30:	0a000002 	beq	6b40 <MCI_Send_Status+0xc8>
			return (respValue[0] );
    6b34:	e51b3028 	ldr	r3, [fp, #-40]
    6b38:	e50b302c 	str	r3, [fp, #-44]
    6b3c:	ea000007 	b	6b60 <MCI_Send_Status+0xe8>
		}
		retryCount--;
    6b40:	e51b3018 	ldr	r3, [fp, #-24]
    6b44:	e2433001 	sub	r3, r3, #1	; 0x1
    6b48:	e50b3018 	str	r3, [fp, #-24]
#endif

	/* Note that, since it's called after the block write and read, this timeout 
	 is important based on the clock you set for the data communication. */
	retryCount = 0x2000;
	while (retryCount > 0) {
    6b4c:	e51b3018 	ldr	r3, [fp, #-24]
    6b50:	e3530000 	cmp	r3, #0	; 0x0
    6b54:	1affffda 	bne	6ac4 <MCI_Send_Status+0x4c>
		if ( !respStatus && (respValue[0] & (1 << 8))) { /* The ready bit should be set, it should be in either TRAN or RCV state now */
			return (respValue[0] );
		}
		retryCount--;
	}
	return ( INVALID_RESPONSE );
    6b58:	e3e03000 	mvn	r3, #0	; 0x0
    6b5c:	e50b302c 	str	r3, [fp, #-44]
    6b60:	e51b302c 	ldr	r3, [fp, #-44]
}
    6b64:	e1a00003 	mov	r0, r3
    6b68:	e24bd00c 	sub	sp, fp, #12	; 0xc
    6b6c:	e89da800 	ldm	sp, {fp, sp, pc}
    6b70:	40000050 	.word	0x40000050
    6b74:	4000004c 	.word	0x4000004c

00006b78 <MCI_Set_BlockLen>:
 ** parameters:			The length of the data block to be written or read.
 ** Returned value:		true or false, return TRUE if ready bit is set, and it's
 **						in TRANS state.
 ** 
 ******************************************************************************/
DWORD MCI_Set_BlockLen(DWORD blockLength) {
    6b78:	e1a0c00d 	mov	ip, sp
    6b7c:	e92dd800 	push	{fp, ip, lr, pc}
    6b80:	e24cb004 	sub	fp, ip, #4	; 0x4
    6b84:	e24dd024 	sub	sp, sp, #36	; 0x24
    6b88:	e50b002c 	str	r0, [fp, #-44]
	volatile DWORD i; // mthomas - volatile
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
    6b8c:	e3a03020 	mov	r3, #32	; 0x20
    6b90:	e50b3014 	str	r3, [fp, #-20]
    6b94:	ea00002a 	b	6c44 <MCI_Set_BlockLen+0xcc>
	while (retryCount > 0) {
		/* Send SET_BLOCK_LEN command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    6b98:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    6b9c:	e2822923 	add	r2, r2, #573440	; 0x8c000
    6ba0:	e2822038 	add	r2, r2, #56	; 0x38
    6ba4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    6ba8:	e2833923 	add	r3, r3, #573440	; 0x8c000
    6bac:	e2833038 	add	r3, r3, #56	; 0x38
    6bb0:	e5933000 	ldr	r3, [r3]
    6bb4:	e3833045 	orr	r3, r3, #69	; 0x45
    6bb8:	e5823000 	str	r3, [r2]
		MCI_SendCmd( SET_BLOCK_LEN, blockLength, EXPECT_SHORT_RESP, 0);
    6bbc:	e3a00010 	mov	r0, #16	; 0x10
    6bc0:	e51b102c 	ldr	r1, [fp, #-44]
    6bc4:	e3a02001 	mov	r2, #1	; 0x1
    6bc8:	e3a03000 	mov	r3, #0	; 0x0
    6bcc:	ebfffc08 	bl	5bf4 <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SET_BLOCK_LEN, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    6bd0:	e24b3028 	sub	r3, fp, #40	; 0x28
    6bd4:	e3a00010 	mov	r0, #16	; 0x10
    6bd8:	e3a01001 	mov	r1, #1	; 0x1
    6bdc:	e1a02003 	mov	r2, r3
    6be0:	ebfffc5a 	bl	5d50 <MCI_GetCmdResp>
    6be4:	e1a03000 	mov	r3, r0
    6be8:	e50b3010 	str	r3, [fp, #-16]
		/* bit 9 through 12 should be in transfer state now. bit 8 is ready. */
		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
    6bec:	e51b3010 	ldr	r3, [fp, #-16]
    6bf0:	e3530000 	cmp	r3, #0	; 0x0
    6bf4:	1a000006 	bne	6c14 <MCI_Set_BlockLen+0x9c>
    6bf8:	e51b3028 	ldr	r3, [fp, #-40]
    6bfc:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    6c00:	e3530c09 	cmp	r3, #2304	; 0x900
    6c04:	1a000002 	bne	6c14 <MCI_Set_BlockLen+0x9c>
			return ( TRUE );
    6c08:	e3a03001 	mov	r3, #1	; 0x1
    6c0c:	e50b3030 	str	r3, [fp, #-48]
    6c10:	ea000010 	b	6c58 <MCI_Set_BlockLen+0xe0>
		}
		for (i = 0; i < 0x20; i++) {
    6c14:	e3a03000 	mov	r3, #0	; 0x0
    6c18:	e50b3018 	str	r3, [fp, #-24]
    6c1c:	ea000002 	b	6c2c <MCI_Set_BlockLen+0xb4>
    6c20:	e51b3018 	ldr	r3, [fp, #-24]
    6c24:	e2833001 	add	r3, r3, #1	; 0x1
    6c28:	e50b3018 	str	r3, [fp, #-24]
    6c2c:	e51b3018 	ldr	r3, [fp, #-24]
    6c30:	e353001f 	cmp	r3, #31	; 0x1f
    6c34:	9afffff9 	bls	6c20 <MCI_Set_BlockLen+0xa8>
			;
		}
		retryCount--;
    6c38:	e51b3014 	ldr	r3, [fp, #-20]
    6c3c:	e2433001 	sub	r3, r3, #1	; 0x1
    6c40:	e50b3014 	str	r3, [fp, #-20]
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
    6c44:	e51b3014 	ldr	r3, [fp, #-20]
    6c48:	e3530000 	cmp	r3, #0	; 0x0
    6c4c:	1affffd1 	bne	6b98 <MCI_Set_BlockLen+0x20>
		for (i = 0; i < 0x20; i++) {
			;
		}
		retryCount--;
	}
	return ( FALSE );
    6c50:	e3a03000 	mov	r3, #0	; 0x0
    6c54:	e50b3030 	str	r3, [fp, #-48]
    6c58:	e51b3030 	ldr	r3, [fp, #-48]
}
    6c5c:	e1a00003 	mov	r0, r3
    6c60:	e24bd00c 	sub	sp, fp, #12	; 0xc
    6c64:	e89da800 	ldm	sp, {fp, sp, pc}

00006c68 <MCI_Send_ACMD_Bus_Width>:
 ** parameters:			Bus width value, 1-bit is 0, 4-bit is 10
 ** Returned value:		true or false, true if the card is still in the 
 **						TRANS state after the cmd.
 ** 
 ******************************************************************************/
DWORD MCI_Send_ACMD_Bus_Width(DWORD buswidth) {
    6c68:	e1a0c00d 	mov	ip, sp
    6c6c:	e92dd800 	push	{fp, ip, lr, pc}
    6c70:	e24cb004 	sub	fp, ip, #4	; 0x4
    6c74:	e24dd024 	sub	sp, sp, #36	; 0x24
    6c78:	e50b002c 	str	r0, [fp, #-44]
	volatile DWORD i; // mthomas - volatile
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20; /* reset retry counter */
    6c7c:	e3a03020 	mov	r3, #32	; 0x20
    6c80:	e50b3014 	str	r3, [fp, #-20]
    6c84:	ea000025 	b	6d20 <MCI_Send_ACMD_Bus_Width+0xb8>
	while (retryCount > 0) {
		if (MCI_Send_ACMD() == FALSE) {
    6c88:	ebfffd2a 	bl	6138 <MCI_Send_ACMD>
    6c8c:	e1a03000 	mov	r3, r0
    6c90:	e3530000 	cmp	r3, #0	; 0x0
    6c94:	0a000021 	beq	6d20 <MCI_Send_ACMD_Bus_Width+0xb8>
			continue;
		}
		/* Send ACMD6 command to set the bus width */
		MCI_SendCmd( SET_ACMD_BUS_WIDTH, buswidth, EXPECT_SHORT_RESP, 0);
    6c98:	e3a00006 	mov	r0, #6	; 0x6
    6c9c:	e51b102c 	ldr	r1, [fp, #-44]
    6ca0:	e3a02001 	mov	r2, #1	; 0x1
    6ca4:	e3a03000 	mov	r3, #0	; 0x0
    6ca8:	ebfffbd1 	bl	5bf4 <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SET_ACMD_BUS_WIDTH, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    6cac:	e24b3028 	sub	r3, fp, #40	; 0x28
    6cb0:	e3a00006 	mov	r0, #6	; 0x6
    6cb4:	e3a01001 	mov	r1, #1	; 0x1
    6cb8:	e1a02003 	mov	r2, r3
    6cbc:	ebfffc23 	bl	5d50 <MCI_GetCmdResp>
    6cc0:	e1a03000 	mov	r3, r0
    6cc4:	e50b3010 	str	r3, [fp, #-16]
		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
    6cc8:	e51b3010 	ldr	r3, [fp, #-16]
    6ccc:	e3530000 	cmp	r3, #0	; 0x0
    6cd0:	1a000006 	bne	6cf0 <MCI_Send_ACMD_Bus_Width+0x88>
    6cd4:	e51b3028 	ldr	r3, [fp, #-40]
    6cd8:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    6cdc:	e3530c09 	cmp	r3, #2304	; 0x900
    6ce0:	1a000002 	bne	6cf0 <MCI_Send_ACMD_Bus_Width+0x88>
			return ( TRUE ); /* response is back and correct. */
    6ce4:	e3a03001 	mov	r3, #1	; 0x1
    6ce8:	e50b3030 	str	r3, [fp, #-48]
    6cec:	ea000010 	b	6d34 <MCI_Send_ACMD_Bus_Width+0xcc>
		}
		for (i = 0; i < 0x20; i++) {
    6cf0:	e3a03000 	mov	r3, #0	; 0x0
    6cf4:	e50b3018 	str	r3, [fp, #-24]
    6cf8:	ea000002 	b	6d08 <MCI_Send_ACMD_Bus_Width+0xa0>
    6cfc:	e51b3018 	ldr	r3, [fp, #-24]
    6d00:	e2833001 	add	r3, r3, #1	; 0x1
    6d04:	e50b3018 	str	r3, [fp, #-24]
    6d08:	e51b3018 	ldr	r3, [fp, #-24]
    6d0c:	e353001f 	cmp	r3, #31	; 0x1f
    6d10:	9afffff9 	bls	6cfc <MCI_Send_ACMD_Bus_Width+0x94>
			;
		}
		retryCount--;
    6d14:	e51b3014 	ldr	r3, [fp, #-20]
    6d18:	e2433001 	sub	r3, r3, #1	; 0x1
    6d1c:	e50b3014 	str	r3, [fp, #-20]
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20; /* reset retry counter */
	while (retryCount > 0) {
    6d20:	e51b3014 	ldr	r3, [fp, #-20]
    6d24:	e3530000 	cmp	r3, #0	; 0x0
    6d28:	1affffd6 	bne	6c88 <MCI_Send_ACMD_Bus_Width+0x20>
		for (i = 0; i < 0x20; i++) {
			;
		}
		retryCount--;
	}
	return ( FALSE );
    6d2c:	e3a03000 	mov	r3, #0	; 0x0
    6d30:	e50b3030 	str	r3, [fp, #-48]
    6d34:	e51b3030 	ldr	r3, [fp, #-48]
}
    6d38:	e1a00003 	mov	r0, r3
    6d3c:	e24bd00c 	sub	sp, fp, #12	; 0xc
    6d40:	e89da800 	ldm	sp, {fp, sp, pc}

00006d44 <MCI_Send_Stop>:
 ** parameters:			None
 ** Returned value:		true or false, true if, at least, the card status
 **						shows ready bit is set.
 ** 
 ******************************************************************************/
DWORD MCI_Send_Stop(void) {
    6d44:	e1a0c00d 	mov	ip, sp
    6d48:	e92dd800 	push	{fp, ip, lr, pc}
    6d4c:	e24cb004 	sub	fp, ip, #4	; 0x4
    6d50:	e24dd020 	sub	sp, sp, #32	; 0x20
	volatile DWORD i; // mthomas - volatile
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
    6d54:	e3a03020 	mov	r3, #32	; 0x20
    6d58:	e50b3014 	str	r3, [fp, #-20]
    6d5c:	ea000027 	b	6e00 <MCI_Send_Stop+0xbc>
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    6d60:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    6d64:	e2822923 	add	r2, r2, #573440	; 0x8c000
    6d68:	e2822038 	add	r2, r2, #56	; 0x38
    6d6c:	e3a03e7f 	mov	r3, #2032	; 0x7f0
    6d70:	e283300f 	add	r3, r3, #15	; 0xf
    6d74:	e5823000 	str	r3, [r2]
		MCI_SendCmd( STOP_TRANSMISSION, 0x00000000, EXPECT_SHORT_RESP, 0);
    6d78:	e3a0000c 	mov	r0, #12	; 0xc
    6d7c:	e3a01000 	mov	r1, #0	; 0x0
    6d80:	e3a02001 	mov	r2, #1	; 0x1
    6d84:	e3a03000 	mov	r3, #0	; 0x0
    6d88:	ebfffb99 	bl	5bf4 <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( STOP_TRANSMISSION, EXPECT_SHORT_RESP, (DWORD *)respValue);
    6d8c:	e24b3028 	sub	r3, fp, #40	; 0x28
    6d90:	e3a0000c 	mov	r0, #12	; 0xc
    6d94:	e3a01001 	mov	r1, #1	; 0x1
    6d98:	e1a02003 	mov	r2, r3
    6d9c:	ebfffbeb 	bl	5d50 <MCI_GetCmdResp>
    6da0:	e1a03000 	mov	r3, r0
    6da4:	e50b3010 	str	r3, [fp, #-16]
		/* ready bit, bit 8, should be set in the card status register */
		if ( !respStatus && (respValue[0] & (1 << 8))) {
    6da8:	e51b3010 	ldr	r3, [fp, #-16]
    6dac:	e3530000 	cmp	r3, #0	; 0x0
    6db0:	1a000006 	bne	6dd0 <MCI_Send_Stop+0x8c>
    6db4:	e51b3028 	ldr	r3, [fp, #-40]
    6db8:	e2033c01 	and	r3, r3, #256	; 0x100
    6dbc:	e3530000 	cmp	r3, #0	; 0x0
    6dc0:	0a000002 	beq	6dd0 <MCI_Send_Stop+0x8c>
			return ( TRUE );
    6dc4:	e3a03001 	mov	r3, #1	; 0x1
    6dc8:	e50b302c 	str	r3, [fp, #-44]
    6dcc:	ea000010 	b	6e14 <MCI_Send_Stop+0xd0>
		}
		for (i = 0; i < 0x20; i++) {
    6dd0:	e3a03000 	mov	r3, #0	; 0x0
    6dd4:	e50b3018 	str	r3, [fp, #-24]
    6dd8:	ea000002 	b	6de8 <MCI_Send_Stop+0xa4>
    6ddc:	e51b3018 	ldr	r3, [fp, #-24]
    6de0:	e2833001 	add	r3, r3, #1	; 0x1
    6de4:	e50b3018 	str	r3, [fp, #-24]
    6de8:	e51b3018 	ldr	r3, [fp, #-24]
    6dec:	e353001f 	cmp	r3, #31	; 0x1f
    6df0:	9afffff9 	bls	6ddc <MCI_Send_Stop+0x98>
			;
		}
		retryCount--;
    6df4:	e51b3014 	ldr	r3, [fp, #-20]
    6df8:	e2433001 	sub	r3, r3, #1	; 0x1
    6dfc:	e50b3014 	str	r3, [fp, #-20]
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
    6e00:	e51b3014 	ldr	r3, [fp, #-20]
    6e04:	e3530000 	cmp	r3, #0	; 0x0
    6e08:	1affffd4 	bne	6d60 <MCI_Send_Stop+0x1c>
		for (i = 0; i < 0x20; i++) {
			;
		}
		retryCount--;
	}
	return ( FALSE );
    6e0c:	e3a03000 	mov	r3, #0	; 0x0
    6e10:	e50b302c 	str	r3, [fp, #-44]
    6e14:	e51b302c 	ldr	r3, [fp, #-44]
}
    6e18:	e1a00003 	mov	r0, r3
    6e1c:	e24bd00c 	sub	sp, fp, #12	; 0xc
    6e20:	e89da800 	ldm	sp, {fp, sp, pc}

00006e24 <MCI_Send_Write_Block>:
 ** Returned value:		Response value
 ** 
 ** modified by mthomas
 ******************************************************************************/
// mthomas - static
static DWORD MCI_Send_Write_Block(DWORD blockNum) {
    6e24:	e1a0c00d 	mov	ip, sp
    6e28:	e92dd800 	push	{fp, ip, lr, pc}
    6e2c:	e24cb004 	sub	fp, ip, #4	; 0x4
    6e30:	e24dd024 	sub	sp, sp, #36	; 0x24
    6e34:	e50b002c 	str	r0, [fp, #-44]
	volatile DWORD i; // mthomas - volatile
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
    6e38:	e3a03020 	mov	r3, #32	; 0x20
    6e3c:	e50b3014 	str	r3, [fp, #-20]
    6e40:	ea000033 	b	6f14 <MCI_Send_Write_Block+0xf0>
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    6e44:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    6e48:	e2822923 	add	r2, r2, #573440	; 0x8c000
    6e4c:	e2822038 	add	r2, r2, #56	; 0x38
    6e50:	e3a03e7f 	mov	r3, #2032	; 0x7f0
    6e54:	e283300f 	add	r3, r3, #15	; 0xf
    6e58:	e5823000 	str	r3, [r2]
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
    6e5c:	e59f30d4 	ldr	r3, [pc, #212]	; 6f38 <MCI_Send_Write_Block+0x114>
    6e60:	e5933000 	ldr	r3, [r3]
    6e64:	e3530004 	cmp	r3, #4	; 0x4
    6e68:	1a000005 	bne	6e84 <MCI_Send_Write_Block+0x60>
			MCI_SendCmd( WRITE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
    6e6c:	e3a00018 	mov	r0, #24	; 0x18
    6e70:	e51b102c 	ldr	r1, [fp, #-44]
    6e74:	e3a02001 	mov	r2, #1	; 0x1
    6e78:	e3a03000 	mov	r3, #0	; 0x0
    6e7c:	ebfffb5c 	bl	5bf4 <MCI_SendCmd>
    6e80:	ea000006 	b	6ea0 <MCI_Send_Write_Block+0x7c>
		} else {
			MCI_SendCmd( WRITE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
    6e84:	e51b302c 	ldr	r3, [fp, #-44]
    6e88:	e1a03483 	lsl	r3, r3, #9
    6e8c:	e3a00018 	mov	r0, #24	; 0x18
    6e90:	e1a01003 	mov	r1, r3
    6e94:	e3a02001 	mov	r2, #1	; 0x1
    6e98:	e3a03000 	mov	r3, #0	; 0x0
    6e9c:	ebfffb54 	bl	5bf4 <MCI_SendCmd>
		}
#else
		// NXP original
		MCI_SendCmd( WRITE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0 );
#endif
		respStatus = MCI_GetCmdResp( WRITE_BLOCK, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    6ea0:	e24b3028 	sub	r3, fp, #40	; 0x28
    6ea4:	e3a00018 	mov	r0, #24	; 0x18
    6ea8:	e3a01001 	mov	r1, #1	; 0x1
    6eac:	e1a02003 	mov	r2, r3
    6eb0:	ebfffba6 	bl	5d50 <MCI_GetCmdResp>
    6eb4:	e1a03000 	mov	r3, r0
    6eb8:	e50b3010 	str	r3, [fp, #-16]
		/* it should be in the transfer state, bit 9~12 is 0x0100 and bit 8 is 1 */
		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
    6ebc:	e51b3010 	ldr	r3, [fp, #-16]
    6ec0:	e3530000 	cmp	r3, #0	; 0x0
    6ec4:	1a000006 	bne	6ee4 <MCI_Send_Write_Block+0xc0>
    6ec8:	e51b3028 	ldr	r3, [fp, #-40]
    6ecc:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    6ed0:	e3530c09 	cmp	r3, #2304	; 0x900
    6ed4:	1a000002 	bne	6ee4 <MCI_Send_Write_Block+0xc0>
			return ( TRUE ); /* ready and in TRAN state */
    6ed8:	e3a03001 	mov	r3, #1	; 0x1
    6edc:	e50b3030 	str	r3, [fp, #-48]
    6ee0:	ea000010 	b	6f28 <MCI_Send_Write_Block+0x104>
		}

		for (i = 0; i < 0x20; i++) {
    6ee4:	e3a03000 	mov	r3, #0	; 0x0
    6ee8:	e50b3018 	str	r3, [fp, #-24]
    6eec:	ea000002 	b	6efc <MCI_Send_Write_Block+0xd8>
    6ef0:	e51b3018 	ldr	r3, [fp, #-24]
    6ef4:	e2833001 	add	r3, r3, #1	; 0x1
    6ef8:	e50b3018 	str	r3, [fp, #-24]
    6efc:	e51b3018 	ldr	r3, [fp, #-24]
    6f00:	e353001f 	cmp	r3, #31	; 0x1f
    6f04:	9afffff9 	bls	6ef0 <MCI_Send_Write_Block+0xcc>
			;
		}
		retryCount--;
    6f08:	e51b3014 	ldr	r3, [fp, #-20]
    6f0c:	e2433001 	sub	r3, r3, #1	; 0x1
    6f10:	e50b3014 	str	r3, [fp, #-20]
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
    6f14:	e51b3014 	ldr	r3, [fp, #-20]
    6f18:	e3530000 	cmp	r3, #0	; 0x0
    6f1c:	1affffc8 	bne	6e44 <MCI_Send_Write_Block+0x20>
		for (i = 0; i < 0x20; i++) {
			;
		}
		retryCount--;
	}
	return ( FALSE ); /* Fatal error */
    6f20:	e3a03000 	mov	r3, #0	; 0x0
    6f24:	e50b3030 	str	r3, [fp, #-48]
    6f28:	e51b3030 	ldr	r3, [fp, #-48]
}
    6f2c:	e1a00003 	mov	r0, r3
    6f30:	e24bd00c 	sub	sp, fp, #12	; 0xc
    6f34:	e89da800 	ldm	sp, {fp, sp, pc}
    6f38:	40000050 	.word	0x40000050

00006f3c <MCI_Send_Write_Multiple_Block>:
 ** Returned value:		Response value
 ** 
 ** Added by Lorenz Aebi
 ******************************************************************************/
// mthomas - static
static DWORD MCI_Send_Write_Multiple_Block(DWORD blockNum) {
    6f3c:	e1a0c00d 	mov	ip, sp
    6f40:	e92dd800 	push	{fp, ip, lr, pc}
    6f44:	e24cb004 	sub	fp, ip, #4	; 0x4
    6f48:	e24dd024 	sub	sp, sp, #36	; 0x24
    6f4c:	e50b002c 	str	r0, [fp, #-44]
	volatile DWORD i; // mthomas - volatile
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
    6f50:	e3a03020 	mov	r3, #32	; 0x20
    6f54:	e50b3014 	str	r3, [fp, #-20]
    6f58:	ea000033 	b	702c <MCI_Send_Write_Multiple_Block+0xf0>
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    6f5c:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    6f60:	e2822923 	add	r2, r2, #573440	; 0x8c000
    6f64:	e2822038 	add	r2, r2, #56	; 0x38
    6f68:	e3a03e7f 	mov	r3, #2032	; 0x7f0
    6f6c:	e283300f 	add	r3, r3, #15	; 0xf
    6f70:	e5823000 	str	r3, [r2]
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
    6f74:	e59f30d4 	ldr	r3, [pc, #212]	; 7050 <MCI_Send_Write_Multiple_Block+0x114>
    6f78:	e5933000 	ldr	r3, [r3]
    6f7c:	e3530004 	cmp	r3, #4	; 0x4
    6f80:	1a000005 	bne	6f9c <MCI_Send_Write_Multiple_Block+0x60>
			MCI_SendCmd( WRITE_MULTIPLE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
    6f84:	e3a00019 	mov	r0, #25	; 0x19
    6f88:	e51b102c 	ldr	r1, [fp, #-44]
    6f8c:	e3a02001 	mov	r2, #1	; 0x1
    6f90:	e3a03000 	mov	r3, #0	; 0x0
    6f94:	ebfffb16 	bl	5bf4 <MCI_SendCmd>
    6f98:	ea000006 	b	6fb8 <MCI_Send_Write_Multiple_Block+0x7c>
		} else {
			MCI_SendCmd( WRITE_MULTIPLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
    6f9c:	e51b302c 	ldr	r3, [fp, #-44]
    6fa0:	e1a03483 	lsl	r3, r3, #9
    6fa4:	e3a00019 	mov	r0, #25	; 0x19
    6fa8:	e1a01003 	mov	r1, r3
    6fac:	e3a02001 	mov	r2, #1	; 0x1
    6fb0:	e3a03000 	mov	r3, #0	; 0x0
    6fb4:	ebfffb0e 	bl	5bf4 <MCI_SendCmd>
		}
#else
		// NXP original
		MCI_SendCmd( WRITE_MULTIPLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0 );
#endif
		respStatus = MCI_GetCmdResp( WRITE_MULTIPLE_BLOCK, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    6fb8:	e24b3028 	sub	r3, fp, #40	; 0x28
    6fbc:	e3a00019 	mov	r0, #25	; 0x19
    6fc0:	e3a01001 	mov	r1, #1	; 0x1
    6fc4:	e1a02003 	mov	r2, r3
    6fc8:	ebfffb60 	bl	5d50 <MCI_GetCmdResp>
    6fcc:	e1a03000 	mov	r3, r0
    6fd0:	e50b3010 	str	r3, [fp, #-16]
		/* it should be in the transfer state, bit 9~12 is 0x0100 and bit 8 is 1 */
		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
    6fd4:	e51b3010 	ldr	r3, [fp, #-16]
    6fd8:	e3530000 	cmp	r3, #0	; 0x0
    6fdc:	1a000006 	bne	6ffc <MCI_Send_Write_Multiple_Block+0xc0>
    6fe0:	e51b3028 	ldr	r3, [fp, #-40]
    6fe4:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    6fe8:	e3530c09 	cmp	r3, #2304	; 0x900
    6fec:	1a000002 	bne	6ffc <MCI_Send_Write_Multiple_Block+0xc0>
			return ( TRUE ); /* ready and in TRAN state */
    6ff0:	e3a03001 	mov	r3, #1	; 0x1
    6ff4:	e50b3030 	str	r3, [fp, #-48]
    6ff8:	ea000010 	b	7040 <MCI_Send_Write_Multiple_Block+0x104>
		}

		for (i = 0; i < 0x20; i++) {
    6ffc:	e3a03000 	mov	r3, #0	; 0x0
    7000:	e50b3018 	str	r3, [fp, #-24]
    7004:	ea000002 	b	7014 <MCI_Send_Write_Multiple_Block+0xd8>
    7008:	e51b3018 	ldr	r3, [fp, #-24]
    700c:	e2833001 	add	r3, r3, #1	; 0x1
    7010:	e50b3018 	str	r3, [fp, #-24]
    7014:	e51b3018 	ldr	r3, [fp, #-24]
    7018:	e353001f 	cmp	r3, #31	; 0x1f
    701c:	9afffff9 	bls	7008 <MCI_Send_Write_Multiple_Block+0xcc>
			;
		}
		retryCount--;
    7020:	e51b3014 	ldr	r3, [fp, #-20]
    7024:	e2433001 	sub	r3, r3, #1	; 0x1
    7028:	e50b3014 	str	r3, [fp, #-20]
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
    702c:	e51b3014 	ldr	r3, [fp, #-20]
    7030:	e3530000 	cmp	r3, #0	; 0x0
    7034:	1affffc8 	bne	6f5c <MCI_Send_Write_Multiple_Block+0x20>
		for (i = 0; i < 0x20; i++) {
			;
		}
		retryCount--;
	}
	return ( FALSE ); /* Fatal error */
    7038:	e3a03000 	mov	r3, #0	; 0x0
    703c:	e50b3030 	str	r3, [fp, #-48]
    7040:	e51b3030 	ldr	r3, [fp, #-48]
}
    7044:	e1a00003 	mov	r0, r3
    7048:	e24bd00c 	sub	sp, fp, #12	; 0xc
    704c:	e89da800 	ldm	sp, {fp, sp, pc}
    7050:	40000050 	.word	0x40000050

00007054 <MCI_Send_Read_Block>:
 ** Returned value:		Response value
 **
 ** modified by mthomas
 ******************************************************************************/
// mthomas - static
static DWORD MCI_Send_Read_Block(DWORD blockNum) {
    7054:	e1a0c00d 	mov	ip, sp
    7058:	e92dd800 	push	{fp, ip, lr, pc}
    705c:	e24cb004 	sub	fp, ip, #4	; 0x4
    7060:	e24dd024 	sub	sp, sp, #36	; 0x24
    7064:	e50b002c 	str	r0, [fp, #-44]
	volatile DWORD i; // mthomas - volatile
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
    7068:	e3a03020 	mov	r3, #32	; 0x20
    706c:	e50b3014 	str	r3, [fp, #-20]
    7070:	ea000033 	b	7144 <MCI_Send_Read_Block+0xf0>
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    7074:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    7078:	e2822923 	add	r2, r2, #573440	; 0x8c000
    707c:	e2822038 	add	r2, r2, #56	; 0x38
    7080:	e3a03e7f 	mov	r3, #2032	; 0x7f0
    7084:	e283300f 	add	r3, r3, #15	; 0xf
    7088:	e5823000 	str	r3, [r2]
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
    708c:	e59f30d4 	ldr	r3, [pc, #212]	; 7168 <MCI_Send_Read_Block+0x114>
    7090:	e5933000 	ldr	r3, [r3]
    7094:	e3530004 	cmp	r3, #4	; 0x4
    7098:	1a000005 	bne	70b4 <MCI_Send_Read_Block+0x60>
			MCI_SendCmd( READ_SINGLE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
    709c:	e3a00011 	mov	r0, #17	; 0x11
    70a0:	e51b102c 	ldr	r1, [fp, #-44]
    70a4:	e3a02001 	mov	r2, #1	; 0x1
    70a8:	e3a03000 	mov	r3, #0	; 0x0
    70ac:	ebfffad0 	bl	5bf4 <MCI_SendCmd>
    70b0:	ea000006 	b	70d0 <MCI_Send_Read_Block+0x7c>
		} else {
			MCI_SendCmd( READ_SINGLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
    70b4:	e51b302c 	ldr	r3, [fp, #-44]
    70b8:	e1a03483 	lsl	r3, r3, #9
    70bc:	e3a00011 	mov	r0, #17	; 0x11
    70c0:	e1a01003 	mov	r1, r3
    70c4:	e3a02001 	mov	r2, #1	; 0x1
    70c8:	e3a03000 	mov	r3, #0	; 0x0
    70cc:	ebfffac8 	bl	5bf4 <MCI_SendCmd>
		}
#else
		// NXP original
		MCI_SendCmd( READ_SINGLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0 );
#endif
		respStatus = MCI_GetCmdResp( READ_SINGLE_BLOCK, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    70d0:	e24b3028 	sub	r3, fp, #40	; 0x28
    70d4:	e3a00011 	mov	r0, #17	; 0x11
    70d8:	e3a01001 	mov	r1, #1	; 0x1
    70dc:	e1a02003 	mov	r2, r3
    70e0:	ebfffb1a 	bl	5d50 <MCI_GetCmdResp>
    70e4:	e1a03000 	mov	r3, r0
    70e8:	e50b3010 	str	r3, [fp, #-16]
		/* it should be in the transfer state, bit 9~12 is 0x0100 and bit 8 is 1 */
		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
    70ec:	e51b3010 	ldr	r3, [fp, #-16]
    70f0:	e3530000 	cmp	r3, #0	; 0x0
    70f4:	1a000006 	bne	7114 <MCI_Send_Read_Block+0xc0>
    70f8:	e51b3028 	ldr	r3, [fp, #-40]
    70fc:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    7100:	e3530c09 	cmp	r3, #2304	; 0x900
    7104:	1a000002 	bne	7114 <MCI_Send_Read_Block+0xc0>
			return ( TRUE ); /* ready and in TRAN state */
    7108:	e3a03001 	mov	r3, #1	; 0x1
    710c:	e50b3030 	str	r3, [fp, #-48]
    7110:	ea000010 	b	7158 <MCI_Send_Read_Block+0x104>
		}
		for (i = 0; i < 0x20; i++) {
    7114:	e3a03000 	mov	r3, #0	; 0x0
    7118:	e50b3018 	str	r3, [fp, #-24]
    711c:	ea000002 	b	712c <MCI_Send_Read_Block+0xd8>
    7120:	e51b3018 	ldr	r3, [fp, #-24]
    7124:	e2833001 	add	r3, r3, #1	; 0x1
    7128:	e50b3018 	str	r3, [fp, #-24]
    712c:	e51b3018 	ldr	r3, [fp, #-24]
    7130:	e353001f 	cmp	r3, #31	; 0x1f
    7134:	9afffff9 	bls	7120 <MCI_Send_Read_Block+0xcc>
			;
		}
		retryCount--;
    7138:	e51b3014 	ldr	r3, [fp, #-20]
    713c:	e2433001 	sub	r3, r3, #1	; 0x1
    7140:	e50b3014 	str	r3, [fp, #-20]
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
    7144:	e51b3014 	ldr	r3, [fp, #-20]
    7148:	e3530000 	cmp	r3, #0	; 0x0
    714c:	1affffc8 	bne	7074 <MCI_Send_Read_Block+0x20>
		for (i = 0; i < 0x20; i++) {
			;
		}
		retryCount--;
	}
	return ( FALSE ); /* Fatal error */
    7150:	e3a03000 	mov	r3, #0	; 0x0
    7154:	e50b3030 	str	r3, [fp, #-48]
    7158:	e51b3030 	ldr	r3, [fp, #-48]
}
    715c:	e1a00003 	mov	r0, r3
    7160:	e24bd00c 	sub	sp, fp, #12	; 0xc
    7164:	e89da800 	ldm	sp, {fp, sp, pc}
    7168:	40000050 	.word	0x40000050

0000716c <MCI_Write_Block>:
 ** parameters:			block number
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 ** 
 ******************************************************************************/
DWORD MCI_Write_Block(DWORD blockNum) {
    716c:	e1a0c00d 	mov	ip, sp
    7170:	e92dd800 	push	{fp, ip, lr, pc}
    7174:	e24cb004 	sub	fp, ip, #4	; 0x4
    7178:	e24dd010 	sub	sp, sp, #16	; 0x10
    717c:	e50b0018 	str	r0, [fp, #-24]
	volatile DWORD i; // mthomas - volatile
	DWORD DataCtrl = 0;
    7180:	e3a03000 	mov	r3, #0	; 0x0
    7184:	e50b3010 	str	r3, [fp, #-16]

	MCI_CLEAR = 0x7FF;
    7188:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    718c:	e2822923 	add	r2, r2, #573440	; 0x8c000
    7190:	e2822038 	add	r2, r2, #56	; 0x38
    7194:	e3a03e7f 	mov	r3, #2032	; 0x7f0
    7198:	e283300f 	add	r3, r3, #15	; 0xf
    719c:	e5823000 	str	r3, [r2]
	MCI_DATA_CTRL = 0;
    71a0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    71a4:	e2833923 	add	r3, r3, #573440	; 0x8c000
    71a8:	e283302c 	add	r3, r3, #44	; 0x2c
    71ac:	e3a02000 	mov	r2, #0	; 0x0
    71b0:	e5832000 	str	r2, [r3]
	for (i = 0; i < 0x10; i++) {
    71b4:	e3a03000 	mov	r3, #0	; 0x0
    71b8:	e50b3014 	str	r3, [fp, #-20]
    71bc:	ea000002 	b	71cc <MCI_Write_Block+0x60>
    71c0:	e51b3014 	ldr	r3, [fp, #-20]
    71c4:	e2833001 	add	r3, r3, #1	; 0x1
    71c8:	e50b3014 	str	r3, [fp, #-20]
    71cc:	e51b3014 	ldr	r3, [fp, #-20]
    71d0:	e353000f 	cmp	r3, #15	; 0xf
    71d4:	9afffff9 	bls	71c0 <MCI_Write_Block+0x54>
		;
	}

	/* Below status check is redundant, but ensure card is in TRANS state
	 before writing and reading to from the card. */
	if (MCI_CheckStatus() != TRUE) {
    71d8:	ebfff815 	bl	5234 <MCI_CheckStatus>
    71dc:	e1a03000 	mov	r3, r0
    71e0:	e3530001 	cmp	r3, #1	; 0x1
    71e4:	0a000003 	beq	71f8 <MCI_Write_Block+0x8c>
		mci_debug_printf("MCI_Wead_Block: not in trans\n");
		MCI_Send_Stop();
    71e8:	ebfffed5 	bl	6d44 <MCI_Send_Stop>
		return ( FALSE );
    71ec:	e3a03000 	mov	r3, #0	; 0x0
    71f0:	e50b301c 	str	r3, [fp, #-28]
    71f4:	ea000032 	b	72c4 <MCI_Write_Block+0x158>
	}

	MCI_DATA_TMR = DATA_TIMER_VALUE;
    71f8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    71fc:	e2833923 	add	r3, r3, #573440	; 0x8c000
    7200:	e2833024 	add	r3, r3, #36	; 0x24
    7204:	e3a02802 	mov	r2, #131072	; 0x20000
    7208:	e5832000 	str	r2, [r3]
	MCI_DATA_LEN = BLOCK_LENGTH;
    720c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7210:	e2833923 	add	r3, r3, #573440	; 0x8c000
    7214:	e2833028 	add	r3, r3, #40	; 0x28
    7218:	e3a02c02 	mov	r2, #512	; 0x200
    721c:	e5832000 	str	r2, [r3]
	MCI_Block_End_Flag = 1;
    7220:	e59f20ac 	ldr	r2, [pc, #172]	; 72d4 <MCI_Write_Block+0x168>
    7224:	e3a03001 	mov	r3, #1	; 0x1
    7228:	e5823000 	str	r3, [r2]
	MCI_TXEnable();
    722c:	ebfff7b8 	bl	5114 <MCI_TXEnable>
	if (MCI_Send_Write_Block(blockNum) == FALSE) {
    7230:	e51b0018 	ldr	r0, [fp, #-24]
    7234:	ebfffefa 	bl	6e24 <MCI_Send_Write_Block>
    7238:	e1a03000 	mov	r3, r0
    723c:	e3530000 	cmp	r3, #0	; 0x0
    7240:	1a000002 	bne	7250 <MCI_Write_Block+0xe4>
		return ( FALSE );
    7244:	e3a03000 	mov	r3, #0	; 0x0
    7248:	e50b301c 	str	r3, [fp, #-28]
    724c:	ea00001c 	b	72c4 <MCI_Write_Block+0x158>
	}

#if MCI_DMA_ENABLED
	DMA_Move( 0, M2P);
    7250:	e3a00000 	mov	r0, #0	; 0x0
    7254:	e3a01001 	mov	r1, #1	; 0x1
    7258:	eb0001d9 	bl	79c4 <DMA_Move>
	GPDMA_CH0_CFG |= 0x10001 | (0x00 << 1) | (0x04 << 6) | (0x05 << 11);
    725c:	e59f2074 	ldr	r2, [pc, #116]	; 72d8 <MCI_Write_Block+0x16c>
    7260:	e59f3070 	ldr	r3, [pc, #112]	; 72d8 <MCI_Write_Block+0x16c>
    7264:	e5933000 	ldr	r3, [r3]
    7268:	e3833b4a 	orr	r3, r3, #75776	; 0x12800
    726c:	e3833c01 	orr	r3, r3, #256	; 0x100
    7270:	e3833001 	orr	r3, r3, #1	; 0x1
    7274:	e5823000 	str	r3, [r2]
	/* Write, block transfer, DMA, and data length */
	DataCtrl |= ((1 << 0) | (1 << 3) | (DATA_BLOCK_LEN << 4));
    7278:	e51b3010 	ldr	r3, [fp, #-16]
    727c:	e3833099 	orr	r3, r3, #153	; 0x99
    7280:	e50b3010 	str	r3, [fp, #-16]
#else
	/* Write, block transfer, and data length */
	DataCtrl |= ((1 << 0) | (DATA_BLOCK_LEN << 4));
#endif
	MCI_DATA_CTRL = DataCtrl;
    7284:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7288:	e2833923 	add	r3, r3, #573440	; 0x8c000
    728c:	e283302c 	add	r3, r3, #44	; 0x2c
    7290:	e51b2010 	ldr	r2, [fp, #-16]
    7294:	e5832000 	str	r2, [r3]
	//laebi - not necessary
	for (i = 0; i < 0x10; i++) {
    7298:	e3a03000 	mov	r3, #0	; 0x0
    729c:	e50b3014 	str	r3, [fp, #-20]
    72a0:	ea000002 	b	72b0 <MCI_Write_Block+0x144>
    72a4:	e51b3014 	ldr	r3, [fp, #-20]
    72a8:	e2833001 	add	r3, r3, #1	; 0x1
    72ac:	e50b3014 	str	r3, [fp, #-20]
    72b0:	e51b3014 	ldr	r3, [fp, #-20]
    72b4:	e353000f 	cmp	r3, #15	; 0xf
    72b8:	9afffff9 	bls	72a4 <MCI_Write_Block+0x138>
		;
	}

	return ( TRUE );
    72bc:	e3a03001 	mov	r3, #1	; 0x1
    72c0:	e50b301c 	str	r3, [fp, #-28]
    72c4:	e51b301c 	ldr	r3, [fp, #-28]
}
    72c8:	e1a00003 	mov	r0, r3
    72cc:	e24bd00c 	sub	sp, fp, #12	; 0xc
    72d0:	e89da800 	ldm	sp, {fp, sp, pc}
    72d4:	40000770 	.word	0x40000770
    72d8:	ffe04110 	.word	0xffe04110

000072dc <MCI_Write_Multiple_Block>:
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 **
 ** Added by Lorenz Aebi
 ******************************************************************************/
DWORD MCI_Write_Multiple_Block(DWORD blockNum, BYTE count, const BYTE *buff) {
    72dc:	e1a0c00d 	mov	ip, sp
    72e0:	e92dd800 	push	{fp, ip, lr, pc}
    72e4:	e24cb004 	sub	fp, ip, #4	; 0x4
    72e8:	e24dd018 	sub	sp, sp, #24	; 0x18
    72ec:	e50b0018 	str	r0, [fp, #-24]
    72f0:	e1a03001 	mov	r3, r1
    72f4:	e50b2020 	str	r2, [fp, #-32]
    72f8:	e54b301c 	strb	r3, [fp, #-28]
	volatile DWORD i; // mthomas - volatile
	DWORD DataCtrl = 0;
    72fc:	e3a03000 	mov	r3, #0	; 0x0
    7300:	e50b3010 	str	r3, [fp, #-16]

	MCI_CLEAR = 0x7FF;
    7304:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    7308:	e2822923 	add	r2, r2, #573440	; 0x8c000
    730c:	e2822038 	add	r2, r2, #56	; 0x38
    7310:	e3a03e7f 	mov	r3, #2032	; 0x7f0
    7314:	e283300f 	add	r3, r3, #15	; 0xf
    7318:	e5823000 	str	r3, [r2]
	MCI_DATA_CTRL = 0;
    731c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7320:	e2833923 	add	r3, r3, #573440	; 0x8c000
    7324:	e283302c 	add	r3, r3, #44	; 0x2c
    7328:	e3a02000 	mov	r2, #0	; 0x0
    732c:	e5832000 	str	r2, [r3]
	//laebi - not necessary
	//for ( i = 0; i < 0x10; i++ ) { ; }

	/* Below status check is redundant, but ensure card is in TRANS state
	 before writing and reading to from the card. */
	if (MCI_CheckStatus() != TRUE) {
    7330:	ebfff7bf 	bl	5234 <MCI_CheckStatus>
    7334:	e1a03000 	mov	r3, r0
    7338:	e3530001 	cmp	r3, #1	; 0x1
    733c:	0a000003 	beq	7350 <MCI_Write_Multiple_Block+0x74>
		mci_debug_printf("MCI_Wead_Block: not in trans\n");
		MCI_Send_Stop();
    7340:	ebfffe7f 	bl	6d44 <MCI_Send_Stop>
		return ( FALSE );
    7344:	e3a03000 	mov	r3, #0	; 0x0
    7348:	e50b3024 	str	r3, [fp, #-36]
    734c:	ea00006c 	b	7504 <MCI_Write_Multiple_Block+0x228>
	}

	MCI_DATA_TMR = DATA_TIMER_VALUE;
    7350:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7354:	e2833923 	add	r3, r3, #573440	; 0x8c000
    7358:	e2833024 	add	r3, r3, #36	; 0x24
    735c:	e3a02802 	mov	r2, #131072	; 0x20000
    7360:	e5832000 	str	r2, [r3]
	MCI_DATA_LEN = BLOCK_LENGTH;
    7364:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7368:	e2833923 	add	r3, r3, #573440	; 0x8c000
    736c:	e2833028 	add	r3, r3, #40	; 0x28
    7370:	e3a02c02 	mov	r2, #512	; 0x200
    7374:	e5832000 	str	r2, [r3]
	MCI_Block_End_Flag = 1;
    7378:	e59f2194 	ldr	r2, [pc, #404]	; 7514 <MCI_Write_Multiple_Block+0x238>
    737c:	e3a03001 	mov	r3, #1	; 0x1
    7380:	e5823000 	str	r3, [r2]
	MCI_TXEnable();
    7384:	ebfff762 	bl	5114 <MCI_TXEnable>
	if (MCI_Send_Write_Multiple_Block(blockNum) == FALSE) {
    7388:	e51b0018 	ldr	r0, [fp, #-24]
    738c:	ebfffeea 	bl	6f3c <MCI_Send_Write_Multiple_Block>
    7390:	e1a03000 	mov	r3, r0
    7394:	e3530000 	cmp	r3, #0	; 0x0
    7398:	1a000002 	bne	73a8 <MCI_Write_Multiple_Block+0xcc>
		return ( FALSE );
    739c:	e3a03000 	mov	r3, #0	; 0x0
    73a0:	e50b3024 	str	r3, [fp, #-36]
    73a4:	ea000056 	b	7504 <MCI_Write_Multiple_Block+0x228>
	}

#if MCI_DMA_ENABLED
	do {
		// TODO: avoid copy
		memcpy((void *)DMA_SRC, buff, 512);
    73a8:	e3a0047f 	mov	r0, #2130706432	; 0x7f000000
    73ac:	e280060d 	add	r0, r0, #13631488	; 0xd00000
    73b0:	e51b1020 	ldr	r1, [fp, #-32]
    73b4:	e3a02c02 	mov	r2, #512	; 0x200
    73b8:	eb000764 	bl	9150 <memcpy>
		buff += 512;
    73bc:	e51b3020 	ldr	r3, [fp, #-32]
    73c0:	e2833c02 	add	r3, r3, #512	; 0x200
    73c4:	e50b3020 	str	r3, [fp, #-32]
		GPDMA_INT_TCCLR = 0x01;
    73c8:	e3a0328f 	mov	r3, #-268435448	; 0xf0000008
    73cc:	e28336fe 	add	r3, r3, #266338304	; 0xfe00000
    73d0:	e2833901 	add	r3, r3, #16384	; 0x4000
    73d4:	e3a02001 	mov	r2, #1	; 0x1
    73d8:	e5832000 	str	r2, [r3]
		GPDMA_INT_ERR_CLR = 0x01;
    73dc:	e3a03143 	mov	r3, #-1073741808	; 0xc0000010
    73e0:	e28335ff 	add	r3, r3, #1069547520	; 0x3fc00000
    73e4:	e2833981 	add	r3, r3, #2113536	; 0x204000
    73e8:	e3a02001 	mov	r2, #1	; 0x1
    73ec:	e5832000 	str	r2, [r3]
		GPDMA_CH0_SRC = DMA_SRC;
    73f0:	e3a024ff 	mov	r2, #-16777216	; 0xff000000
    73f4:	e282260e 	add	r2, r2, #14680064	; 0xe00000
    73f8:	e2822c41 	add	r2, r2, #16640	; 0x4100
    73fc:	e3a0347f 	mov	r3, #2130706432	; 0x7f000000
    7400:	e283360d 	add	r3, r3, #13631488	; 0xd00000
    7404:	e5823000 	str	r3, [r2]
		GPDMA_CH0_DEST = DMA_MCIFIFO;
    7408:	e3a0224f 	mov	r2, #-268435452	; 0xf0000004
    740c:	e28226fe 	add	r2, r2, #266338304	; 0xfe00000
    7410:	e2822c41 	add	r2, r2, #16640	; 0x4100
    7414:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7418:	e2833923 	add	r3, r3, #573440	; 0x8c000
    741c:	e2833080 	add	r3, r3, #128	; 0x80
    7420:	e5823000 	str	r3, [r2]
		GPDMA_CONFIG = 0x01;
    7424:	e3a031c3 	mov	r3, #-1073741776	; 0xc0000030
    7428:	e28335ff 	add	r3, r3, #1069547520	; 0x3fc00000
    742c:	e2833981 	add	r3, r3, #2113536	; 0x204000
    7430:	e3a02001 	mov	r2, #1	; 0x1
    7434:	e5832000 	str	r2, [r3]
		/* Enable DMA channels, little endian */
		while ( !(GPDMA_CONFIG & 0x01))
    7438:	e3a031c3 	mov	r3, #-1073741776	; 0xc0000030
    743c:	e28335ff 	add	r3, r3, #1069547520	; 0x3fc00000
    7440:	e2833981 	add	r3, r3, #2113536	; 0x204000
    7444:	e5933000 	ldr	r3, [r3]
    7448:	e2033001 	and	r3, r3, #1	; 0x1
    744c:	e3530000 	cmp	r3, #0	; 0x0
    7450:	0afffff8 	beq	7438 <MCI_Write_Multiple_Block+0x15c>
			;
		/* The burst size is set to 8, the size is 8 bit too. */
		/* Terminal Count Int enable */
		GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    7454:	e3a022cf 	mov	r2, #-268435444	; 0xf000000c
    7458:	e28226fe 	add	r2, r2, #266338304	; 0xfe00000
    745c:	e2822c41 	add	r2, r2, #16640	; 0x4100
    7460:	e3a03321 	mov	r3, #-2080374784	; 0x84000000
    7464:	e2833849 	add	r3, r3, #4784128	; 0x490000
    7468:	e2833c42 	add	r3, r3, #16896	; 0x4200
    746c:	e5823000 	str	r3, [r2]
		| (0x02 << 18) | (0x02 << 21) | (1 << 26) | 0x80000000;
		//DMA_Move( 0, M2P );
		GPDMA_CH0_CFG |= 0x10001 | (0x00 << 1) | (0x04 << 6) | (0x05 << 11);
    7470:	e59f20a0 	ldr	r2, [pc, #160]	; 7518 <MCI_Write_Multiple_Block+0x23c>
    7474:	e59f309c 	ldr	r3, [pc, #156]	; 7518 <MCI_Write_Multiple_Block+0x23c>
    7478:	e5933000 	ldr	r3, [r3]
    747c:	e3833b4a 	orr	r3, r3, #75776	; 0x12800
    7480:	e3833c01 	orr	r3, r3, #256	; 0x100
    7484:	e3833001 	orr	r3, r3, #1	; 0x1
    7488:	e5823000 	str	r3, [r2]
		/* Write, block transfer, DMA, and data length */
		DataCtrl |= ((1 << 0) | (1 << 3) | (DATA_BLOCK_LEN << 4));
    748c:	e51b3010 	ldr	r3, [fp, #-16]
    7490:	e3833099 	orr	r3, r3, #153	; 0x99
    7494:	e50b3010 	str	r3, [fp, #-16]
#else
		/* Write, block transfer, and data length */
		DataCtrl |= ((1 << 0) | (DATA_BLOCK_LEN << 4));
#endif
		MCI_DATA_CTRL = DataCtrl;
    7498:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    749c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    74a0:	e283302c 	add	r3, r3, #44	; 0x2c
    74a4:	e51b2010 	ldr	r2, [fp, #-16]
    74a8:	e5832000 	str	r2, [r3]
		for (i = 0; i < 0x10; i++) {
    74ac:	e3a03000 	mov	r3, #0	; 0x0
    74b0:	e50b3014 	str	r3, [fp, #-20]
    74b4:	ea000002 	b	74c4 <MCI_Write_Multiple_Block+0x1e8>
    74b8:	e51b3014 	ldr	r3, [fp, #-20]
    74bc:	e2833001 	add	r3, r3, #1	; 0x1
    74c0:	e50b3014 	str	r3, [fp, #-20]
    74c4:	e51b3014 	ldr	r3, [fp, #-20]
    74c8:	e353000f 	cmp	r3, #15	; 0xf
    74cc:	9afffff9 	bls	74b8 <MCI_Write_Multiple_Block+0x1dc>
			;
		}
	} while (count--);
    74d0:	e55b301c 	ldrb	r3, [fp, #-28]
    74d4:	e3530000 	cmp	r3, #0	; 0x0
    74d8:	03a03000 	moveq	r3, #0	; 0x0
    74dc:	13a03001 	movne	r3, #1	; 0x1
    74e0:	e20320ff 	and	r2, r3, #255	; 0xff
    74e4:	e55b301c 	ldrb	r3, [fp, #-28]
    74e8:	e2433001 	sub	r3, r3, #1	; 0x1
    74ec:	e54b301c 	strb	r3, [fp, #-28]
    74f0:	e3520000 	cmp	r2, #0	; 0x0
    74f4:	1affffab 	bne	73a8 <MCI_Write_Multiple_Block+0xcc>

	//for (i = 0; i < 0x10; i++) { ; }

	MCI_Send_Stop();
    74f8:	ebfffe11 	bl	6d44 <MCI_Send_Stop>

	return ( TRUE );
    74fc:	e3a03001 	mov	r3, #1	; 0x1
    7500:	e50b3024 	str	r3, [fp, #-36]
    7504:	e51b3024 	ldr	r3, [fp, #-36]
}
    7508:	e1a00003 	mov	r0, r3
    750c:	e24bd00c 	sub	sp, fp, #12	; 0xc
    7510:	e89da800 	ldm	sp, {fp, sp, pc}
    7514:	40000770 	.word	0x40000770
    7518:	ffe04110 	.word	0xffe04110

0000751c <MCI_Read_Block>:
 ** parameters:			block number
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 **
 ******************************************************************************/
DWORD MCI_Read_Block(DWORD blockNum) {
    751c:	e1a0c00d 	mov	ip, sp
    7520:	e92dd800 	push	{fp, ip, lr, pc}
    7524:	e24cb004 	sub	fp, ip, #4	; 0x4
    7528:	e24dd010 	sub	sp, sp, #16	; 0x10
    752c:	e50b0018 	str	r0, [fp, #-24]
	volatile DWORD i; // mthomas - volatile
	DWORD DataCtrl = 0;
    7530:	e3a03000 	mov	r3, #0	; 0x0
    7534:	e50b3010 	str	r3, [fp, #-16]

	MCI_CLEAR = 0x7FF;
    7538:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    753c:	e2822923 	add	r2, r2, #573440	; 0x8c000
    7540:	e2822038 	add	r2, r2, #56	; 0x38
    7544:	e3a03e7f 	mov	r3, #2032	; 0x7f0
    7548:	e283300f 	add	r3, r3, #15	; 0xf
    754c:	e5823000 	str	r3, [r2]
	MCI_DATA_CTRL = 0;
    7550:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7554:	e2833923 	add	r3, r3, #573440	; 0x8c000
    7558:	e283302c 	add	r3, r3, #44	; 0x2c
    755c:	e3a02000 	mov	r2, #0	; 0x0
    7560:	e5832000 	str	r2, [r3]
	for (i = 0; i < 0x10; i++) {
    7564:	e3a03000 	mov	r3, #0	; 0x0
    7568:	e50b3014 	str	r3, [fp, #-20]
    756c:	ea000002 	b	757c <MCI_Read_Block+0x60>
    7570:	e51b3014 	ldr	r3, [fp, #-20]
    7574:	e2833001 	add	r3, r3, #1	; 0x1
    7578:	e50b3014 	str	r3, [fp, #-20]
    757c:	e51b3014 	ldr	r3, [fp, #-20]
    7580:	e353000f 	cmp	r3, #15	; 0xf
    7584:	9afffff9 	bls	7570 <MCI_Read_Block+0x54>
		;
	}

	/* Below status check is redundant, but ensure card is in TRANS state
	 before writing and reading to from the card. */
	if (MCI_CheckStatus() != TRUE) {
    7588:	ebfff729 	bl	5234 <MCI_CheckStatus>
    758c:	e1a03000 	mov	r3, r0
    7590:	e3530001 	cmp	r3, #1	; 0x1
    7594:	0a000003 	beq	75a8 <MCI_Read_Block+0x8c>
		mci_debug_printf("MCI_Read_Block: not in trans\n");
		MCI_Send_Stop();
    7598:	ebfffde9 	bl	6d44 <MCI_Send_Stop>
		return ( FALSE );
    759c:	e3a03000 	mov	r3, #0	; 0x0
    75a0:	e50b301c 	str	r3, [fp, #-28]
    75a4:	ea000031 	b	7670 <MCI_Read_Block+0x154>
	}
	MCI_RXEnable();
    75a8:	ebfff709 	bl	51d4 <MCI_RXEnable>

	MCI_DATA_TMR = DATA_TIMER_VALUE;
    75ac:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    75b0:	e2833923 	add	r3, r3, #573440	; 0x8c000
    75b4:	e2833024 	add	r3, r3, #36	; 0x24
    75b8:	e3a02802 	mov	r2, #131072	; 0x20000
    75bc:	e5832000 	str	r2, [r3]
	MCI_DATA_LEN = BLOCK_LENGTH;
    75c0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    75c4:	e2833923 	add	r3, r3, #573440	; 0x8c000
    75c8:	e2833028 	add	r3, r3, #40	; 0x28
    75cc:	e3a02c02 	mov	r2, #512	; 0x200
    75d0:	e5832000 	str	r2, [r3]
	MCI_Block_End_Flag = 1;
    75d4:	e59f20a4 	ldr	r2, [pc, #164]	; 7680 <MCI_Read_Block+0x164>
    75d8:	e3a03001 	mov	r3, #1	; 0x1
    75dc:	e5823000 	str	r3, [r2]
	if (MCI_Send_Read_Block(blockNum) == FALSE) {
    75e0:	e51b0018 	ldr	r0, [fp, #-24]
    75e4:	ebfffe9a 	bl	7054 <MCI_Send_Read_Block>
    75e8:	e1a03000 	mov	r3, r0
    75ec:	e3530000 	cmp	r3, #0	; 0x0
    75f0:	1a000002 	bne	7600 <MCI_Read_Block+0xe4>
		return ( FALSE );
    75f4:	e3a03000 	mov	r3, #0	; 0x0
    75f8:	e50b301c 	str	r3, [fp, #-28]
    75fc:	ea00001b 	b	7670 <MCI_Read_Block+0x154>
	}

#if MCI_DMA_ENABLED
	DMA_Move( 1, P2M);
    7600:	e3a00001 	mov	r0, #1	; 0x1
    7604:	e3a01002 	mov	r1, #2	; 0x2
    7608:	eb0000ed 	bl	79c4 <DMA_Move>
	GPDMA_CH1_CFG |= 0x10001 | (0x04 << 1) | (0x00 << 6) | (0x06 << 11);
    760c:	e59f2070 	ldr	r2, [pc, #112]	; 7684 <MCI_Read_Block+0x168>
    7610:	e59f306c 	ldr	r3, [pc, #108]	; 7684 <MCI_Read_Block+0x168>
    7614:	e5933000 	ldr	r3, [r3]
    7618:	e3833a13 	orr	r3, r3, #77824	; 0x13000
    761c:	e3833009 	orr	r3, r3, #9	; 0x9
    7620:	e5823000 	str	r3, [r2]
	/* Write, block transfer, DMA, and data length */
	DataCtrl |= ((1 << 0) | (1 << 1) | (1 << 3) | (DATA_BLOCK_LEN << 4));
    7624:	e51b3010 	ldr	r3, [fp, #-16]
    7628:	e383309b 	orr	r3, r3, #155	; 0x9b
    762c:	e50b3010 	str	r3, [fp, #-16]
#else
	/* Read, enable, block transfer, and data length */
	DataCtrl |= ((1 << 0) | (1 << 1) | (DATA_BLOCK_LEN << 4));
#endif
	MCI_DATA_CTRL = DataCtrl;
    7630:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7634:	e2833923 	add	r3, r3, #573440	; 0x8c000
    7638:	e283302c 	add	r3, r3, #44	; 0x2c
    763c:	e51b2010 	ldr	r2, [fp, #-16]
    7640:	e5832000 	str	r2, [r3]
	for (i = 0; i < 0x10; i++) {
    7644:	e3a03000 	mov	r3, #0	; 0x0
    7648:	e50b3014 	str	r3, [fp, #-20]
    764c:	ea000002 	b	765c <MCI_Read_Block+0x140>
    7650:	e51b3014 	ldr	r3, [fp, #-20]
    7654:	e2833001 	add	r3, r3, #1	; 0x1
    7658:	e50b3014 	str	r3, [fp, #-20]
    765c:	e51b3014 	ldr	r3, [fp, #-20]
    7660:	e353000f 	cmp	r3, #15	; 0xf
    7664:	9afffff9 	bls	7650 <MCI_Read_Block+0x134>
		;
	}

	return ( TRUE );
    7668:	e3a03001 	mov	r3, #1	; 0x1
    766c:	e50b301c 	str	r3, [fp, #-28]
    7670:	e51b301c 	ldr	r3, [fp, #-28]
}
    7674:	e1a00003 	mov	r0, r3
    7678:	e24bd00c 	sub	sp, fp, #12	; 0xc
    767c:	e89da800 	ldm	sp, {fp, sp, pc}
    7680:	40000770 	.word	0x40000770
    7684:	ffe04130 	.word	0xffe04130

00007688 <MCI_Sd_Status>:
 ** parameters:			none
 ** Returned value:		true or false 
 ** 
 ** Added by Martin Thomas
 ******************************************************************************/
DWORD MCI_Sd_Status(void) {
    7688:	e1a0c00d 	mov	ip, sp
    768c:	e92dd800 	push	{fp, ip, lr, pc}
    7690:	e24cb004 	sub	fp, ip, #4	; 0x4
    7694:	e24dd028 	sub	sp, sp, #40	; 0x28
	volatile DWORD i;
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];
	DWORD stuffbits = 0x00000000;
    7698:	e3a03000 	mov	r3, #0	; 0x0
    769c:	e50b3014 	str	r3, [fp, #-20]
	DWORD DataCtrl = 0;
    76a0:	e3a03000 	mov	r3, #0	; 0x0
    76a4:	e50b3010 	str	r3, [fp, #-16]

	if ( (MCI_CardType == CARD_UNKNOWN ) || (MCI_CardType == MMC_CARD )) {
    76a8:	e59f322c 	ldr	r3, [pc, #556]	; 78dc <MCI_Sd_Status+0x254>
    76ac:	e5933000 	ldr	r3, [r3]
    76b0:	e3530000 	cmp	r3, #0	; 0x0
    76b4:	0a000003 	beq	76c8 <MCI_Sd_Status+0x40>
    76b8:	e59f321c 	ldr	r3, [pc, #540]	; 78dc <MCI_Sd_Status+0x254>
    76bc:	e5933000 	ldr	r3, [r3]
    76c0:	e3530001 	cmp	r3, #1	; 0x1
    76c4:	1a000002 	bne	76d4 <MCI_Sd_Status+0x4c>
		return ( FALSE ); // unsupported
    76c8:	e3a03000 	mov	r3, #0	; 0x0
    76cc:	e50b3034 	str	r3, [fp, #-52]
    76d0:	ea00007d 	b	78cc <MCI_Sd_Status+0x244>
	}

	MCI_CLEAR = 0x7FF;
    76d4:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    76d8:	e2822923 	add	r2, r2, #573440	; 0x8c000
    76dc:	e2822038 	add	r2, r2, #56	; 0x38
    76e0:	e3a03e7f 	mov	r3, #2032	; 0x7f0
    76e4:	e283300f 	add	r3, r3, #15	; 0xf
    76e8:	e5823000 	str	r3, [r2]
	MCI_DATA_CTRL = 0;
    76ec:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    76f0:	e2833923 	add	r3, r3, #573440	; 0x8c000
    76f4:	e283302c 	add	r3, r3, #44	; 0x2c
    76f8:	e3a02000 	mov	r2, #0	; 0x0
    76fc:	e5832000 	str	r2, [r3]
	for (i = 0; i < 0x10; i++) {
    7700:	e3a03000 	mov	r3, #0	; 0x0
    7704:	e50b3020 	str	r3, [fp, #-32]
    7708:	ea000002 	b	7718 <MCI_Sd_Status+0x90>
    770c:	e51b3020 	ldr	r3, [fp, #-32]
    7710:	e2833001 	add	r3, r3, #1	; 0x1
    7714:	e50b3020 	str	r3, [fp, #-32]
    7718:	e51b3020 	ldr	r3, [fp, #-32]
    771c:	e353000f 	cmp	r3, #15	; 0xf
    7720:	9afffff9 	bls	770c <MCI_Sd_Status+0x84>
		;
	}

	/* Below status check is redundant, but ensure card is in TRANS state
	 before writing and reading to from the card. */
	if (MCI_CheckStatus() != TRUE) {
    7724:	ebfff6c2 	bl	5234 <MCI_CheckStatus>
    7728:	e1a03000 	mov	r3, r0
    772c:	e3530001 	cmp	r3, #1	; 0x1
    7730:	0a000003 	beq	7744 <MCI_Sd_Status+0xbc>
		MCI_Send_Stop();mci_debug_printf("Sd_Status: Not in trans-state\n");
    7734:	ebfffd82 	bl	6d44 <MCI_Send_Stop>
		return ( FALSE );
    7738:	e3a03000 	mov	r3, #0	; 0x0
    773c:	e50b3034 	str	r3, [fp, #-52]
    7740:	ea000061 	b	78cc <MCI_Sd_Status+0x244>
	}

	MCI_RXEnable();
    7744:	ebfff6a2 	bl	51d4 <MCI_RXEnable>

	MCI_DATA_TMR = DATA_TIMER_VALUE;
    7748:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    774c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    7750:	e2833024 	add	r3, r3, #36	; 0x24
    7754:	e3a02802 	mov	r2, #131072	; 0x20000
    7758:	e5832000 	str	r2, [r3]
	MCI_DATA_LEN = BLOCK_LENGTH;
    775c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7760:	e2833923 	add	r3, r3, #573440	; 0x8c000
    7764:	e2833028 	add	r3, r3, #40	; 0x28
    7768:	e3a02c02 	mov	r2, #512	; 0x200
    776c:	e5832000 	str	r2, [r3]
	// MCI_DATA_LEN = SD_BLOCK_LENGTH;
	MCI_Block_End_Flag = 1;
    7770:	e59f2168 	ldr	r2, [pc, #360]	; 78e0 <MCI_Sd_Status+0x258>
    7774:	e3a03001 	mov	r3, #1	; 0x1
    7778:	e5823000 	str	r3, [r2]
	SDStatRead = 1;
    777c:	e59f2160 	ldr	r2, [pc, #352]	; 78e4 <MCI_Sd_Status+0x25c>
    7780:	e3a03001 	mov	r3, #1	; 0x1
    7784:	e5823000 	str	r3, [r2]

	// "MCI_Send_SD_STATUS":
	retryCount = 0x20;
    7788:	e3a03020 	mov	r3, #32	; 0x20
    778c:	e50b301c 	str	r3, [fp, #-28]
    7790:	ea000028 	b	7838 <MCI_Sd_Status+0x1b0>
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    7794:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7798:	e2833923 	add	r3, r3, #573440	; 0x8c000
    779c:	e2833038 	add	r3, r3, #56	; 0x38
    77a0:	e3a02e7f 	mov	r2, #2032	; 0x7f0
    77a4:	e282200f 	add	r2, r2, #15	; 0xf
    77a8:	e5832000 	str	r2, [r3]
		// prepare for ACMD (with CMD55)
		if (MCI_Send_ACMD() == TRUE) {
    77ac:	ebfffa61 	bl	6138 <MCI_Send_ACMD>
    77b0:	e1a03000 	mov	r3, r0
    77b4:	e3530001 	cmp	r3, #1	; 0x1
    77b8:	1a000012 	bne	7808 <MCI_Sd_Status+0x180>
			// Send ACMD13
			MCI_SendCmd( SD_STATUS, stuffbits, EXPECT_SHORT_RESP, 0);
    77bc:	e3a0000d 	mov	r0, #13	; 0xd
    77c0:	e51b1014 	ldr	r1, [fp, #-20]
    77c4:	e3a02001 	mov	r2, #1	; 0x1
    77c8:	e3a03000 	mov	r3, #0	; 0x0
    77cc:	ebfff908 	bl	5bf4 <MCI_SendCmd>
			respStatus = MCI_GetCmdResp( SD_STATUS, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    77d0:	e24b3030 	sub	r3, fp, #48	; 0x30
    77d4:	e3a0000d 	mov	r0, #13	; 0xd
    77d8:	e3a01001 	mov	r1, #1	; 0x1
    77dc:	e1a02003 	mov	r2, r3
    77e0:	ebfff95a 	bl	5d50 <MCI_GetCmdResp>
    77e4:	e1a03000 	mov	r3, r0
    77e8:	e50b3018 	str	r3, [fp, #-24]
			/* it should be in the transfer state, bit 9~12 is 0x0100 and bit 8 is 1 */
			if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
    77ec:	e51b3018 	ldr	r3, [fp, #-24]
    77f0:	e3530000 	cmp	r3, #0	; 0x0
    77f4:	1a000003 	bne	7808 <MCI_Sd_Status+0x180>
    77f8:	e51b3030 	ldr	r3, [fp, #-48]
    77fc:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    7800:	e3530c09 	cmp	r3, #2304	; 0x900
    7804:	0a00000e 	beq	7844 <MCI_Sd_Status+0x1bc>
				break; /* ready and in TRAN state */
			}
		}
		for (i = 0; i < 0x20; i++) {
    7808:	e3a03000 	mov	r3, #0	; 0x0
    780c:	e50b3020 	str	r3, [fp, #-32]
    7810:	ea000002 	b	7820 <MCI_Sd_Status+0x198>
    7814:	e51b3020 	ldr	r3, [fp, #-32]
    7818:	e2833001 	add	r3, r3, #1	; 0x1
    781c:	e50b3020 	str	r3, [fp, #-32]
    7820:	e51b3020 	ldr	r3, [fp, #-32]
    7824:	e353001f 	cmp	r3, #31	; 0x1f
    7828:	9afffff9 	bls	7814 <MCI_Sd_Status+0x18c>
			;
		}
		retryCount--;
    782c:	e51b301c 	ldr	r3, [fp, #-28]
    7830:	e2433001 	sub	r3, r3, #1	; 0x1
    7834:	e50b301c 	str	r3, [fp, #-28]
	MCI_Block_End_Flag = 1;
	SDStatRead = 1;

	// "MCI_Send_SD_STATUS":
	retryCount = 0x20;
	while (retryCount > 0) {
    7838:	e51b301c 	ldr	r3, [fp, #-28]
    783c:	e3530000 	cmp	r3, #0	; 0x0
    7840:	1affffd3 	bne	7794 <MCI_Sd_Status+0x10c>
		for (i = 0; i < 0x20; i++) {
			;
		}
		retryCount--;
	}
	if (retryCount == 0) {
    7844:	e51b301c 	ldr	r3, [fp, #-28]
    7848:	e3530000 	cmp	r3, #0	; 0x0
    784c:	1a000002 	bne	785c <MCI_Sd_Status+0x1d4>
		mci_debug_printf("Sd_Status: ACMD13 failed\n");
		return ( FALSE ); // error sending ACMD13 or state not trans
    7850:	e3a03000 	mov	r3, #0	; 0x0
    7854:	e50b3034 	str	r3, [fp, #-52]
    7858:	ea00001b 	b	78cc <MCI_Sd_Status+0x244>
	}

#if MCI_DMA_ENABLED
	DMA_Move( 1, P2M);
    785c:	e3a00001 	mov	r0, #1	; 0x1
    7860:	e3a01002 	mov	r1, #2	; 0x2
    7864:	eb000056 	bl	79c4 <DMA_Move>
	GPDMA_CH1_CFG |= 0x10001 | (0x04 << 1) | (0x00 << 6) | (0x06 << 11);
    7868:	e59f2078 	ldr	r2, [pc, #120]	; 78e8 <MCI_Sd_Status+0x260>
    786c:	e59f3074 	ldr	r3, [pc, #116]	; 78e8 <MCI_Sd_Status+0x260>
    7870:	e5933000 	ldr	r3, [r3]
    7874:	e3833a13 	orr	r3, r3, #77824	; 0x13000
    7878:	e3833009 	orr	r3, r3, #9	; 0x9
    787c:	e5823000 	str	r3, [r2]
	/* Write, block transfer, DMA, and data length */
	DataCtrl |= ((1 << 0) | (1 << 1) | (1 << 3) | (SD_STATUS_BLOCK_LEN << 4));
    7880:	e51b3010 	ldr	r3, [fp, #-16]
    7884:	e383306b 	orr	r3, r3, #107	; 0x6b
    7888:	e50b3010 	str	r3, [fp, #-16]
#else
	/* Read, enable, block transfer, and data length */
	DataCtrl |= ((1 << 0) | (1 << 1) | ( SD_STATUS_BLOCK_LEN << 4 ));
#endif
	MCI_DATA_CTRL = DataCtrl;
    788c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7890:	e2833923 	add	r3, r3, #573440	; 0x8c000
    7894:	e283302c 	add	r3, r3, #44	; 0x2c
    7898:	e51b2010 	ldr	r2, [fp, #-16]
    789c:	e5832000 	str	r2, [r3]
	// mci_debug_printf("MCI_SD_Status: DATA_CTRL set\n");
	for (i = 0; i < 0x10; i++) {
    78a0:	e3a03000 	mov	r3, #0	; 0x0
    78a4:	e50b3020 	str	r3, [fp, #-32]
    78a8:	ea000002 	b	78b8 <MCI_Sd_Status+0x230>
    78ac:	e51b3020 	ldr	r3, [fp, #-32]
    78b0:	e2833001 	add	r3, r3, #1	; 0x1
    78b4:	e50b3020 	str	r3, [fp, #-32]
    78b8:	e51b3020 	ldr	r3, [fp, #-32]
    78bc:	e353000f 	cmp	r3, #15	; 0xf
    78c0:	9afffff9 	bls	78ac <MCI_Sd_Status+0x224>
		;
	}

	return ( TRUE );
    78c4:	e3a03001 	mov	r3, #1	; 0x1
    78c8:	e50b3034 	str	r3, [fp, #-52]
    78cc:	e51b3034 	ldr	r3, [fp, #-52]
}
    78d0:	e1a00003 	mov	r0, r3
    78d4:	e24bd00c 	sub	sp, fp, #12	; 0xc
    78d8:	e89da800 	ldm	sp, {fp, sp, pc}
    78dc:	40000050 	.word	0x40000050
    78e0:	40000770 	.word	0x40000770
    78e4:	40000780 	.word	0x40000780
    78e8:	ffe04130 	.word	0xffe04130

000078ec <MCI_Power_Off>:
 ** parameters:			none
 ** Returned value:		none
 ** 
 ** Added by Martin Thomas - but it does not work on MCB2300
 ******************************************************************************/
void MCI_Power_Off(void) {
    78ec:	e1a0c00d 	mov	ip, sp
    78f0:	e92dd800 	push	{fp, ip, lr, pc}
    78f4:	e24cb004 	sub	fp, ip, #4	; 0x4
    78f8:	e24dd004 	sub	sp, sp, #4	; 0x4
	volatile DWORD i;

	// SCS |= (1<<8);
	MCI_POWER = 0;
    78fc:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7900:	e2833923 	add	r3, r3, #573440	; 0x8c000
    7904:	e3a02000 	mov	r2, #0	; 0x0
    7908:	e5832000 	str	r2, [r3]
	for (i = 0; i < 0x100; i++)
    790c:	e3a03000 	mov	r3, #0	; 0x0
    7910:	e50b3010 	str	r3, [fp, #-16]
    7914:	ea000002 	b	7924 <MCI_Power_Off+0x38>
    7918:	e51b3010 	ldr	r3, [fp, #-16]
    791c:	e2833001 	add	r3, r3, #1	; 0x1
    7920:	e50b3010 	str	r3, [fp, #-16]
    7924:	e51b3010 	ldr	r3, [fp, #-16]
    7928:	e35300ff 	cmp	r3, #255	; 0xff
    792c:	9afffff9 	bls	7918 <MCI_Power_Off+0x2c>
		;mci_debug_printf( "MCI_POWER 0x%08x\n", MCI_POWER );
}
    7930:	e89da808 	ldm	sp, {r3, fp, sp, pc}

00007934 <DMAHandler>:
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
void DMAHandler (void)
{
    7934:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
    7938:	e1a0c00d 	mov	ip, sp
    793c:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
    7940:	e24cb004 	sub	fp, ip, #4	; 0x4
  DWORD regVal;
  static DWORD DMATCCount, DMAErrCount;

  regVal = GPDMA_INT_TCSTAT;
    7944:	e59fc06c 	ldr	ip, [pc, #108]	; 79b8 <DMAHandler+0x84>
    7948:	e51c0ffb 	ldr	r0, [ip, #-4091]
  if ( regVal )
    794c:	e3500000 	cmp	r0, #0	; 0x0
    7950:	0a000006 	beq	7970 <DMAHandler+0x3c>
  {
	DMATCCount++;
    7954:	e59f1060 	ldr	r1, [pc, #96]	; 79bc <DMAHandler+0x88>
	GPDMA_INT_TCCLR |= regVal;
    7958:	e51c2ff7 	ldr	r2, [ip, #-4087]
  static DWORD DMATCCount, DMAErrCount;

  regVal = GPDMA_INT_TCSTAT;
  if ( regVal )
  {
	DMATCCount++;
    795c:	e5913000 	ldr	r3, [r1]
	GPDMA_INT_TCCLR |= regVal;
    7960:	e1822000 	orr	r2, r2, r0
  static DWORD DMATCCount, DMAErrCount;

  regVal = GPDMA_INT_TCSTAT;
  if ( regVal )
  {
	DMATCCount++;
    7964:	e2833001 	add	r3, r3, #1	; 0x1
    7968:	e5813000 	str	r3, [r1]
	GPDMA_INT_TCCLR |= regVal;
    796c:	e50c2ff7 	str	r2, [ip, #-4087]
  } 

  regVal = GPDMA_INT_ERR_STAT;
    7970:	e59fc040 	ldr	ip, [pc, #64]	; 79b8 <DMAHandler+0x84>
    7974:	e51c0ff3 	ldr	r0, [ip, #-4083]
  if ( regVal )
    7978:	e3500000 	cmp	r0, #0	; 0x0
    797c:	0a000006 	beq	799c <DMAHandler+0x68>
  {
	DMAErrCount++;
    7980:	e59f1038 	ldr	r1, [pc, #56]	; 79c0 <DMAHandler+0x8c>
	GPDMA_INT_ERR_CLR |= regVal;
    7984:	e51c2fef 	ldr	r2, [ip, #-4079]
  } 

  regVal = GPDMA_INT_ERR_STAT;
  if ( regVal )
  {
	DMAErrCount++;
    7988:	e5913000 	ldr	r3, [r1]
	GPDMA_INT_ERR_CLR |= regVal;
    798c:	e1822000 	orr	r2, r2, r0
  } 

  regVal = GPDMA_INT_ERR_STAT;
  if ( regVal )
  {
	DMAErrCount++;
    7990:	e2833001 	add	r3, r3, #1	; 0x1
    7994:	e5813000 	str	r3, [r1]
	GPDMA_INT_ERR_CLR |= regVal;
    7998:	e50c2fef 	str	r2, [ip, #-4079]
  } 
  VICVectAddr = 0;		/* Acknowledge Interrupt */
    799c:	e3a02000 	mov	r2, #0	; 0x0
    79a0:	e3e03000 	mvn	r3, #0	; 0x0
    79a4:	e50320ff 	str	r2, [r3, #-255]
}
    79a8:	e24bd01c 	sub	sp, fp, #28	; 0x1c
    79ac:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
    79b0:	e8bd1000 	pop	{ip}
    79b4:	e25ef004 	subs	pc, lr, #4	; 0x4
    79b8:	ffe04fff 	.word	0xffe04fff
    79bc:	40000788 	.word	0x40000788
    79c0:	40000784 	.word	0x40000784

000079c4 <DMA_Move>:
** parameters:			Channel number, DMA mode			
** Returned value:		TRUE or FALSE		
** 
******************************************************************************/
DWORD DMA_Move( DWORD ChannelNum, DWORD DMAMode )
{
    79c4:	e1a0c00d 	mov	ip, sp
  /* USB RAM is used for test.
  Please note, Ethernet has its own SRAM, but GPDMA can't access
  that. GPDMA can access USB SRAM and IRAM. Ethernet DMA controller can 
  access both IRAM and Ethernet SRAM. */
  if ( ChannelNum == 0 )
    79c8:	e3500000 	cmp	r0, #0	; 0x0
** parameters:			Channel number, DMA mode			
** Returned value:		TRUE or FALSE		
** 
******************************************************************************/
DWORD DMA_Move( DWORD ChannelNum, DWORD DMAMode )
{
    79cc:	e92dd800 	push	{fp, ip, lr, pc}
    79d0:	e24cb004 	sub	fp, ip, #4	; 0x4
  /* USB RAM is used for test.
  Please note, Ethernet has its own SRAM, but GPDMA can't access
  that. GPDMA can access USB SRAM and IRAM. Ethernet DMA controller can 
  access both IRAM and Ethernet SRAM. */
  if ( ChannelNum == 0 )
    79d4:	1a00001c 	bne	7a4c <DMA_Move+0x88>
  {
	GPDMA_INT_TCCLR = 0x01;   
    79d8:	e59f210c 	ldr	r2, [pc, #268]	; 7aec <DMA_Move+0x128>
    79dc:	e3a03001 	mov	r3, #1	; 0x1
	GPDMA_INT_ERR_CLR = 0x01;
	if ( DMAMode == M2M )
    79e0:	e3510000 	cmp	r1, #0	; 0x0
  Please note, Ethernet has its own SRAM, but GPDMA can't access
  that. GPDMA can access USB SRAM and IRAM. Ethernet DMA controller can 
  access both IRAM and Ethernet SRAM. */
  if ( ChannelNum == 0 )
  {
	GPDMA_INT_TCCLR = 0x01;   
    79e4:	e5023ff7 	str	r3, [r2, #-4087]
	GPDMA_INT_ERR_CLR = 0x01;
    79e8:	e5023fef 	str	r3, [r2, #-4079]
	if ( DMAMode == M2M )
    79ec:	1a000005 	bne	7a08 <DMA_Move+0x44>
	{
	  /* Ch0 is set for M2M tranfer from AHB1 to AHB2 SRAM */
	  GPDMA_CH0_SRC = DMA_SRC;
    79f0:	e59f30f8 	ldr	r3, [pc, #248]	; 7af0 <DMA_Move+0x12c>
    79f4:	e5023eff 	str	r3, [r2, #-3839]
	  GPDMA_CH0_DEST = DMA_DST;
    79f8:	e2833a01 	add	r3, r3, #4096	; 0x1000
    79fc:	e5023efb 	str	r3, [r2, #-3835]
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x04 << 15) 
    7a00:	e59f30ec 	ldr	r3, [pc, #236]	; 7af4 <DMA_Move+0x130>
    7a04:	ea000006 	b	7a24 <DMA_Move+0x60>
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | (1 << 27) | 0x80000000;	
	}
	else if ( DMAMode == M2P )
    7a08:	e3510001 	cmp	r1, #1	; 0x1
    7a0c:	1a000006 	bne	7a2c <DMA_Move+0x68>
	{
	  /* Ch0 set for M2P transfer from mempry to MCI FIFO. */
	  GPDMA_CH0_SRC = DMA_SRC;
    7a10:	e59f30d8 	ldr	r3, [pc, #216]	; 7af0 <DMA_Move+0x12c>
    7a14:	e5023eff 	str	r3, [r2, #-3839]
	  GPDMA_CH0_DEST = DMA_MCIFIFO;
    7a18:	e59f30d8 	ldr	r3, [pc, #216]	; 7af8 <DMA_Move+0x134>
    7a1c:	e5023efb 	str	r3, [r2, #-3835]
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    7a20:	e59f30d4 	ldr	r3, [pc, #212]	; 7afc <DMA_Move+0x138>
    7a24:	e5023ef3 	str	r3, [r2, #-3827]
    7a28:	ea000025 	b	7ac4 <DMA_Move+0x100>
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | 0x80000000;
	}
	else if ( DMAMode == P2M )
    7a2c:	e3510002 	cmp	r1, #2	; 0x2
    7a30:	1a00002b 	bne	7ae4 <DMA_Move+0x120>
	{
	  /* Ch0 set for P2M transfer from MCI FIFO to memory. */
	  GPDMA_CH0_SRC = DMA_MCIFIFO;
    7a34:	e59f30bc 	ldr	r3, [pc, #188]	; 7af8 <DMA_Move+0x134>
    7a38:	e5023eff 	str	r3, [r2, #-3839]
	  GPDMA_CH0_DEST = DMA_DST;
    7a3c:	e59f30bc 	ldr	r3, [pc, #188]	; 7b00 <DMA_Move+0x13c>
    7a40:	e5023efb 	str	r3, [r2, #-3835]
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x02 << 12) | (0x04 << 15)
    7a44:	e59f30b8 	ldr	r3, [pc, #184]	; 7b04 <DMA_Move+0x140>
    7a48:	eafffff5 	b	7a24 <DMA_Move+0x60>
	else
	{
	  return ( FALSE );
	}
  }
  else if ( ChannelNum == 1 )
    7a4c:	e3500001 	cmp	r0, #1	; 0x1
    7a50:	1a000023 	bne	7ae4 <DMA_Move+0x120>
  {   
	GPDMA_INT_TCCLR = 0x02;   
    7a54:	e59f2090 	ldr	r2, [pc, #144]	; 7aec <DMA_Move+0x128>
    7a58:	e3a03002 	mov	r3, #2	; 0x2
	GPDMA_INT_ERR_CLR = 0x02;
	if ( DMAMode == M2M )
    7a5c:	e3510000 	cmp	r1, #0	; 0x0
	  return ( FALSE );
	}
  }
  else if ( ChannelNum == 1 )
  {   
	GPDMA_INT_TCCLR = 0x02;   
    7a60:	e5023ff7 	str	r3, [r2, #-4087]
	GPDMA_INT_ERR_CLR = 0x02;
    7a64:	e5023fef 	str	r3, [r2, #-4079]
	if ( DMAMode == M2M )
    7a68:	1a000005 	bne	7a84 <DMA_Move+0xc0>
	{
	  /* Ch1 is set for M2M tranfer */
	  GPDMA_CH1_SRC = DMA_SRC;
    7a6c:	e59f307c 	ldr	r3, [pc, #124]	; 7af0 <DMA_Move+0x12c>
    7a70:	e5023edf 	str	r3, [r2, #-3807]
	  GPDMA_CH1_DEST = DMA_DST;
    7a74:	e2833a01 	add	r3, r3, #4096	; 0x1000
    7a78:	e5023edb 	str	r3, [r2, #-3803]
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x04 << 15) 
    7a7c:	e59f3070 	ldr	r3, [pc, #112]	; 7af4 <DMA_Move+0x130>
    7a80:	ea00000e 	b	7ac0 <DMA_Move+0xfc>
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | (1 << 27) | 0x80000000;	
	}
	else if ( DMAMode == M2P )
    7a84:	e3510001 	cmp	r1, #1	; 0x1
    7a88:	1a000005 	bne	7aa4 <DMA_Move+0xe0>
	{
	  /* Ch1 set for M2P transfer from memory to MCI FIFO. */
	  GPDMA_CH1_SRC = DMA_SRC;
    7a8c:	e59f305c 	ldr	r3, [pc, #92]	; 7af0 <DMA_Move+0x12c>
    7a90:	e5023edf 	str	r3, [r2, #-3807]
	  GPDMA_CH1_DEST = DMA_MCIFIFO;
    7a94:	e59f305c 	ldr	r3, [pc, #92]	; 7af8 <DMA_Move+0x134>
    7a98:	e5023edb 	str	r3, [r2, #-3803]
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    7a9c:	e59f3058 	ldr	r3, [pc, #88]	; 7afc <DMA_Move+0x138>
    7aa0:	ea000006 	b	7ac0 <DMA_Move+0xfc>
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | 0x80000000;
	}
	else if ( DMAMode == P2M )
    7aa4:	e3510002 	cmp	r1, #2	; 0x2
    7aa8:	1a00000d 	bne	7ae4 <DMA_Move+0x120>
	{
	  /* Ch1 set for P2M transfer from MCI_FIFO to memory. */
	  GPDMA_CH1_SRC = DMA_MCIFIFO;
    7aac:	e59f3044 	ldr	r3, [pc, #68]	; 7af8 <DMA_Move+0x134>
    7ab0:	e5023edf 	str	r3, [r2, #-3807]
	  GPDMA_CH1_DEST = DMA_DST;
    7ab4:	e59f3044 	ldr	r3, [pc, #68]	; 7b00 <DMA_Move+0x13c>
    7ab8:	e5023edb 	str	r3, [r2, #-3803]
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x02 << 12) | (0x04 << 15)
    7abc:	e59f3040 	ldr	r3, [pc, #64]	; 7b04 <DMA_Move+0x140>
    7ac0:	e5023ed3 	str	r3, [r2, #-3795]
  else
  {
	return ( FALSE );
  }
	
  GPDMA_CONFIG = 0x01;	/* Enable DMA channels, little endian */
    7ac4:	e59f2020 	ldr	r2, [pc, #32]	; 7aec <DMA_Move+0x128>
    7ac8:	e3a03001 	mov	r3, #1	; 0x1
    7acc:	e5023fcf 	str	r3, [r2, #-4047]
  while ( !(GPDMA_CONFIG & 0x01) );    
    7ad0:	e5123fcf 	ldr	r3, [r2, #-4047]
    7ad4:	e3130001 	tst	r3, #1	; 0x1
    7ad8:	0afffffc 	beq	7ad0 <DMA_Move+0x10c>
    7adc:	e3a00001 	mov	r0, #1	; 0x1
    7ae0:	e89da800 	ldm	sp, {fp, sp, pc}
    7ae4:	e3a00000 	mov	r0, #0	; 0x0
  return (TRUE);
}
    7ae8:	e89da800 	ldm	sp, {fp, sp, pc}
    7aec:	ffe04fff 	.word	0xffe04fff
    7af0:	7fd00000 	.word	0x7fd00000
    7af4:	8c4a4200 	.word	0x8c4a4200
    7af8:	e008c080 	.word	0xe008c080
    7afc:	84494200 	.word	0x84494200
    7b00:	7fd01000 	.word	0x7fd01000
    7b04:	884a2200 	.word	0x884a2200

00007b08 <DMA_Init>:
** Returned value:		TRUE or FALSE, FALSE if ISR can't be installed.		
** 
******************************************************************************/
DWORD DMA_Init(void)
{
  PCONP |= (1 << 29);	/* Enable GPDMA clock */
    7b08:	e59f0054 	ldr	r0, [pc, #84]	; 7b64 <DMA_Init+0x5c>
    7b0c:	e59030c4 	ldr	r3, [r0, #196]

  /* clear all interrupts on channel 0 and 1 */
  GPDMA_INT_TCCLR = 0x03;
    7b10:	e59f2050 	ldr	r2, [pc, #80]	; 7b68 <DMA_Init+0x60>
** Returned value:		TRUE or FALSE, FALSE if ISR can't be installed.		
** 
******************************************************************************/
DWORD DMA_Init(void)
{
  PCONP |= (1 << 29);	/* Enable GPDMA clock */
    7b14:	e3833202 	orr	r3, r3, #536870912	; 0x20000000
    7b18:	e58030c4 	str	r3, [r0, #196]

  /* clear all interrupts on channel 0 and 1 */
  GPDMA_INT_TCCLR = 0x03;
    7b1c:	e3a01003 	mov	r1, #3	; 0x3
  GPDMA_INT_ERR_CLR = 0x03;

  GPDMA_CONFIG = 0x01;	/* Enable DMA channels, little endian */
    7b20:	e3a03001 	mov	r3, #1	; 0x1
** parameters:			None			
** Returned value:		TRUE or FALSE, FALSE if ISR can't be installed.		
** 
******************************************************************************/
DWORD DMA_Init(void)
{
    7b24:	e1a0c00d 	mov	ip, sp
  PCONP |= (1 << 29);	/* Enable GPDMA clock */

  /* clear all interrupts on channel 0 and 1 */
  GPDMA_INT_TCCLR = 0x03;
    7b28:	e5021ff7 	str	r1, [r2, #-4087]
  GPDMA_INT_ERR_CLR = 0x03;
    7b2c:	e5021fef 	str	r1, [r2, #-4079]

  GPDMA_CONFIG = 0x01;	/* Enable DMA channels, little endian */
    7b30:	e5023fcf 	str	r3, [r2, #-4047]
** parameters:			None			
** Returned value:		TRUE or FALSE, FALSE if ISR can't be installed.		
** 
******************************************************************************/
DWORD DMA_Init(void)
{
    7b34:	e92dd800 	push	{fp, ip, lr, pc}
    7b38:	e24cb004 	sub	fp, ip, #4	; 0x4
  /* clear all interrupts on channel 0 and 1 */
  GPDMA_INT_TCCLR = 0x03;
  GPDMA_INT_ERR_CLR = 0x03;

  GPDMA_CONFIG = 0x01;	/* Enable DMA channels, little endian */
  while ( !(GPDMA_CONFIG & 0x01) );    
    7b3c:	e5123fcf 	ldr	r3, [r2, #-4047]
    7b40:	e3130001 	tst	r3, #1	; 0x1
    7b44:	0afffffc 	beq	7b3c <DMA_Init+0x34>
		
  if ( install_irq( GPDMA_INT, (void *)DMAHandler, HIGHEST_PRIORITY ) == FALSE )
    7b48:	e59f101c 	ldr	r1, [pc, #28]	; 7b6c <DMA_Init+0x64>
    7b4c:	e3a02001 	mov	r2, #1	; 0x1
    7b50:	e3a00019 	mov	r0, #25	; 0x19
    7b54:	ebffe40a 	bl	b84 <install_irq>
  {
	return( FALSE );
  }
  return( TRUE );
}   
    7b58:	e2500000 	subs	r0, r0, #0	; 0x0
    7b5c:	13a00001 	movne	r0, #1	; 0x1
    7b60:	e89da800 	ldm	sp, {fp, sp, pc}
    7b64:	e01fc000 	.word	0xe01fc000
    7b68:	ffe04fff 	.word	0xffe04fff
    7b6c:	00007934 	.word	0x00007934

00007b70 <put_rc>:
#include "FAT.h"
FATFS fatfs[_DRIVES];
FIL file1, file2;		/* File objects */
UINT s2;				/* not used */
void put_rc (FRESULT rc)
{
    7b70:	e1a0c00d 	mov	ip, sp
    7b74:	e92dd800 	push	{fp, ip, lr, pc}
    7b78:	e24cb004 	sub	fp, ip, #4	; 0x4
    7b7c:	e24dd00c 	sub	sp, sp, #12	; 0xc
    7b80:	e50b0018 	str	r0, [fp, #-24]
		"OK\0" "NOT_READY\0" "NO_FILE\0" "FR_NO_PATH\0" "INVALID_NAME\0" "INVALID_DRIVE\0"
		"DENIED\0" "EXIST\0" "RW_ERROR\0" "WRITE_PROTECTED\0" "NOT_ENABLED\0"
		"NO_FILESYSTEM\0" "INVALID_OBJECT\0" "MKFS_ABORTED\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && *p; i++) {
    7b84:	e59f307c 	ldr	r3, [pc, #124]	; 7c08 <put_rc+0x98>
    7b88:	e50b3014 	str	r3, [fp, #-20]
    7b8c:	e3a03000 	mov	r3, #0	; 0x0
    7b90:	e50b3010 	str	r3, [fp, #-16]
    7b94:	ea00000d 	b	7bd0 <put_rc+0x60>
		while(*p++);
    7b98:	e51b3014 	ldr	r3, [fp, #-20]
    7b9c:	e5d33000 	ldrb	r3, [r3]
    7ba0:	e3530000 	cmp	r3, #0	; 0x0
    7ba4:	03a03000 	moveq	r3, #0	; 0x0
    7ba8:	13a03001 	movne	r3, #1	; 0x1
    7bac:	e20320ff 	and	r2, r3, #255	; 0xff
    7bb0:	e51b3014 	ldr	r3, [fp, #-20]
    7bb4:	e2833001 	add	r3, r3, #1	; 0x1
    7bb8:	e50b3014 	str	r3, [fp, #-20]
    7bbc:	e3520000 	cmp	r2, #0	; 0x0
    7bc0:	1afffff4 	bne	7b98 <put_rc+0x28>
		"OK\0" "NOT_READY\0" "NO_FILE\0" "FR_NO_PATH\0" "INVALID_NAME\0" "INVALID_DRIVE\0"
		"DENIED\0" "EXIST\0" "RW_ERROR\0" "WRITE_PROTECTED\0" "NOT_ENABLED\0"
		"NO_FILESYSTEM\0" "INVALID_OBJECT\0" "MKFS_ABORTED\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && *p; i++) {
    7bc4:	e51b3010 	ldr	r3, [fp, #-16]
    7bc8:	e2833001 	add	r3, r3, #1	; 0x1
    7bcc:	e50b3010 	str	r3, [fp, #-16]
    7bd0:	e51b2010 	ldr	r2, [fp, #-16]
    7bd4:	e51b3018 	ldr	r3, [fp, #-24]
    7bd8:	e1520003 	cmp	r2, r3
    7bdc:	0a000003 	beq	7bf0 <put_rc+0x80>
    7be0:	e51b3014 	ldr	r3, [fp, #-20]
    7be4:	e5d33000 	ldrb	r3, [r3]
    7be8:	e3530000 	cmp	r3, #0	; 0x0
    7bec:	1affffe9 	bne	7b98 <put_rc+0x28>
		while(*p++);
	}
	xprintf("\nrc=%u FR_%s", (UINT)rc, p);
    7bf0:	e59f0014 	ldr	r0, [pc, #20]	; 7c0c <put_rc+0x9c>
    7bf4:	e51b1018 	ldr	r1, [fp, #-24]
    7bf8:	e51b2014 	ldr	r2, [fp, #-20]
    7bfc:	ebffe287 	bl	620 <xprintf>
}
    7c00:	e24bd00c 	sub	sp, fp, #12	; 0xc
    7c04:	e89da800 	ldm	sp, {fp, sp, pc}
    7c08:	0000978c 	.word	0x0000978c
    7c0c:	00009568 	.word	0x00009568

00007c10 <initSDCard>:
void initSDCard()//fi 0 (force initialize 0)
{
    7c10:	e1a0c00d 	mov	ip, sp
    7c14:	e92dd800 	push	{fp, ip, lr, pc}
    7c18:	e24cb004 	sub	fp, ip, #4	; 0x4
    7c1c:	e24dd004 	sub	sp, sp, #4	; 0x4
	long p1=0;
    7c20:	e3a03000 	mov	r3, #0	; 0x0
    7c24:	e50b3010 	str	r3, [fp, #-16]
	put_rc(f_mount((BYTE)p1, &fatfs[p1]));
    7c28:	e51b3010 	ldr	r3, [fp, #-16]
    7c2c:	e20330ff 	and	r3, r3, #255	; 0xff
    7c30:	e1a01003 	mov	r1, r3
    7c34:	e51b3010 	ldr	r3, [fp, #-16]
    7c38:	e1a03203 	lsl	r3, r3, #4
    7c3c:	e1a02103 	lsl	r2, r3, #2
    7c40:	e0833002 	add	r3, r3, r2
    7c44:	e1a02183 	lsl	r2, r3, #3
    7c48:	e0632002 	rsb	r2, r3, r2
    7c4c:	e59f301c 	ldr	r3, [pc, #28]	; 7c70 <initSDCard+0x60>
    7c50:	e0823003 	add	r3, r2, r3
    7c54:	e1a00001 	mov	r0, r1
    7c58:	e1a01003 	mov	r1, r3
    7c5c:	ebffed50 	bl	31a4 <f_mount>
    7c60:	e1a03000 	mov	r3, r0
    7c64:	e1a00003 	mov	r0, r3
    7c68:	ebffffc0 	bl	7b70 <put_rc>
}
    7c6c:	e89da808 	ldm	sp, {r3, fp, sp, pc}
    7c70:	400004a0 	.word	0x400004a0

00007c74 <writeToSDCard>:
void writeToSDCard(int size)
{
    7c74:	e1a0c00d 	mov	ip, sp
    7c78:	e92dd800 	push	{fp, ip, lr, pc}
    7c7c:	e24cb004 	sub	fp, ip, #4	; 0x4
    7c80:	e24dd00c 	sub	sp, sp, #12	; 0xc
    7c84:	e50b0018 	str	r0, [fp, #-24]
	unsigned int * data;
	data = (volatile unsigned int *)0x80000000;
    7c88:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
    7c8c:	e50b3014 	str	r3, [fp, #-20]
	long p1=7;				/* read(1) write(2) create(4)*/
    7c90:	e3a03007 	mov	r3, #7	; 0x7
    7c94:	e50b3010 	str	r3, [fp, #-16]
	put_rc(f_unlink("size.bin"));
    7c98:	e59f00a0 	ldr	r0, [pc, #160]	; 7d40 <writeToSDCard+0xcc>
    7c9c:	ebfff0ed 	bl	4058 <f_unlink>
    7ca0:	e1a03000 	mov	r3, r0
    7ca4:	e1a00003 	mov	r0, r3
    7ca8:	ebffffb0 	bl	7b70 <put_rc>
	put_rc(f_unlink("image.bin"));
    7cac:	e59f0090 	ldr	r0, [pc, #144]	; 7d44 <writeToSDCard+0xd0>
    7cb0:	ebfff0e8 	bl	4058 <f_unlink>
    7cb4:	e1a03000 	mov	r3, r0
    7cb8:	e1a00003 	mov	r0, r3
    7cbc:	ebffffab 	bl	7b70 <put_rc>
	put_rc(f_open(&file1, "size.bin", (BYTE)p1));
    7cc0:	e51b3010 	ldr	r3, [fp, #-16]
    7cc4:	e20330ff 	and	r3, r3, #255	; 0xff
    7cc8:	e59f0078 	ldr	r0, [pc, #120]	; 7d48 <writeToSDCard+0xd4>
    7ccc:	e59f106c 	ldr	r1, [pc, #108]	; 7d40 <writeToSDCard+0xcc>
    7cd0:	e1a02003 	mov	r2, r3
    7cd4:	ebffed5a 	bl	3244 <f_open>
    7cd8:	e1a03000 	mov	r3, r0
    7cdc:	e1a00003 	mov	r0, r3
    7ce0:	ebffffa2 	bl	7b70 <put_rc>
	put_rc(f_open(&file2, "image.bin", (BYTE)p1));
    7ce4:	e51b3010 	ldr	r3, [fp, #-16]
    7ce8:	e20330ff 	and	r3, r3, #255	; 0xff
    7cec:	e59f0058 	ldr	r0, [pc, #88]	; 7d4c <writeToSDCard+0xd8>
    7cf0:	e59f104c 	ldr	r1, [pc, #76]	; 7d44 <writeToSDCard+0xd0>
    7cf4:	e1a02003 	mov	r2, r3
    7cf8:	ebffed51 	bl	3244 <f_open>
    7cfc:	e1a03000 	mov	r3, r0
    7d00:	e1a00003 	mov	r0, r3
    7d04:	ebffff99 	bl	7b70 <put_rc>
	f_write(&file1, &size, sizeof(int), &s2);
    7d08:	e24b3018 	sub	r3, fp, #24	; 0x18
    7d0c:	e59f0034 	ldr	r0, [pc, #52]	; 7d48 <writeToSDCard+0xd4>
    7d10:	e1a01003 	mov	r1, r3
    7d14:	e3a02004 	mov	r2, #4	; 0x4
    7d18:	e59f3030 	ldr	r3, [pc, #48]	; 7d50 <writeToSDCard+0xdc>
    7d1c:	ebffeebd 	bl	3818 <f_write>
	f_write(&file2, data, size, &s2);
    7d20:	e51b3018 	ldr	r3, [fp, #-24]
    7d24:	e59f0020 	ldr	r0, [pc, #32]	; 7d4c <writeToSDCard+0xd8>
    7d28:	e51b1014 	ldr	r1, [fp, #-20]
    7d2c:	e1a02003 	mov	r2, r3
    7d30:	e59f3018 	ldr	r3, [pc, #24]	; 7d50 <writeToSDCard+0xdc>
    7d34:	ebffeeb7 	bl	3818 <f_write>
}
    7d38:	e24bd00c 	sub	sp, fp, #12	; 0xc
    7d3c:	e89da800 	ldm	sp, {fp, sp, pc}
    7d40:	00009578 	.word	0x00009578
    7d44:	00009584 	.word	0x00009584
    7d48:	4000027c 	.word	0x4000027c
    7d4c:	40000054 	.word	0x40000054
    7d50:	40000278 	.word	0x40000278

00007d54 <closeFile>:
void closeFile()
{
    7d54:	e1a0c00d 	mov	ip, sp
    7d58:	e92dd800 	push	{fp, ip, lr, pc}
    7d5c:	e24cb004 	sub	fp, ip, #4	; 0x4
	put_rc(f_close(&file1));
    7d60:	e59f0024 	ldr	r0, [pc, #36]	; 7d8c <closeFile+0x38>
    7d64:	ebfff0a8 	bl	400c <f_close>
    7d68:	e1a03000 	mov	r3, r0
    7d6c:	e1a00003 	mov	r0, r3
    7d70:	ebffff7e 	bl	7b70 <put_rc>
	put_rc(f_close(&file2));
    7d74:	e59f0014 	ldr	r0, [pc, #20]	; 7d90 <closeFile+0x3c>
    7d78:	ebfff0a3 	bl	400c <f_close>
    7d7c:	e1a03000 	mov	r3, r0
    7d80:	e1a00003 	mov	r0, r3
    7d84:	ebffff79 	bl	7b70 <put_rc>
}
    7d88:	e89da800 	ldm	sp, {fp, sp, pc}
    7d8c:	4000027c 	.word	0x4000027c
    7d90:	40000054 	.word	0x40000054

00007d94 <SPIInit>:
** Returned value:		true or false, if the interrupt handler
**				can't be installed correctly, return false.
** 
*****************************************************************************/
DWORD SPIInit( void )
{
    7d94:	e1a0c00d 	mov	ip, sp
    7d98:	e92dd800 	push	{fp, ip, lr, pc}
    7d9c:	e24cb004 	sub	fp, ip, #4	; 0x4
  TxCounter = 0;
    7da0:	e59f20e4 	ldr	r2, [pc, #228]	; 7e8c <SPIInit+0xf8>
    7da4:	e3a03000 	mov	r3, #0	; 0x0
    7da8:	e5823000 	str	r3, [r2]
  PCONP |= (1 << 8);	/* by default, it's enabled already, for safety reason */
    7dac:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    7db0:	e282297f 	add	r2, r2, #2080768	; 0x1fc000
    7db4:	e28220c4 	add	r2, r2, #196	; 0xc4
    7db8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7dbc:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    7dc0:	e28330c4 	add	r3, r3, #196	; 0xc4
    7dc4:	e5933000 	ldr	r3, [r3]
    7dc8:	e3833c01 	orr	r3, r3, #256	; 0x100
    7dcc:	e5823000 	str	r3, [r2]

  S0SPCR = 0x00;
    7dd0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7dd4:	e2833802 	add	r3, r3, #131072	; 0x20000
    7dd8:	e3a02000 	mov	r2, #0	; 0x0
    7ddc:	e5832000 	str	r2, [r3]
  /* Port 0.15 SPI SCK, port0.16 uses GPIO SPI_SEL, 
  port0.17 MISO, port0.18 MOSI */
  PINSEL0 |= 0xC0000000;
    7de0:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    7de4:	e282290b 	add	r2, r2, #180224	; 0x2c000
    7de8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7dec:	e283390b 	add	r3, r3, #180224	; 0x2c000
    7df0:	e5933000 	ldr	r3, [r3]
    7df4:	e3833103 	orr	r3, r3, #-1073741824	; 0xc0000000
    7df8:	e5823000 	str	r3, [r2]
  PINSEL1 |= 0x0000003C;
    7dfc:	e3a0224e 	mov	r2, #-536870908	; 0xe0000004
    7e00:	e282290b 	add	r2, r2, #180224	; 0x2c000
    7e04:	e3a0324e 	mov	r3, #-536870908	; 0xe0000004
    7e08:	e283390b 	add	r3, r3, #180224	; 0x2c000
    7e0c:	e5933000 	ldr	r3, [r3]
    7e10:	e383303c 	orr	r3, r3, #60	; 0x3c
    7e14:	e5823000 	str	r3, [r2]
  PINMODE0 |= 0x80000000;
    7e18:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    7e1c:	e282290b 	add	r2, r2, #180224	; 0x2c000
    7e20:	e2822040 	add	r2, r2, #64	; 0x40
    7e24:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7e28:	e283390b 	add	r3, r3, #180224	; 0x2c000
    7e2c:	e2833040 	add	r3, r3, #64	; 0x40
    7e30:	e5933000 	ldr	r3, [r3]
    7e34:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
    7e38:	e5823000 	str	r3, [r2]
  PINMODE1 |= 0x00000028;
    7e3c:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    7e40:	e282290b 	add	r2, r2, #180224	; 0x2c000
    7e44:	e2822044 	add	r2, r2, #68	; 0x44
    7e48:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7e4c:	e283390b 	add	r3, r3, #180224	; 0x2c000
    7e50:	e2833044 	add	r3, r3, #68	; 0x44
    7e54:	e5933000 	ldr	r3, [r3]
    7e58:	e3833028 	orr	r3, r3, #40	; 0x28
    7e5c:	e5823000 	str	r3, [r2]
  //PINSEL1 = PINSEL1&0xFFFC3FFF;


  /* Setting SPI0 clock, for Atmel SEEPROM, SPI clock should be no more 
  than 3Mhz on 4.5V~5.5V, no more than 2.1Mhz on 2.7V~5.5V */
  S0SPCCR = 4;
    7e60:	e3a032ce 	mov	r3, #-536870900	; 0xe000000c
    7e64:	e2833802 	add	r3, r3, #131072	; 0x20000
    7e68:	e3a02004 	mov	r2, #4	; 0x4
    7e6c:	e5832000 	str	r2, [r3]
//	return (FALSE);
//  }
  /* 8 bit, CPOL=CPHA=0, master mode, MSB first, interrupt enabled */
  S0SPCR = SPI0_SPIE | SPI0_MSTR;
#else
  S0SPCR = SPI0_MSTR;
    7e70:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7e74:	e2833802 	add	r3, r3, #131072	; 0x20000
    7e78:	e3a02020 	mov	r2, #32	; 0x20
    7e7c:	e5832000 	str	r2, [r3]
#endif
  return( TRUE );
    7e80:	e3a03001 	mov	r3, #1	; 0x1
}
    7e84:	e1a00003 	mov	r0, r3
    7e88:	e89da800 	ldm	sp, {fp, sp, pc}
    7e8c:	4000078c 	.word	0x4000078c

00007e90 <SPISend>:
** parameters:			buffer pointer, and the block length
** Returned value:		None
** 
*****************************************************************************/
void SPISend( BYTE *buf, DWORD Length )
{
    7e90:	e1a0c00d 	mov	ip, sp
    7e94:	e92dd800 	push	{fp, ip, lr, pc}
    7e98:	e24cb004 	sub	fp, ip, #4	; 0x4
    7e9c:	e24dd00c 	sub	sp, sp, #12	; 0xc
    7ea0:	e50b0014 	str	r0, [fp, #-20]
    7ea4:	e50b1018 	str	r1, [fp, #-24]
  DWORD i;
  recvI=0;
    7ea8:	e59f20dc 	ldr	r2, [pc, #220]	; 7f8c <SPISend+0xfc>
    7eac:	e3a03000 	mov	r3, #0	; 0x0
    7eb0:	e5823000 	str	r3, [r2]
  IOPIN0 = IOPIN0 & ~0x1000000;
    7eb4:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    7eb8:	e282290a 	add	r2, r2, #163840	; 0x28000
    7ebc:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7ec0:	e283390a 	add	r3, r3, #163840	; 0x28000
    7ec4:	e5933000 	ldr	r3, [r3]
    7ec8:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
    7ecc:	e5823000 	str	r3, [r2]
  if ( Length == 0 )
    7ed0:	e51b3018 	ldr	r3, [fp, #-24]
    7ed4:	e3530000 	cmp	r3, #0	; 0x0
    7ed8:	0a000029 	beq	7f84 <SPISend+0xf4>
	return;
  for ( i = 0; i < Length; i++ )
    7edc:	e3a03000 	mov	r3, #0	; 0x0
    7ee0:	e50b3010 	str	r3, [fp, #-16]
    7ee4:	ea00001b 	b	7f58 <SPISend+0xc8>
  {
	S0SPDR = *buf;
    7ee8:	e3a0228e 	mov	r2, #-536870904	; 0xe0000008
    7eec:	e2822802 	add	r2, r2, #131072	; 0x20000
    7ef0:	e51b3014 	ldr	r3, [fp, #-20]
    7ef4:	e5d33000 	ldrb	r3, [r3]
    7ef8:	e5823000 	str	r3, [r2]
	is being handled inside the ISR. Not an ideal example but show how the 
	interrupt is being set and handled. */ 
	while ( (SPI0Status & SPI0_TX_DONE) != SPI0_TX_DONE );
	SPI0Status &= ~SPI0_TX_DONE;
#else
	while ( !(S0SPSR & SPIF) );
    7efc:	e3a0324e 	mov	r3, #-536870908	; 0xe0000004
    7f00:	e2833802 	add	r3, r3, #131072	; 0x20000
    7f04:	e5933000 	ldr	r3, [r3]
    7f08:	e2033080 	and	r3, r3, #128	; 0x80
    7f0c:	e3530000 	cmp	r3, #0	; 0x0
    7f10:	0afffff9 	beq	7efc <SPISend+0x6c>
#endif
	recv[recvI++] = S0SPDR;		/* Flush the RxFIFO */
    7f14:	e59f3070 	ldr	r3, [pc, #112]	; 7f8c <SPISend+0xfc>
    7f18:	e5931000 	ldr	r1, [r3]
    7f1c:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
    7f20:	e2833802 	add	r3, r3, #131072	; 0x20000
    7f24:	e5933000 	ldr	r3, [r3]
    7f28:	e20330ff 	and	r3, r3, #255	; 0xff
    7f2c:	e59f205c 	ldr	r2, [pc, #92]	; 7f90 <SPISend+0x100>
    7f30:	e7c23001 	strb	r3, [r2, r1]
    7f34:	e2812001 	add	r2, r1, #1	; 0x1
    7f38:	e59f304c 	ldr	r3, [pc, #76]	; 7f8c <SPISend+0xfc>
    7f3c:	e5832000 	str	r2, [r3]
	buf++;
    7f40:	e51b3014 	ldr	r3, [fp, #-20]
    7f44:	e2833001 	add	r3, r3, #1	; 0x1
    7f48:	e50b3014 	str	r3, [fp, #-20]
  DWORD i;
  recvI=0;
  IOPIN0 = IOPIN0 & ~0x1000000;
  if ( Length == 0 )
	return;
  for ( i = 0; i < Length; i++ )
    7f4c:	e51b3010 	ldr	r3, [fp, #-16]
    7f50:	e2833001 	add	r3, r3, #1	; 0x1
    7f54:	e50b3010 	str	r3, [fp, #-16]
    7f58:	e51b2010 	ldr	r2, [fp, #-16]
    7f5c:	e51b3018 	ldr	r3, [fp, #-24]
    7f60:	e1520003 	cmp	r2, r3
    7f64:	3affffdf 	bcc	7ee8 <SPISend+0x58>
	while ( !(S0SPSR & SPIF) );
#endif
	recv[recvI++] = S0SPDR;		/* Flush the RxFIFO */
	buf++;
  }
    IOPIN0 |= 0x1000000;
    7f68:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    7f6c:	e282290a 	add	r2, r2, #163840	; 0x28000
    7f70:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7f74:	e283390a 	add	r3, r3, #163840	; 0x28000
    7f78:	e5933000 	ldr	r3, [r3]
    7f7c:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    7f80:	e5823000 	str	r3, [r2]
  return; 
}
    7f84:	e24bd00c 	sub	sp, fp, #12	; 0xc
    7f88:	e89da800 	ldm	sp, {fp, sp, pc}
    7f8c:	40000790 	.word	0x40000790
    7f90:	400006d0 	.word	0x400006d0

00007f94 <SPIReceive>:
** parameters:			buffer pointer, and block length
** Returned value:		None
** 
*****************************************************************************/
void SPIReceive( BYTE *buf, DWORD Length )
{
    7f94:	e1a0c00d 	mov	ip, sp
    7f98:	e92dd800 	push	{fp, ip, lr, pc}
    7f9c:	e24cb004 	sub	fp, ip, #4	; 0x4
    7fa0:	e24dd00c 	sub	sp, sp, #12	; 0xc
    7fa4:	e50b0014 	str	r0, [fp, #-20]
    7fa8:	e50b1018 	str	r1, [fp, #-24]
  DWORD i;
  IOPIN0 &= ~0x1000000;
    7fac:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    7fb0:	e282290a 	add	r2, r2, #163840	; 0x28000
    7fb4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    7fb8:	e283390a 	add	r3, r3, #163840	; 0x28000
    7fbc:	e5933000 	ldr	r3, [r3]
    7fc0:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
    7fc4:	e5823000 	str	r3, [r2]
  for ( i = 0; i < Length; i++ )
    7fc8:	e3a03000 	mov	r3, #0	; 0x0
    7fcc:	e50b3010 	str	r3, [fp, #-16]
    7fd0:	ea000009 	b	7ffc <SPIReceive+0x68>
  {
	*buf = SPIReceiveByte();
    7fd4:	eb000015 	bl	8030 <SPIReceiveByte>
    7fd8:	e1a03000 	mov	r3, r0
    7fdc:	e51b2014 	ldr	r2, [fp, #-20]
    7fe0:	e5c23000 	strb	r3, [r2]
	buf++;
    7fe4:	e51b3014 	ldr	r3, [fp, #-20]
    7fe8:	e2833001 	add	r3, r3, #1	; 0x1
    7fec:	e50b3014 	str	r3, [fp, #-20]
*****************************************************************************/
void SPIReceive( BYTE *buf, DWORD Length )
{
  DWORD i;
  IOPIN0 &= ~0x1000000;
  for ( i = 0; i < Length; i++ )
    7ff0:	e51b3010 	ldr	r3, [fp, #-16]
    7ff4:	e2833001 	add	r3, r3, #1	; 0x1
    7ff8:	e50b3010 	str	r3, [fp, #-16]
    7ffc:	e51b2010 	ldr	r2, [fp, #-16]
    8000:	e51b3018 	ldr	r3, [fp, #-24]
    8004:	e1520003 	cmp	r2, r3
    8008:	3afffff1 	bcc	7fd4 <SPIReceive+0x40>
  {
	*buf = SPIReceiveByte();
	buf++;
  }
  IOPIN0 |= 0x1000000;
    800c:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    8010:	e282290a 	add	r2, r2, #163840	; 0x28000
    8014:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8018:	e283390a 	add	r3, r3, #163840	; 0x28000
    801c:	e5933000 	ldr	r3, [r3]
    8020:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    8024:	e5823000 	str	r3, [r2]
  return; 
}
    8028:	e24bd00c 	sub	sp, fp, #12	; 0xc
    802c:	e89da800 	ldm	sp, {fp, sp, pc}

00008030 <SPIReceiveByte>:
** parameters:			None
** Returned value:		the data byte received
** 
*****************************************************************************/
BYTE SPIReceiveByte( void )
{
    8030:	e1a0c00d 	mov	ip, sp
    8034:	e92dd800 	push	{fp, ip, lr, pc}
    8038:	e24cb004 	sub	fp, ip, #4	; 0x4
    803c:	e24dd004 	sub	sp, sp, #4	; 0x4
  BYTE data;

  /* wrtie dummy byte out to generate clock, then read data from MISO */
  S0SPDR = 0xFF; //changed from 0x0
    8040:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
    8044:	e2833802 	add	r3, r3, #131072	; 0x20000
    8048:	e3a020ff 	mov	r2, #255	; 0xff
    804c:	e5832000 	str	r2, [r3]
  or not which is being handled inside the ISR. Not an ideal example but 
  show how the interrupt is being set and handled. */ 
  while ( (SPI0Status & SPI0_TX_DONE) != SPI0_TX_DONE );
  SPI0Status &= ~SPI0_TX_DONE;
#else
  while ( !(S0SPSR & SPIF) );
    8050:	e3a0324e 	mov	r3, #-536870908	; 0xe0000004
    8054:	e2833802 	add	r3, r3, #131072	; 0x20000
    8058:	e5933000 	ldr	r3, [r3]
    805c:	e2033080 	and	r3, r3, #128	; 0x80
    8060:	e3530000 	cmp	r3, #0	; 0x0
    8064:	0afffff9 	beq	8050 <SPIReceiveByte+0x20>
#endif
  data = S0SPDR;
    8068:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
    806c:	e2833802 	add	r3, r3, #131072	; 0x20000
    8070:	e5933000 	ldr	r3, [r3]
    8074:	e54b300d 	strb	r3, [fp, #-13]
  return ( data ); 
    8078:	e55b300d 	ldrb	r3, [fp, #-13]
}
    807c:	e1a00003 	mov	r0, r3
    8080:	e89da808 	ldm	sp, {r3, fp, sp, pc}

00008084 <isAck>:
BYTE ackimgqual[8]={0xFF, 0xFF, 0xFF, 0x0E, 0x10, 0, 0, 0};
BYTE ackreset[8]={0xFF, 0xFF, 0xFF, 0x0E, 0x08, 0, 0, 0xFF};
int global=0;

char isAck(BYTE * resp, BYTE cmd)
{
    8084:	e1a0c00d 	mov	ip, sp
    8088:	e92dd800 	push	{fp, ip, lr, pc}
    808c:	e24cb004 	sub	fp, ip, #4	; 0x4
    8090:	e24dd014 	sub	sp, sp, #20	; 0x14
    8094:	e50b0014 	str	r0, [fp, #-20]
    8098:	e1a03001 	mov	r3, r1
    809c:	e54b3018 	strb	r3, [fp, #-24]
	int i;
	for(i=0; i<8; i++)
    80a0:	e3a03000 	mov	r3, #0	; 0x0
    80a4:	e50b3010 	str	r3, [fp, #-16]
    80a8:	ea000021 	b	8134 <isAck+0xb0>
	{
		switch(i)
    80ac:	e51b3010 	ldr	r3, [fp, #-16]
    80b0:	e50b3020 	str	r3, [fp, #-32]
    80b4:	e51b3020 	ldr	r3, [fp, #-32]
    80b8:	e3530004 	cmp	r3, #4	; 0x4
    80bc:	0a000003 	beq	80d0 <isAck+0x4c>
    80c0:	e51b3020 	ldr	r3, [fp, #-32]
    80c4:	e3530005 	cmp	r3, #5	; 0x5
    80c8:	0a000016 	beq	8128 <isAck+0xa4>
    80cc:	ea000009 	b	80f8 <isAck+0x74>
		{
		case(4): if(resp[i]!=cmd) return 0;
    80d0:	e51b2010 	ldr	r2, [fp, #-16]
    80d4:	e51b3014 	ldr	r3, [fp, #-20]
    80d8:	e0833002 	add	r3, r3, r2
    80dc:	e5d32000 	ldrb	r2, [r3]
    80e0:	e55b3018 	ldrb	r3, [fp, #-24]
    80e4:	e1530002 	cmp	r3, r2
    80e8:	0a00000e 	beq	8128 <isAck+0xa4>
    80ec:	e3a03000 	mov	r3, #0	; 0x0
    80f0:	e50b301c 	str	r3, [fp, #-28]
    80f4:	ea000013 	b	8148 <isAck+0xc4>
				 break;
		case(5): break;
		default: if(resp[i]!=ack[i]) return 0;
    80f8:	e51b2010 	ldr	r2, [fp, #-16]
    80fc:	e51b3014 	ldr	r3, [fp, #-20]
    8100:	e0833002 	add	r3, r3, r2
    8104:	e5d31000 	ldrb	r1, [r3]
    8108:	e51b2010 	ldr	r2, [fp, #-16]
    810c:	e59f3044 	ldr	r3, [pc, #68]	; 8158 <isAck+0xd4>
    8110:	e7d33002 	ldrb	r3, [r3, r2]
    8114:	e1510003 	cmp	r1, r3
    8118:	0a000002 	beq	8128 <isAck+0xa4>
    811c:	e3a03000 	mov	r3, #0	; 0x0
    8120:	e50b301c 	str	r3, [fp, #-28]
    8124:	ea000007 	b	8148 <isAck+0xc4>
int global=0;

char isAck(BYTE * resp, BYTE cmd)
{
	int i;
	for(i=0; i<8; i++)
    8128:	e51b3010 	ldr	r3, [fp, #-16]
    812c:	e2833001 	add	r3, r3, #1	; 0x1
    8130:	e50b3010 	str	r3, [fp, #-16]
    8134:	e51b3010 	ldr	r3, [fp, #-16]
    8138:	e3530007 	cmp	r3, #7	; 0x7
    813c:	daffffda 	ble	80ac <isAck+0x28>
				 break;
		case(5): break;
		default: if(resp[i]!=ack[i]) return 0;
		}
	}
	return 1;
    8140:	e3a03001 	mov	r3, #1	; 0x1
    8144:	e50b301c 	str	r3, [fp, #-28]
    8148:	e51b301c 	ldr	r3, [fp, #-28]
}
    814c:	e1a00003 	mov	r0, r3
    8150:	e24bd00c 	sub	sp, fp, #12	; 0xc
    8154:	e89da800 	ldm	sp, {fp, sp, pc}
    8158:	40000014 	.word	0x40000014

0000815c <sendSync>:
	}
	}
*/

void sendSync()
	{
    815c:	e1a0c00d 	mov	ip, sp
    8160:	e92dd870 	push	{r4, r5, r6, fp, ip, lr, pc}
    8164:	e24cb004 	sub	fp, ip, #4	; 0x4
    8168:	e24dd01c 	sub	sp, sp, #28	; 0x1c
    int i = 0;
    816c:	e3a03000 	mov	r3, #0	; 0x0
    8170:	e50b3020 	str	r3, [fp, #-32]
    int j=0;
    8174:	e3a03000 	mov	r3, #0	; 0x0
    8178:	e50b301c 	str	r3, [fp, #-28]

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    817c:	e3a0228e 	mov	r2, #-536870904	; 0xe0000008
    8180:	e282290a 	add	r2, r2, #163840	; 0x28000
    8184:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
    8188:	e283390a 	add	r3, r3, #163840	; 0x28000
    818c:	e5933000 	ldr	r3, [r3]
    8190:	e3c33506 	bic	r3, r3, #25165824	; 0x1800000
    8194:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    8198:	e5823000 	str	r3, [r2]
	IOPIN0 &= ~0x1000000;		// drive CS low
    819c:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    81a0:	e282290a 	add	r2, r2, #163840	; 0x28000
    81a4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    81a8:	e283390a 	add	r3, r3, #163840	; 0x28000
    81ac:	e5933000 	ldr	r3, [r3]
    81b0:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
    81b4:	e5823000 	str	r3, [r2]
    81b8:	ea00008b 	b	83ec <sendSync+0x290>

    //sync loop
	while(i++!=60)
		{
			xprintf("SYNC: (try #%d)   ", i);
    81bc:	e59f0274 	ldr	r0, [pc, #628]	; 8438 <sendSync+0x2dc>
    81c0:	e51b1020 	ldr	r1, [fp, #-32]
    81c4:	ebffe115 	bl	620 <xprintf>

			//if the OV529 is not ready, loop
			while((volatile int)IOPIN0 & (1<<23)) ;
    81c8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    81cc:	e283390a 	add	r3, r3, #163840	; 0x28000
    81d0:	e5933000 	ldr	r3, [r3]
    81d4:	e2033502 	and	r3, r3, #8388608	; 0x800000
    81d8:	e3530000 	cmp	r3, #0	; 0x0
    81dc:	1afffff9 	bne	81c8 <sendSync+0x6c>

			SPISend(sync, 8);
    81e0:	e59f0254 	ldr	r0, [pc, #596]	; 843c <sendSync+0x2e0>
    81e4:	e3a01008 	mov	r1, #8	; 0x8
    81e8:	ebffff28 	bl	7e90 <SPISend>

			for(j=0; j<100000; j++);	// delay approx 25msec
    81ec:	e3a03000 	mov	r3, #0	; 0x0
    81f0:	e50b301c 	str	r3, [fp, #-28]
    81f4:	ea000002 	b	8204 <sendSync+0xa8>
    81f8:	e51b301c 	ldr	r3, [fp, #-28]
    81fc:	e2833001 	add	r3, r3, #1	; 0x1
    8200:	e50b301c 	str	r3, [fp, #-28]
    8204:	e51b201c 	ldr	r2, [fp, #-28]
    8208:	e3a03b61 	mov	r3, #99328	; 0x18400
    820c:	e2833fa7 	add	r3, r3, #668	; 0x29c
    8210:	e2833003 	add	r3, r3, #3	; 0x3
    8214:	e1520003 	cmp	r2, r3
    8218:	dafffff6 	ble	81f8 <sendSync+0x9c>

			SPIReceive(SPIRDData, 8);
    821c:	e59f021c 	ldr	r0, [pc, #540]	; 8440 <sendSync+0x2e4>
    8220:	e3a01008 	mov	r1, #8	; 0x8
    8224:	ebffff5a 	bl	7f94 <SPIReceive>

			xprintf("MISO: %02x %02x %02x %02x %02x %02x %02x %02x\r\n ",
    8228:	e59f3210 	ldr	r3, [pc, #528]	; 8440 <sendSync+0x2e4>
    822c:	e5d33000 	ldrb	r3, [r3]
    8230:	e1a0c003 	mov	ip, r3
    8234:	e59f3204 	ldr	r3, [pc, #516]	; 8440 <sendSync+0x2e4>
    8238:	e5d33001 	ldrb	r3, [r3, #1]
    823c:	e1a04003 	mov	r4, r3
    8240:	e59f31f8 	ldr	r3, [pc, #504]	; 8440 <sendSync+0x2e4>
    8244:	e5d33002 	ldrb	r3, [r3, #2]
    8248:	e1a05003 	mov	r5, r3
    824c:	e59f31ec 	ldr	r3, [pc, #492]	; 8440 <sendSync+0x2e4>
    8250:	e5d33003 	ldrb	r3, [r3, #3]
    8254:	e1a00003 	mov	r0, r3
    8258:	e59f31e0 	ldr	r3, [pc, #480]	; 8440 <sendSync+0x2e4>
    825c:	e5d33004 	ldrb	r3, [r3, #4]
    8260:	e1a06003 	mov	r6, r3
    8264:	e59f31d4 	ldr	r3, [pc, #468]	; 8440 <sendSync+0x2e4>
    8268:	e5d33005 	ldrb	r3, [r3, #5]
    826c:	e1a02003 	mov	r2, r3
    8270:	e59f31c8 	ldr	r3, [pc, #456]	; 8440 <sendSync+0x2e4>
    8274:	e5d33006 	ldrb	r3, [r3, #6]
    8278:	e1a01003 	mov	r1, r3
    827c:	e59f31bc 	ldr	r3, [pc, #444]	; 8440 <sendSync+0x2e4>
    8280:	e5d33007 	ldrb	r3, [r3, #7]
    8284:	e58d0000 	str	r0, [sp]
    8288:	e58d6004 	str	r6, [sp, #4]
    828c:	e58d2008 	str	r2, [sp, #8]
    8290:	e58d100c 	str	r1, [sp, #12]
    8294:	e58d3010 	str	r3, [sp, #16]
    8298:	e59f01a4 	ldr	r0, [pc, #420]	; 8444 <sendSync+0x2e8>
    829c:	e1a0100c 	mov	r1, ip
    82a0:	e1a02004 	mov	r2, r4
    82a4:	e1a03005 	mov	r3, r5
    82a8:	ebffe0dc 	bl	620 <xprintf>
					SPIRDData[0], SPIRDData[1], SPIRDData[2], SPIRDData[3],
					SPIRDData[4], SPIRDData[5], SPIRDData[6], SPIRDData[7]);

			if(isAck(SPIRDData, 0x0D))
    82ac:	e59f018c 	ldr	r0, [pc, #396]	; 8440 <sendSync+0x2e4>
    82b0:	e3a0100d 	mov	r1, #13	; 0xd
    82b4:	ebffff72 	bl	8084 <isAck>
    82b8:	e1a03000 	mov	r3, r0
    82bc:	e3530000 	cmp	r3, #0	; 0x0
    82c0:	0a000049 	beq	83ec <sendSync+0x290>
				{
					xprintf("ack sync was received\n");
    82c4:	e59f017c 	ldr	r0, [pc, #380]	; 8448 <sendSync+0x2ec>
    82c8:	ebffe0d4 	bl	620 <xprintf>

					SPIReceive(SPIRDData, 8);		// receive SYNC cmd from camera
    82cc:	e59f016c 	ldr	r0, [pc, #364]	; 8440 <sendSync+0x2e4>
    82d0:	e3a01008 	mov	r1, #8	; 0x8
    82d4:	ebffff2e 	bl	7f94 <SPIReceive>
					for(j=0; j<8; j++) {
    82d8:	e3a03000 	mov	r3, #0	; 0x0
    82dc:	e50b301c 	str	r3, [fp, #-28]
    82e0:	ea00002b 	b	8394 <sendSync+0x238>
						if(SPIRDData[j] != sync[j]) {
    82e4:	e51b201c 	ldr	r2, [fp, #-28]
    82e8:	e59f3150 	ldr	r3, [pc, #336]	; 8440 <sendSync+0x2e4>
    82ec:	e7d31002 	ldrb	r1, [r3, r2]
    82f0:	e51b201c 	ldr	r2, [fp, #-28]
    82f4:	e59f3140 	ldr	r3, [pc, #320]	; 843c <sendSync+0x2e0>
    82f8:	e7d33002 	ldrb	r3, [r3, r2]
    82fc:	e1510003 	cmp	r1, r3
    8300:	0a000020 	beq	8388 <sendSync+0x22c>
							xprintf("Expected SYNC, got: %02x %02x %02x %02x %02x %02x %02x %02x\r\n ",
    8304:	e59f3134 	ldr	r3, [pc, #308]	; 8440 <sendSync+0x2e4>
    8308:	e5d33000 	ldrb	r3, [r3]
    830c:	e1a0c003 	mov	ip, r3
    8310:	e59f3128 	ldr	r3, [pc, #296]	; 8440 <sendSync+0x2e4>
    8314:	e5d33001 	ldrb	r3, [r3, #1]
    8318:	e1a0e003 	mov	lr, r3
    831c:	e59f311c 	ldr	r3, [pc, #284]	; 8440 <sendSync+0x2e4>
    8320:	e5d33002 	ldrb	r3, [r3, #2]
    8324:	e1a04003 	mov	r4, r3
    8328:	e59f3110 	ldr	r3, [pc, #272]	; 8440 <sendSync+0x2e4>
    832c:	e5d33003 	ldrb	r3, [r3, #3]
    8330:	e1a00003 	mov	r0, r3
    8334:	e59f3104 	ldr	r3, [pc, #260]	; 8440 <sendSync+0x2e4>
    8338:	e5d33004 	ldrb	r3, [r3, #4]
    833c:	e1a05003 	mov	r5, r3
    8340:	e59f30f8 	ldr	r3, [pc, #248]	; 8440 <sendSync+0x2e4>
    8344:	e5d33005 	ldrb	r3, [r3, #5]
    8348:	e1a02003 	mov	r2, r3
    834c:	e59f30ec 	ldr	r3, [pc, #236]	; 8440 <sendSync+0x2e4>
    8350:	e5d33006 	ldrb	r3, [r3, #6]
    8354:	e1a01003 	mov	r1, r3
    8358:	e59f30e0 	ldr	r3, [pc, #224]	; 8440 <sendSync+0x2e4>
    835c:	e5d33007 	ldrb	r3, [r3, #7]
    8360:	e58d0000 	str	r0, [sp]
    8364:	e58d5004 	str	r5, [sp, #4]
    8368:	e58d2008 	str	r2, [sp, #8]
    836c:	e58d100c 	str	r1, [sp, #12]
    8370:	e58d3010 	str	r3, [sp, #16]
    8374:	e59f00d0 	ldr	r0, [pc, #208]	; 844c <sendSync+0x2f0>
    8378:	e1a0100c 	mov	r1, ip
    837c:	e1a0200e 	mov	r2, lr
    8380:	e1a03004 	mov	r3, r4
    8384:	ebffe0a5 	bl	620 <xprintf>
			if(isAck(SPIRDData, 0x0D))
				{
					xprintf("ack sync was received\n");

					SPIReceive(SPIRDData, 8);		// receive SYNC cmd from camera
					for(j=0; j<8; j++) {
    8388:	e51b301c 	ldr	r3, [fp, #-28]
    838c:	e2833001 	add	r3, r3, #1	; 0x1
    8390:	e50b301c 	str	r3, [fp, #-28]
    8394:	e51b301c 	ldr	r3, [fp, #-28]
    8398:	e3530007 	cmp	r3, #7	; 0x7
    839c:	daffffd0 	ble	82e4 <sendSync+0x188>
									SPIRDData[4], SPIRDData[5], SPIRDData[6], SPIRDData[7]);
							// don't exactly know what should be done in this case
							// for the moment, let's send ACK and try to continue ....
						}
					}
					if(j==8) xprintf("Got SYNC from camera\n");
    83a0:	e51b301c 	ldr	r3, [fp, #-28]
    83a4:	e3530008 	cmp	r3, #8	; 0x8
    83a8:	1a000001 	bne	83b4 <sendSync+0x258>
    83ac:	e59f009c 	ldr	r0, [pc, #156]	; 8450 <sendSync+0x2f4>
    83b0:	ebffe09a 	bl	620 <xprintf>
					SPISend(acksync, 8);
    83b4:	e59f0098 	ldr	r0, [pc, #152]	; 8454 <sendSync+0x2f8>
    83b8:	e3a01008 	mov	r1, #8	; 0x8
    83bc:	ebfffeb3 	bl	7e90 <SPISend>
					AckCounter++;
    83c0:	e59f3090 	ldr	r3, [pc, #144]	; 8458 <sendSync+0x2fc>
    83c4:	e5d33000 	ldrb	r3, [r3]
    83c8:	e2833001 	add	r3, r3, #1	; 0x1
    83cc:	e20330ff 	and	r3, r3, #255	; 0xff
    83d0:	e59f2080 	ldr	r2, [pc, #128]	; 8458 <sendSync+0x2fc>
    83d4:	e5c23000 	strb	r3, [r2]
					acksync[5] = AckCounter;
    83d8:	e59f3078 	ldr	r3, [pc, #120]	; 8458 <sendSync+0x2fc>
    83dc:	e5d33000 	ldrb	r3, [r3]
    83e0:	e59f206c 	ldr	r2, [pc, #108]	; 8454 <sendSync+0x2f8>
    83e4:	e5c23005 	strb	r3, [r2, #5]
    83e8:	ea000009 	b	8414 <sendSync+0x2b8>

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
	IOPIN0 &= ~0x1000000;		// drive CS low

    //sync loop
	while(i++!=60)
    83ec:	e51b3020 	ldr	r3, [fp, #-32]
    83f0:	e353003c 	cmp	r3, #60	; 0x3c
    83f4:	03a03000 	moveq	r3, #0	; 0x0
    83f8:	13a03001 	movne	r3, #1	; 0x1
    83fc:	e20320ff 	and	r2, r3, #255	; 0xff
    8400:	e51b3020 	ldr	r3, [fp, #-32]
    8404:	e2833001 	add	r3, r3, #1	; 0x1
    8408:	e50b3020 	str	r3, [fp, #-32]
    840c:	e3520000 	cmp	r2, #0	; 0x0
    8410:	1affff69 	bne	81bc <sendSync+0x60>
					AckCounter++;
					acksync[5] = AckCounter;
					break;
				}
		}
	IOPIN0 |= 0x1000000;	// drive CS high
    8414:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    8418:	e282290a 	add	r2, r2, #163840	; 0x28000
    841c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8420:	e283390a 	add	r3, r3, #163840	; 0x28000
    8424:	e5933000 	ldr	r3, [r3]
    8428:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    842c:	e5823000 	str	r3, [r2]
}
    8430:	e24bd018 	sub	sp, fp, #24	; 0x18
    8434:	e89da870 	ldm	sp, {r4, r5, r6, fp, sp, pc}
    8438:	00009590 	.word	0x00009590
    843c:	4000000c 	.word	0x4000000c
    8440:	400006ea 	.word	0x400006ea
    8444:	000095a4 	.word	0x000095a4
    8448:	000095d8 	.word	0x000095d8
    844c:	000095f0 	.word	0x000095f0
    8450:	00009630 	.word	0x00009630
    8454:	4000003c 	.word	0x4000003c
    8458:	40000794 	.word	0x40000794

0000845c <getInit>:
    }
	IOPIN0 |= 0x1000000;	// drive CS high
}

void getInit()
	{
    845c:	e1a0c00d 	mov	ip, sp
    8460:	e92dd870 	push	{r4, r5, r6, fp, ip, lr, pc}
    8464:	e24cb004 	sub	fp, ip, #4	; 0x4
    8468:	e24dd018 	sub	sp, sp, #24	; 0x18
    int j=0;
    846c:	e3a03000 	mov	r3, #0	; 0x0
    8470:	e50b301c 	str	r3, [fp, #-28]

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    8474:	e3a0228e 	mov	r2, #-536870904	; 0xe0000008
    8478:	e282290a 	add	r2, r2, #163840	; 0x28000
    847c:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
    8480:	e283390a 	add	r3, r3, #163840	; 0x28000
    8484:	e5933000 	ldr	r3, [r3]
    8488:	e3c33506 	bic	r3, r3, #25165824	; 0x1800000
    848c:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    8490:	e5823000 	str	r3, [r2]
	IOPIN0 &= ~0x1000000;		// drive CS low
    8494:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    8498:	e282290a 	add	r2, r2, #163840	; 0x28000
    849c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    84a0:	e283390a 	add	r3, r3, #163840	; 0x28000
    84a4:	e5933000 	ldr	r3, [r3]
    84a8:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
    84ac:	e5823000 	str	r3, [r2]

	xprintf("INIT:   " );
    84b0:	e59f0128 	ldr	r0, [pc, #296]	; 85e0 <getInit+0x184>
    84b4:	ebffe059 	bl	620 <xprintf>

	//if the OV529 is not ready, loop
	while((volatile int)IOPIN0 & (1<<23)) ;
    84b8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    84bc:	e283390a 	add	r3, r3, #163840	; 0x28000
    84c0:	e5933000 	ldr	r3, [r3]
    84c4:	e2033502 	and	r3, r3, #8388608	; 0x800000
    84c8:	e3530000 	cmp	r3, #0	; 0x0
    84cc:	1afffff9 	bne	84b8 <getInit+0x5c>

	SPISend(camInit, 8);
    84d0:	e59f010c 	ldr	r0, [pc, #268]	; 85e4 <getInit+0x188>
    84d4:	e3a01008 	mov	r1, #8	; 0x8
    84d8:	ebfffe6c 	bl	7e90 <SPISend>
	for(j=0; j<100000; j++);
    84dc:	e3a03000 	mov	r3, #0	; 0x0
    84e0:	e50b301c 	str	r3, [fp, #-28]
    84e4:	ea000002 	b	84f4 <getInit+0x98>
    84e8:	e51b301c 	ldr	r3, [fp, #-28]
    84ec:	e2833001 	add	r3, r3, #1	; 0x1
    84f0:	e50b301c 	str	r3, [fp, #-28]
    84f4:	e51b201c 	ldr	r2, [fp, #-28]
    84f8:	e3a03b61 	mov	r3, #99328	; 0x18400
    84fc:	e2833fa7 	add	r3, r3, #668	; 0x29c
    8500:	e2833003 	add	r3, r3, #3	; 0x3
    8504:	e1520003 	cmp	r2, r3
    8508:	dafffff6 	ble	84e8 <getInit+0x8c>
	SPIReceive(SPIRDData, 8);
    850c:	e59f00d4 	ldr	r0, [pc, #212]	; 85e8 <getInit+0x18c>
    8510:	e3a01008 	mov	r1, #8	; 0x8
    8514:	ebfffe9e 	bl	7f94 <SPIReceive>

	xprintf("MISO: %02x %02x %02x %02x %02x %02x %02x %02x\r\n ",
    8518:	e59f30c8 	ldr	r3, [pc, #200]	; 85e8 <getInit+0x18c>
    851c:	e5d33000 	ldrb	r3, [r3]
    8520:	e1a0c003 	mov	ip, r3
    8524:	e59f30bc 	ldr	r3, [pc, #188]	; 85e8 <getInit+0x18c>
    8528:	e5d33001 	ldrb	r3, [r3, #1]
    852c:	e1a04003 	mov	r4, r3
    8530:	e59f30b0 	ldr	r3, [pc, #176]	; 85e8 <getInit+0x18c>
    8534:	e5d33002 	ldrb	r3, [r3, #2]
    8538:	e1a05003 	mov	r5, r3
    853c:	e59f30a4 	ldr	r3, [pc, #164]	; 85e8 <getInit+0x18c>
    8540:	e5d33003 	ldrb	r3, [r3, #3]
    8544:	e1a00003 	mov	r0, r3
    8548:	e59f3098 	ldr	r3, [pc, #152]	; 85e8 <getInit+0x18c>
    854c:	e5d33004 	ldrb	r3, [r3, #4]
    8550:	e1a06003 	mov	r6, r3
    8554:	e59f308c 	ldr	r3, [pc, #140]	; 85e8 <getInit+0x18c>
    8558:	e5d33005 	ldrb	r3, [r3, #5]
    855c:	e1a02003 	mov	r2, r3
    8560:	e59f3080 	ldr	r3, [pc, #128]	; 85e8 <getInit+0x18c>
    8564:	e5d33006 	ldrb	r3, [r3, #6]
    8568:	e1a01003 	mov	r1, r3
    856c:	e59f3074 	ldr	r3, [pc, #116]	; 85e8 <getInit+0x18c>
    8570:	e5d33007 	ldrb	r3, [r3, #7]
    8574:	e58d0000 	str	r0, [sp]
    8578:	e58d6004 	str	r6, [sp, #4]
    857c:	e58d2008 	str	r2, [sp, #8]
    8580:	e58d100c 	str	r1, [sp, #12]
    8584:	e58d3010 	str	r3, [sp, #16]
    8588:	e59f005c 	ldr	r0, [pc, #92]	; 85ec <getInit+0x190>
    858c:	e1a0100c 	mov	r1, ip
    8590:	e1a02004 	mov	r2, r4
    8594:	e1a03005 	mov	r3, r5
    8598:	ebffe020 	bl	620 <xprintf>
			SPIRDData[0], SPIRDData[1], SPIRDData[2], SPIRDData[3],
			SPIRDData[4], SPIRDData[5], SPIRDData[6], SPIRDData[7]);

	if(isAck(SPIRDData, 0x01))
    859c:	e59f0044 	ldr	r0, [pc, #68]	; 85e8 <getInit+0x18c>
    85a0:	e3a01001 	mov	r1, #1	; 0x1
    85a4:	ebfffeb6 	bl	8084 <isAck>
    85a8:	e1a03000 	mov	r3, r0
    85ac:	e3530000 	cmp	r3, #0	; 0x0
    85b0:	0a000001 	beq	85bc <getInit+0x160>
		{
			xprintf("ack camera init was received\n");
    85b4:	e59f0034 	ldr	r0, [pc, #52]	; 85f0 <getInit+0x194>
    85b8:	ebffe018 	bl	620 <xprintf>
		}
	IOPIN0 |= 0x1000000;	// drive CS high
    85bc:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    85c0:	e282290a 	add	r2, r2, #163840	; 0x28000
    85c4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    85c8:	e283390a 	add	r3, r3, #163840	; 0x28000
    85cc:	e5933000 	ldr	r3, [r3]
    85d0:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    85d4:	e5823000 	str	r3, [r2]
}
    85d8:	e24bd018 	sub	sp, fp, #24	; 0x18
    85dc:	e89da870 	ldm	sp, {r4, r5, r6, fp, sp, pc}
    85e0:	00009674 	.word	0x00009674
    85e4:	4000001c 	.word	0x4000001c
    85e8:	400006ea 	.word	0x400006ea
    85ec:	000095a4 	.word	0x000095a4
    85f0:	00009680 	.word	0x00009680

000085f4 <getImageQuality>:

void getImageQuality()
	{
    85f4:	e1a0c00d 	mov	ip, sp
    85f8:	e92dd870 	push	{r4, r5, r6, fp, ip, lr, pc}
    85fc:	e24cb004 	sub	fp, ip, #4	; 0x4
    8600:	e24dd018 	sub	sp, sp, #24	; 0x18
    int j = 0;
    8604:	e3a03000 	mov	r3, #0	; 0x0
    8608:	e50b301c 	str	r3, [fp, #-28]

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    860c:	e3a0228e 	mov	r2, #-536870904	; 0xe0000008
    8610:	e282290a 	add	r2, r2, #163840	; 0x28000
    8614:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
    8618:	e283390a 	add	r3, r3, #163840	; 0x28000
    861c:	e5933000 	ldr	r3, [r3]
    8620:	e3c33506 	bic	r3, r3, #25165824	; 0x1800000
    8624:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    8628:	e5823000 	str	r3, [r2]
	IOPIN0 &= ~0x1000000;		// drive CS low
    862c:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    8630:	e282290a 	add	r2, r2, #163840	; 0x28000
    8634:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8638:	e283390a 	add	r3, r3, #163840	; 0x28000
    863c:	e5933000 	ldr	r3, [r3]
    8640:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
    8644:	e5823000 	str	r3, [r2]

	xprintf("IMAGE QUALITY:   ");
    8648:	e59f0134 	ldr	r0, [pc, #308]	; 8784 <getImageQuality+0x190>
    864c:	ebffdff3 	bl	620 <xprintf>

	//if the OV529 is not ready, loop
	while((volatile int)IOPIN0 & (1<<23)) ;
    8650:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8654:	e283390a 	add	r3, r3, #163840	; 0x28000
    8658:	e5933000 	ldr	r3, [r3]
    865c:	e2033502 	and	r3, r3, #8388608	; 0x800000
    8660:	e3530000 	cmp	r3, #0	; 0x0
    8664:	1afffff9 	bne	8650 <getImageQuality+0x5c>

	SPISend(picQuality, 8);
    8668:	e59f0118 	ldr	r0, [pc, #280]	; 8788 <getImageQuality+0x194>
    866c:	e3a01008 	mov	r1, #8	; 0x8
    8670:	ebfffe06 	bl	7e90 <SPISend>
	for(j=0; j<100000; j++);
    8674:	e3a03000 	mov	r3, #0	; 0x0
    8678:	e50b301c 	str	r3, [fp, #-28]
    867c:	ea000002 	b	868c <getImageQuality+0x98>
    8680:	e51b301c 	ldr	r3, [fp, #-28]
    8684:	e2833001 	add	r3, r3, #1	; 0x1
    8688:	e50b301c 	str	r3, [fp, #-28]
    868c:	e51b201c 	ldr	r2, [fp, #-28]
    8690:	e3a03b61 	mov	r3, #99328	; 0x18400
    8694:	e2833fa7 	add	r3, r3, #668	; 0x29c
    8698:	e2833003 	add	r3, r3, #3	; 0x3
    869c:	e1520003 	cmp	r2, r3
    86a0:	dafffff6 	ble	8680 <getImageQuality+0x8c>

	SPIReceive(SPIRDData, 8);
    86a4:	e59f00e0 	ldr	r0, [pc, #224]	; 878c <getImageQuality+0x198>
    86a8:	e3a01008 	mov	r1, #8	; 0x8
    86ac:	ebfffe38 	bl	7f94 <SPIReceive>
	xprintf("MISO: %02x %02x %02x %02x %02x %02x %02x %02x\r\n ",
    86b0:	e59f30d4 	ldr	r3, [pc, #212]	; 878c <getImageQuality+0x198>
    86b4:	e5d33000 	ldrb	r3, [r3]
    86b8:	e1a0c003 	mov	ip, r3
    86bc:	e59f30c8 	ldr	r3, [pc, #200]	; 878c <getImageQuality+0x198>
    86c0:	e5d33001 	ldrb	r3, [r3, #1]
    86c4:	e1a04003 	mov	r4, r3
    86c8:	e59f30bc 	ldr	r3, [pc, #188]	; 878c <getImageQuality+0x198>
    86cc:	e5d33002 	ldrb	r3, [r3, #2]
    86d0:	e1a05003 	mov	r5, r3
    86d4:	e59f30b0 	ldr	r3, [pc, #176]	; 878c <getImageQuality+0x198>
    86d8:	e5d33003 	ldrb	r3, [r3, #3]
    86dc:	e1a00003 	mov	r0, r3
    86e0:	e59f30a4 	ldr	r3, [pc, #164]	; 878c <getImageQuality+0x198>
    86e4:	e5d33004 	ldrb	r3, [r3, #4]
    86e8:	e1a06003 	mov	r6, r3
    86ec:	e59f3098 	ldr	r3, [pc, #152]	; 878c <getImageQuality+0x198>
    86f0:	e5d33005 	ldrb	r3, [r3, #5]
    86f4:	e1a02003 	mov	r2, r3
    86f8:	e59f308c 	ldr	r3, [pc, #140]	; 878c <getImageQuality+0x198>
    86fc:	e5d33006 	ldrb	r3, [r3, #6]
    8700:	e1a01003 	mov	r1, r3
    8704:	e59f3080 	ldr	r3, [pc, #128]	; 878c <getImageQuality+0x198>
    8708:	e5d33007 	ldrb	r3, [r3, #7]
    870c:	e58d0000 	str	r0, [sp]
    8710:	e58d6004 	str	r6, [sp, #4]
    8714:	e58d2008 	str	r2, [sp, #8]
    8718:	e58d100c 	str	r1, [sp, #12]
    871c:	e58d3010 	str	r3, [sp, #16]
    8720:	e59f0068 	ldr	r0, [pc, #104]	; 8790 <getImageQuality+0x19c>
    8724:	e1a0100c 	mov	r1, ip
    8728:	e1a02004 	mov	r2, r4
    872c:	e1a03005 	mov	r3, r5
    8730:	ebffdfba 	bl	620 <xprintf>
			SPIRDData[0], SPIRDData[1], SPIRDData[2], SPIRDData[3],
			SPIRDData[4], SPIRDData[5], SPIRDData[6], SPIRDData[7]);

	if(isAck(SPIRDData, 0x10))
    8734:	e59f0050 	ldr	r0, [pc, #80]	; 878c <getImageQuality+0x198>
    8738:	e3a01010 	mov	r1, #16	; 0x10
    873c:	ebfffe50 	bl	8084 <isAck>
    8740:	e1a03000 	mov	r3, r0
    8744:	e3530000 	cmp	r3, #0	; 0x0
    8748:	0a000004 	beq	8760 <getImageQuality+0x16c>
		{
			xprintf("ack image quality was received\n");
    874c:	e59f0040 	ldr	r0, [pc, #64]	; 8794 <getImageQuality+0x1a0>
    8750:	ebffdfb2 	bl	620 <xprintf>
			SPISend(ackimgqual, 8);
    8754:	e59f003c 	ldr	r0, [pc, #60]	; 8798 <getImageQuality+0x1a4>
    8758:	e3a01008 	mov	r1, #8	; 0x8
    875c:	ebfffdcb 	bl	7e90 <SPISend>
		}
	IOPIN0 |= 0x1000000;	// drive CS high
    8760:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    8764:	e282290a 	add	r2, r2, #163840	; 0x28000
    8768:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    876c:	e283390a 	add	r3, r3, #163840	; 0x28000
    8770:	e5933000 	ldr	r3, [r3]
    8774:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    8778:	e5823000 	str	r3, [r2]
}
    877c:	e24bd018 	sub	sp, fp, #24	; 0x18
    8780:	e89da870 	ldm	sp, {r4, r5, r6, fp, sp, pc}
    8784:	000096a0 	.word	0x000096a0
    8788:	40000024 	.word	0x40000024
    878c:	400006ea 	.word	0x400006ea
    8790:	000095a4 	.word	0x000095a4
    8794:	000096b4 	.word	0x000096b4
    8798:	40000044 	.word	0x40000044

0000879c <getSnapshot>:

void getSnapshot()
	{
    879c:	e1a0c00d 	mov	ip, sp
    87a0:	e92dd870 	push	{r4, r5, r6, fp, ip, lr, pc}
    87a4:	e24cb004 	sub	fp, ip, #4	; 0x4
    87a8:	e24dd01c 	sub	sp, sp, #28	; 0x1c
    int i = 0;
    87ac:	e3a03000 	mov	r3, #0	; 0x0
    87b0:	e50b3020 	str	r3, [fp, #-32]
    int j=0;
    87b4:	e3a03000 	mov	r3, #0	; 0x0
    87b8:	e50b301c 	str	r3, [fp, #-28]

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    87bc:	e3a0228e 	mov	r2, #-536870904	; 0xe0000008
    87c0:	e282290a 	add	r2, r2, #163840	; 0x28000
    87c4:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
    87c8:	e283390a 	add	r3, r3, #163840	; 0x28000
    87cc:	e5933000 	ldr	r3, [r3]
    87d0:	e3c33506 	bic	r3, r3, #25165824	; 0x1800000
    87d4:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    87d8:	e5823000 	str	r3, [r2]
	IOPIN0 &= ~0x1000000;	// drive CS low
    87dc:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    87e0:	e282290a 	add	r2, r2, #163840	; 0x28000
    87e4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    87e8:	e283390a 	add	r3, r3, #163840	; 0x28000
    87ec:	e5933000 	ldr	r3, [r3]
    87f0:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
    87f4:	e5823000 	str	r3, [r2]

	xprintf("GET SNAPSHOT: (try #%d)   ", i);
    87f8:	e59f012c 	ldr	r0, [pc, #300]	; 892c <getSnapshot+0x190>
    87fc:	e51b1020 	ldr	r1, [fp, #-32]
    8800:	ebffdf86 	bl	620 <xprintf>

	//if the OV529 is not ready, loop
	while((volatile int)IOPIN0 & (1<<23)) ;
    8804:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8808:	e283390a 	add	r3, r3, #163840	; 0x28000
    880c:	e5933000 	ldr	r3, [r3]
    8810:	e2033502 	and	r3, r3, #8388608	; 0x800000
    8814:	e3530000 	cmp	r3, #0	; 0x0
    8818:	1afffff9 	bne	8804 <getSnapshot+0x68>

	SPISend(snapshot, 8);
    881c:	e59f010c 	ldr	r0, [pc, #268]	; 8930 <getSnapshot+0x194>
    8820:	e3a01008 	mov	r1, #8	; 0x8
    8824:	ebfffd99 	bl	7e90 <SPISend>
	for(j=0; j<100000; j++);
    8828:	e3a03000 	mov	r3, #0	; 0x0
    882c:	e50b301c 	str	r3, [fp, #-28]
    8830:	ea000002 	b	8840 <getSnapshot+0xa4>
    8834:	e51b301c 	ldr	r3, [fp, #-28]
    8838:	e2833001 	add	r3, r3, #1	; 0x1
    883c:	e50b301c 	str	r3, [fp, #-28]
    8840:	e51b201c 	ldr	r2, [fp, #-28]
    8844:	e3a03b61 	mov	r3, #99328	; 0x18400
    8848:	e2833fa7 	add	r3, r3, #668	; 0x29c
    884c:	e2833003 	add	r3, r3, #3	; 0x3
    8850:	e1520003 	cmp	r2, r3
    8854:	dafffff6 	ble	8834 <getSnapshot+0x98>

	SPIReceive(SPIRDData, 8);
    8858:	e59f00d4 	ldr	r0, [pc, #212]	; 8934 <getSnapshot+0x198>
    885c:	e3a01008 	mov	r1, #8	; 0x8
    8860:	ebfffdcb 	bl	7f94 <SPIReceive>

	xprintf("MISO: %02x %02x %02x %02x %02x %02x %02x %02x\r\n ",
    8864:	e59f30c8 	ldr	r3, [pc, #200]	; 8934 <getSnapshot+0x198>
    8868:	e5d33000 	ldrb	r3, [r3]
    886c:	e1a0c003 	mov	ip, r3
    8870:	e59f30bc 	ldr	r3, [pc, #188]	; 8934 <getSnapshot+0x198>
    8874:	e5d33001 	ldrb	r3, [r3, #1]
    8878:	e1a04003 	mov	r4, r3
    887c:	e59f30b0 	ldr	r3, [pc, #176]	; 8934 <getSnapshot+0x198>
    8880:	e5d33002 	ldrb	r3, [r3, #2]
    8884:	e1a05003 	mov	r5, r3
    8888:	e59f30a4 	ldr	r3, [pc, #164]	; 8934 <getSnapshot+0x198>
    888c:	e5d33003 	ldrb	r3, [r3, #3]
    8890:	e1a00003 	mov	r0, r3
    8894:	e59f3098 	ldr	r3, [pc, #152]	; 8934 <getSnapshot+0x198>
    8898:	e5d33004 	ldrb	r3, [r3, #4]
    889c:	e1a06003 	mov	r6, r3
    88a0:	e59f308c 	ldr	r3, [pc, #140]	; 8934 <getSnapshot+0x198>
    88a4:	e5d33005 	ldrb	r3, [r3, #5]
    88a8:	e1a02003 	mov	r2, r3
    88ac:	e59f3080 	ldr	r3, [pc, #128]	; 8934 <getSnapshot+0x198>
    88b0:	e5d33006 	ldrb	r3, [r3, #6]
    88b4:	e1a01003 	mov	r1, r3
    88b8:	e59f3074 	ldr	r3, [pc, #116]	; 8934 <getSnapshot+0x198>
    88bc:	e5d33007 	ldrb	r3, [r3, #7]
    88c0:	e58d0000 	str	r0, [sp]
    88c4:	e58d6004 	str	r6, [sp, #4]
    88c8:	e58d2008 	str	r2, [sp, #8]
    88cc:	e58d100c 	str	r1, [sp, #12]
    88d0:	e58d3010 	str	r3, [sp, #16]
    88d4:	e59f005c 	ldr	r0, [pc, #92]	; 8938 <getSnapshot+0x19c>
    88d8:	e1a0100c 	mov	r1, ip
    88dc:	e1a02004 	mov	r2, r4
    88e0:	e1a03005 	mov	r3, r5
    88e4:	ebffdf4d 	bl	620 <xprintf>
			SPIRDData[0], SPIRDData[1], SPIRDData[2], SPIRDData[3],
			SPIRDData[4], SPIRDData[5], SPIRDData[6], SPIRDData[7]);
	if(isAck(SPIRDData, 0x05))
    88e8:	e59f0044 	ldr	r0, [pc, #68]	; 8934 <getSnapshot+0x198>
    88ec:	e3a01005 	mov	r1, #5	; 0x5
    88f0:	ebfffde3 	bl	8084 <isAck>
    88f4:	e1a03000 	mov	r3, r0
    88f8:	e3530000 	cmp	r3, #0	; 0x0
    88fc:	0a000001 	beq	8908 <getSnapshot+0x16c>
		{
			xprintf("ack snapshot was received\n");
    8900:	e59f0034 	ldr	r0, [pc, #52]	; 893c <getSnapshot+0x1a0>
    8904:	ebffdf45 	bl	620 <xprintf>
		}
	IOPIN0 |= 0x1000000;	// drive CS high
    8908:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    890c:	e282290a 	add	r2, r2, #163840	; 0x28000
    8910:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8914:	e283390a 	add	r3, r3, #163840	; 0x28000
    8918:	e5933000 	ldr	r3, [r3]
    891c:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    8920:	e5823000 	str	r3, [r2]
}
    8924:	e24bd018 	sub	sp, fp, #24	; 0x18
    8928:	e89da870 	ldm	sp, {r4, r5, r6, fp, sp, pc}
    892c:	000096d4 	.word	0x000096d4
    8930:	4000002c 	.word	0x4000002c
    8934:	400006ea 	.word	0x400006ea
    8938:	000095a4 	.word	0x000095a4
    893c:	000096f0 	.word	0x000096f0

00008940 <getPic>:

int getPic()  //return image size
{
    8940:	e1a0c00d 	mov	ip, sp
    8944:	e92dd870 	push	{r4, r5, r6, fp, ip, lr, pc}
    8948:	e24cb004 	sub	fp, ip, #4	; 0x4
    894c:	e24dd024 	sub	sp, sp, #36	; 0x24
    int i = 0;
    8950:	e3a03000 	mov	r3, #0	; 0x0
    8954:	e50b3028 	str	r3, [fp, #-40]
    int j = 0;
    8958:	e3a03000 	mov	r3, #0	; 0x0
    895c:	e50b3024 	str	r3, [fp, #-36]
    int imgsz;
    BYTE *imagebuf = (BYTE*)0x80000000;	// SRAM area starting address (used for image buffer)
    8960:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
    8964:	e50b301c 	str	r3, [fp, #-28]
//    BYTE *imagebuf = (BYTE*)0x40004000;	// ON-CHIP SRAM area starting address (used for image buffer)

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    8968:	e3a0228e 	mov	r2, #-536870904	; 0xe0000008
    896c:	e282290a 	add	r2, r2, #163840	; 0x28000
    8970:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
    8974:	e283390a 	add	r3, r3, #163840	; 0x28000
    8978:	e5933000 	ldr	r3, [r3]
    897c:	e3c33506 	bic	r3, r3, #25165824	; 0x1800000
    8980:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    8984:	e5823000 	str	r3, [r2]
	IOPIN0 &= ~0x1000000;	// drive CS low
    8988:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    898c:	e282290a 	add	r2, r2, #163840	; 0x28000
    8990:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8994:	e283390a 	add	r3, r3, #163840	; 0x28000
    8998:	e5933000 	ldr	r3, [r3]
    899c:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
    89a0:	e5823000 	str	r3, [r2]
    89a4:	ea00009a 	b	8c14 <getPic+0x2d4>

	    while(i++ != 30)
	    {
			xprintf("GET PICTURE: (try #%d) \n  ", i);
    89a8:	e59f02b8 	ldr	r0, [pc, #696]	; 8c68 <getPic+0x328>
    89ac:	e51b1028 	ldr	r1, [fp, #-40]
    89b0:	ebffdf1a 	bl	620 <xprintf>

			//if the OV529 is not ready, loop
			while((volatile int)IOPIN0 & (1<<23)) ;
    89b4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    89b8:	e283390a 	add	r3, r3, #163840	; 0x28000
    89bc:	e5933000 	ldr	r3, [r3]
    89c0:	e2033502 	and	r3, r3, #8388608	; 0x800000
    89c4:	e3530000 	cmp	r3, #0	; 0x0
    89c8:	1afffff9 	bne	89b4 <getPic+0x74>

			SPISend(getPicture, 8);
    89cc:	e59f0298 	ldr	r0, [pc, #664]	; 8c6c <getPic+0x32c>
    89d0:	e3a01008 	mov	r1, #8	; 0x8
    89d4:	ebfffd2d 	bl	7e90 <SPISend>
			for(j=0; j<100000; j++);
    89d8:	e3a03000 	mov	r3, #0	; 0x0
    89dc:	e50b3024 	str	r3, [fp, #-36]
    89e0:	ea000002 	b	89f0 <getPic+0xb0>
    89e4:	e51b3024 	ldr	r3, [fp, #-36]
    89e8:	e2833001 	add	r3, r3, #1	; 0x1
    89ec:	e50b3024 	str	r3, [fp, #-36]
    89f0:	e51b2024 	ldr	r2, [fp, #-36]
    89f4:	e3a03b61 	mov	r3, #99328	; 0x18400
    89f8:	e2833fa7 	add	r3, r3, #668	; 0x29c
    89fc:	e2833003 	add	r3, r3, #3	; 0x3
    8a00:	e1520003 	cmp	r2, r3
    8a04:	dafffff6 	ble	89e4 <getPic+0xa4>

			SPIReceive(SPIRDData, 8);
    8a08:	e59f0260 	ldr	r0, [pc, #608]	; 8c70 <getPic+0x330>
    8a0c:	e3a01008 	mov	r1, #8	; 0x8
    8a10:	ebfffd5f 	bl	7f94 <SPIReceive>
			xprintf("MISO: %02x %02x %02x %02x %02x %02x %02x %02x\r\n ",
    8a14:	e59f3254 	ldr	r3, [pc, #596]	; 8c70 <getPic+0x330>
    8a18:	e5d33000 	ldrb	r3, [r3]
    8a1c:	e1a0c003 	mov	ip, r3
    8a20:	e59f3248 	ldr	r3, [pc, #584]	; 8c70 <getPic+0x330>
    8a24:	e5d33001 	ldrb	r3, [r3, #1]
    8a28:	e1a04003 	mov	r4, r3
    8a2c:	e59f323c 	ldr	r3, [pc, #572]	; 8c70 <getPic+0x330>
    8a30:	e5d33002 	ldrb	r3, [r3, #2]
    8a34:	e1a05003 	mov	r5, r3
    8a38:	e59f3230 	ldr	r3, [pc, #560]	; 8c70 <getPic+0x330>
    8a3c:	e5d33003 	ldrb	r3, [r3, #3]
    8a40:	e1a00003 	mov	r0, r3
    8a44:	e59f3224 	ldr	r3, [pc, #548]	; 8c70 <getPic+0x330>
    8a48:	e5d33004 	ldrb	r3, [r3, #4]
    8a4c:	e1a06003 	mov	r6, r3
    8a50:	e59f3218 	ldr	r3, [pc, #536]	; 8c70 <getPic+0x330>
    8a54:	e5d33005 	ldrb	r3, [r3, #5]
    8a58:	e1a02003 	mov	r2, r3
    8a5c:	e59f320c 	ldr	r3, [pc, #524]	; 8c70 <getPic+0x330>
    8a60:	e5d33006 	ldrb	r3, [r3, #6]
    8a64:	e1a01003 	mov	r1, r3
    8a68:	e59f3200 	ldr	r3, [pc, #512]	; 8c70 <getPic+0x330>
    8a6c:	e5d33007 	ldrb	r3, [r3, #7]
    8a70:	e58d0000 	str	r0, [sp]
    8a74:	e58d6004 	str	r6, [sp, #4]
    8a78:	e58d2008 	str	r2, [sp, #8]
    8a7c:	e58d100c 	str	r1, [sp, #12]
    8a80:	e58d3010 	str	r3, [sp, #16]
    8a84:	e59f01e8 	ldr	r0, [pc, #488]	; 8c74 <getPic+0x334>
    8a88:	e1a0100c 	mov	r1, ip
    8a8c:	e1a02004 	mov	r2, r4
    8a90:	e1a03005 	mov	r3, r5
    8a94:	ebffdee1 	bl	620 <xprintf>
					SPIRDData[0], SPIRDData[1], SPIRDData[2], SPIRDData[3],
					SPIRDData[4], SPIRDData[5], SPIRDData[6], SPIRDData[7]);

			if(isAck(SPIRDData, 0x04))
    8a98:	e59f01d0 	ldr	r0, [pc, #464]	; 8c70 <getPic+0x330>
    8a9c:	e3a01004 	mov	r1, #4	; 0x4
    8aa0:	ebfffd77 	bl	8084 <isAck>
    8aa4:	e1a03000 	mov	r3, r0
    8aa8:	e3530000 	cmp	r3, #0	; 0x0
    8aac:	0a000058 	beq	8c14 <getPic+0x2d4>
				{
					xprintf("ack getPic was received\n");
    8ab0:	e59f01c0 	ldr	r0, [pc, #448]	; 8c78 <getPic+0x338>
    8ab4:	ebffded9 	bl	620 <xprintf>
					SPIReceive(SPIRDData, 8);
    8ab8:	e59f01b0 	ldr	r0, [pc, #432]	; 8c70 <getPic+0x330>
    8abc:	e3a01008 	mov	r1, #8	; 0x8
    8ac0:	ebfffd33 	bl	7f94 <SPIReceive>
					xprintf("MISO: %02x %02x %02x %02x %02x %02x %02x %02x\r\n ",
    8ac4:	e59f31a4 	ldr	r3, [pc, #420]	; 8c70 <getPic+0x330>
    8ac8:	e5d33000 	ldrb	r3, [r3]
    8acc:	e1a0c003 	mov	ip, r3
    8ad0:	e59f3198 	ldr	r3, [pc, #408]	; 8c70 <getPic+0x330>
    8ad4:	e5d33001 	ldrb	r3, [r3, #1]
    8ad8:	e1a04003 	mov	r4, r3
    8adc:	e59f318c 	ldr	r3, [pc, #396]	; 8c70 <getPic+0x330>
    8ae0:	e5d33002 	ldrb	r3, [r3, #2]
    8ae4:	e1a05003 	mov	r5, r3
    8ae8:	e59f3180 	ldr	r3, [pc, #384]	; 8c70 <getPic+0x330>
    8aec:	e5d33003 	ldrb	r3, [r3, #3]
    8af0:	e1a00003 	mov	r0, r3
    8af4:	e59f3174 	ldr	r3, [pc, #372]	; 8c70 <getPic+0x330>
    8af8:	e5d33004 	ldrb	r3, [r3, #4]
    8afc:	e1a06003 	mov	r6, r3
    8b00:	e59f3168 	ldr	r3, [pc, #360]	; 8c70 <getPic+0x330>
    8b04:	e5d33005 	ldrb	r3, [r3, #5]
    8b08:	e1a02003 	mov	r2, r3
    8b0c:	e59f315c 	ldr	r3, [pc, #348]	; 8c70 <getPic+0x330>
    8b10:	e5d33006 	ldrb	r3, [r3, #6]
    8b14:	e1a01003 	mov	r1, r3
    8b18:	e59f3150 	ldr	r3, [pc, #336]	; 8c70 <getPic+0x330>
    8b1c:	e5d33007 	ldrb	r3, [r3, #7]
    8b20:	e58d0000 	str	r0, [sp]
    8b24:	e58d6004 	str	r6, [sp, #4]
    8b28:	e58d2008 	str	r2, [sp, #8]
    8b2c:	e58d100c 	str	r1, [sp, #12]
    8b30:	e58d3010 	str	r3, [sp, #16]
    8b34:	e59f0138 	ldr	r0, [pc, #312]	; 8c74 <getPic+0x334>
    8b38:	e1a0100c 	mov	r1, ip
    8b3c:	e1a02004 	mov	r2, r4
    8b40:	e1a03005 	mov	r3, r5
    8b44:	ebffdeb5 	bl	620 <xprintf>
							SPIRDData[0], SPIRDData[1], SPIRDData[2], SPIRDData[3],
							SPIRDData[4], SPIRDData[5], SPIRDData[6], SPIRDData[7]);
					for(j=0; j<4; j++) {
    8b48:	e3a03000 	mov	r3, #0	; 0x0
    8b4c:	e50b3024 	str	r3, [fp, #-36]
    8b50:	ea000015 	b	8bac <getPic+0x26c>
						if((j!=3 && SPIRDData[j] != 0xff) ||
    8b54:	e51b3024 	ldr	r3, [fp, #-36]
    8b58:	e3530003 	cmp	r3, #3	; 0x3
    8b5c:	0a000004 	beq	8b74 <getPic+0x234>
    8b60:	e51b3024 	ldr	r3, [fp, #-36]
    8b64:	e59f2104 	ldr	r2, [pc, #260]	; 8c70 <getPic+0x330>
    8b68:	e7d23003 	ldrb	r3, [r2, r3]
    8b6c:	e35300ff 	cmp	r3, #255	; 0xff
    8b70:	1a000007 	bne	8b94 <getPic+0x254>
    8b74:	e51b3024 	ldr	r3, [fp, #-36]
    8b78:	e3530003 	cmp	r3, #3	; 0x3
    8b7c:	1a000007 	bne	8ba0 <getPic+0x260>
    8b80:	e51b3024 	ldr	r3, [fp, #-36]
    8b84:	e59f20e4 	ldr	r2, [pc, #228]	; 8c70 <getPic+0x330>
    8b88:	e7d23003 	ldrb	r3, [r2, r3]
    8b8c:	e353000a 	cmp	r3, #10	; 0xa
    8b90:	0a000002 	beq	8ba0 <getPic+0x260>
						   (j==3 && SPIRDData[j] != 0x0A) ) {
							xprintf("Expected FFFFFF0A... \n");
    8b94:	e59f00e0 	ldr	r0, [pc, #224]	; 8c7c <getPic+0x33c>
    8b98:	ebffdea0 	bl	620 <xprintf>
    8b9c:	ea000005 	b	8bb8 <getPic+0x278>
					xprintf("ack getPic was received\n");
					SPIReceive(SPIRDData, 8);
					xprintf("MISO: %02x %02x %02x %02x %02x %02x %02x %02x\r\n ",
							SPIRDData[0], SPIRDData[1], SPIRDData[2], SPIRDData[3],
							SPIRDData[4], SPIRDData[5], SPIRDData[6], SPIRDData[7]);
					for(j=0; j<4; j++) {
    8ba0:	e51b3024 	ldr	r3, [fp, #-36]
    8ba4:	e2833001 	add	r3, r3, #1	; 0x1
    8ba8:	e50b3024 	str	r3, [fp, #-36]
    8bac:	e51b3024 	ldr	r3, [fp, #-36]
    8bb0:	e3530003 	cmp	r3, #3	; 0x3
    8bb4:	daffffe6 	ble	8b54 <getPic+0x214>
						   (j==3 && SPIRDData[j] != 0x0A) ) {
							xprintf("Expected FFFFFF0A... \n");
							break;
						}
					}
					if(j==4) {
    8bb8:	e51b3024 	ldr	r3, [fp, #-36]
    8bbc:	e3530004 	cmp	r3, #4	; 0x4
    8bc0:	1a000013 	bne	8c14 <getPic+0x2d4>
						xprintf("Data size: %d\r\n",
    8bc4:	e59f30a4 	ldr	r3, [pc, #164]	; 8c70 <getPic+0x330>
    8bc8:	e5d33005 	ldrb	r3, [r3, #5]
    8bcc:	e1a02003 	mov	r2, r3
    8bd0:	e59f3098 	ldr	r3, [pc, #152]	; 8c70 <getPic+0x330>
    8bd4:	e5d33006 	ldrb	r3, [r3, #6]
    8bd8:	e1a03403 	lsl	r3, r3, #8
    8bdc:	e0822003 	add	r2, r2, r3
    8be0:	e59f3088 	ldr	r3, [pc, #136]	; 8c70 <getPic+0x330>
    8be4:	e5d33007 	ldrb	r3, [r3, #7]
    8be8:	e1a03803 	lsl	r3, r3, #16
    8bec:	e0823003 	add	r3, r2, r3
    8bf0:	e50b3020 	str	r3, [fp, #-32]
    8bf4:	e59f0084 	ldr	r0, [pc, #132]	; 8c80 <getPic+0x340>
    8bf8:	e51b1020 	ldr	r1, [fp, #-32]
    8bfc:	ebffde87 	bl	620 <xprintf>
								imgsz = (SPIRDData[5] + (SPIRDData[6]<<8) + (SPIRDData[7]<<16)));
						SPIReceive(imagebuf, imgsz);
    8c00:	e51b3020 	ldr	r3, [fp, #-32]
    8c04:	e51b001c 	ldr	r0, [fp, #-28]
    8c08:	e1a01003 	mov	r1, r3
    8c0c:	ebfffce0 	bl	7f94 <SPIReceive>
    8c10:	ea000009 	b	8c3c <getPic+0x2fc>
//    BYTE *imagebuf = (BYTE*)0x40004000;	// ON-CHIP SRAM area starting address (used for image buffer)

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
	IOPIN0 &= ~0x1000000;	// drive CS low

	    while(i++ != 30)
    8c14:	e51b3028 	ldr	r3, [fp, #-40]
    8c18:	e353001e 	cmp	r3, #30	; 0x1e
    8c1c:	03a03000 	moveq	r3, #0	; 0x0
    8c20:	13a03001 	movne	r3, #1	; 0x1
    8c24:	e20320ff 	and	r2, r3, #255	; 0xff
    8c28:	e51b3028 	ldr	r3, [fp, #-40]
    8c2c:	e2833001 	add	r3, r3, #1	; 0x1
    8c30:	e50b3028 	str	r3, [fp, #-40]
    8c34:	e3520000 	cmp	r2, #0	; 0x0
    8c38:	1affff5a 	bne	89a8 <getPic+0x68>
						SPIReceive(imagebuf, imgsz);
						break;
					}
				}
	    }
		IOPIN0 |= 0x1000000;	// drive CS high
    8c3c:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    8c40:	e282290a 	add	r2, r2, #163840	; 0x28000
    8c44:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8c48:	e283390a 	add	r3, r3, #163840	; 0x28000
    8c4c:	e5933000 	ldr	r3, [r3]
    8c50:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    8c54:	e5823000 	str	r3, [r2]
		return imgsz;
    8c58:	e51b3020 	ldr	r3, [fp, #-32]
}
    8c5c:	e1a00003 	mov	r0, r3
    8c60:	e24bd018 	sub	sp, fp, #24	; 0x18
    8c64:	e89da870 	ldm	sp, {r4, r5, r6, fp, sp, pc}
    8c68:	0000970c 	.word	0x0000970c
    8c6c:	40000034 	.word	0x40000034
    8c70:	400006ea 	.word	0x400006ea
    8c74:	000095a4 	.word	0x000095a4
    8c78:	00009728 	.word	0x00009728
    8c7c:	00009744 	.word	0x00009744
    8c80:	0000975c 	.word	0x0000975c

00008c84 <stopRec>:

void stopRec(){
    8c84:	e1a0c00d 	mov	ip, sp
    8c88:	e92dd800 	push	{fp, ip, lr, pc}
    8c8c:	e24cb004 	sub	fp, ip, #4	; 0x4
	global=1;
    8c90:	e59f2008 	ldr	r2, [pc, #8]	; 8ca0 <stopRec+0x1c>
    8c94:	e3a03001 	mov	r3, #1	; 0x1
    8c98:	e5823000 	str	r3, [r2]
}
    8c9c:	e89da800 	ldm	sp, {fp, sp, pc}
    8ca0:	40000798 	.word	0x40000798

00008ca4 <setupCamera>:
void setupCamera()
{
    8ca4:	e1a0c00d 	mov	ip, sp
    8ca8:	e92dd800 	push	{fp, ip, lr, pc}
    8cac:	e24cb004 	sub	fp, ip, #4	; 0x4
	sendSync();
    8cb0:	ebfffd29 	bl	815c <sendSync>
	getInit();
    8cb4:	ebfffde8 	bl	845c <getInit>
	getImageQuality();
    8cb8:	ebfffe4d 	bl	85f4 <getImageQuality>
}
    8cbc:	e89da800 	ldm	sp, {fp, sp, pc}

00008cc0 <takePicture>:
void takePicture()
{
    8cc0:	e1a0c00d 	mov	ip, sp
    8cc4:	e92dd800 	push	{fp, ip, lr, pc}
    8cc8:	e24cb004 	sub	fp, ip, #4	; 0x4
	getSnapshot();
    8ccc:	ebfffeb2 	bl	879c <getSnapshot>
	writeToSDCard(getPic());
    8cd0:	ebffff1a 	bl	8940 <getPic>
    8cd4:	e1a03000 	mov	r3, r0
    8cd8:	e1a00003 	mov	r0, r3
    8cdc:	ebfffbe4 	bl	7c74 <writeToSDCard>
	closeFile();
    8ce0:	ebfffc1b 	bl	7d54 <closeFile>
}
    8ce4:	e89da800 	ldm	sp, {fp, sp, pc}

00008ce8 <record>:

void record()
{
    8ce8:	e1a0c00d 	mov	ip, sp
    8cec:	e92dd800 	push	{fp, ip, lr, pc}
    8cf0:	e24cb004 	sub	fp, ip, #4	; 0x4
    8cf4:	ea000004 	b	8d0c <record+0x24>
	while(global!=1)
	{
		getSnapshot();
    8cf8:	ebfffea7 	bl	879c <getSnapshot>
		writeToSDCard(getPic());
    8cfc:	ebffff0f 	bl	8940 <getPic>
    8d00:	e1a03000 	mov	r3, r0
    8d04:	e1a00003 	mov	r0, r3
    8d08:	ebfffbd9 	bl	7c74 <writeToSDCard>
	closeFile();
}

void record()
{
	while(global!=1)
    8d0c:	e59f301c 	ldr	r3, [pc, #28]	; 8d30 <record+0x48>
    8d10:	e5933000 	ldr	r3, [r3]
    8d14:	e3530001 	cmp	r3, #1	; 0x1
    8d18:	1afffff6 	bne	8cf8 <record+0x10>
	{
		getSnapshot();
		writeToSDCard(getPic());
	}
	global=0;
    8d1c:	e59f200c 	ldr	r2, [pc, #12]	; 8d30 <record+0x48>
    8d20:	e3a03000 	mov	r3, #0	; 0x0
    8d24:	e5823000 	str	r3, [r2]
	closeFile();
    8d28:	ebfffc09 	bl	7d54 <closeFile>
}
    8d2c:	e89da800 	ldm	sp, {fp, sp, pc}
    8d30:	40000798 	.word	0x40000798

00008d34 <EINT3_Handler>:
** parameters:			None
** Returned value:		None
** 
*****************************************************************************/
void EINT3_Handler (void)
{
    8d34:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
    8d38:	e1a0c00d 	mov	ip, sp
    8d3c:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
    8d40:	e24cb004 	sub	fp, ip, #4	; 0x4
    8d44:	e24dd010 	sub	sp, sp, #16	; 0x10
	EXTINT = EINT3;		/* clear interrupt */
    8d48:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8d4c:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    8d50:	e2833d05 	add	r3, r3, #320	; 0x140
    8d54:	e3a02008 	mov	r2, #8	; 0x8
    8d58:	e5832000 	str	r2, [r3]
	IO0_INT_CLR |= 15<<6;
    8d5c:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    8d60:	e282290a 	add	r2, r2, #163840	; 0x28000
    8d64:	e282208c 	add	r2, r2, #140	; 0x8c
    8d68:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8d6c:	e283390a 	add	r3, r3, #163840	; 0x28000
    8d70:	e283308c 	add	r3, r3, #140	; 0x8c
    8d74:	e5933000 	ldr	r3, [r3]
    8d78:	e3833d0f 	orr	r3, r3, #960	; 0x3c0
    8d7c:	e5823000 	str	r3, [r2]
	int d0, d1, d2, d3;
	d0 = (IO0PIN >>6)&1;
    8d80:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8d84:	e283390a 	add	r3, r3, #163840	; 0x28000
    8d88:	e5933000 	ldr	r3, [r3]
    8d8c:	e1a03323 	lsr	r3, r3, #6
    8d90:	e2033001 	and	r3, r3, #1	; 0x1
    8d94:	e50b302c 	str	r3, [fp, #-44]
	d1 = (IO0PIN >>7)&1;
    8d98:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8d9c:	e283390a 	add	r3, r3, #163840	; 0x28000
    8da0:	e5933000 	ldr	r3, [r3]
    8da4:	e1a033a3 	lsr	r3, r3, #7
    8da8:	e2033001 	and	r3, r3, #1	; 0x1
    8dac:	e50b3028 	str	r3, [fp, #-40]
	d2 = (IO0PIN >>8)&1;
    8db0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8db4:	e283390a 	add	r3, r3, #163840	; 0x28000
    8db8:	e5933000 	ldr	r3, [r3]
    8dbc:	e1a03423 	lsr	r3, r3, #8
    8dc0:	e2033001 	and	r3, r3, #1	; 0x1
    8dc4:	e50b3024 	str	r3, [fp, #-36]
	d3 = (IO0PIN >>9)&1;
    8dc8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8dcc:	e283390a 	add	r3, r3, #163840	; 0x28000
    8dd0:	e5933000 	ldr	r3, [r3]
    8dd4:	e1a034a3 	lsr	r3, r3, #9
    8dd8:	e2033001 	and	r3, r3, #1	; 0x1
    8ddc:	e50b3020 	str	r3, [fp, #-32]
	if(!d0){
    8de0:	e51b302c 	ldr	r3, [fp, #-44]
    8de4:	e3530000 	cmp	r3, #0	; 0x0
    8de8:	1a00000e 	bne	8e28 <EINT3_Handler+0xf4>
	  	uart0Puts("d0\r\n");
    8dec:	e59f0120 	ldr	r0, [pc, #288]	; 8f14 <EINT3_Handler+0x1e0>
    8df0:	ebffdf2d 	bl	aac <uart0Puts>
	  	takeSnapshot=1;
    8df4:	e59f211c 	ldr	r2, [pc, #284]	; 8f18 <EINT3_Handler+0x1e4>
    8df8:	e3a03001 	mov	r3, #1	; 0x1
    8dfc:	e5823000 	str	r3, [r2]
    8e00:	ea000005 	b	8e1c <EINT3_Handler+0xe8>
	  	while(!d0)
	  		d0 = (IO0PIN >>6)&1;
    8e04:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8e08:	e283390a 	add	r3, r3, #163840	; 0x28000
    8e0c:	e5933000 	ldr	r3, [r3]
    8e10:	e1a03323 	lsr	r3, r3, #6
    8e14:	e2033001 	and	r3, r3, #1	; 0x1
    8e18:	e50b302c 	str	r3, [fp, #-44]
	d2 = (IO0PIN >>8)&1;
	d3 = (IO0PIN >>9)&1;
	if(!d0){
	  	uart0Puts("d0\r\n");
	  	takeSnapshot=1;
	  	while(!d0)
    8e1c:	e51b302c 	ldr	r3, [fp, #-44]
    8e20:	e3530000 	cmp	r3, #0	; 0x0
    8e24:	0afffff6 	beq	8e04 <EINT3_Handler+0xd0>
	  		d0 = (IO0PIN >>6)&1;
	  	}
	if(!d1){
    8e28:	e51b3028 	ldr	r3, [fp, #-40]
    8e2c:	e3530000 	cmp	r3, #0	; 0x0
    8e30:	1a00000e 	bne	8e70 <EINT3_Handler+0x13c>
		uart0Puts("d1\r\n");
    8e34:	e59f00e0 	ldr	r0, [pc, #224]	; 8f1c <EINT3_Handler+0x1e8>
    8e38:	ebffdf1b 	bl	aac <uart0Puts>
		startRecording=1;
    8e3c:	e59f20dc 	ldr	r2, [pc, #220]	; 8f20 <EINT3_Handler+0x1ec>
    8e40:	e3a03001 	mov	r3, #1	; 0x1
    8e44:	e5823000 	str	r3, [r2]
    8e48:	ea000005 	b	8e64 <EINT3_Handler+0x130>
		while(!d1)
			d1 = (IO0PIN >>7)&1;
    8e4c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8e50:	e283390a 	add	r3, r3, #163840	; 0x28000
    8e54:	e5933000 	ldr	r3, [r3]
    8e58:	e1a033a3 	lsr	r3, r3, #7
    8e5c:	e2033001 	and	r3, r3, #1	; 0x1
    8e60:	e50b3028 	str	r3, [fp, #-40]
	  		d0 = (IO0PIN >>6)&1;
	  	}
	if(!d1){
		uart0Puts("d1\r\n");
		startRecording=1;
		while(!d1)
    8e64:	e51b3028 	ldr	r3, [fp, #-40]
    8e68:	e3530000 	cmp	r3, #0	; 0x0
    8e6c:	0afffff6 	beq	8e4c <EINT3_Handler+0x118>
			d1 = (IO0PIN >>7)&1;
	}
	if(!d2){
    8e70:	e51b3024 	ldr	r3, [fp, #-36]
    8e74:	e3530000 	cmp	r3, #0	; 0x0
    8e78:	1a00000e 	bne	8eb8 <EINT3_Handler+0x184>
		stopRecording=1;
    8e7c:	e59f20a0 	ldr	r2, [pc, #160]	; 8f24 <EINT3_Handler+0x1f0>
    8e80:	e3a03001 	mov	r3, #1	; 0x1
    8e84:	e5823000 	str	r3, [r2]
		uart0Puts("d2\r\n");
    8e88:	e59f0098 	ldr	r0, [pc, #152]	; 8f28 <EINT3_Handler+0x1f4>
    8e8c:	ebffdf06 	bl	aac <uart0Puts>
    8e90:	ea000005 	b	8eac <EINT3_Handler+0x178>
		while(!d2)
			d2 = (IO0PIN >>8)&1;
    8e94:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8e98:	e283390a 	add	r3, r3, #163840	; 0x28000
    8e9c:	e5933000 	ldr	r3, [r3]
    8ea0:	e1a03423 	lsr	r3, r3, #8
    8ea4:	e2033001 	and	r3, r3, #1	; 0x1
    8ea8:	e50b3024 	str	r3, [fp, #-36]
			d1 = (IO0PIN >>7)&1;
	}
	if(!d2){
		stopRecording=1;
		uart0Puts("d2\r\n");
		while(!d2)
    8eac:	e51b3024 	ldr	r3, [fp, #-36]
    8eb0:	e3530000 	cmp	r3, #0	; 0x0
    8eb4:	0afffff6 	beq	8e94 <EINT3_Handler+0x160>
			d2 = (IO0PIN >>8)&1;
	}
	if(!d3){
    8eb8:	e51b3020 	ldr	r3, [fp, #-32]
    8ebc:	e3530000 	cmp	r3, #0	; 0x0
    8ec0:	1a00000b 	bne	8ef4 <EINT3_Handler+0x1c0>
		uart0Puts("d3\r\n");
    8ec4:	e59f0060 	ldr	r0, [pc, #96]	; 8f2c <EINT3_Handler+0x1f8>
    8ec8:	ebffdef7 	bl	aac <uart0Puts>
    8ecc:	ea000005 	b	8ee8 <EINT3_Handler+0x1b4>
		while(!d3)
			d3 = (IO0PIN >>9)&1;
    8ed0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8ed4:	e283390a 	add	r3, r3, #163840	; 0x28000
    8ed8:	e5933000 	ldr	r3, [r3]
    8edc:	e1a034a3 	lsr	r3, r3, #9
    8ee0:	e2033001 	and	r3, r3, #1	; 0x1
    8ee4:	e50b3020 	str	r3, [fp, #-32]
		while(!d2)
			d2 = (IO0PIN >>8)&1;
	}
	if(!d3){
		uart0Puts("d3\r\n");
		while(!d3)
    8ee8:	e51b3020 	ldr	r3, [fp, #-32]
    8eec:	e3530000 	cmp	r3, #0	; 0x0
    8ef0:	0afffff6 	beq	8ed0 <EINT3_Handler+0x19c>
			d3 = (IO0PIN >>9)&1;
	}
    disable_interrupt();
    8ef4:	eb00000d 	bl	8f30 <disable_interrupt>
    VICVectAddr = 0;		/* Acknowledge Interrupt */
    8ef8:	e3e020ff 	mvn	r2, #255	; 0xff
    8efc:	e3a03000 	mov	r3, #0	; 0x0
    8f00:	e5823000 	str	r3, [r2]
}
    8f04:	e24bd01c 	sub	sp, fp, #28	; 0x1c
    8f08:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
    8f0c:	e8bd1000 	pop	{ip}
    8f10:	e25ef004 	subs	pc, lr, #4	; 0x4
    8f14:	0000976c 	.word	0x0000976c
    8f18:	400006f4 	.word	0x400006f4
    8f1c:	00009774 	.word	0x00009774
    8f20:	400006f8 	.word	0x400006f8
    8f24:	400006fc 	.word	0x400006fc
    8f28:	0000977c 	.word	0x0000977c
    8f2c:	00009784 	.word	0x00009784

00008f30 <disable_interrupt>:
	__set_CPSR(temp & ~0xC0);
}

/* Disable interrupts and save CPSR */
static inline uint32_t disable_interrupt(void)
{
    8f30:	e1a0c00d 	mov	ip, sp
    8f34:	e92dd800 	push	{fp, ip, lr, pc}
    8f38:	e24cb004 	sub	fp, ip, #4	; 0x4
    8f3c:	e24dd004 	sub	sp, sp, #4	; 0x4
	uint32_t temp;
	temp = __get_CPSR();
    8f40:	eb000008 	bl	8f68 <__get_CPSR>
    8f44:	e1a03000 	mov	r3, r0
    8f48:	e50b3010 	str	r3, [fp, #-16]
	__set_CPSR(temp | 0xC0);
    8f4c:	e51b3010 	ldr	r3, [fp, #-16]
    8f50:	e38330c0 	orr	r3, r3, #192	; 0xc0
    8f54:	e1a00003 	mov	r0, r3
    8f58:	eb00000b 	bl	8f8c <__set_CPSR>
	return temp;
    8f5c:	e51b3010 	ldr	r3, [fp, #-16]
}
    8f60:	e1a00003 	mov	r0, r3
    8f64:	e89da808 	ldm	sp, {r3, fp, sp, pc}

00008f68 <__get_CPSR>:
#include <stdint.h>
//#include "inttypes.h"

#ifndef __thumb
static inline uint32_t __get_CPSR(void)
{
    8f68:	e1a0c00d 	mov	ip, sp
    8f6c:	e92dd800 	push	{fp, ip, lr, pc}
    8f70:	e24cb004 	sub	fp, ip, #4	; 0x4
    8f74:	e24dd004 	sub	sp, sp, #4	; 0x4
	uint32_t temp;
	asm volatile ("mrs %0,CPSR":"=r" (temp):) ;
    8f78:	e10f3000 	mrs	r3, CPSR
    8f7c:	e50b3010 	str	r3, [fp, #-16]
	return temp;
    8f80:	e51b3010 	ldr	r3, [fp, #-16]
}
    8f84:	e1a00003 	mov	r0, r3
    8f88:	e89da808 	ldm	sp, {r3, fp, sp, pc}

00008f8c <__set_CPSR>:

static inline void __set_CPSR(uint32_t save_cpsr)
{
    8f8c:	e1a0c00d 	mov	ip, sp
    8f90:	e92dd800 	push	{fp, ip, lr, pc}
    8f94:	e24cb004 	sub	fp, ip, #4	; 0x4
    8f98:	e24dd004 	sub	sp, sp, #4	; 0x4
    8f9c:	e50b0010 	str	r0, [fp, #-16]
	asm volatile (" msr CPSR_cxsf,%0"::"r"(save_cpsr) );
    8fa0:	e51b3010 	ldr	r3, [fp, #-16]
    8fa4:	e12ff003 	msr	CPSR_fsxc, r3
}
    8fa8:	e89da808 	ldm	sp, {r3, fp, sp, pc}

00008fac <EINTInit>:
** 
*****************************************************************************/
#define IO0DIR (*(volatile unsigned long *)0xE0028008)
#define IO0PIN (*(volatile unsigned long *)0xE0028000)
DWORD EINTInit( void )
{
    8fac:	e1a0c00d 	mov	ip, sp
    8fb0:	e92dd800 	push	{fp, ip, lr, pc}
    8fb4:	e24cb004 	sub	fp, ip, #4	; 0x4
    8fb8:	e24dd004 	sub	sp, sp, #4	; 0x4
	PINSEL0 &= 0xFFF00FFF;
    8fbc:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    8fc0:	e282290b 	add	r2, r2, #180224	; 0x2c000
    8fc4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    8fc8:	e283390b 	add	r3, r3, #180224	; 0x2c000
    8fcc:	e5933000 	ldr	r3, [r3]
    8fd0:	e3c33aff 	bic	r3, r3, #1044480	; 0xff000
    8fd4:	e5823000 	str	r3, [r2]
    IO0DIR &= 0xFFF00FFF;				/* input */
    8fd8:	e3a0228e 	mov	r2, #-536870904	; 0xe0000008
    8fdc:	e282290a 	add	r2, r2, #163840	; 0x28000
    8fe0:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
    8fe4:	e283390a 	add	r3, r3, #163840	; 0x28000
    8fe8:	e5933000 	ldr	r3, [r3]
    8fec:	e3c33aff 	bic	r3, r3, #1044480	; 0xff000
    8ff0:	e5823000 	str	r3, [r2]
    SCS&=~1;
    8ff4:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    8ff8:	e282297f 	add	r2, r2, #2080768	; 0x1fc000
    8ffc:	e2822e1a 	add	r2, r2, #416	; 0x1a0
    9000:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    9004:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    9008:	e2833e1a 	add	r3, r3, #416	; 0x1a0
    900c:	e5933000 	ldr	r3, [r3]
    9010:	e3c33001 	bic	r3, r3, #1	; 0x1
    9014:	e5823000 	str	r3, [r2]
    EXTMODE = EINT3_EDGE;		/* INT1 edge trigger */
    9018:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    901c:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    9020:	e2833f52 	add	r3, r3, #328	; 0x148
    9024:	e3a02008 	mov	r2, #8	; 0x8
    9028:	e5832000 	str	r2, [r3]
    EXTPOLAR = 0;			/* INT1 is falling edge by default */
    902c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    9030:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    9034:	e2833f53 	add	r3, r3, #332	; 0x14c
    9038:	e3a02000 	mov	r2, #0	; 0x0
    903c:	e5832000 	str	r2, [r3]


    if ( install_irq( EINT3_INT, (void *)EINT3_Handler, MID_PRIORITY) == FALSE )
    9040:	e3a00011 	mov	r0, #17	; 0x11
    9044:	e59f1054 	ldr	r1, [pc, #84]	; 90a0 <EINTInit+0xf4>
    9048:	e3a02004 	mov	r2, #4	; 0x4
    904c:	ebffdecc 	bl	b84 <install_irq>
    9050:	e1a03000 	mov	r3, r0
    9054:	e3530000 	cmp	r3, #0	; 0x0
    9058:	1a000002 	bne	9068 <EINTInit+0xbc>
    {
	return (FALSE);
    905c:	e3a03000 	mov	r3, #0	; 0x0
    9060:	e50b3010 	str	r3, [fp, #-16]
    9064:	ea00000a 	b	9094 <EINTInit+0xe8>
    }
    IO0_INT_EN_F  |= 15<<6;		/*set falling edge*/
    9068:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    906c:	e282290a 	add	r2, r2, #163840	; 0x28000
    9070:	e2822094 	add	r2, r2, #148	; 0x94
    9074:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    9078:	e283390a 	add	r3, r3, #163840	; 0x28000
    907c:	e2833094 	add	r3, r3, #148	; 0x94
    9080:	e5933000 	ldr	r3, [r3]
    9084:	e3833d0f 	orr	r3, r3, #960	; 0x3c0
    9088:	e5823000 	str	r3, [r2]
    return( TRUE );
    908c:	e3a03001 	mov	r3, #1	; 0x1
    9090:	e50b3010 	str	r3, [fp, #-16]
    9094:	e51b3010 	ldr	r3, [fp, #-16]
}
    9098:	e1a00003 	mov	r0, r3
    909c:	e89da808 	ldm	sp, {r3, fp, sp, pc}
    90a0:	00008d34 	.word	0x00008d34

000090a4 <memcmp>:
    90a4:	e3520003 	cmp	r2, #3	; 0x3
    90a8:	e92d0070 	push	{r4, r5, r6}
    90ac:	e1a04002 	mov	r4, r2
    90b0:	e1a06000 	mov	r6, r0
    90b4:	e1a05001 	mov	r5, r1
    90b8:	9a00001f 	bls	913c <memcmp+0x98>
    90bc:	e1813000 	orr	r3, r1, r0
    90c0:	e3130003 	tst	r3, #3	; 0x3
    90c4:	0a000011 	beq	9110 <memcmp+0x6c>
    90c8:	e5d6c000 	ldrb	ip, [r6]
    90cc:	e5d50000 	ldrb	r0, [r5]
    90d0:	e15c0000 	cmp	ip, r0
    90d4:	02442001 	subeq	r2, r4, #1	; 0x1
    90d8:	01a03006 	moveq	r3, r6
    90dc:	01a01005 	moveq	r1, r5
    90e0:	0a000004 	beq	90f8 <memcmp+0x54>
    90e4:	ea000017 	b	9148 <memcmp+0xa4>
    90e8:	e5f3c001 	ldrb	ip, [r3, #1]!
    90ec:	e5f10001 	ldrb	r0, [r1, #1]!
    90f0:	e15c0000 	cmp	ip, r0
    90f4:	1a000013 	bne	9148 <memcmp+0xa4>
    90f8:	e3520000 	cmp	r2, #0	; 0x0
    90fc:	e2422001 	sub	r2, r2, #1	; 0x1
    9100:	1afffff8 	bne	90e8 <memcmp+0x44>
    9104:	e3a00000 	mov	r0, #0	; 0x0
    9108:	e8bd0070 	pop	{r4, r5, r6}
    910c:	e12fff1e 	bx	lr
    9110:	e5902000 	ldr	r2, [r0]
    9114:	e5913000 	ldr	r3, [r1]
    9118:	e1520003 	cmp	r2, r3
    911c:	1a000004 	bne	9134 <memcmp+0x90>
    9120:	e2444004 	sub	r4, r4, #4	; 0x4
    9124:	e3540003 	cmp	r4, #3	; 0x3
    9128:	e2800004 	add	r0, r0, #4	; 0x4
    912c:	e2811004 	add	r1, r1, #4	; 0x4
    9130:	8afffff6 	bhi	9110 <memcmp+0x6c>
    9134:	e1a06000 	mov	r6, r0
    9138:	e1a05001 	mov	r5, r1
    913c:	e3540000 	cmp	r4, #0	; 0x0
    9140:	1affffe0 	bne	90c8 <memcmp+0x24>
    9144:	eaffffee 	b	9104 <memcmp+0x60>
    9148:	e060000c 	rsb	r0, r0, ip
    914c:	eaffffed 	b	9108 <memcmp+0x64>

00009150 <memcpy>:
    9150:	e92d0070 	push	{r4, r5, r6}
    9154:	e352000f 	cmp	r2, #15	; 0xf
    9158:	e1a04002 	mov	r4, r2
    915c:	e1a05001 	mov	r5, r1
    9160:	e1a02001 	mov	r2, r1
    9164:	e1a06000 	mov	r6, r0
    9168:	e1a01004 	mov	r1, r4
    916c:	9a000002 	bls	917c <memcpy+0x2c>
    9170:	e1853006 	orr	r3, r5, r6
    9174:	e3130003 	tst	r3, #3	; 0x3
    9178:	0a00000a 	beq	91a8 <memcpy+0x58>
    917c:	e3510000 	cmp	r1, #0	; 0x0
    9180:	0a000005 	beq	919c <memcpy+0x4c>
    9184:	e3a0c000 	mov	ip, #0	; 0x0
    9188:	e7d2300c 	ldrb	r3, [r2, ip]
    918c:	e7c0300c 	strb	r3, [r0, ip]
    9190:	e28cc001 	add	ip, ip, #1	; 0x1
    9194:	e15c0001 	cmp	ip, r1
    9198:	1afffffa 	bne	9188 <memcpy+0x38>
    919c:	e1a00006 	mov	r0, r6
    91a0:	e8bd0070 	pop	{r4, r5, r6}
    91a4:	e12fff1e 	bx	lr
    91a8:	e1a01006 	mov	r1, r6
    91ac:	e1a0c005 	mov	ip, r5
    91b0:	e1a00004 	mov	r0, r4
    91b4:	e59c3000 	ldr	r3, [ip]
    91b8:	e5813000 	str	r3, [r1]
    91bc:	e59c2004 	ldr	r2, [ip, #4]
    91c0:	e5812004 	str	r2, [r1, #4]
    91c4:	e59c3008 	ldr	r3, [ip, #8]
    91c8:	e5813008 	str	r3, [r1, #8]
    91cc:	e2400010 	sub	r0, r0, #16	; 0x10
    91d0:	e59c300c 	ldr	r3, [ip, #12]
    91d4:	e350000f 	cmp	r0, #15	; 0xf
    91d8:	e581300c 	str	r3, [r1, #12]
    91dc:	e28cc010 	add	ip, ip, #16	; 0x10
    91e0:	e2811010 	add	r1, r1, #16	; 0x10
    91e4:	8afffff2 	bhi	91b4 <memcpy+0x64>
    91e8:	e2442010 	sub	r2, r4, #16	; 0x10
    91ec:	e1a03222 	lsr	r3, r2, #4
    91f0:	e0421203 	sub	r1, r2, r3, lsl #4
    91f4:	e2833001 	add	r3, r3, #1	; 0x1
    91f8:	e1a03203 	lsl	r3, r3, #4
    91fc:	e3510003 	cmp	r1, #3	; 0x3
    9200:	e0854003 	add	r4, r5, r3
    9204:	e0860003 	add	r0, r6, r3
    9208:	9a00000d 	bls	9244 <memcpy+0xf4>
    920c:	e3a0c000 	mov	ip, #0	; 0x0
    9210:	e794300c 	ldr	r3, [r4, ip]
    9214:	e780300c 	str	r3, [r0, ip]
    9218:	e28cc004 	add	ip, ip, #4	; 0x4
    921c:	e06c3001 	rsb	r3, ip, r1
    9220:	e3530003 	cmp	r3, #3	; 0x3
    9224:	8afffff9 	bhi	9210 <memcpy+0xc0>
    9228:	e2411004 	sub	r1, r1, #4	; 0x4
    922c:	e1a02121 	lsr	r2, r1, #2
    9230:	e2823001 	add	r3, r2, #1	; 0x1
    9234:	e1a03103 	lsl	r3, r3, #2
    9238:	e0800003 	add	r0, r0, r3
    923c:	e0411102 	sub	r1, r1, r2, lsl #2
    9240:	e0844003 	add	r4, r4, r3
    9244:	e1a02004 	mov	r2, r4
    9248:	eaffffcb 	b	917c <memcpy+0x2c>

0000924c <memset>:
    924c:	e3100003 	tst	r0, #3	; 0x3
    9250:	e92d0070 	push	{r4, r5, r6}
    9254:	e1a0c000 	mov	ip, r0
    9258:	e1a05000 	mov	r5, r0
    925c:	e1a06001 	mov	r6, r1
    9260:	0a00000a 	beq	9290 <memset+0x44>
    9264:	e3520000 	cmp	r2, #0	; 0x0
    9268:	12422001 	subne	r2, r2, #1	; 0x1
    926c:	120130ff 	andne	r3, r1, #255	; 0xff
    9270:	1a000003 	bne	9284 <memset+0x38>
    9274:	ea000033 	b	9348 <memset+0xfc>
    9278:	e3520000 	cmp	r2, #0	; 0x0
    927c:	0a000031 	beq	9348 <memset+0xfc>
    9280:	e2422001 	sub	r2, r2, #1	; 0x1
    9284:	e4cc3001 	strb	r3, [ip], #1
    9288:	e31c0003 	tst	ip, #3	; 0x3
    928c:	1afffff9 	bne	9278 <memset+0x2c>
    9290:	e3520003 	cmp	r2, #3	; 0x3
    9294:	e1a01002 	mov	r1, r2
    9298:	e1a0000c 	mov	r0, ip
    929c:	9a000021 	bls	9328 <memset+0xdc>
    92a0:	e20630ff 	and	r3, r6, #255	; 0xff
    92a4:	e1833403 	orr	r3, r3, r3, lsl #8
    92a8:	e352000f 	cmp	r2, #15	; 0xf
    92ac:	e1830803 	orr	r0, r3, r3, lsl #16
    92b0:	e1a0400c 	mov	r4, ip
    92b4:	9a00000d 	bls	92f0 <memset+0xa4>
    92b8:	e1a0300c 	mov	r3, ip
    92bc:	e2411010 	sub	r1, r1, #16	; 0x10
    92c0:	e351000f 	cmp	r1, #15	; 0xf
    92c4:	e5830000 	str	r0, [r3]
    92c8:	e5830004 	str	r0, [r3, #4]
    92cc:	e5830008 	str	r0, [r3, #8]
    92d0:	e583000c 	str	r0, [r3, #12]
    92d4:	e2833010 	add	r3, r3, #16	; 0x10
    92d8:	8afffff7 	bhi	92bc <memset+0x70>
    92dc:	e2422010 	sub	r2, r2, #16	; 0x10
    92e0:	e3c2300f 	bic	r3, r2, #15	; 0xf
    92e4:	e2833010 	add	r3, r3, #16	; 0x10
    92e8:	e08c4003 	add	r4, ip, r3
    92ec:	e202100f 	and	r1, r2, #15	; 0xf
    92f0:	e3510003 	cmp	r1, #3	; 0x3
    92f4:	9a00000a 	bls	9324 <memset+0xd8>
    92f8:	e3a0c000 	mov	ip, #0	; 0x0
    92fc:	e784000c 	str	r0, [r4, ip]
    9300:	e28cc004 	add	ip, ip, #4	; 0x4
    9304:	e06c3001 	rsb	r3, ip, r1
    9308:	e3530003 	cmp	r3, #3	; 0x3
    930c:	8afffffa 	bhi	92fc <memset+0xb0>
    9310:	e2412004 	sub	r2, r1, #4	; 0x4
    9314:	e3c23003 	bic	r3, r2, #3	; 0x3
    9318:	e2833004 	add	r3, r3, #4	; 0x4
    931c:	e0844003 	add	r4, r4, r3
    9320:	e2021003 	and	r1, r2, #3	; 0x3
    9324:	e1a00004 	mov	r0, r4
    9328:	e3510000 	cmp	r1, #0	; 0x0
    932c:	0a000005 	beq	9348 <memset+0xfc>
    9330:	e20630ff 	and	r3, r6, #255	; 0xff
    9334:	e3a0c000 	mov	ip, #0	; 0x0
    9338:	e7c0300c 	strb	r3, [r0, ip]
    933c:	e28cc001 	add	ip, ip, #1	; 0x1
    9340:	e151000c 	cmp	r1, ip
    9344:	1afffffb 	bne	9338 <memset+0xec>
    9348:	e1a00005 	mov	r0, r5
    934c:	e8bd0070 	pop	{r4, r5, r6}
    9350:	e12fff1e 	bx	lr

00009354 <__aeabi_uidiv>:
    9354:	e2512001 	subs	r2, r1, #1	; 0x1
    9358:	012fff1e 	bxeq	lr
    935c:	3a000036 	bcc	943c <__aeabi_uidiv+0xe8>
    9360:	e1500001 	cmp	r0, r1
    9364:	9a000022 	bls	93f4 <__aeabi_uidiv+0xa0>
    9368:	e1110002 	tst	r1, r2
    936c:	0a000023 	beq	9400 <__aeabi_uidiv+0xac>
    9370:	e311020e 	tst	r1, #-536870912	; 0xe0000000
    9374:	01a01181 	lsleq	r1, r1, #3
    9378:	03a03008 	moveq	r3, #8	; 0x8
    937c:	13a03001 	movne	r3, #1	; 0x1
    9380:	e3510201 	cmp	r1, #268435456	; 0x10000000
    9384:	31510000 	cmpcc	r1, r0
    9388:	31a01201 	lslcc	r1, r1, #4
    938c:	31a03203 	lslcc	r3, r3, #4
    9390:	3afffffa 	bcc	9380 <__aeabi_uidiv+0x2c>
    9394:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    9398:	31510000 	cmpcc	r1, r0
    939c:	31a01081 	lslcc	r1, r1, #1
    93a0:	31a03083 	lslcc	r3, r3, #1
    93a4:	3afffffa 	bcc	9394 <__aeabi_uidiv+0x40>
    93a8:	e3a02000 	mov	r2, #0	; 0x0
    93ac:	e1500001 	cmp	r0, r1
    93b0:	20400001 	subcs	r0, r0, r1
    93b4:	21822003 	orrcs	r2, r2, r3
    93b8:	e15000a1 	cmp	r0, r1, lsr #1
    93bc:	204000a1 	subcs	r0, r0, r1, lsr #1
    93c0:	218220a3 	orrcs	r2, r2, r3, lsr #1
    93c4:	e1500121 	cmp	r0, r1, lsr #2
    93c8:	20400121 	subcs	r0, r0, r1, lsr #2
    93cc:	21822123 	orrcs	r2, r2, r3, lsr #2
    93d0:	e15001a1 	cmp	r0, r1, lsr #3
    93d4:	204001a1 	subcs	r0, r0, r1, lsr #3
    93d8:	218221a3 	orrcs	r2, r2, r3, lsr #3
    93dc:	e3500000 	cmp	r0, #0	; 0x0
    93e0:	11b03223 	lsrsne	r3, r3, #4
    93e4:	11a01221 	lsrne	r1, r1, #4
    93e8:	1affffef 	bne	93ac <__aeabi_uidiv+0x58>
    93ec:	e1a00002 	mov	r0, r2
    93f0:	e12fff1e 	bx	lr
    93f4:	03a00001 	moveq	r0, #1	; 0x1
    93f8:	13a00000 	movne	r0, #0	; 0x0
    93fc:	e12fff1e 	bx	lr
    9400:	e3510801 	cmp	r1, #65536	; 0x10000
    9404:	21a01821 	lsrcs	r1, r1, #16
    9408:	23a02010 	movcs	r2, #16	; 0x10
    940c:	33a02000 	movcc	r2, #0	; 0x0
    9410:	e3510c01 	cmp	r1, #256	; 0x100
    9414:	21a01421 	lsrcs	r1, r1, #8
    9418:	22822008 	addcs	r2, r2, #8	; 0x8
    941c:	e3510010 	cmp	r1, #16	; 0x10
    9420:	21a01221 	lsrcs	r1, r1, #4
    9424:	22822004 	addcs	r2, r2, #4	; 0x4
    9428:	e3510004 	cmp	r1, #4	; 0x4
    942c:	82822003 	addhi	r2, r2, #3	; 0x3
    9430:	908220a1 	addls	r2, r2, r1, lsr #1
    9434:	e1a00230 	lsr	r0, r0, r2
    9438:	e12fff1e 	bx	lr
    943c:	e52de008 	str	lr, [sp, #-8]!
    9440:	eb00003a 	bl	9530 <__aeabi_idiv0>
    9444:	e3a00000 	mov	r0, #0	; 0x0
    9448:	e49df008 	ldr	pc, [sp], #8

0000944c <__aeabi_uidivmod>:
    944c:	e92d4003 	push	{r0, r1, lr}
    9450:	ebffffbf 	bl	9354 <__aeabi_uidiv>
    9454:	e8bd4006 	pop	{r1, r2, lr}
    9458:	e0030092 	mul	r3, r2, r0
    945c:	e0411003 	sub	r1, r1, r3
    9460:	e12fff1e 	bx	lr

00009464 <__umodsi3>:
    9464:	e2512001 	subs	r2, r1, #1	; 0x1
    9468:	3a00002c 	bcc	9520 <__umodsi3+0xbc>
    946c:	11500001 	cmpne	r0, r1
    9470:	03a00000 	moveq	r0, #0	; 0x0
    9474:	81110002 	tsthi	r1, r2
    9478:	00000002 	andeq	r0, r0, r2
    947c:	912fff1e 	bxls	lr
    9480:	e3a02000 	mov	r2, #0	; 0x0
    9484:	e3510201 	cmp	r1, #268435456	; 0x10000000
    9488:	31510000 	cmpcc	r1, r0
    948c:	31a01201 	lslcc	r1, r1, #4
    9490:	32822004 	addcc	r2, r2, #4	; 0x4
    9494:	3afffffa 	bcc	9484 <__umodsi3+0x20>
    9498:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    949c:	31510000 	cmpcc	r1, r0
    94a0:	31a01081 	lslcc	r1, r1, #1
    94a4:	32822001 	addcc	r2, r2, #1	; 0x1
    94a8:	3afffffa 	bcc	9498 <__umodsi3+0x34>
    94ac:	e2522003 	subs	r2, r2, #3	; 0x3
    94b0:	ba00000e 	blt	94f0 <__umodsi3+0x8c>
    94b4:	e1500001 	cmp	r0, r1
    94b8:	20400001 	subcs	r0, r0, r1
    94bc:	e15000a1 	cmp	r0, r1, lsr #1
    94c0:	204000a1 	subcs	r0, r0, r1, lsr #1
    94c4:	e1500121 	cmp	r0, r1, lsr #2
    94c8:	20400121 	subcs	r0, r0, r1, lsr #2
    94cc:	e15001a1 	cmp	r0, r1, lsr #3
    94d0:	204001a1 	subcs	r0, r0, r1, lsr #3
    94d4:	e3500001 	cmp	r0, #1	; 0x1
    94d8:	e1a01221 	lsr	r1, r1, #4
    94dc:	a2522004 	subsge	r2, r2, #4	; 0x4
    94e0:	aafffff3 	bge	94b4 <__umodsi3+0x50>
    94e4:	e3120003 	tst	r2, #3	; 0x3
    94e8:	13300000 	teqne	r0, #0	; 0x0
    94ec:	0a00000a 	beq	951c <__umodsi3+0xb8>
    94f0:	e3720002 	cmn	r2, #2	; 0x2
    94f4:	ba000006 	blt	9514 <__umodsi3+0xb0>
    94f8:	0a000002 	beq	9508 <__umodsi3+0xa4>
    94fc:	e1500001 	cmp	r0, r1
    9500:	20400001 	subcs	r0, r0, r1
    9504:	e1a010a1 	lsr	r1, r1, #1
    9508:	e1500001 	cmp	r0, r1
    950c:	20400001 	subcs	r0, r0, r1
    9510:	e1a010a1 	lsr	r1, r1, #1
    9514:	e1500001 	cmp	r0, r1
    9518:	20400001 	subcs	r0, r0, r1
    951c:	e12fff1e 	bx	lr
    9520:	e52de008 	str	lr, [sp, #-8]!
    9524:	eb000001 	bl	9530 <__aeabi_idiv0>
    9528:	e3a00000 	mov	r0, #0	; 0x0
    952c:	e49df008 	ldr	pc, [sp], #8

00009530 <__aeabi_idiv0>:
    9530:	e12fff1e 	bx	lr
    9534:	00544146 	subseq	r4, r4, r6, asr #2
    9538:	33544146 	cmpcc	r4, #-2147483631	; 0x80000011
    953c:	00000032 	andeq	r0, r0, r2, lsr r0
    9540:	4e204f4e 	cdpmi	15, 2, cr4, cr0, cr14, {2}
    9544:	20454d41 	subcs	r4, r5, r1, asr #26
    9548:	46202020 	strtmi	r2, [r0], -r0, lsr #32
    954c:	20205441 	eorcs	r5, r0, r1, asr #8
    9550:	00202020 	eoreq	r2, r0, r0, lsr #32
    9554:	4e204f4e 	cdpmi	15, 2, cr4, cr0, cr14, {2}
    9558:	20454d41 	subcs	r4, r5, r1, asr #26
    955c:	46202020 	strtmi	r2, [r0], -r0, lsr #32
    9560:	32335441 	eorscc	r5, r3, #1090519040	; 0x41000000
    9564:	00202020 	eoreq	r2, r0, r0, lsr #32
    9568:	3d63720a 	sfmcc	f7, 2, [r3, #-40]!
    956c:	46207525 	strtmi	r7, [r0], -r5, lsr #10
    9570:	73255f52 	teqvc	r5, #328	; 0x148
    9574:	00000000 	andeq	r0, r0, r0
    9578:	657a6973 	ldrbvs	r6, [sl, #-2419]!
    957c:	6e69622e 	cdpvs	2, 6, cr6, cr9, cr14, {1}
    9580:	00000000 	andeq	r0, r0, r0
    9584:	67616d69 	strbvs	r6, [r1, -r9, ror #26]!
    9588:	69622e65 	stmdbvs	r2!, {r0, r2, r5, r6, r9, sl, fp, sp}^
    958c:	0000006e 	andeq	r0, r0, lr, rrx
    9590:	434e5953 	movtmi	r5, #59731	; 0xe953
    9594:	7428203a 	strtvc	r2, [r8], #-58
    9598:	23207972 	teqcs	r0, #1867776	; 0x1c8000
    959c:	20296425 	eorcs	r6, r9, r5, lsr #8
    95a0:	00002020 	andeq	r2, r0, r0, lsr #32
    95a4:	4f53494d 	svcmi	0x0053494d
    95a8:	3025203a 	eorcc	r2, r5, sl, lsr r0
    95ac:	25207832 	strcs	r7, [r0, #-2098]!
    95b0:	20783230 	rsbscs	r3, r8, r0, lsr r2
    95b4:	78323025 	ldmdavc	r2!, {r0, r2, r5, ip, sp}
    95b8:	32302520 	eorscc	r2, r0, #134217728	; 0x8000000
    95bc:	30252078 	eorcc	r2, r5, r8, ror r0
    95c0:	25207832 	strcs	r7, [r0, #-2098]!
    95c4:	20783230 	rsbscs	r3, r8, r0, lsr r2
    95c8:	78323025 	ldmdavc	r2!, {r0, r2, r5, ip, sp}
    95cc:	32302520 	eorscc	r2, r0, #134217728	; 0x8000000
    95d0:	200a0d78 	andcs	r0, sl, r8, ror sp
    95d4:	00000000 	andeq	r0, r0, r0
    95d8:	206b6361 	rsbcs	r6, fp, r1, ror #6
    95dc:	636e7973 	cmnvs	lr, #1884160	; 0x1cc000
    95e0:	73617720 	cmnvc	r1, #8388608	; 0x800000
    95e4:	63657220 	cmnvs	r5, #2	; 0x2
    95e8:	65766965 	ldrbvs	r6, [r6, #-2405]!
    95ec:	00000a64 	andeq	r0, r0, r4, ror #20
    95f0:	65707845 	ldrbvs	r7, [r0, #-2117]!
    95f4:	64657463 	strbtvs	r7, [r5], #-1123
    95f8:	4e595320 	cdpmi	3, 5, cr5, cr9, cr0, {1}
    95fc:	67202c43 	strvs	r2, [r0, -r3, asr #24]!
    9600:	203a746f 	eorscs	r7, sl, pc, ror #8
    9604:	78323025 	ldmdavc	r2!, {r0, r2, r5, ip, sp}
    9608:	32302520 	eorscc	r2, r0, #134217728	; 0x8000000
    960c:	30252078 	eorcc	r2, r5, r8, ror r0
    9610:	25207832 	strcs	r7, [r0, #-2098]!
    9614:	20783230 	rsbscs	r3, r8, r0, lsr r2
    9618:	78323025 	ldmdavc	r2!, {r0, r2, r5, ip, sp}
    961c:	32302520 	eorscc	r2, r0, #134217728	; 0x8000000
    9620:	30252078 	eorcc	r2, r5, r8, ror r0
    9624:	25207832 	strcs	r7, [r0, #-2098]!
    9628:	0d783230 	lfmeq	f3, 2, [r8, #-192]!
    962c:	0000200a 	andeq	r2, r0, sl
    9630:	20746f47 	rsbscs	r6, r4, r7, asr #30
    9634:	434e5953 	movtmi	r5, #59731	; 0xe953
    9638:	6f726620 	svcvs	0x00726620
    963c:	6163206d 	cmnvs	r3, sp, rrx
    9640:	6172656d 	cmnvs	r2, sp, ror #10
    9644:	0000000a 	andeq	r0, r0, sl
    9648:	45534552 	ldrbmi	r4, [r3, #-1362]
    964c:	28203a54 	stmdacs	r0!, {r2, r4, r6, r9, fp, ip, sp}
    9650:	20797274 	rsbscs	r7, r9, r4, ror r2
    9654:	29642523 	stmdbcs	r4!, {r0, r1, r5, r8, sl, sp}^
    9658:	00202020 	eoreq	r2, r0, r0, lsr #32
    965c:	206b6361 	rsbcs	r6, fp, r1, ror #6
    9660:	65736572 	ldrbvs	r6, [r3, #-1394]!
    9664:	61772074 	cmnvs	r7, r4, ror r0
    9668:	65722073 	ldrbvs	r2, [r2, #-115]!
    966c:	76696563 	strbtvc	r6, [r9], -r3, ror #10
    9670:	000a6465 	andeq	r6, sl, r5, ror #8
    9674:	54494e49 	strbpl	r4, [r9], #-3657
    9678:	2020203a 	eorcs	r2, r0, sl, lsr r0
    967c:	00000000 	andeq	r0, r0, r0
    9680:	206b6361 	rsbcs	r6, fp, r1, ror #6
    9684:	656d6163 	strbvs	r6, [sp, #-355]!
    9688:	69206172 	stmdbvs	r0!, {r1, r4, r5, r6, r8, sp, lr}
    968c:	2074696e 	rsbscs	r6, r4, lr, ror #18
    9690:	20736177 	rsbscs	r6, r3, r7, ror r1
    9694:	65636572 	strbvs	r6, [r3, #-1394]!
    9698:	64657669 	strbtvs	r7, [r5], #-1641
    969c:	0000000a 	andeq	r0, r0, sl
    96a0:	47414d49 	strbmi	r4, [r1, -r9, asr #26]
    96a4:	55512045 	ldrbpl	r2, [r1, #-69]
    96a8:	54494c41 	strbpl	r4, [r9], #-3137
    96ac:	20203a59 	eorcs	r3, r0, r9, asr sl
    96b0:	00000020 	andeq	r0, r0, r0, lsr #32
    96b4:	206b6361 	rsbcs	r6, fp, r1, ror #6
    96b8:	67616d69 	strbvs	r6, [r1, -r9, ror #26]!
    96bc:	75712065 	ldrbvc	r2, [r1, #-101]!
    96c0:	74696c61 	strbtvc	r6, [r9], #-3169
    96c4:	61772079 	cmnvs	r7, r9, ror r0
    96c8:	65722073 	ldrbvs	r2, [r2, #-115]!
    96cc:	76696563 	strbtvc	r6, [r9], -r3, ror #10
    96d0:	000a6465 	andeq	r6, sl, r5, ror #8
    96d4:	20544547 	subscs	r4, r4, r7, asr #10
    96d8:	50414e53 	subpl	r4, r1, r3, asr lr
    96dc:	544f4853 	strbpl	r4, [pc], #2131	; 96e4 <__aeabi_idiv0+0x1b4>
    96e0:	7428203a 	strtvc	r2, [r8], #-58
    96e4:	23207972 	teqcs	r0, #1867776	; 0x1c8000
    96e8:	20296425 	eorcs	r6, r9, r5, lsr #8
    96ec:	00002020 	andeq	r2, r0, r0, lsr #32
    96f0:	206b6361 	rsbcs	r6, fp, r1, ror #6
    96f4:	70616e73 	rsbvc	r6, r1, r3, ror lr
    96f8:	746f6873 	strbtvc	r6, [pc], #2163	; 9700 <__aeabi_idiv0+0x1d0>
    96fc:	73617720 	cmnvc	r1, #8388608	; 0x800000
    9700:	63657220 	cmnvs	r5, #2	; 0x2
    9704:	65766965 	ldrbvs	r6, [r6, #-2405]!
    9708:	00000a64 	andeq	r0, r0, r4, ror #20
    970c:	20544547 	subscs	r4, r4, r7, asr #10
    9710:	54434950 	strbpl	r4, [r3], #-2384
    9714:	3a455255 	bcc	115e070 <__ctors_end__+0x115484c>
    9718:	72742820 	rsbsvc	r2, r4, #2097152	; 0x200000
    971c:	25232079 	strcs	r2, [r3, #-121]!
    9720:	0a202964 	beq	813cb8 <__ctors_end__+0x80a494>
    9724:	00002020 	andeq	r2, r0, r0, lsr #32
    9728:	206b6361 	rsbcs	r6, fp, r1, ror #6
    972c:	50746567 	rsbspl	r6, r4, r7, ror #10
    9730:	77206369 	strvc	r6, [r0, -r9, ror #6]!
    9734:	72207361 	eorvc	r7, r0, #-2080374783	; 0x84000001
    9738:	69656365 	stmdbvs	r5!, {r0, r2, r5, r6, r8, r9, sp, lr}^
    973c:	0a646576 	beq	1922d1c <__ctors_end__+0x19194f8>
    9740:	00000000 	andeq	r0, r0, r0
    9744:	65707845 	ldrbvs	r7, [r0, #-2117]!
    9748:	64657463 	strbtvs	r7, [r5], #-1123
    974c:	46464620 	strbmi	r4, [r6], -r0, lsr #12
    9750:	30464646 	subcc	r4, r6, r6, asr #12
    9754:	2e2e2e41 	cdpcs	14, 2, cr2, cr14, cr1, {2}
    9758:	00000a20 	andeq	r0, r0, r0, lsr #20
    975c:	61746144 	cmnvs	r4, r4, asr #2
    9760:	7a697320 	bvc	1a663e8 <__ctors_end__+0x1a5cbc4>
    9764:	25203a65 	strcs	r3, [r0, #-2661]!
    9768:	000a0d64 	andeq	r0, sl, r4, ror #26
    976c:	0a0d3064 	beq	355904 <__ctors_end__+0x34c0e0>
    9770:	00000000 	andeq	r0, r0, r0
    9774:	0a0d3164 	beq	355d0c <__ctors_end__+0x34c4e8>
    9778:	00000000 	andeq	r0, r0, r0
    977c:	0a0d3264 	beq	356114 <__ctors_end__+0x34c8f0>
    9780:	00000000 	andeq	r0, r0, r0
    9784:	0a0d3364 	beq	35651c <__ctors_end__+0x34ccf8>
    9788:	00000000 	andeq	r0, r0, r0

0000978c <str.1457>:
    978c:	4e004b4f 525f544f 59444145 5f4f4e00     OK.NOT_READY.NO_
    979c:	454c4946 5f524600 505f4f4e 00485441     FILE.FR_NO_PATH.
    97ac:	41564e49 5f44494c 454d414e 564e4900     INVALID_NAME.INV
    97bc:	44494c41 4952445f 44004556 45494e45     ALID_DRIVE.DENIE
    97cc:	58450044 00545349 455f5752 524f5252     D.EXIST.RW_ERROR
    97dc:	49525700 505f4554 45544f52 44455443     .WRITE_PROTECTED
    97ec:	544f4e00 414e455f 44454c42 5f4f4e00     .NOT_ENABLED.NO_
    97fc:	454c4946 54535953 49004d45 4c41564e     FILESYSTEM.INVAL
    980c:	4f5f4449 43454a42 4b4d0054 415f5346     ID_OBJECT.MKFS_A
    981c:	54524f42 00004445                       BORTED..
