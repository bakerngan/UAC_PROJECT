   1              		.file	"mci.c"
   9              	.Ltext0:
  10              		.section	.text.MCI_TXEnable,"ax",%progbits
  11              		.align	2
  12              		.global	MCI_TXEnable
  14              	MCI_TXEnable:
  15              	.LFB8:
  16              		.file 1 "drivers_nxp/mci.c"
   1:drivers_nxp/mci.c **** /*****************************************************************************
   2:drivers_nxp/mci.c ****  *   mci.c:  SD/MMC module file for NXP LPC23xx/24xx Family Microprocessors
   3:drivers_nxp/mci.c ****  *
   4:drivers_nxp/mci.c ****  *   Copyright(C) 2006, NXP Semiconductor
   5:drivers_nxp/mci.c ****  *   All rights reserved.
   6:drivers_nxp/mci.c ****  *
   7:drivers_nxp/mci.c ****  *   History
   8:drivers_nxp/mci.c ****  *   YYYY.MM.DD
   9:drivers_nxp/mci.c ****  *   2006.07.20  ver 1.00     Prelimnary version, first Release
  10:drivers_nxp/mci.c ****  *   2007.09.13  ver n/a      Martin Thomas (not NXP) - see below
  11:drivers_nxp/mci.c ****  *   2008.07	 ver n/a	  Lorenz Aebi (not NXP) - see below
  12:drivers_nxp/mci.c ****  *
  13:drivers_nxp/mci.c ****  *****************************************************************************
  14:drivers_nxp/mci.c ****  Software that is described herein is for illustrative purposes only which 
  15:drivers_nxp/mci.c ****  provides customers with programming information regarding the products.
  16:drivers_nxp/mci.c ****  This software is supplied "AS IS" without any warranties. NXP Semiconductors 
  17:drivers_nxp/mci.c ****  assumes no responsibility or liability for the use of the software, conveys no 
  18:drivers_nxp/mci.c ****  license or title under any patent, copyright, or mask work right to the 
  19:drivers_nxp/mci.c ****  product. NXP Semiconductors reserves the right to make changes in the 
  20:drivers_nxp/mci.c ****  software without notification. NXP Semiconductors also make no representation 
  21:drivers_nxp/mci.c ****  or warranty that such application will be suitable for the specified use 
  22:drivers_nxp/mci.c ****  without further testing or modification.
  23:drivers_nxp/mci.c ****  *****************************************************************************/
  24:drivers_nxp/mci.c **** 
  25:drivers_nxp/mci.c **** /*
  26:drivers_nxp/mci.c ****  This code has been modified and extended by
  27:drivers_nxp/mci.c ****  Martin Thomas, Kaiserslautern, Germany
  28:drivers_nxp/mci.c ****  <mthomas(at)rhrk(dot)uni-kl(dot)de>
  29:drivers_nxp/mci.c ****  http://www.siwawi.arubi.uni-kl.de/avr_projects
  30:drivers_nxp/mci.c ****  - I'm not working for NXP -
  31:drivers_nxp/mci.c **** 
  32:drivers_nxp/mci.c ****  Modifications:
  33:drivers_nxp/mci.c ****  --------------
  34:drivers_nxp/mci.c ****  - volatiles of delay-loop counters
  35:drivers_nxp/mci.c ****  - fixed retry count in Send_ACMD_OP_Cond (continue is evil ;-) )
  36:drivers_nxp/mci.c ****  - reformat source (tab/space)
  37:drivers_nxp/mci.c ****  - init MCI_CardType to unknown(when defined other then unknown
  38:drivers_nxp/mci.c ****  a repeated card-init failed)
  39:drivers_nxp/mci.c ****  - removed PINSEL kidnapping
  40:drivers_nxp/mci.c ****  Please NXP developer: a little quality control
  41:drivers_nxp/mci.c ****  will help a lot of people ot save a lot of time
  42:drivers_nxp/mci.c ****  and will make the code more reuseable.
  43:drivers_nxp/mci.c ****  - laebi: SDHC-Card Bug
  44:drivers_nxp/mci.c ****  - laebi: config for EA_LPC2468 Board
  45:drivers_nxp/mci.c **** 
  46:drivers_nxp/mci.c ****  Extensions:
  47:drivers_nxp/mci.c ****  -----------
  48:drivers_nxp/mci.c ****  - added debug outputs (can be turned off)
  49:drivers_nxp/mci.c ****  - Inserted license text in this file to avoid requests
  50:drivers_nxp/mci.c ****  because of the NXP Copyright. I understand the license like:
  51:drivers_nxp/mci.c ****  "Do whatever you want with the code but don't blame NXP if 
  52:drivers_nxp/mci.c ****  it doesn't work as expected."
  53:drivers_nxp/mci.c ****  And please don't blame me if my extensiones/modifications do
  54:drivers_nxp/mci.c ****  not work for you. Send me an e-mail with your bug-fix.
  55:drivers_nxp/mci.c ****  - SDHC support (my introduce new mistakes but
  56:drivers_nxp/mci.c ****  should still work as expected for SDSC and MMC cards)
  57:drivers_nxp/mci.c ****  Some information to do this came from Juri Haberland.
  58:drivers_nxp/mci.c ****  - modified/extended card_init
  59:drivers_nxp/mci.c ****  - write/read address
  60:drivers_nxp/mci.c ****  case HC: do not multitply block-num with 512
  61:drivers_nxp/mci.c ****  case SC: multiply block-num by 512
  62:drivers_nxp/mci.c ****  - Extended select_card for unselect (RCA=0) to
  63:drivers_nxp/mci.c ****  bring card in stby. Also needed for CMD4, 9, 10, 13 
  64:drivers_nxp/mci.c ****  (see SanDisk manual V2.2 4-7)
  65:drivers_nxp/mci.c ****  (I' not sure if the implementation is correct - but it
  66:drivers_nxp/mci.c ****  seems to work.)
  67:drivers_nxp/mci.c ****  - Added function for SD_STATUS (do not confuse with
  68:drivers_nxp/mci.c ****  the status-register - it's something different)
  69:drivers_nxp/mci.c ****  - laebi: Added Multiple Block Send Command (CMD25)
  70:drivers_nxp/mci.c ****  */
  71:drivers_nxp/mci.c **** 
  72:drivers_nxp/mci.c **** // #define MCI_DEBUGOUT   /* undefine to disable the outputs */
  73:drivers_nxp/mci.c **** 
  74:drivers_nxp/mci.c **** #include "LPC23xx.h"   /* LPC23xx/24xx definitions */
  75:drivers_nxp/mci.c **** #include "target.h"
  76:drivers_nxp/mci.c **** #include "type.h"
  77:drivers_nxp/mci.c **** #include "irq.h"
  78:drivers_nxp/mci.c **** #include "mci.h"
  79:drivers_nxp/mci.c **** #include <string.h>
  80:drivers_nxp/mci.c **** #include "dma.h"
  81:drivers_nxp/mci.c **** 
  82:drivers_nxp/mci.c **** // mthomas - for debug outputs
  83:drivers_nxp/mci.c **** #ifdef __GNUC__
  84:drivers_nxp/mci.c **** #include "monitor.h"
  85:drivers_nxp/mci.c **** #define myprintf xprintf
  86:drivers_nxp/mci.c **** #else
  87:drivers_nxp/mci.c **** #define myprintf printf
  88:drivers_nxp/mci.c **** #endif
  89:drivers_nxp/mci.c **** 
  90:drivers_nxp/mci.c **** #ifdef MCI_DEBUGOUT
  91:drivers_nxp/mci.c **** #include <stdio.h>
  92:drivers_nxp/mci.c **** #define mci_debug_printf myprintf
  93:drivers_nxp/mci.c **** #else
  94:drivers_nxp/mci.c **** #define mci_debug_printf( fmt, args... )
  95:drivers_nxp/mci.c **** #endif
  96:drivers_nxp/mci.c **** 
  97:drivers_nxp/mci.c **** volatile DWORD MCI_DataErrorProcess_count = 0;
  98:drivers_nxp/mci.c **** volatile DWORD MCI_DATA_END_InterruptService_count = 0;
  99:drivers_nxp/mci.c **** volatile DWORD MCI_FIFOInterruptService_count = 0;
 100:drivers_nxp/mci.c **** volatile DWORD MCI_CmdProcess_count = 0;
 101:drivers_nxp/mci.c **** 
 102:drivers_nxp/mci.c **** volatile DWORD CmdCRCErrCount = 0;
 103:drivers_nxp/mci.c **** volatile DWORD CmdTimeoutErrCount = 0;
 104:drivers_nxp/mci.c **** volatile DWORD CmdRespEndCount = 0;
 105:drivers_nxp/mci.c **** volatile DWORD CmdSentCount = 0;
 106:drivers_nxp/mci.c **** volatile DWORD CmdActiveCount = 0;
 107:drivers_nxp/mci.c **** 
 108:drivers_nxp/mci.c **** volatile DWORD DataCRCErrCount = 0;
 109:drivers_nxp/mci.c **** volatile DWORD DataTimeoutErrCount = 0;
 110:drivers_nxp/mci.c **** volatile DWORD DataTxUnderrunErrCount = 0;
 111:drivers_nxp/mci.c **** volatile DWORD DataRxOverrunErrCount = 0;
 112:drivers_nxp/mci.c **** volatile DWORD DataStartbitErrCount = 0;
 113:drivers_nxp/mci.c **** 
 114:drivers_nxp/mci.c **** volatile DWORD DataEndCount = 0;
 115:drivers_nxp/mci.c **** volatile DWORD DataBlockEndCount = 0;
 116:drivers_nxp/mci.c **** volatile DWORD MCI_Block_End_Flag = 0;
 117:drivers_nxp/mci.c **** 
 118:drivers_nxp/mci.c **** volatile DWORD DataTxActiveCount = 0;
 119:drivers_nxp/mci.c **** volatile DWORD DataRxActiveCount = 0;
 120:drivers_nxp/mci.c **** 
 121:drivers_nxp/mci.c **** volatile DWORD DataFIFOCount = 0;
 122:drivers_nxp/mci.c **** volatile DWORD DataRxFIFOCount = 0;
 123:drivers_nxp/mci.c **** volatile DWORD DataTxFIFOCount = 0;
 124:drivers_nxp/mci.c **** 
 125:drivers_nxp/mci.c **** volatile DWORD CardRCA;
 126:drivers_nxp/mci.c **** volatile DWORD MCI_CardType;
 127:drivers_nxp/mci.c **** 
 128:drivers_nxp/mci.c **** /* Assembly modules using the ARM block transfer instruction in readfifo.s. */
 129:drivers_nxp/mci.c **** // mthomas - volatile
 130:drivers_nxp/mci.c **** extern DWORD MCI_ReadFifo(volatile DWORD * dest);
 131:drivers_nxp/mci.c **** extern DWORD MCI_WriteFifo(volatile DWORD * src);
 132:drivers_nxp/mci.c **** 
 133:drivers_nxp/mci.c **** // mthomas
 134:drivers_nxp/mci.c **** #ifdef __GNUC__
 135:drivers_nxp/mci.c **** volatile BYTE *WriteBlock __attribute__ ((aligned (4))) = (volatile BYTE *)(DMA_SRC); /* treat Writ
 136:drivers_nxp/mci.c **** volatile BYTE *ReadBlock __attribute__ ((aligned (4))) = (volatile BYTE *)(DMA_DST); /* treat ReadB
 137:drivers_nxp/mci.c **** #else
 138:drivers_nxp/mci.c **** volatile BYTE *WriteBlock = (BYTE *)(DMA_SRC); /* treat WriteBlock as a constant address */
 139:drivers_nxp/mci.c **** volatile BYTE *ReadBlock = (BYTE *)(DMA_DST); /* treat ReadBlock as a constant address */
 140:drivers_nxp/mci.c **** #endif
 141:drivers_nxp/mci.c **** 
 142:drivers_nxp/mci.c **** volatile DWORD TXBlockCounter=0, RXBlockCounter=0;
 143:drivers_nxp/mci.c **** // mthomas
 144:drivers_nxp/mci.c **** volatile DWORD SDStatRead = 0;
 145:drivers_nxp/mci.c **** 
 146:drivers_nxp/mci.c **** /******************************************************************************
 147:drivers_nxp/mci.c ****  ** Function name:		MCI_Interrupt related
 148:drivers_nxp/mci.c ****  **
 149:drivers_nxp/mci.c ****  ** Descriptions:		MCI interrupt handler and related APIs
 150:drivers_nxp/mci.c ****  **
 151:drivers_nxp/mci.c ****  **
 152:drivers_nxp/mci.c ****  ** parameters:			None
 153:drivers_nxp/mci.c ****  ** Returned value:		None
 154:drivers_nxp/mci.c ****  ** 
 155:drivers_nxp/mci.c ****  ******************************************************************************/
 156:drivers_nxp/mci.c **** void MCI_TXEnable(void) {
  17              	 args = 0, pretend = 0, frame = 0
  18              		@ frame_needed = 1, uses_anonymous_args = 0
  19              		.loc 1 158 0
 157:drivers_nxp/mci.c **** #if MCI_DMA_ENABLED
 158:drivers_nxp/mci.c **** 	MCI_MASK0 |= ((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
  20              	v	r0, #-536870912
  21 0000 0E02A0E3 		add	r0, r0, #573440
  22 0004 230980E2 		ldr	r2, [r0, #60]
  23 0008 3C2090E5 		mov	r1, #1808
  24 000c 711EA0E3 		add	r1, r1, #10
  25 0010 0A1081E2 		orr	r2, r2, r1
  26 0014 012082E1 		str	r2, [r0, #60]
  27 0018 3C2080E5 		.loc 1 160 0
 159:drivers_nxp/mci.c **** 	/* Enable TX interrupts only */
 160:drivers_nxp/mci.c **** 	MCI_MASK1 |= ((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
  28              	 [r0, #64]
  29 001c 403090E5 		.loc 1 156 0
  30              		mov	ip, sp
  31 0020 0DC0A0E1 	.LCFI0:
  32              		.loc 1 160 0
  33              		orr	r3, r3, r1
  34 0024 013083E1 		.loc 1 156 0
  35              		stmfd	sp!, {fp, ip, lr, pc}
  36 0028 00D82DE9 	.LCFI1:
  37              		.loc 1 160 0
  38              		str	r3, [r0, #64]
  39 002c 403080E5 		.loc 1 156 0
  40              		sub	fp, ip, #4
  41 0030 04B04CE2 	.LCFI2:
  42              		.loc 1 167 0
 161:drivers_nxp/mci.c **** 	/* Enable TX interrupts only */
 162:drivers_nxp/mci.c **** #else
 163:drivers_nxp/mci.c **** 	MCI_MASK0 |= ((FIFO_TX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_TX_INT_MASK)); /* FIFO TX interrupts onl
 164:drivers_nxp/mci.c **** 	MCI_MASK1 |= ((FIFO_TX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_TX_INT_MASK)); /* FIFO TX interrupts onl
 165:drivers_nxp/mci.c **** #endif
 166:drivers_nxp/mci.c **** 	return;
 167:drivers_nxp/mci.c **** }
  43              	 sp, pc}
  44 0034 00A89DE8 	.LFE8:
  46              		.section	.text.MCI_TXDisable,"ax",%progbits
  47              		.align	2
  48              		.global	MCI_TXDisable
  50              	MCI_TXDisable:
  51              	.LFB9:
  52              		.loc 1 170 0
 168:drivers_nxp/mci.c **** /*****************************************************************/
 169:drivers_nxp/mci.c **** 
 170:drivers_nxp/mci.c **** void MCI_TXDisable(void) {
  53              	0, pretend = 0, frame = 0
  54              		@ frame_needed = 1, uses_anonymous_args = 0
  55              		.loc 1 172 0
 171:drivers_nxp/mci.c **** #if MCI_DMA_ENABLED
 172:drivers_nxp/mci.c **** 	MCI_MASK0 &= ~((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
  56              	v	r0, #-536870912
  57 0000 0E02A0E3 		add	r0, r0, #573440
  58 0004 230980E2 		ldr	r2, [r0, #60]
  59 0008 3C2090E5 		mvn	r1, #1808
  60 000c 711EE0E3 		sub	r1, r1, #10
  61 0010 0A1041E2 		and	r2, r2, r1
  62 0014 012002E0 		str	r2, [r0, #60]
  63 0018 3C2080E5 		.loc 1 174 0
 173:drivers_nxp/mci.c **** 	/* Enable TX interrupts only */
 174:drivers_nxp/mci.c **** 	MCI_MASK1 &= ~((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
  64              	 [r0, #64]
  65 001c 403090E5 		.loc 1 170 0
  66              		mov	ip, sp
  67 0020 0DC0A0E1 	.LCFI3:
  68              		.loc 1 174 0
  69              		and	r3, r3, r1
  70 0024 013003E0 		.loc 1 170 0
  71              		stmfd	sp!, {fp, ip, lr, pc}
  72 0028 00D82DE9 	.LCFI4:
  73              		.loc 1 174 0
  74              		str	r3, [r0, #64]
  75 002c 403080E5 		.loc 1 170 0
  76              		sub	fp, ip, #4
  77 0030 04B04CE2 	.LCFI5:
  78              		.loc 1 181 0
 175:drivers_nxp/mci.c **** 	/* Enable TX interrupts only */
 176:drivers_nxp/mci.c **** #else
 177:drivers_nxp/mci.c **** 	MCI_MASK0 &= ~((FIFO_TX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_TX_INT_MASK)); /* FIFO TX interrupts on
 178:drivers_nxp/mci.c **** 	MCI_MASK1 &= ~((FIFO_TX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_TX_INT_MASK)); /* FIFO TX interrupts on
 179:drivers_nxp/mci.c **** #endif
 180:drivers_nxp/mci.c **** 	return;
 181:drivers_nxp/mci.c **** }
  79              	 sp, pc}
  80 0034 00A89DE8 	.LFE9:
  82              		.section	.text.MCI_RXEnable,"ax",%progbits
  83              		.align	2
  84              		.global	MCI_RXEnable
  86              	MCI_RXEnable:
  87              	.LFB10:
  88              		.loc 1 184 0
 182:drivers_nxp/mci.c **** /*****************************************************************/
 183:drivers_nxp/mci.c **** 
 184:drivers_nxp/mci.c **** void MCI_RXEnable(void) {
  89              	0, pretend = 0, frame = 0
  90              		@ frame_needed = 1, uses_anonymous_args = 0
  91              		.loc 1 187 0
 185:drivers_nxp/mci.c **** 	//myprintf("inside MCI_RXEnable");
 186:drivers_nxp/mci.c **** #if MCI_DMA_ENABLED
 187:drivers_nxp/mci.c **** 	MCI_MASK0 |= ((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));
  92              	v	r0, #-536870912
  93 0000 0E02A0E3 		add	r0, r0, #573440
  94 0004 230980E2 		ldr	r2, [r0, #60]
  95 0008 3C2090E5 		mov	r1, #1824
  96 000c 721EA0E3 		add	r1, r1, #10
  97 0010 0A1081E2 		orr	r2, r2, r1
  98 0014 012082E1 		str	r2, [r0, #60]
  99 0018 3C2080E5 		.loc 1 189 0
 188:drivers_nxp/mci.c **** 	/* Enable RX interrupts only */
 189:drivers_nxp/mci.c **** 	MCI_MASK1 |= ((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));
 100              	 [r0, #64]
 101 001c 403090E5 		.loc 1 184 0
 102              		mov	ip, sp
 103 0020 0DC0A0E1 	.LCFI6:
 104              		.loc 1 189 0
 105              		orr	r3, r3, r1
 106 0024 013083E1 		.loc 1 184 0
 107              		stmfd	sp!, {fp, ip, lr, pc}
 108 0028 00D82DE9 	.LCFI7:
 109              		.loc 1 189 0
 110              		str	r3, [r0, #64]
 111 002c 403080E5 		.loc 1 184 0
 112              		sub	fp, ip, #4
 113 0030 04B04CE2 	.LCFI8:
 114              		.loc 1 196 0
 190:drivers_nxp/mci.c **** 	/* Enable RX interrupts only */
 191:drivers_nxp/mci.c **** #else
 192:drivers_nxp/mci.c **** 	MCI_MASK0 |= ((FIFO_RX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_RX_INT_MASK)); /* FIFO RX interrupts onl
 193:drivers_nxp/mci.c **** 	MCI_MASK1 |= ((FIFO_RX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_RX_INT_MASK)); /* FIFO RX interrupts onl
 194:drivers_nxp/mci.c **** #endif
 195:drivers_nxp/mci.c **** 	return;
 196:drivers_nxp/mci.c **** }
 115              	 sp, pc}
 116 0034 00A89DE8 	.LFE10:
 118              		.section	.text.MCI_RXDisable,"ax",%progbits
 119              		.align	2
 120              		.global	MCI_RXDisable
 122              	MCI_RXDisable:
 123              	.LFB11:
 124              		.loc 1 199 0
 197:drivers_nxp/mci.c **** /*****************************************************************/
 198:drivers_nxp/mci.c **** 
 199:drivers_nxp/mci.c **** void MCI_RXDisable(void) {
 125              	0, pretend = 0, frame = 0
 126              		@ frame_needed = 1, uses_anonymous_args = 0
 127              		.loc 1 201 0
 200:drivers_nxp/mci.c **** #if MCI_DMA_ENABLED
 201:drivers_nxp/mci.c **** 	MCI_MASK0 &= ~((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));
 128              	v	r0, #-536870912
 129 0000 0E02A0E3 		add	r0, r0, #573440
 130 0004 230980E2 		ldr	r2, [r0, #60]
 131 0008 3C2090E5 		mvn	r1, #1824
 132 000c 721EE0E3 		sub	r1, r1, #10
 133 0010 0A1041E2 		and	r2, r2, r1
 134 0014 012002E0 		str	r2, [r0, #60]
 135 0018 3C2080E5 		.loc 1 203 0
 202:drivers_nxp/mci.c **** 	/* Enable TX interrupts only */
 203:drivers_nxp/mci.c **** 	MCI_MASK1 &= ~((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));
 136              	 [r0, #64]
 137 001c 403090E5 		.loc 1 199 0
 138              		mov	ip, sp
 139 0020 0DC0A0E1 	.LCFI9:
 140              		.loc 1 203 0
 141              		and	r3, r3, r1
 142 0024 013003E0 		.loc 1 199 0
 143              		stmfd	sp!, {fp, ip, lr, pc}
 144 0028 00D82DE9 	.LCFI10:
 145              		.loc 1 203 0
 146              		str	r3, [r0, #64]
 147 002c 403080E5 		.loc 1 199 0
 148              		sub	fp, ip, #4
 149 0030 04B04CE2 	.LCFI11:
 150              		.loc 1 210 0
 204:drivers_nxp/mci.c **** 	/* Enable TX interrupts only */
 205:drivers_nxp/mci.c **** #else
 206:drivers_nxp/mci.c **** 	MCI_MASK0 &= ~((FIFO_RX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_RX_INT_MASK)); /* FIFO TX interrupts on
 207:drivers_nxp/mci.c **** 	MCI_MASK1 &= ~((FIFO_RX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_RX_INT_MASK)); /* FIFO TX interrupts on
 208:drivers_nxp/mci.c **** #endif
 209:drivers_nxp/mci.c **** 	return;
 210:drivers_nxp/mci.c **** }
 151              	 sp, pc}
 152 0034 00A89DE8 	.LFE11:
 154              		.section	.text.MCI_IRQHandler,"ax",%progbits
 155              		.align	2
 156              		.global	MCI_IRQHandler
 158              	MCI_IRQHandler:
 159              	.LFB17:
 160              		.loc 1 456 0
 211:drivers_nxp/mci.c **** 
 212:drivers_nxp/mci.c **** /******************************************************************************
 213:drivers_nxp/mci.c ****  ** Function name:		MCI_CheckStatus
 214:drivers_nxp/mci.c ****  **
 215:drivers_nxp/mci.c ****  ** Descriptions:		MCI Check status before and after the block read and 
 216:drivers_nxp/mci.c ****  **						write. Right after the block read and write, this routine 
 217:drivers_nxp/mci.c ****  **						is important that, even the FIFO is empty, complete
 218:drivers_nxp/mci.c ****  **						block has been sent, but, data is still being written
 219:drivers_nxp/mci.c ****  **						to the card, this routine is to ensure that the data
 220:drivers_nxp/mci.c ****  **						has been written based on the state of the card, not
 221:drivers_nxp/mci.c ****  **						by the length being set.  
 222:drivers_nxp/mci.c ****  **
 223:drivers_nxp/mci.c ****  ** parameters:			None
 224:drivers_nxp/mci.c ****  ** Returned value:		TRUE or FALSE
 225:drivers_nxp/mci.c ****  ** 
 226:drivers_nxp/mci.c ****  ******************************************************************************/
 227:drivers_nxp/mci.c **** DWORD MCI_CheckStatus(void) {
 228:drivers_nxp/mci.c **** 	DWORD respValue;
 229:drivers_nxp/mci.c **** 
 230:drivers_nxp/mci.c **** 	while ( 1) // mthomas TODO: possible deadlock
 231:drivers_nxp/mci.c **** 	{
 232:drivers_nxp/mci.c **** 		if ( (respValue = MCI_Send_Status()) == INVALID_RESPONSE) {
 233:drivers_nxp/mci.c **** 			break;
 234:drivers_nxp/mci.c **** 		} else {
 235:drivers_nxp/mci.c **** 			/* The only valid state is TRANS per MMC and SD state diagram.
 236:drivers_nxp/mci.c **** 			 RCV state may be seen, but, I have found that it happens
 237:drivers_nxp/mci.c **** 			 only when TX_ACTIVE or RX_ACTIVE occurs before the WRITE_BLOCK and 
 238:drivers_nxp/mci.c **** 			 READ_BLOCK cmds are being sent, which is not a valid sequence. */
 239:drivers_nxp/mci.c **** 			if ( (respValue & (0x0F << 8)) == 0x0900) {
 240:drivers_nxp/mci.c **** 				return ( TRUE );
 241:drivers_nxp/mci.c **** 			}
 242:drivers_nxp/mci.c **** 		}
 243:drivers_nxp/mci.c **** 	}
 244:drivers_nxp/mci.c **** 
 245:drivers_nxp/mci.c **** 	return ( FALSE );
 246:drivers_nxp/mci.c **** }
 247:drivers_nxp/mci.c **** 
 248:drivers_nxp/mci.c **** /******************************************************************************
 249:drivers_nxp/mci.c ****  ** Function name:		MCI_CmdProcess
 250:drivers_nxp/mci.c ****  **
 251:drivers_nxp/mci.c ****  ** Descriptions:		Called by MCI interrupt handler
 252:drivers_nxp/mci.c ****  **						To simplify the process, for card initialization, the 
 253:drivers_nxp/mci.c ****  **						CMD interrupts are disabled.
 254:drivers_nxp/mci.c ****  **						
 255:drivers_nxp/mci.c ****  **
 256:drivers_nxp/mci.c ****  ** parameters:			None
 257:drivers_nxp/mci.c ****  ** Returned value:		None
 258:drivers_nxp/mci.c ****  ** 
 259:drivers_nxp/mci.c ****  ******************************************************************************/
 260:drivers_nxp/mci.c **** // mthomas - static
 261:drivers_nxp/mci.c **** static void MCI_CmdProcess(void) {
 262:drivers_nxp/mci.c **** 	DWORD MCIStatus;
 263:drivers_nxp/mci.c **** 
 264:drivers_nxp/mci.c **** 	MCIStatus = MCI_STATUS;
 265:drivers_nxp/mci.c **** 
 266:drivers_nxp/mci.c **** 	if (MCIStatus & MCI_CMD_CRC_FAIL) {
 267:drivers_nxp/mci.c **** 		CmdCRCErrCount++;
 268:drivers_nxp/mci.c **** 		MCI_CLEAR = MCI_CMD_CRC_FAIL;
 269:drivers_nxp/mci.c **** 	}
 270:drivers_nxp/mci.c **** 	if (MCIStatus & MCI_CMD_TIMEOUT) {
 271:drivers_nxp/mci.c **** 		CmdTimeoutErrCount++;
 272:drivers_nxp/mci.c **** 		MCI_CLEAR = MCI_CMD_TIMEOUT;
 273:drivers_nxp/mci.c **** 	}
 274:drivers_nxp/mci.c **** 	/* Cmd Resp End or Cmd Sent */
 275:drivers_nxp/mci.c **** 	if (MCIStatus & MCI_CMD_RESP_END) {
 276:drivers_nxp/mci.c **** 		CmdRespEndCount++;
 277:drivers_nxp/mci.c **** 		MCI_CLEAR = MCI_CMD_RESP_END;
 278:drivers_nxp/mci.c **** 	}
 279:drivers_nxp/mci.c **** 	if (MCIStatus & MCI_CMD_SENT) {
 280:drivers_nxp/mci.c **** 		CmdSentCount++;
 281:drivers_nxp/mci.c **** 		MCI_CLEAR = MCI_CMD_SENT;
 282:drivers_nxp/mci.c **** 	}
 283:drivers_nxp/mci.c **** 	if (MCIStatus & MCI_CMD_ACTIVE) {
 284:drivers_nxp/mci.c **** 		CmdActiveCount++;
 285:drivers_nxp/mci.c **** 		MCI_CLEAR = MCI_CMD_ACTIVE;
 286:drivers_nxp/mci.c **** 	}
 287:drivers_nxp/mci.c **** 	return;
 288:drivers_nxp/mci.c **** }
 289:drivers_nxp/mci.c **** 
 290:drivers_nxp/mci.c **** /******************************************************************************
 291:drivers_nxp/mci.c ****  ** Function name:		MCI_DataErrorProcess
 292:drivers_nxp/mci.c ****  **
 293:drivers_nxp/mci.c ****  ** Descriptions:		Called by MCI interrupt handler
 294:drivers_nxp/mci.c ****  **						Process data error. 
 295:drivers_nxp/mci.c ****  **
 296:drivers_nxp/mci.c ****  ** parameters:			None
 297:drivers_nxp/mci.c ****  ** Returned value:		None
 298:drivers_nxp/mci.c ****  ** 
 299:drivers_nxp/mci.c ****  ******************************************************************************/
 300:drivers_nxp/mci.c **** // mthomas - static
 301:drivers_nxp/mci.c **** static void MCI_DataErrorProcess(void) {
 302:drivers_nxp/mci.c **** 	DWORD MCIStatus;
 303:drivers_nxp/mci.c **** 
 304:drivers_nxp/mci.c **** 	MCIStatus = MCI_STATUS;
 305:drivers_nxp/mci.c **** 
 306:drivers_nxp/mci.c **** 	if (MCIStatus & MCI_DATA_CRC_FAIL) {
 307:drivers_nxp/mci.c **** 		DataCRCErrCount++;
 308:drivers_nxp/mci.c **** 		MCI_CLEAR = MCI_DATA_CRC_FAIL;
 309:drivers_nxp/mci.c **** 	}
 310:drivers_nxp/mci.c **** 	if (MCIStatus & MCI_DATA_TIMEOUT) {
 311:drivers_nxp/mci.c **** 		DataTimeoutErrCount++;
 312:drivers_nxp/mci.c **** 		MCI_CLEAR = MCI_DATA_TIMEOUT;
 313:drivers_nxp/mci.c **** 	}
 314:drivers_nxp/mci.c **** 	/* Underrun or overrun */
 315:drivers_nxp/mci.c **** 	if (MCIStatus & MCI_TX_UNDERRUN) {
 316:drivers_nxp/mci.c **** 		DataTxUnderrunErrCount++;
 317:drivers_nxp/mci.c **** 		MCI_CLEAR = MCI_TX_UNDERRUN;
 318:drivers_nxp/mci.c **** 	}
 319:drivers_nxp/mci.c **** 	if (MCIStatus & MCI_RX_OVERRUN) {
 320:drivers_nxp/mci.c **** 		DataRxOverrunErrCount++;
 321:drivers_nxp/mci.c **** 		MCI_CLEAR = MCI_RX_OVERRUN;
 322:drivers_nxp/mci.c **** 	}
 323:drivers_nxp/mci.c **** 	/* Start bit error on data signal */
 324:drivers_nxp/mci.c **** 	if (MCIStatus & MCI_START_BIT_ERR) {
 325:drivers_nxp/mci.c **** 		DataStartbitErrCount++;
 326:drivers_nxp/mci.c **** 		MCI_CLEAR = MCI_START_BIT_ERR;
 327:drivers_nxp/mci.c **** 	}
 328:drivers_nxp/mci.c **** 	return;
 329:drivers_nxp/mci.c **** }
 330:drivers_nxp/mci.c **** 
 331:drivers_nxp/mci.c **** /******************************************************************************
 332:drivers_nxp/mci.c ****  ** Function name:		MCI_DATA_END_InterruptService
 333:drivers_nxp/mci.c ****  **
 334:drivers_nxp/mci.c ****  ** Descriptions:		Called by MCI interrupt handler
 335:drivers_nxp/mci.c ****  **						This is the last interrupt module processing 
 336:drivers_nxp/mci.c ****  **						the block write and	read to and from the MM card.
 337:drivers_nxp/mci.c ****  **					 
 338:drivers_nxp/mci.c ****  **						FIFO interrupts are also used when DMA is disabled                                   
 339:drivers_nxp/mci.c ****  **						This routine simply clears the
 340:drivers_nxp/mci.c ****  **						MCI_Block_End_Flag, and increments counters for debug
 341:drivers_nxp/mci.c ****  **
 342:drivers_nxp/mci.c ****  ** parameters:			None
 343:drivers_nxp/mci.c ****  ** Returned value:		None
 344:drivers_nxp/mci.c ****  ** 
 345:drivers_nxp/mci.c ****  ******************************************************************************/
 346:drivers_nxp/mci.c **** // mthomas - static
 347:drivers_nxp/mci.c **** static void MCI_DATA_END_InterruptService(void) {
 348:drivers_nxp/mci.c **** 	DWORD MCIStatus;
 349:drivers_nxp/mci.c **** 
 350:drivers_nxp/mci.c **** 	MCIStatus = MCI_STATUS;
 351:drivers_nxp/mci.c **** 
 352:drivers_nxp/mci.c **** 	if (MCIStatus & MCI_DATA_END) /* Data end, and Data block end  */
 353:drivers_nxp/mci.c **** 	{
 354:drivers_nxp/mci.c **** 		DataEndCount++;
 355:drivers_nxp/mci.c **** 		MCI_CLEAR = MCI_DATA_END;
 356:drivers_nxp/mci.c **** 		return;
 357:drivers_nxp/mci.c **** 	}
 358:drivers_nxp/mci.c **** 	if (MCIStatus & MCI_DATA_BLK_END) {
 359:drivers_nxp/mci.c **** 		DataBlockEndCount++;
 360:drivers_nxp/mci.c **** 		MCI_CLEAR = MCI_DATA_BLK_END;
 361:drivers_nxp/mci.c **** 		MCI_TXDisable();
 362:drivers_nxp/mci.c **** 		MCI_Block_End_Flag = 0;
 363:drivers_nxp/mci.c **** 		return;
 364:drivers_nxp/mci.c **** 	}
 365:drivers_nxp/mci.c **** 
 366:drivers_nxp/mci.c **** 	/* Tx active  */
 367:drivers_nxp/mci.c **** 	if (MCIStatus & MCI_TX_ACTIVE) {
 368:drivers_nxp/mci.c **** 		DataTxActiveCount++;
 369:drivers_nxp/mci.c **** 	}
 370:drivers_nxp/mci.c **** 	/* Rx active  */
 371:drivers_nxp/mci.c **** 	if (MCIStatus & MCI_RX_ACTIVE) {
 372:drivers_nxp/mci.c **** 		DataRxActiveCount++;
 373:drivers_nxp/mci.c **** 	}
 374:drivers_nxp/mci.c **** 
 375:drivers_nxp/mci.c **** 	return;
 376:drivers_nxp/mci.c **** }
 377:drivers_nxp/mci.c **** 
 378:drivers_nxp/mci.c **** /******************************************************************************
 379:drivers_nxp/mci.c ****  ** Function name:	MCI_FIFOInterruptService
 380:drivers_nxp/mci.c ****  **
 381:drivers_nxp/mci.c ****  ** Descriptions:	Called by MCI interrupt handler when using FIFO 
 382:drivers_nxp/mci.c ****  **					interrupts and DMA is disabled
 383:drivers_nxp/mci.c ****  **
 384:drivers_nxp/mci.c ****  **
 385:drivers_nxp/mci.c ****  ** parameters:			None
 386:drivers_nxp/mci.c ****  ** Returned value:		None
 387:drivers_nxp/mci.c ****  ** 
 388:drivers_nxp/mci.c ****  ******************************************************************************/
 389:drivers_nxp/mci.c **** // mthomas - static
 390:drivers_nxp/mci.c **** static void MCI_FIFOInterruptService(void) {
 391:drivers_nxp/mci.c **** #if !MCI_DMA_ENABLED
 392:drivers_nxp/mci.c **** 	DWORD MCIStatus;
 393:drivers_nxp/mci.c **** 
 394:drivers_nxp/mci.c **** 	MCIStatus = MCI_STATUS;
 395:drivers_nxp/mci.c **** 
 396:drivers_nxp/mci.c **** 	if ( MCIStatus & (FIFO_TX_INT_MASK ) )
 397:drivers_nxp/mci.c **** 	{
 398:drivers_nxp/mci.c **** 		DataTxFIFOCount++; /* if using TX_HALF_EMPTY remove one WriteFifo below */
 399:drivers_nxp/mci.c **** 		if ( MCIStatus & MCI_TX_HALF_EMPTY ) /* empty is multiple of 512 block size */
 400:drivers_nxp/mci.c **** 		{
 401:drivers_nxp/mci.c **** 			// mthomas
 402:drivers_nxp/mci.c **** 			// MCI_WriteFifo((DWORD *)&WriteBlock[TXBlockCounter]); /* write 8 words to fifo */
 403:drivers_nxp/mci.c **** 			MCI_WriteFifo((volatile DWORD *)&WriteBlock[TXBlockCounter]); /* write 8 words to fifo */
 404:drivers_nxp/mci.c **** 			TXBlockCounter += 32;
 405:drivers_nxp/mci.c **** 		}
 406:drivers_nxp/mci.c **** 		if (TXBlockCounter == BLOCK_LENGTH) /* block complete */
 407:drivers_nxp/mci.c **** 		{
 408:drivers_nxp/mci.c **** 			TXBlockCounter = 0;
 409:drivers_nxp/mci.c **** 			MCI_MASK0 &= ~(FIFO_TX_INT_MASK); /* disable FIFO int until next block write */
 410:drivers_nxp/mci.c **** 			MCI_MASK1 &= ~(FIFO_TX_INT_MASK);
 411:drivers_nxp/mci.c **** 			/* wait for SD card to complete sending data i.e MCI_DATA_BLK_END interrupt */
 412:drivers_nxp/mci.c **** 		}
 413:drivers_nxp/mci.c **** 	}
 414:drivers_nxp/mci.c **** 	else if ( MCIStatus & (FIFO_RX_INT_MASK) )
 415:drivers_nxp/mci.c **** 	{
 416:drivers_nxp/mci.c **** 		DataRxFIFOCount++;
 417:drivers_nxp/mci.c **** 		if ( MCIStatus & MCI_RX_HALF_FULL ) /* if using RX_HALF_FULL remove one ReadFIFO below */
 418:drivers_nxp/mci.c **** 		{
 419:drivers_nxp/mci.c **** 			// mhomas
 420:drivers_nxp/mci.c **** 			// MCI_ReadFifo((DWORD *)&ReadBlock[RXBlockCounter]); /* read 8 words from fifo */
 421:drivers_nxp/mci.c **** 			MCI_ReadFifo((volatile DWORD *)&ReadBlock[RXBlockCounter]); /* read 8 words from fifo */
 422:drivers_nxp/mci.c **** 			RXBlockCounter += 32;
 423:drivers_nxp/mci.c **** 		}
 424:drivers_nxp/mci.c **** 		if (RXBlockCounter == BLOCK_LENGTH) /* block complete */
 425:drivers_nxp/mci.c **** 		{
 426:drivers_nxp/mci.c **** 			RXBlockCounter = 0;
 427:drivers_nxp/mci.c **** 		}
 428:drivers_nxp/mci.c **** 		// mthomas: maybe redundant
 429:drivers_nxp/mci.c **** 		if ( SDStatRead && RXBlockCounter == SD_BLOCK_LENGTH ) /* SD_STATUS complete */
 430:drivers_nxp/mci.c **** 		{
 431:drivers_nxp/mci.c **** 			SDStatRead = 0;
 432:drivers_nxp/mci.c **** 			RXBlockCounter = 0;
 433:drivers_nxp/mci.c **** 		}
 434:drivers_nxp/mci.c **** 		// mthomas end
 435:drivers_nxp/mci.c **** 	}
 436:drivers_nxp/mci.c **** #endif
 437:drivers_nxp/mci.c **** 
 438:drivers_nxp/mci.c **** 	DataFIFOCount++;
 439:drivers_nxp/mci.c **** 	return;
 440:drivers_nxp/mci.c **** }
 441:drivers_nxp/mci.c **** 
 442:drivers_nxp/mci.c **** /******************************************************************************
 443:drivers_nxp/mci.c ****  ** Function name:		MCI_IRQHandler
 444:drivers_nxp/mci.c ****  **
 445:drivers_nxp/mci.c ****  ** Descriptions:		MCI interrupt handler
 446:drivers_nxp/mci.c ****  **						The handler to handle the block data write and read
 447:drivers_nxp/mci.c ****  **						not for the commands.
 448:drivers_nxp/mci.c ****  **
 449:drivers_nxp/mci.c ****  ** parameters:			None
 450:drivers_nxp/mci.c ****  ** Returned value:		None
 451:drivers_nxp/mci.c ****  ** 
 452:drivers_nxp/mci.c ****  ******************************************************************************/
 453:drivers_nxp/mci.c **** // mthomas - avoid warning missing prototype
 454:drivers_nxp/mci.c **** void MCI_IRQHandler(void)  __attribute__((interrupt("IRQ")));
 455:drivers_nxp/mci.c **** void MCI_IRQHandler(void)
 456:drivers_nxp/mci.c **** {
 161              	pt Service Routine.
 162              		@ args = 0, pretend = 0, frame = 0
 163              		@ frame_needed = 1, uses_anonymous_args = 0
 164              		str	ip, [sp, #-4]!
 165 0000 04C02DE5 		mov	ip, sp
 166 0004 0DC0A0E1 	.LCFI12:
 167              		stmfd	sp!, {r0, r1, r2, r3, fp, ip, lr, pc}
 168 0008 0FD82DE9 	.LCFI13:
 169              		.loc 1 460 0
 457:drivers_nxp/mci.c **** 	//myprintf("MCI_INTERRUPT_HANDLER");
 458:drivers_nxp/mci.c **** 	DWORD MCI_Status;
 459:drivers_nxp/mci.c **** 
 460:drivers_nxp/mci.c **** 	MCI_Status = MCI_STATUS;
 170              	#-536870912
 171 000c 0E02A0E3 		add	r0, r0, #573440
 172 0010 230980E2 		ldr	r2, [r0, #52]
 173 0014 342090E5 	.LVL0:
 174              		.loc 1 465 0
 461:drivers_nxp/mci.c **** 
 462:drivers_nxp/mci.c **** 	//myprintf("calling MCI_IRQHandler\r\n");
 463:drivers_nxp/mci.c **** 
 464:drivers_nxp/mci.c **** 	/* handle MCI_STATUS interrupt */
 465:drivers_nxp/mci.c **** 	if ( MCI_Status & DATA_ERR_INT_MASK )
 175              	r3, r2, #452
 176 0018 713FC2E3 		bic	r3, r3, #1
 177 001c 0130C3E3 		mov	r3, r3, asl #22
 178 0020 033BA0E1 		mov	r3, r3, lsr #22
 179 0024 233BA0E1 		cmp	r3, #0
 180 0028 000053E3 		.loc 1 456 0
 181              		sub	fp, ip, #4
 182 002c 04B04CE2 	.LCFI14:
 183              		.loc 1 465 0
 184              		beq	.L10
 185 0030 3B00000A 	.LBB34:
 186              	.LBB35:
 187              		.loc 1 304 0
 188              		ldr	ip, [r0, #52]
 189 0034 34C090E5 	.LVL1:
 190              		.loc 1 306 0
 191              		tst	ip, #2
 192 0038 02001CE3 		beq	.L11
 193 003c 0500000A 		.loc 1 307 0
 194              		ldr	r3, .L34
 195 0040 C0329FE5 		ldr	r2, [r3, #0]
 196 0044 002093E5 	.LVL2:
 197              		.loc 1 308 0
 198              		mov	r1, #2
 199 0048 0210A0E3 		.loc 1 307 0
 200              		add	r2, r2, #1
 201 004c 012082E2 		str	r2, [r3, #0]
 202 0050 002083E5 		.loc 1 308 0
 203              		str	r1, [r0, #56]
 204 0054 381080E5 	.LVL3:
 205              	.L11:
 206              		.loc 1 310 0
 207              		tst	ip, #8
 208 0058 08001CE3 		beq	.L12
 209 005c 0700000A 		.loc 1 311 0
 210              		ldr	r0, .L34+4
 211 0060 A4029FE5 		ldr	r3, [r0, #0]
 212 0064 003090E5 		.loc 1 312 0
 213              		mov	r1, #-536870912
 214 0068 0E12A0E3 		.loc 1 311 0
 215              		add	r3, r3, #1
 216 006c 013083E2 		.loc 1 312 0
 217              		add	r1, r1, #573440
 218 0070 231981E2 		mov	r2, #8
 219 0074 0820A0E3 	.LVL4:
 220              		.loc 1 311 0
 221              		str	r3, [r0, #0]
 222 0078 003080E5 		.loc 1 312 0
 223              		str	r2, [r1, #56]
 224 007c 382081E5 	.LVL5:
 225              	.L12:
 226              		.loc 1 315 0
 227              		tst	ip, #16
 228 0080 10001CE3 		beq	.L13
 229 0084 0700000A 		.loc 1 316 0
 230              		ldr	r0, .L34+8
 231 0088 80029FE5 		ldr	r3, [r0, #0]
 232 008c 003090E5 		.loc 1 317 0
 233              		mov	r1, #-536870912
 234 0090 0E12A0E3 		.loc 1 316 0
 235              		add	r3, r3, #1
 236 0094 013083E2 		.loc 1 317 0
 237              		add	r1, r1, #573440
 238 0098 231981E2 		mov	r2, #16
 239 009c 1020A0E3 	.LVL6:
 240              		.loc 1 316 0
 241              		str	r3, [r0, #0]
 242 00a0 003080E5 		.loc 1 317 0
 243              		str	r2, [r1, #56]
 244 00a4 382081E5 	.LVL7:
 245              	.L13:
 246              		.loc 1 319 0
 247              		tst	ip, #32
 248 00a8 20001CE3 		beq	.L14
 249 00ac 0700000A 		.loc 1 320 0
 250              		ldr	r0, .L34+12
 251 00b0 5C029FE5 		ldr	r3, [r0, #0]
 252 00b4 003090E5 		.loc 1 321 0
 253              		mov	r1, #-536870912
 254 00b8 0E12A0E3 		.loc 1 320 0
 255              		add	r3, r3, #1
 256 00bc 013083E2 		.loc 1 321 0
 257              		add	r1, r1, #573440
 258 00c0 231981E2 		mov	r2, #32
 259 00c4 2020A0E3 	.LVL8:
 260              		.loc 1 320 0
 261              		str	r3, [r0, #0]
 262 00c8 003080E5 		.loc 1 321 0
 263              		str	r2, [r1, #56]
 264 00cc 382081E5 	.LVL9:
 265              	.L14:
 266              		.loc 1 324 0
 267              		tst	ip, #512
 268 00d0 020C1CE3 		beq	.L15
 269 00d4 0700000A 		.loc 1 325 0
 270              		ldr	r0, .L34+16
 271 00d8 38029FE5 		ldr	r3, [r0, #0]
 272 00dc 003090E5 		.loc 1 326 0
 273              		mov	r1, #-536870912
 274 00e0 0E12A0E3 		.loc 1 325 0
 275              		add	r3, r3, #1
 276 00e4 013083E2 		.loc 1 326 0
 277              		add	r1, r1, #573440
 278 00e8 231981E2 		mov	r2, #512
 279 00ec 022CA0E3 	.LVL10:
 280              		.loc 1 325 0
 281              		str	r3, [r0, #0]
 282 00f0 003080E5 		.loc 1 326 0
 283              		str	r2, [r1, #56]
 284 00f4 382081E5 	.LVL11:
 285              	.L15:
 286              	.LBE35:
 287              	.LBE34:
 288              		.loc 1 468 0
 466:drivers_nxp/mci.c **** 	{
 467:drivers_nxp/mci.c **** 		MCI_DataErrorProcess();
 468:drivers_nxp/mci.c **** 		MCI_DataErrorProcess_count++;
 289              	v	r1, #0
 290 00f8 1C229FE5 	.LVL13:
 291              		mvn	r3, #0
 292              		str	r1, [r3, #-255]
 469:drivers_nxp/mci.c **** 		VICVectAddr = 0; /* Acknowledge Interrupt */
 470:drivers_nxp/mci.c **** 		return;
 471:drivers_nxp/mci.c **** 	}
 472:drivers_nxp/mci.c **** 	if ( MCI_Status & DATA_END_INT_MASK )
 473:drivers_nxp/mci.c **** 	{
 474:drivers_nxp/mci.c **** 		MCI_DATA_END_InterruptService();
 475:drivers_nxp/mci.c **** 		MCI_DATA_END_InterruptService_count++;
 293              	:
 294 00fc 003092E5 		.loc 1 496 0
 295 0100 013083E2 		sub	sp, fp, #28
 296 0104 003082E5 		ldmfd	sp, {r0, r1, r2, r3, fp, sp, lr}
 476:drivers_nxp/mci.c **** 		VICVectAddr = 0; /* Acknowledge Interrupt */
 297              	fd	sp!, {ip}
 298 0108 0010A0E3 		subs	pc, lr, #4
 299              	.LVL14:
 300 010c 0030E0E3 	.L10:
 301 0110 FF1003E5 		.loc 1 472 0
 302              		ands	ip, r2, #1280
 477:drivers_nxp/mci.c **** 		return;
 478:drivers_nxp/mci.c **** 	}
 479:drivers_nxp/mci.c **** 	else if ( MCI_Status & FIFO_INT_MASK )
 480:drivers_nxp/mci.c **** 	{
 481:drivers_nxp/mci.c **** 		MCI_FIFOInterruptService();
 482:drivers_nxp/mci.c **** 		MCI_FIFOInterruptService_count++;
 483:drivers_nxp/mci.c **** 		VICVectAddr = 0; /* Acknowledge Interrupt */
 484:drivers_nxp/mci.c **** 		return;
 485:drivers_nxp/mci.c **** 	}
 486:drivers_nxp/mci.c **** 	else if ( MCI_Status & CMD_INT_MASK )
 487:drivers_nxp/mci.c **** 	{
 488:drivers_nxp/mci.c **** 		MCI_CmdProcess();
 489:drivers_nxp/mci.c **** 		MCI_CmdProcess_count++;
 490:drivers_nxp/mci.c **** 		VICVectAddr = 0; /* Acknowledge Interrupt */
 491:drivers_nxp/mci.c **** 		return;
 492:drivers_nxp/mci.c **** 	}
 493:drivers_nxp/mci.c **** 
 494:drivers_nxp/mci.c **** 	VICVectAddr = 0; /* Acknowledge Interrupt */
 495:drivers_nxp/mci.c **** 	return;
 496:drivers_nxp/mci.c **** }
 303              	L17
 304 0114 1CD04BE2 	.LBB36:
 305 0118 0F689DE8 	.LBB38:
 306 011c 0010BDE8 		.loc 1 350 0
 307 0120 04F05EE2 		ldr	r1, [r0, #52]
 308              	.LVL15:
 309              		.loc 1 352 0
 310              		ands	ip, r1, #256
 311 0124 05CC12E2 		bne	.L32
 312 0128 1600000A 		.loc 1 358 0
 313              		tst	r1, #1024
 314              		beq	.L20
 315              		.loc 1 359 0
 316 012c 341090E5 		ldr	r1, .L34+24
 317              	.LVL16:
 318              		ldr	r3, [r1, #0]
 319 0130 01CC11E2 		.loc 1 360 0
 320 0134 5400001A 		mov	r2, #1024
 321              	.LVL17:
 322 0138 010B11E3 		.loc 1 359 0
 323 013c 6500000A 		add	r3, r3, #1
 324              		str	r3, [r1, #0]
 325 0140 D8119FE5 		.loc 1 360 0
 326              		str	r2, [r0, #56]
 327 0144 003091E5 	.LBB39:
 328              	.LBB40:
 329 0148 012BA0E3 		.loc 1 172 0
 330              		ldr	r3, [r0, #60]
 331              		bic	r3, r3, #1808
 332 014c 013083E2 		bic	r3, r3, #10
 333 0150 003081E5 		str	r3, [r0, #60]
 334              		.loc 1 174 0
 335 0154 382080E5 		ldr	r2, [r0, #64]
 336              	.LBE40:
 337              	.LBE39:
 338              		.loc 1 362 0
 339 0158 3C3090E5 		ldr	r3, .L34+28
 340 015c 713EC3E3 	.LBB42:
 341 0160 0A30C3E3 	.LBB41:
 342 0164 3C3080E5 		.loc 1 174 0
 343              		bic	r2, r2, #1808
 344 0168 402090E5 		bic	r2, r2, #10
 345              		str	r2, [r0, #64]
 346              	.LBE41:
 347              	.LBE42:
 348 016c B0319FE5 		.loc 1 362 0
 349              		str	ip, [r3, #0]
 350              	.LBE38:
 351              	.LBE36:
 352 0170 712EC2E3 		.loc 1 475 0
 353 0174 0A20C2E3 		ldr	r2, .L34+32
 354 0178 402080E5 		b	.L30
 355              	.LVL18:
 356              	.L17:
 357              		.loc 1 479 0
 358 017c 00C083E5 		bic	r3, r2, #-16777216
 359              		bic	r3, r3, #15728640
 360              		bic	r3, r3, #15296
 361              		bic	r3, r3, #63
 362 0180 A0219FE5 		cmp	r3, #0
 363 0184 DCFFFFEA 		bne	.L33
 364              		.loc 1 486 0
 365              		bic	r2, r2, #1840
 366              	.LVL19:
 367 0188 FF34C2E3 		bic	r2, r2, #10
 368 018c 0F36C3E3 		mov	r2, r2, asl #20
 369 0190 EF3DC3E3 		mov	r2, r2, lsr #20
 370 0194 3F30C3E3 		cmp	r2, #0
 371 0198 000053E3 		.loc 1 494 0
 372 019c 4200001A 		mvneq	r3, #0
 373              		streq	r2, [r3, #-255]
 374 01a0 732EC2E3 		.loc 1 486 0
 375              		beq	.L29
 376 01a4 0A20C2E3 	.LBB44:
 377 01a8 022AA0E1 	.LBB45:
 378 01ac 222AA0E1 		.loc 1 264 0
 379 01b0 000052E3 		ldr	ip, [r0, #52]
 380              	.LVL20:
 381 01b4 0030E003 	.LBE45:
 382 01b8 FF200305 		.loc 1 266 0
 383              		tst	ip, #1
 384 01bc D4FFFF0A 		beq	.L24
 385              	.LBB46:
 386              		.loc 1 267 0
 387              		ldr	r3, .L34+36
 388 01c0 34C090E5 		ldr	r2, [r3, #0]
 389              		.loc 1 268 0
 390              		mov	r1, #1
 391              		.loc 1 267 0
 392 01c4 01001CE3 		add	r2, r2, #1
 393 01c8 0500000A 		str	r2, [r3, #0]
 394              		.loc 1 268 0
 395              		str	r1, [r0, #56]
 396 01cc 58319FE5 	.L24:
 397 01d0 002093E5 		.loc 1 270 0
 398              		tst	ip, #4
 399 01d4 0110A0E3 		beq	.L25
 400              		.loc 1 271 0
 401 01d8 012082E2 		ldr	r0, .L34+40
 402 01dc 002083E5 		ldr	r3, [r0, #0]
 403              		.loc 1 272 0
 404 01e0 381080E5 		mov	r1, #-536870912
 405              		.loc 1 271 0
 406              		add	r3, r3, #1
 407 01e4 04001CE3 		.loc 1 272 0
 408 01e8 0700000A 		add	r1, r1, #573440
 409              		mov	r2, #4
 410 01ec 3C019FE5 		.loc 1 271 0
 411 01f0 003090E5 		str	r3, [r0, #0]
 412              		.loc 1 272 0
 413 01f4 0E12A0E3 		str	r2, [r1, #56]
 414              	.L25:
 415 01f8 013083E2 		.loc 1 275 0
 416              		tst	ip, #64
 417 01fc 231981E2 		beq	.L26
 418 0200 0420A0E3 		.loc 1 276 0
 419              		ldr	r0, .L34+44
 420 0204 003080E5 		ldr	r3, [r0, #0]
 421              		.loc 1 277 0
 422 0208 382081E5 		mov	r1, #-536870912
 423              		.loc 1 276 0
 424              		add	r3, r3, #1
 425 020c 40001CE3 		.loc 1 277 0
 426 0210 0700000A 		add	r1, r1, #573440
 427              		mov	r2, #64
 428 0214 18019FE5 		.loc 1 276 0
 429 0218 003090E5 		str	r3, [r0, #0]
 430              		.loc 1 277 0
 431 021c 0E12A0E3 		str	r2, [r1, #56]
 432              	.L26:
 433 0220 013083E2 		.loc 1 279 0
 434              		tst	ip, #128
 435 0224 231981E2 		beq	.L27
 436 0228 4020A0E3 		.loc 1 280 0
 437              		ldr	r0, .L34+48
 438 022c 003080E5 		ldr	r3, [r0, #0]
 439              		.loc 1 281 0
 440 0230 382081E5 		mov	r1, #-536870912
 441              		.loc 1 280 0
 442              		add	r3, r3, #1
 443 0234 80001CE3 		.loc 1 281 0
 444 0238 0700000A 		add	r1, r1, #573440
 445              		mov	r2, #128
 446 023c F4009FE5 		.loc 1 280 0
 447 0240 003090E5 		str	r3, [r0, #0]
 448              		.loc 1 281 0
 449 0244 0E12A0E3 		str	r2, [r1, #56]
 450              	.L27:
 451 0248 013083E2 		.loc 1 283 0
 452              		tst	ip, #2048
 453 024c 231981E2 		beq	.L28
 454 0250 8020A0E3 		.loc 1 284 0
 455              		ldr	r0, .L34+52
 456 0254 003080E5 		ldr	r3, [r0, #0]
 457              		.loc 1 285 0
 458 0258 382081E5 		mov	r1, #-536870912
 459              		.loc 1 284 0
 460              		add	r3, r3, #1
 461 025c 020B1CE3 		.loc 1 285 0
 462 0260 0700000A 		add	r1, r1, #573440
 463              		mov	r2, #2048
 464 0264 D0009FE5 		.loc 1 284 0
 465 0268 003090E5 		str	r3, [r0, #0]
 466              		.loc 1 285 0
 467 026c 0E12A0E3 		str	r2, [r1, #56]
 468              	.L28:
 469 0270 013083E2 	.LBE46:
 470              	.LBE44:
 471 0274 231981E2 		.loc 1 489 0
 472 0278 022BA0E3 		ldr	r2, .L34+56
 473              		b	.L30
 474 027c 003080E5 	.LVL21:
 475              	.L32:
 476 0280 382081E5 	.LBB47:
 477              	.LBB37:
 478              		.loc 1 354 0
 479              		ldr	r3, .L34+60
 480              		ldr	r2, [r3, #0]
 481 0284 B4209FE5 	.LVL22:
 482 0288 9BFFFFEA 		.loc 1 355 0
 483              		mov	r1, #256
 484              	.LVL23:
 485              		.loc 1 354 0
 486              		add	r2, r2, #1
 487              		str	r2, [r3, #0]
 488 028c B0309FE5 		.loc 1 355 0
 489 0290 002093E5 		str	r1, [r0, #56]
 490              	.LBE37:
 491              	.LBE47:
 492 0294 011CA0E3 		.loc 1 475 0
 493              		ldr	r2, .L34+32
 494              		b	.L30
 495 0298 012082E2 	.LVL24:
 496 029c 002083E5 	.L33:
 497              	.LBB48:
 498 02a0 381080E5 	.LBB49:
 499              		.loc 1 438 0
 500              		ldr	r2, .L34+64
 501              	.LVL25:
 502 02a4 7C209FE5 		ldr	r3, [r2, #0]
 503 02a8 93FFFFEA 		add	r3, r3, #1
 504              		str	r3, [r2, #0]
 505              	.LBE49:
 506              	.LBE48:
 507              		.loc 1 482 0
 508              		ldr	r1, .L34+68
 509 02ac 94209FE5 		ldr	r3, [r1, #0]
 510              		.loc 1 483 0
 511 02b0 003092E5 		mvn	r2, #0
 512 02b4 013083E2 		.loc 1 482 0
 513 02b8 003082E5 		add	r3, r3, #1
 514              		str	r3, [r1, #0]
 515              		.loc 1 483 0
 516              		str	ip, [r2, #-255]
 517 02bc 88109FE5 		b	.L29
 518 02c0 003091E5 	.LVL26:
 519              	.L20:
 520 02c4 0020E0E3 	.LBB50:
 521              	.LBB43:
 522 02c8 013083E2 		.loc 1 367 0
 523 02cc 003081E5 		tst	r1, #4096
 524              		.loc 1 368 0
 525 02d0 FFC002E5 		ldrne	r2, .L34+72
 526 02d4 8EFFFFEA 	.LVL27:
 527              		ldrne	r3, [r2, #0]
 528              		addne	r3, r3, #1
 529              		strne	r3, [r2, #0]
 530              		.loc 1 371 0
 531              		tst	r1, #8192
 532 02d8 010A11E3 		.loc 1 372 0
 533              		ldrne	r2, .L34+76
 534 02dc 6C209F15 		ldrne	r3, [r2, #0]
 535              		addne	r3, r3, #1
 536 02e0 00309215 		strne	r3, [r2, #0]
 537 02e4 01308312 	.LBE43:
 538 02e8 00308215 	.LBE50:
 539              		.loc 1 475 0
 540 02ec 020A11E3 		ldr	r2, .L34+32
 541              		b	.L30
 542 02f0 5C209F15 	.L35:
 543 02f4 00309215 		.align	2
 544 02f8 01308312 	.L34:
 545 02fc 00308215 		.word	DataCRCErrCount
 546              		.word	DataTimeoutErrCount
 547              		.word	DataTxUnderrunErrCount
 548              		.word	DataRxOverrunErrCount
 549 0300 20209FE5 		.word	DataStartbitErrCount
 550 0304 7CFFFFEA 		.word	MCI_DataErrorProcess_count
 551              		.word	DataBlockEndCount
 552              		.word	MCI_Block_End_Flag
 553              		.word	MCI_DATA_END_InterruptService_count
 554 0308 00000000 		.word	CmdCRCErrCount
 555 030c 00000000 		.word	CmdTimeoutErrCount
 556 0310 00000000 		.word	CmdRespEndCount
 557 0314 00000000 		.word	CmdSentCount
 558 0318 00000000 		.word	CmdActiveCount
 559 031c 00000000 		.word	MCI_CmdProcess_count
 560 0320 00000000 		.word	DataEndCount
 561 0324 00000000 		.word	DataFIFOCount
 562 0328 00000000 		.word	MCI_FIFOInterruptService_count
 563 032c 00000000 		.word	DataTxActiveCount
 564 0330 00000000 		.word	DataRxActiveCount
 565 0334 00000000 	.LFE17:
 567 033c 00000000 		.section	.text.MCI_Set_MCIClock,"ax",%progbits
 568 0340 00000000 		.align	2
 569 0344 00000000 		.global	MCI_Set_MCIClock
 571 034c 00000000 	MCI_Set_MCIClock:
 572 0350 00000000 	.LFB18:
 573 0354 00000000 		.loc 1 508 0
 574              		@ args = 0, pretend = 0, frame = 4
 575              		@ frame_needed = 1, uses_anonymous_args = 0
 576              	.LVL28:
 577              		mov	ip, sp
 578              	.LCFI15:
 579              		stmfd	sp!, {fp, ip, lr, pc}
 580              	.LCFI16:
 581              		.loc 1 512 0
 497:drivers_nxp/mci.c **** 
 498:drivers_nxp/mci.c **** /******************************************************************************
 499:drivers_nxp/mci.c ****  ** Function name:		MCI_Set_MCIClock
 500:drivers_nxp/mci.c ****  **
 501:drivers_nxp/mci.c ****  ** Descriptions:		Set MCI clock rate, during initialization phase < 400K
 502:drivers_nxp/mci.c ****  **						during data phase < 20Mhz.
 503:drivers_nxp/mci.c ****  **
 504:drivers_nxp/mci.c ****  ** parameters:			Clock rate to be set
 505:drivers_nxp/mci.c ****  ** Returned value:		None
 506:drivers_nxp/mci.c ****  ** 
 507:drivers_nxp/mci.c ****  ******************************************************************************/
 508:drivers_nxp/mci.c **** void MCI_Set_MCIClock(DWORD ClockRate) {
 582              	 #1
 583              		.loc 1 508 0
 584              		sub	fp, ip, #4
 585              	.LCFI17:
 586 0000 0DC0A0E1 		sub	sp, sp, #4
 587              	.LCFI18:
 588 0004 00D82DE9 		.loc 1 512 0
 589              		beq	.L37
 509:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas volatile
 510:drivers_nxp/mci.c **** 	DWORD ClkValue = 0;
 511:drivers_nxp/mci.c **** 
 512:drivers_nxp/mci.c **** 	if (ClockRate == SLOW_RATE) {
 590              	514 0
 591 0008 010050E3 		cmp	r0, #2
 592              		subeq	r0, r0, #2
 593 000c 04B04CE2 	.LVL29:
 594              		beq	.L38
 595 0010 04D04DE2 	.LVL30:
 596              	.L37:
 597              		mov	r0, #61
 598 0014 0200000A 	.LVL31:
 513:drivers_nxp/mci.c **** 		ClkValue |= MCLKDIV_SLOW; /* slow clock */
 514:drivers_nxp/mci.c **** 	} else if (ClockRate == NORMAL_RATE) {
 599              	oc 1 521 0
 600 0018 020050E3 		mov	r1, #-536870912
 601 001c 02004002 		add	r1, r1, #573440
 602              		ldr	r3, [r1, #4]
 603 0020 0000000A 		bic	r3, r3, #255
 604              		str	r3, [r1, #4]
 605              		.loc 1 524 0
 606 0024 3D00A0E3 		ldr	r2, [r1, #4]
 607              		orr	r2, r2, #768
 608              		orr	r2, r2, r0
 515:drivers_nxp/mci.c **** 		ClkValue |= MCLKDIV_NORMAL;/* normal clock */
 516:drivers_nxp/mci.c **** 	} else {
 517:drivers_nxp/mci.c **** 		// mthomas - added default - low
 518:drivers_nxp/mci.c **** 		ClkValue |= MCLKDIV_SLOW;
 519:drivers_nxp/mci.c **** 	}
 520:drivers_nxp/mci.c **** 
 521:drivers_nxp/mci.c **** 	MCI_CLOCK &= ~(0xFF);
 609              	5 0
 610 0028 0E12A0E3 		mov	r3, #0
 611 002c 231981E2 		.loc 1 524 0
 612 0030 043091E5 		str	r2, [r1, #4]
 613 0034 FF30C3E3 		.loc 1 525 0
 614 0038 043081E5 		str	r3, [fp, #-16]
 522:drivers_nxp/mci.c **** 	/* clear clock divider */
 523:drivers_nxp/mci.c **** 	// laebi: Disable MCI clock output when bus is idle (bit 9)
 524:drivers_nxp/mci.c **** 	MCI_CLOCK |= (1 << 8) | (1 << 9) | ClkValue;
 615              	:
 616 003c 042091E5 		ldr	r2, [fp, #-16]
 617 0040 032C82E3 		cmp	r2, #255
 618 0044 002082E1 		ldmhifd	sp, {r3, fp, sp, pc}
 525:drivers_nxp/mci.c **** 	for (i = 0; i < 0x100; i++)
 619              	:
 620 0048 0030A0E3 		ldr	r3, [fp, #-16]
 621              		add	r3, r3, #1
 622 004c 042081E5 	.LVL33:
 623              		str	r3, [fp, #-16]
 624 0050 10300BE5 		ldr	r2, [fp, #-16]
 625              		cmp	r2, #255
 626 0054 10201BE5 		bls	.L42
 627 0058 FF0052E3 	.LVL34:
 628 005c 08A89D88 		ldmfd	sp, {r3, fp, sp, pc}
 629              	.LFE18:
 631 0064 013083E2 		.section	.text.MCI_SendCmd,"ax",%progbits
 632              		.align	2
 633 0068 10300BE5 		.global	MCI_SendCmd
 635 0070 FF0052E3 	MCI_SendCmd:
 636 0074 F9FFFF9A 	.LFB21:
 637              		.loc 1 703 0
 638 0078 08A89DE8 		@ args = 0, pretend = 0, frame = 4
 639              		@ frame_needed = 1, uses_anonymous_args = 0
 640              	.LVL35:
 641              		mov	ip, sp
 642              	.LCFI19:
 643              		stmfd	sp!, {r4, r5, r6, fp, ip, lr, pc}
 644              	.LCFI20:
 645              		sub	fp, ip, #4
 646              	.LCFI21:
 526:drivers_nxp/mci.c **** 		; /* delay 3MCLK + 2PCLK before next write */
 527:drivers_nxp/mci.c **** 
 528:drivers_nxp/mci.c **** 	return;
 529:drivers_nxp/mci.c **** }
 530:drivers_nxp/mci.c **** 
 531:drivers_nxp/mci.c **** /******************************************************************************
 532:drivers_nxp/mci.c ****  ** Function name:		SD_Set_BusWidth
 533:drivers_nxp/mci.c ****  **
 534:drivers_nxp/mci.c ****  ** Descriptions:		1-bit bus or 4-bit bus.
 535:drivers_nxp/mci.c ****  **
 536:drivers_nxp/mci.c ****  ** parameters:			bus width
 537:drivers_nxp/mci.c ****  ** Returned value:		TRUE or FALSE
 538:drivers_nxp/mci.c ****  **
 539:drivers_nxp/mci.c ****  ** modified by Martin Thomas: do not set 4 bit if 
 540:drivers_nxp/mci.c ****  ** parameter is SD_1_BIT
 541:drivers_nxp/mci.c ****  ******************************************************************************/
 542:drivers_nxp/mci.c **** DWORD SD_Set_BusWidth(DWORD width) {
 543:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
 544:drivers_nxp/mci.c **** 
 545:drivers_nxp/mci.c **** 	for (i = 0; i < 0x10; i++)
 546:drivers_nxp/mci.c **** 		; /* delay 3MCLK + 2PCLK  */
 547:drivers_nxp/mci.c **** 
 548:drivers_nxp/mci.c **** 	if (width == SD_1_BIT) {
 549:drivers_nxp/mci.c **** 		MCI_CLOCK &= ~(1 << 11);
 550:drivers_nxp/mci.c **** 		/* 1 bit bus */
 551:drivers_nxp/mci.c **** 	} else if (width == SD_4_BIT) {
 552:drivers_nxp/mci.c **** 		MCI_CLOCK |= (1 << 11);
 553:drivers_nxp/mci.c **** 		/* 4 bit bus */
 554:drivers_nxp/mci.c **** 		// mthomas - moved this here from below
 555:drivers_nxp/mci.c **** 		if (MCI_Send_ACMD_Bus_Width( BUS_WIDTH_4BITS) == FALSE) {
 556:drivers_nxp/mci.c **** 			mci_debug_printf("setting 4bit width failed\n");
 557:drivers_nxp/mci.c **** 			return ( FALSE );
 558:drivers_nxp/mci.c **** 		}mci_debug_printf("setting 4bit width success\n");
 559:drivers_nxp/mci.c **** 	} else {
 560:drivers_nxp/mci.c **** 		// mthomas - added default
 561:drivers_nxp/mci.c **** 		MCI_CLOCK &= ~(1 << 11);
 562:drivers_nxp/mci.c **** 		/* 1 bit bus */
 563:drivers_nxp/mci.c **** 	}
 564:drivers_nxp/mci.c **** 
 565:drivers_nxp/mci.c **** #if 0
 566:drivers_nxp/mci.c **** 	// mthomas - TODO: why set 4bit if param is given as SD_1_BIT?
 567:drivers_nxp/mci.c **** 	if ( MCI_Send_ACMD_Bus_Width( BUS_WIDTH_4BITS ) == FALSE )
 568:drivers_nxp/mci.c **** 	{
 569:drivers_nxp/mci.c **** 		return( FALSE );
 570:drivers_nxp/mci.c **** 	}
 571:drivers_nxp/mci.c **** #endif
 572:drivers_nxp/mci.c **** 
 573:drivers_nxp/mci.c **** 	return ( TRUE );
 574:drivers_nxp/mci.c **** }
 575:drivers_nxp/mci.c **** 
 576:drivers_nxp/mci.c **** /******************************************************************************
 577:drivers_nxp/mci.c ****  ** Function name:		MCI_Init
 578:drivers_nxp/mci.c ****  **
 579:drivers_nxp/mci.c ****  ** Descriptions:		Set MCI clock and power registers, setup VIC for
 580:drivers_nxp/mci.c ****  **						data interrupt.
 581:drivers_nxp/mci.c ****  **
 582:drivers_nxp/mci.c ****  ** parameters:			None
 583:drivers_nxp/mci.c ****  ** Returned value:		true or false, if VIC table is full, return false
 584:drivers_nxp/mci.c ****  **
 585:drivers_nxp/mci.c ****  ** modified by Martin Thomas to avoid that the
 586:drivers_nxp/mci.c ****  ** hard-coded pinsel-values disable other functions
 587:drivers_nxp/mci.c ****  ******************************************************************************/
 588:drivers_nxp/mci.c **** DWORD MCI_Init(void) {
 589:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
 590:drivers_nxp/mci.c **** 
 591:drivers_nxp/mci.c **** 	PCONP |= ( 1 << 28 );
 592:drivers_nxp/mci.c **** 	/* Enable clock to the MCI block */
 593:drivers_nxp/mci.c **** 
 594:drivers_nxp/mci.c **** 	if ( MCI_CLOCK & (1 << 8)) {
 595:drivers_nxp/mci.c **** 		MCI_CLOCK &= ~(1 << 8);
 596:drivers_nxp/mci.c **** 	}
 597:drivers_nxp/mci.c **** 	if ( MCI_POWER & 0x02) {
 598:drivers_nxp/mci.c **** 		MCI_POWER = 0x00;
 599:drivers_nxp/mci.c **** 	}
 600:drivers_nxp/mci.c **** 	for (i = 0; i < 0x1000; i++)
 601:drivers_nxp/mci.c **** 		;
 602:drivers_nxp/mci.c **** 
 603:drivers_nxp/mci.c **** 	/* Disable all interrupts for now */
 604:drivers_nxp/mci.c **** 	MCI_MASK0 = 0;
 605:drivers_nxp/mci.c **** 	MCI_MASK1 = MCI_MASK0;
 606:drivers_nxp/mci.c **** 
 607:drivers_nxp/mci.c **** 	/* Due to reversed H/W logic in the MCB2300 board, the MCI power pin
 608:drivers_nxp/mci.c **** 	 needs to be configured as GPIO pin that I need to set it active low manually, 
 609:drivers_nxp/mci.c **** 	 once it's set as MCI power pin, it will be active high. */
 610:drivers_nxp/mci.c **** 	/*connect MCI signals to P0.19-P0.22, and P2.11-P2.13*/
 611:drivers_nxp/mci.c **** 
 612:drivers_nxp/mci.c **** 	// laebi: EA_BOARD pinout is different
 613:drivers_nxp/mci.c **** #if EA_BOARD_LPC24XX
 614:drivers_nxp/mci.c **** #warning EA24
 615:drivers_nxp/mci.c **** 	PINSEL1 = ( PINSEL1 & ~( (3<<12) )) | ((2<<12));
 616:drivers_nxp/mci.c **** 	PINSEL2 = ( PINSEL2 & ~( (3<<4)|(3<<6)|(3<<10)|(3<<14)|(3<<22)|(3<<24)) )
 617:drivers_nxp/mci.c **** 	| ((2<<4)|(2<<6)|(2<<10)|(2<<14)|(2<<22)|(2<<24));
 618:drivers_nxp/mci.c **** #elif (IAR_BOARD_LPC23XX) || (KEIL_BOARD_LPC23XX)
 619:drivers_nxp/mci.c **** #warning EA,OMX23/Keil23
 620:drivers_nxp/mci.c **** /*	PINSEL1 = ( PINSEL1 & ~( (3<<6)|(3<<8)|(3<<10)|(3<<12) ) )
 621:drivers_nxp/mci.c **** 	| ((2<<6)|(2<<8)|(2<<10)|(2<<12));
 622:drivers_nxp/mci.c **** 	PINSEL4 = ( PINSEL4 & ~((3<<22)|(3<<24)|(3<<26) ) )
 623:drivers_nxp/mci.c **** 	| ((2<<22)|(2<<24)|(2<<26) );*/
 624:drivers_nxp/mci.c **** 	  PINSEL1 &= 0xFFFFC03F;
 625:drivers_nxp/mci.c **** 	  PINSEL1 |= 0x2A80;	/*Sets Clock, command,DAT0+ Power*/
 626:drivers_nxp/mci.c **** 
 627:drivers_nxp/mci.c **** 	  PINSEL2 &=0xFD7F7FFF;
 628:drivers_nxp/mci.c **** 	  PINSEL2 |=0x02808000;
 629:drivers_nxp/mci.c **** #else
 630:drivers_nxp/mci.c **** #warning NXP default
 631:drivers_nxp/mci.c **** 	PINSEL1 = 0x2A80;
 632:drivers_nxp/mci.c **** 	PINSEL4 = 0x0A800000;
 633:drivers_nxp/mci.c **** #endif
 634:drivers_nxp/mci.c **** 
 635:drivers_nxp/mci.c **** #if MCB2300_VERSION_0
 636:drivers_nxp/mci.c **** #warning SCS MCIPWR active level high
 637:drivers_nxp/mci.c **** 	SCS |= 0x08;
 638:drivers_nxp/mci.c **** #if 0
 639:drivers_nxp/mci.c **** 	PINSEL1 = 0x2280;
 640:drivers_nxp/mci.c **** 	PINSEL4 = 0x0A800000;
 641:drivers_nxp/mci.c **** 	IODIR0 = 1 << 21; /* MCI_PWR as GPIO output */
 642:drivers_nxp/mci.c **** 	IOCLR0 = 1 << 21;
 643:drivers_nxp/mci.c **** #endif
 644:drivers_nxp/mci.c **** #else
 645:drivers_nxp/mci.c **** 	// #warning SCS MCIPWR active level low
 646:drivers_nxp/mci.c **** 	SCS &= ~0x08;
 647:drivers_nxp/mci.c **** #if 0
 648:drivers_nxp/mci.c **** 	PINSEL1 = 0x2A80;
 649:drivers_nxp/mci.c **** 	PINSEL4 = 0x0A800000;
 650:drivers_nxp/mci.c **** #endif
 651:drivers_nxp/mci.c **** #endif
 652:drivers_nxp/mci.c **** 
 653:drivers_nxp/mci.c **** 	/*set up clocking default mode, clear any registers as needed */
 654:drivers_nxp/mci.c **** 	MCI_COMMAND = 0;
 655:drivers_nxp/mci.c **** 	MCI_DATA_CTRL = 0;
 656:drivers_nxp/mci.c **** 	MCI_CLEAR = 0x7FF;
 657:drivers_nxp/mci.c **** 	/* clear all pending interrupts */
 658:drivers_nxp/mci.c **** 
 659:drivers_nxp/mci.c **** 	MCI_POWER = 0x02;
 660:drivers_nxp/mci.c **** 	/* power up */
 661:drivers_nxp/mci.c **** 	while ( !(MCI_POWER & 0x02)) {
 662:drivers_nxp/mci.c **** 		;
 663:drivers_nxp/mci.c **** 	}
 664:drivers_nxp/mci.c **** 	for (i = 0; i < 0x100; i++) {
 665:drivers_nxp/mci.c **** 		;
 666:drivers_nxp/mci.c **** 	}
 667:drivers_nxp/mci.c **** 
 668:drivers_nxp/mci.c **** 	/* During identification phase, the clock should be less than
 669:drivers_nxp/mci.c **** 	 400Khz. Once we pass this phase, the normal clock can be set up
 670:drivers_nxp/mci.c **** 	 to 25Mhz on SD card and 20Mhz on MMC card. */
 671:drivers_nxp/mci.c **** 	MCI_Set_MCIClock( SLOW_RATE);
 672:drivers_nxp/mci.c **** 	MCI_POWER |= 0x01;
 673:drivers_nxp/mci.c **** 	/* bit 1 is set already, from power up to power on */
 674:drivers_nxp/mci.c **** 
 675:drivers_nxp/mci.c **** 	for (i = 0; i < 0x2000; i++) {
 676:drivers_nxp/mci.c **** 		;
 677:drivers_nxp/mci.c **** 	}
 678:drivers_nxp/mci.c **** 	if (install_irq( MCI_INT, (void *)MCI_IRQHandler, HIGHEST_PRIORITY+1) == FALSE) {
 679:drivers_nxp/mci.c **** 		return ( FALSE );
 680:drivers_nxp/mci.c **** 	}
 681:drivers_nxp/mci.c **** 
 682:drivers_nxp/mci.c **** 	/* During the initialization phase, to simplify the process, the CMD related 
 683:drivers_nxp/mci.c **** 	 interrupts are disabled. The DATA related interrupts are enabled when
 684:drivers_nxp/mci.c **** 	 the FIFOs are used and just before WRITE_BLOCK READ_BLOCK cmds are issues, and 
 685:drivers_nxp/mci.c **** 	 disabled after the data block has been written and read. Please also note,
 686:drivers_nxp/mci.c **** 	 before WRITE_BLOCK only TX related data interrupts are enabled, and before
 687:drivers_nxp/mci.c **** 	 READ_BLOCK only RX related data interrupts are enabled. */
 688:drivers_nxp/mci.c **** 
 689:drivers_nxp/mci.c **** 	mci_debug_printf("MCI_INIT ok\n");
 690:drivers_nxp/mci.c **** 	return ( TRUE );
 691:drivers_nxp/mci.c **** }
 692:drivers_nxp/mci.c **** 
 693:drivers_nxp/mci.c **** /******************************************************************************
 694:drivers_nxp/mci.c ****  ** Function name:		MCI_SendCmd
 695:drivers_nxp/mci.c ****  **
 696:drivers_nxp/mci.c ****  ** Descriptions:		The routine is used to send a CMD to the card		
 697:drivers_nxp/mci.c ****  **
 698:drivers_nxp/mci.c ****  ** parameters:			CmdIndex, Argument, ExpectResp Flag, AllowTimeout flag
 699:drivers_nxp/mci.c ****  ** Returned value:		None
 700:drivers_nxp/mci.c ****  ** 
 701:drivers_nxp/mci.c ****  ******************************************************************************/
 702:drivers_nxp/mci.c **** void MCI_SendCmd(DWORD CmdIndex, DWORD Argument, DWORD ExpectResp,
 703:drivers_nxp/mci.c **** 		DWORD AllowTimeout) {
 647              	oc 1 710 0
 648              		mov	r4, #-536870912
 649              		.loc 1 703 0
 650              		.loc 1 710 0
 651 0000 0DC0A0E1 		add	r4, r4, #573440
 652              		ldr	ip, [r4, #52]
 653 0004 70D82DE9 	.LVL36:
 654              		tst	ip, #2048
 655 0008 04B04CE2 		.loc 1 703 0
 656              		mov	r6, r1
 657 000c 04D04DE2 		mov	r5, r3
 658              		mov	r1, r2
 704:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
 705:drivers_nxp/mci.c **** 	DWORD CmdData = 0;
 706:drivers_nxp/mci.c **** 	DWORD CmdStatus;
 707:drivers_nxp/mci.c **** 
 708:drivers_nxp/mci.c **** 	/* the command engine must be disabled when we modify the argument
 709:drivers_nxp/mci.c **** 	 or the peripheral resends */
 710:drivers_nxp/mci.c **** 	while ( (CmdStatus = MCI_STATUS) & MCI_CMD_ACTIVE) /* Command in progress. */
 659              	c 1 710 0
 660 0010 0E42A0E3 		beq	.L45
 661              	.LVL38:
 662              		.loc 1 712 0
 663 0014 234984E2 		mov	r2, r4
 664 0018 34C094E5 		mov	r4, #0
 665              	.L56:
 666 001c 020B1CE3 		.loc 1 713 0
 667              		orr	r3, ip, #2048
 668 0020 0160A0E1 		.loc 1 712 0
 669 0024 0350A0E1 		str	r4, [r2, #12]
 670 0028 0210A0E1 		.loc 1 713 0
 671              		str	r3, [r2, #56]
 672              		.loc 1 710 0
 673 002c 0700000A 		ldr	ip, [r2, #52]
 674              		tst	ip, #2048
 711:drivers_nxp/mci.c **** 	{
 712:drivers_nxp/mci.c **** 		MCI_COMMAND = 0;
 675              	:
 676 0030 0420A0E1 	.L45:
 677 0034 0040A0E3 		.loc 1 715 0
 678              		mov	r3, #0
 713:drivers_nxp/mci.c **** 		MCI_CLEAR = CmdStatus | MCI_CMD_ACTIVE;
 679              		r3, [fp, #-28]
 680 0038 023B8CE3 	.LVL40:
 681              		ldr	r2, [fp, #-28]
 682 003c 0C4082E5 		cmp	r2, #255
 683              		bhi	.L47
 684 0040 383082E5 	.L55:
 685              		ldr	r3, [fp, #-28]
 686 0044 34C092E5 		add	r3, r3, #1
 687 0048 020B1CE3 	.LVL41:
 688 004c F9FFFF1A 		str	r3, [fp, #-28]
 689              		ldr	r2, [fp, #-28]
 690              		cmp	r2, #255
 714:drivers_nxp/mci.c **** 	}
 715:drivers_nxp/mci.c **** 	for (i = 0; i < 0x100; i++) {
 691              	VL42:
 692 0050 0030A0E3 	.L47:
 693 0054 1C300BE5 		.loc 1 721 0
 694              		cmp	r1, #0
 695 0058 1C201BE5 		.loc 1 720 0
 696 005c FF0052E3 		and	r0, r0, #63
 697 0060 0500008A 	.LVL43:
 698              		.loc 1 721 0
 699 0064 1C301BE5 		beq	.L50
 700 0068 013083E2 		.loc 1 724 0
 701              		cmp	r1, #1
 702 006c 1C300BE5 		.loc 1 726 0
 703 0070 1C201BE5 		orreq	r0, r0, #64
 704 0074 FF0052E3 		.loc 1 724 0
 705 0078 F9FFFF9A 		beq	.L50
 706              		.loc 1 727 0
 707              		cmp	r1, #2
 716:drivers_nxp/mci.c **** 		;
 717:drivers_nxp/mci.c **** 	}
 718:drivers_nxp/mci.c **** 
 719:drivers_nxp/mci.c **** 	/*set the command details, the CmdIndex should 0 through 0x3F only */
 720:drivers_nxp/mci.c **** 	CmdData |= (CmdIndex & 0x3F); /* bit 0 through 5 only */
 721:drivers_nxp/mci.c **** 	if (ExpectResp == EXPECT_NO_RESP) /* no response */
 708              	req	r0, r0, #192
 709 007c 000051E3 	.L50:
 710              		.loc 1 732 0
 711 0080 3F0000E2 		cmp	r5, #0
 712              		.loc 1 734 0
 713              		orrne	r0, r0, #256
 714 0084 0400000A 	.LVL44:
 722:drivers_nxp/mci.c **** 	{
 723:drivers_nxp/mci.c **** 		CmdData &= ~((1 << 6) | (1 << 7)); /* Clear long response bit as well */
 724:drivers_nxp/mci.c **** 	} else if (ExpectResp == EXPECT_SHORT_RESP) /* expect short response */
 715              	 736 0
 716 0088 010051E3 		biceq	r0, r0, #256
 725:drivers_nxp/mci.c **** 	{
 726:drivers_nxp/mci.c **** 		CmdData |= (1 << 6);
 717              	loc 1 741 0
 718 008c 40008003 		mov	r3, #-536870912
 719              		add	r3, r3, #573440
 720 0090 0100000A 		.loc 1 740 0
 727:drivers_nxp/mci.c **** 	} else if (ExpectResp == EXPECT_LONG_RESP) /* expect long response */
 721              		r2, r0, #1024
 722 0094 020051E3 	.LVL45:
 728:drivers_nxp/mci.c **** 	{
 729:drivers_nxp/mci.c **** 		CmdData |= (1 << 6) | (1 << 7);
 723              	loc 1 741 0
 724 0098 C0008003 		str	r6, [r3, #8]
 725              		.loc 1 743 0
 730:drivers_nxp/mci.c **** 	}
 731:drivers_nxp/mci.c **** 
 732:drivers_nxp/mci.c **** 	if (AllowTimeout) /* allow timeout or not */
 726              	r	r2, [r3, #12]
 727 009c 000055E3 		.loc 1 746 0
 733:drivers_nxp/mci.c **** 	{
 734:drivers_nxp/mci.c **** 		CmdData |= (1 << 8);
 728              	dmfd	sp, {r3, r4, r5, r6, fp, sp, pc}
 729 00a0 010C8013 	.LFE21:
 735:drivers_nxp/mci.c **** 	} else {
 736:drivers_nxp/mci.c **** 		CmdData &= ~(1 << 8);
 731              	ection	.text.MCI_GetCmdResp,"ax",%progbits
 732 00a4 010CC003 		.align	2
 737:drivers_nxp/mci.c **** 	}
 738:drivers_nxp/mci.c **** 
 739:drivers_nxp/mci.c **** 	/*send the command*/
 740:drivers_nxp/mci.c **** 	CmdData |= (1 << 10); /* This bit needs to be set last. */
 741:drivers_nxp/mci.c **** 	MCI_ARGUMENT = Argument;
 733              	global	MCI_GetCmdResp
 735 00ac 233983E2 	MCI_GetCmdResp:
 736              	.LFB22:
 737 00b0 012B80E3 		.loc 1 767 0
 738              		@ args = 0, pretend = 0, frame = 0
 739              		@ frame_needed = 1, uses_anonymous_args = 0
 740 00b4 086083E5 	.LVL46:
 742:drivers_nxp/mci.c **** 	/* Set the argument first, finally command */
 743:drivers_nxp/mci.c **** 	MCI_COMMAND = CmdData;
 741              	 sp
 742 00b8 0C2083E5 	.LCFI23:
 744:drivers_nxp/mci.c **** 
 745:drivers_nxp/mci.c **** 	return;
 746:drivers_nxp/mci.c **** }
 743              	tmfd	sp!, {r4, r5, fp, ip, lr, pc}
 744 00bc 78A89DE8 	.LCFI24:
 745              		.loc 1 771 0
 746              		subs	r5, r1, #0
 747              		.loc 1 767 0
 748              		sub	fp, ip, #4
 749              	.LCFI25:
 750              		.loc 1 767 0
 751              		mov	r4, r2
 752              		mov	ip, r0
 747:drivers_nxp/mci.c **** 
 748:drivers_nxp/mci.c **** /******************************************************************************
 749:drivers_nxp/mci.c ****  ** Function name:		MCI_GetCmdResp
 750:drivers_nxp/mci.c ****  **
 751:drivers_nxp/mci.c ****  ** Descriptions:		Get response from the card. This module is always used
 752:drivers_nxp/mci.c ****  **						in pair with MCI_SendCmd()		
 753:drivers_nxp/mci.c ****  **
 754:drivers_nxp/mci.c ****  ** parameters:			Expected cmd data, expect response flag, pointer to the 
 755:drivers_nxp/mci.c ****  **						response
 756:drivers_nxp/mci.c ****  **						Expected cmd data should be the same as that in SendCmd()
 757:drivers_nxp/mci.c ****  **						expect response flag could be	EXPECT_NO_RESP
 758:drivers_nxp/mci.c ****  **														EXPECT_SHORT_RESP
 759:drivers_nxp/mci.c ****  **														EXPECT_LONG_RESP
 760:drivers_nxp/mci.c ****  **						if GetCmdResp() is 0, check the pointer to the response
 761:drivers_nxp/mci.c ****  **						field to get the response value, if GetCmdResp() returns 
 762:drivers_nxp/mci.c ****  **						non-zero, no need to check the response field, just resend
 763:drivers_nxp/mci.c ****  **						command or bailout. 
 764:drivers_nxp/mci.c ****  ** Returned value:		Response status, 0 is valid response. 
 765:drivers_nxp/mci.c ****  ** 
 766:drivers_nxp/mci.c ****  ******************************************************************************/
 767:drivers_nxp/mci.c **** DWORD MCI_GetCmdResp(DWORD ExpectCmdData, DWORD ExpectResp, DWORD *CmdResp) {
 753              	1 0
 754              		beq	.L60
 755              	.LVL47:
 756              		.loc 1 776 0
 757 0000 0DC0A0E1 		mov	r3, #-536870912
 758              		add	r3, r3, #573440
 759 0004 30D82DE9 	.LVL48:
 760              	.L70:
 768:drivers_nxp/mci.c **** 	DWORD CmdRespStatus = 0;
 769:drivers_nxp/mci.c **** 	DWORD LastCmdIndex;
 770:drivers_nxp/mci.c **** 
 771:drivers_nxp/mci.c **** 	if (ExpectResp == EXPECT_NO_RESP) {
 761              	 [r3, #52]
 762 0008 005051E2 		mov	r1, #-536870912
 763              		.loc 1 777 0
 764 000c 04B04CE2 		tst	r0, #4
 765              		.loc 1 776 0
 766              		add	r1, r1, #573440
 767 0010 0240A0E1 		.loc 1 777 0
 768 0014 00C0A0E1 		bne	.L72
 769              		.loc 1 783 0
 770 0018 1D00000A 		tst	r0, #1
 771              		bne	.L73
 772:drivers_nxp/mci.c **** 		return ( 0 );
 773:drivers_nxp/mci.c **** 	}
 774:drivers_nxp/mci.c **** 
 775:drivers_nxp/mci.c **** 	while ( 1) {
 776:drivers_nxp/mci.c **** 		CmdRespStatus = MCI_STATUS;
 772              	 0
 773 001c 0E32A0E3 		tst	r0, #64
 774 0020 233983E2 		beq	.L70
 775              		.loc 1 797 0
 776              		orr	r3, r0, #64
 777 0024 340093E5 		str	r3, [r1, #56]
 778 0028 0E12A0E3 	.L65:
 777:drivers_nxp/mci.c **** 		if (CmdRespStatus & (MCI_CMD_TIMEOUT)) {
 779              	 802 0
 780 002c 040010E3 		mov	r3, #-536870912
 781              		add	r3, r3, #573440
 782 0030 231981E2 		ldr	r2, [r3, #16]
 783              		and	r2, r2, #63
 784 0034 2A00001A 		cmp	r2, ip
 778:drivers_nxp/mci.c **** 			MCI_CLEAR = CmdRespStatus | MCI_CMD_TIMEOUT;
 779:drivers_nxp/mci.c **** 			MCI_COMMAND = 0;
 780:drivers_nxp/mci.c **** 			MCI_ARGUMENT = 0xFFFFFFFF;
 781:drivers_nxp/mci.c **** 			return (CmdRespStatus );
 782:drivers_nxp/mci.c **** 		}
 783:drivers_nxp/mci.c **** 		if (CmdRespStatus & MCI_CMD_CRC_FAIL) {
 785              	L67
 786 0038 010010E3 		.loc 1 807 0
 787 003c 2F00001A 		cmp	ip, #1
 784:drivers_nxp/mci.c **** 			MCI_CLEAR = CmdRespStatus | MCI_CMD_CRC_FAIL;
 785:drivers_nxp/mci.c **** 			LastCmdIndex = MCI_COMMAND & 0x003F;
 786:drivers_nxp/mci.c **** 			if ( (LastCmdIndex == SEND_OP_COND) || (LastCmdIndex
 787:drivers_nxp/mci.c **** 					== SEND_APP_OP_COND) || (LastCmdIndex == STOP_TRANSMISSION)) {
 788:drivers_nxp/mci.c **** 				MCI_COMMAND = 0;
 789:drivers_nxp/mci.c **** 				MCI_ARGUMENT = 0xFFFFFFFF;
 790:drivers_nxp/mci.c **** 				break; /* ignore CRC error if it's a resp for SEND_OP_COND 
 791:drivers_nxp/mci.c **** 				 or STOP_TRANSMISSION. */
 792:drivers_nxp/mci.c **** 			} else {
 793:drivers_nxp/mci.c **** 				mci_debug_printf("*** CRCfail");
 794:drivers_nxp/mci.c **** 				return (CmdRespStatus );
 795:drivers_nxp/mci.c **** 			}
 796:drivers_nxp/mci.c **** 		} else if (CmdRespStatus & MCI_CMD_RESP_END) {
 788              	pne	ip, #41
 789 0040 400010E3 		beq	.L67
 790 0044 F6FFFF0A 		cmp	ip, #2
 797:drivers_nxp/mci.c **** 			MCI_CLEAR = CmdRespStatus | MCI_CMD_RESP_END;
 791              	pne	ip, #9
 792 0048 403080E3 		mvnne	r0, #0
 793 004c 383081E5 		ldmnefd	sp, {r4, r5, fp, sp, pc}
 794              	.L67:
 798:drivers_nxp/mci.c **** 			break; /* cmd response is received, expecting response */
 799:drivers_nxp/mci.c **** 		}
 800:drivers_nxp/mci.c **** 	}
 801:drivers_nxp/mci.c **** 
 802:drivers_nxp/mci.c **** 	if ( (MCI_RESP_CMD & 0x3F) != ExpectCmdData) {
 795              	c 1 815 0
 796 0050 0E32A0E3 		cmp	r5, #1
 797 0054 233983E2 		beq	.L74
 798 0058 102093E5 		.loc 1 817 0
 799 005c 3F2002E2 		cmp	r5, #2
 800 0060 0C0052E1 		beq	.L75
 801 0064 0600000A 	.LVL49:
 803:drivers_nxp/mci.c **** 		/* If the response is not R1, in the response field, the Expected Cmd data
 804:drivers_nxp/mci.c **** 		 won't be the same as the CMD data in SendCmd(). Below four cmds have
 805:drivers_nxp/mci.c **** 		 R2 or R3 response. We don't need to check if MCI_RESP_CMD is the same
 806:drivers_nxp/mci.c **** 		 as the Expected or not. */
 807:drivers_nxp/mci.c **** 		if ( (ExpectCmdData != SEND_OP_COND) && (ExpectCmdData
 802              	.loc 1 821 0
 803 0068 01005CE3 		mov	r0, #0
 804 006c 29005C13 	.LVL50:
 805 0070 0300000A 		.loc 1 824 0
 806 0074 02005CE3 		ldmfd	sp, {r4, r5, fp, sp, pc}
 807 0078 09005C13 	.LVL51:
 808 007c 0000E013 	.L75:
 809 0080 30A89D18 		.loc 1 818 0
 810              		mov	r1, #-536870912
 808:drivers_nxp/mci.c **** 				!= SEND_APP_OP_COND) && (ExpectCmdData != ALL_SEND_CID)
 809:drivers_nxp/mci.c **** 				&& (ExpectCmdData != SEND_CSD)) {
 810:drivers_nxp/mci.c **** 			CmdRespStatus = INVALID_RESPONSE; /* Reuse error status */
 811:drivers_nxp/mci.c **** 			return ( INVALID_RESPONSE );
 812:drivers_nxp/mci.c **** 		}
 813:drivers_nxp/mci.c **** 	}
 814:drivers_nxp/mci.c **** 
 815:drivers_nxp/mci.c **** 	if (ExpectResp == EXPECT_SHORT_RESP) {
 811              	r1, #573440
 812 0084 010055E3 		ldr	r3, [r1, #20]
 813 0088 0F00000A 		str	r3, [r4, #0]
 816:drivers_nxp/mci.c **** 		*CmdResp = MCI_RESP0;
 817:drivers_nxp/mci.c **** 	} else if (ExpectResp == EXPECT_LONG_RESP) {
 814              	oc 1 819 0
 815 008c 020055E3 		ldr	r2, [r1, #24]
 816 0090 0100000A 		str	r2, [r4, #4]
 817              		.loc 1 820 0
 818              		ldr	r3, [r1, #28]
 818:drivers_nxp/mci.c **** 		*CmdResp = MCI_RESP0;
 819:drivers_nxp/mci.c **** 		*(CmdResp+1) = MCI_RESP1;
 820:drivers_nxp/mci.c **** 		*(CmdResp+2) = MCI_RESP2;
 821:drivers_nxp/mci.c **** 		*(CmdResp+3) = MCI_RESP3;
 819              	r3, [r4, #8]
 820 0094 0000A0E3 		.loc 1 821 0
 821              		ldr	r2, [r1, #32]
 822:drivers_nxp/mci.c **** 	}
 823:drivers_nxp/mci.c **** 	return ( 0 ); /* Read MCI_RESP0 register assuming it's not long response. */
 824:drivers_nxp/mci.c **** }
 822              	v	r0, #0
 823 0098 30A89DE8 		str	r2, [r4, #12]
 824              		ldmfd	sp, {r4, r5, fp, sp, pc}
 825              	.L74:
 826              		.loc 1 816 0
 827 009c 0E12A0E3 		mov	r3, #-536870912
 828 00a0 231981E2 		add	r3, r3, #573440
 829 00a4 143091E5 		ldr	r2, [r3, #20]
 830 00a8 003084E5 		mov	r0, #0
 831              		str	r2, [r4, #0]
 832 00ac 182091E5 		ldmfd	sp, {r4, r5, fp, sp, pc}
 833 00b0 042084E5 	.LVL52:
 834              	.L72:
 835 00b4 1C3091E5 		.loc 1 778 0
 836 00b8 083084E5 		orr	r3, r0, #4
 837              		str	r3, [r1, #56]
 838 00bc 202091E5 		.loc 1 779 0
 839 00c0 0000A0E3 		mov	r2, #0
 840 00c4 0C2084E5 		.loc 1 780 0
 841 00c8 30A89DE8 		mvn	r3, #0
 842              		.loc 1 779 0
 843              		str	r2, [r1, #12]
 844 00cc 0E32A0E3 		.loc 1 780 0
 845 00d0 233983E2 		str	r3, [r1, #8]
 846 00d4 142093E5 		ldmfd	sp, {r4, r5, fp, sp, pc}
 847 00d8 0000A0E3 	.LVL53:
 848 00dc 002084E5 	.L73:
 849 00e0 30A89DE8 		.loc 1 784 0
 850              		orr	r3, r0, #1
 851              		str	r3, [r1, #56]
 852              		.loc 1 785 0
 853 00e4 043080E3 		ldr	r2, [r1, #12]
 854 00e8 383081E5 		and	r2, r2, #63
 855              	.LVL54:
 856 00ec 0020A0E3 		.loc 1 786 0
 857              		cmp	r2, #41
 858 00f0 0030E0E3 		cmpne	r2, #1
 859              		bne	.L76
 860 00f4 0C2081E5 	.L64:
 861              		.loc 1 788 0
 862 00f8 083081E5 		mov	r3, #-536870912
 863 00fc 30A89DE8 		add	r3, r3, #573440
 864              		mov	r2, #0
 865              	.LVL55:
 866              		.loc 1 789 0
 867 0100 013080E3 		mvn	r1, #0
 868 0104 383081E5 		.loc 1 788 0
 869              		str	r2, [r3, #12]
 870 0108 0C2091E5 		.loc 1 789 0
 871 010c 3F2002E2 		str	r1, [r3, #8]
 872              		b	.L65
 873              	.LVL56:
 874 0110 290052E3 	.L76:
 875 0114 01005213 		.loc 1 786 0
 876 0118 0600001A 		cmp	r2, #12
 877              		ldmnefd	sp, {r4, r5, fp, sp, pc}
 878              		b	.L64
 879 011c 0E32A0E3 	.LFE22:
 881 0124 0020A0E3 		.section	.text.MCI_Go_Idle_State,"ax",%progbits
 882              		.align	2
 883              		.global	MCI_Go_Idle_State
 885              	MCI_Go_Idle_State:
 886 012c 0C2083E5 	.LFB23:
 887              		.loc 1 836 0
 888 0130 081083E5 		@ args = 0, pretend = 0, frame = 16
 889 0134 C5FFFFEA 		@ frame_needed = 1, uses_anonymous_args = 0
 890              		mov	ip, sp
 891              	.LCFI26:
 892              		stmfd	sp!, {r4, r5, fp, ip, lr, pc}
 893 0138 0C0052E3 	.LCFI27:
 894 013c 30A89D18 		sub	fp, ip, #4
 895 0140 F5FFFFEA 	.LCFI28:
 896              		sub	sp, sp, #16
 897              	.LCFI29:
 898              		.loc 1 836 0
 899              		mov	r4, #32
 900              	.LVL57:
 901              		sub	r5, fp, #36
 902              		b	.L80
 903              	.L78:
 825:drivers_nxp/mci.c **** 
 826:drivers_nxp/mci.c **** /******************************************************************************
 827:drivers_nxp/mci.c ****  ** Function name:		MCI_Go_Idle_State
 828:drivers_nxp/mci.c ****  **
 829:drivers_nxp/mci.c ****  ** Descriptions:		CMD0, the very first command to be sent to initialize
 830:drivers_nxp/mci.c ****  **						either MMC or SD card.
 831:drivers_nxp/mci.c ****  **
 832:drivers_nxp/mci.c ****  ** parameters:			None
 833:drivers_nxp/mci.c ****  ** Returned value:		true or false, true if card has been initialized.
 834:drivers_nxp/mci.c ****  ** 
 835:drivers_nxp/mci.c ****  ******************************************************************************/
 836:drivers_nxp/mci.c **** DWORD MCI_Go_Idle_State(void) {
 904              	r0
 905              		mov	r2, r0
 906              		mov	r3, r0
 907 0000 0DC0A0E1 		bl	MCI_SendCmd
 908              		.loc 1 845 0
 909 0004 30D82DE9 		mov	r0, #0
 910              		mov	r1, r0
 911 0008 04B04CE2 		mov	r2, r5
 912              		bl	MCI_GetCmdResp
 913 000c 10D04DE2 		.loc 1 846 0
 914              		cmp	r0, #0
 915              		bne	.L78
 916 0010 2040A0E3 		add	r0, r0, #1
 917              	.L79:
 918 0014 24504BE2 		.loc 1 858 0
 919 0018 010000EA 		sub	sp, fp, #20
 920              		ldmfd	sp, {r4, r5, fp, sp, pc}
 837:drivers_nxp/mci.c **** 	DWORD retryCount;
 838:drivers_nxp/mci.c **** 	DWORD respStatus;
 839:drivers_nxp/mci.c **** 	DWORD respValue[4];
 840:drivers_nxp/mci.c **** 
 841:drivers_nxp/mci.c **** 	retryCount = 0x20;
 842:drivers_nxp/mci.c **** 	while (retryCount > 0) {
 921              	 0
 922 001c 014054E2 		mov	r0, r4
 923 0020 0D00000A 		b	.L79
 924              	.LFE23:
 843:drivers_nxp/mci.c **** 		/* Send CMD0 command repeatedly until the response is back correctly */
 844:drivers_nxp/mci.c **** 		MCI_SendCmd( GO_IDLE_STATE, 0x00000000, EXPECT_NO_RESP, 0);
 925              	ze	MCI_Go_Idle_State, .-MCI_Go_Idle_State
 926 0024 0000A0E3 		.section	.text.MCI_Send_ACMD,"ax",%progbits
 927 0028 0010A0E1 		.align	2
 929 0030 0030A0E1 	MCI_Send_ACMD:
 930 0034 FEFFFFEB 	.LFB25:
 845:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( GO_IDLE_STATE, EXPECT_NO_RESP, (DWORD *)respValue);
 931              	1 904 0
 932 0038 0000A0E3 		@ args = 0, pretend = 0, frame = 20
 933 003c 0010A0E1 		@ frame_needed = 1, uses_anonymous_args = 0
 934 0040 0520A0E1 		mov	ip, sp
 935 0044 FEFFFFEB 	.LCFI30:
 846:drivers_nxp/mci.c **** 		if (respStatus == 0) {
 936              	d	sp!, {r4, r5, r6, r7, fp, ip, lr, pc}
 937 0048 000050E3 	.LCFI31:
 938 004c F2FFFF1A 		.loc 1 915 0
 939 0050 010080E2 		ldr	r2, .L97
 940              		.loc 1 904 0
 847:drivers_nxp/mci.c **** 			break;
 848:drivers_nxp/mci.c **** 		}
 849:drivers_nxp/mci.c **** 		retryCount--;
 850:drivers_nxp/mci.c **** 	}
 851:drivers_nxp/mci.c **** 
 852:drivers_nxp/mci.c **** 	if (respStatus != 0) /* timeout, give up */
 853:drivers_nxp/mci.c **** 	{
 854:drivers_nxp/mci.c **** 		mci_debug_printf("Timeout go idle\n");
 855:drivers_nxp/mci.c **** 		return ( FALSE );
 856:drivers_nxp/mci.c **** 	}
 857:drivers_nxp/mci.c **** 	return ( TRUE );
 858:drivers_nxp/mci.c **** }
 941              	fp, ip, #4
 942 0054 14D04BE2 	.LCFI32:
 943 0058 30A89DE8 		sub	sp, sp, #20
 944              	.LCFI33:
 945              		.loc 1 915 0
 946 005c 0400A0E1 		ldr	r3, [r2, #0]
 947 0060 FBFFFFEA 		cmp	r3, #2
 948              		beq	.L85
 949              		ldr	r3, [r2, #0]
 950              		cmp	r3, #4
 951              		movne	r5, #0
 952              	.LVL58:
 953              		beq	.L85
 954              	.L86:
 859:drivers_nxp/mci.c **** 
 860:drivers_nxp/mci.c **** /******************************************************************************
 861:drivers_nxp/mci.c ****  ** Function name:		MCI_Send_OP_Cond
 862:drivers_nxp/mci.c ****  **
 863:drivers_nxp/mci.c ****  ** Descriptions:		CMD1 for MMC
 864:drivers_nxp/mci.c ****  **
 865:drivers_nxp/mci.c ****  ** parameters:			None
 866:drivers_nxp/mci.c ****  ** Returned value:		true or false, true if card has response back before
 867:drivers_nxp/mci.c ****  **						timeout, false is timeout on the command.
 868:drivers_nxp/mci.c ****  ** 
 869:drivers_nxp/mci.c ****  ******************************************************************************/
 870:drivers_nxp/mci.c **** // mthomas - static
 871:drivers_nxp/mci.c **** static DWORD MCI_Send_OP_Cond(void) {
 872:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
 873:drivers_nxp/mci.c **** 	DWORD retryCount;
 874:drivers_nxp/mci.c **** 	DWORD respStatus;
 875:drivers_nxp/mci.c **** 	DWORD respValue[4];
 876:drivers_nxp/mci.c **** 
 877:drivers_nxp/mci.c **** 	retryCount = 0x200; /* reset retry counter */
 878:drivers_nxp/mci.c **** 	while (retryCount > 0) {
 879:drivers_nxp/mci.c **** 		/* Send CMD1 command repeatedly until the response is back correctly */
 880:drivers_nxp/mci.c **** 		MCI_SendCmd( SEND_OP_COND, OCR_INDEX, EXPECT_SHORT_RESP, 0);
 881:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( SEND_OP_COND, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
 882:drivers_nxp/mci.c **** 		/* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
 883:drivers_nxp/mci.c **** 		if ( !(respStatus & MCI_CMD_TIMEOUT) && (respValue[0] & 0x80000000)) {
 884:drivers_nxp/mci.c **** 			return ( TRUE ); /* response is back and correct. */
 885:drivers_nxp/mci.c **** 		}
 886:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++)
 887:drivers_nxp/mci.c **** 			;
 888:drivers_nxp/mci.c **** 		retryCount--;
 889:drivers_nxp/mci.c **** 	}
 890:drivers_nxp/mci.c **** 	return ( FALSE );
 891:drivers_nxp/mci.c **** }
 892:drivers_nxp/mci.c **** 
 893:drivers_nxp/mci.c **** /******************************************************************************
 894:drivers_nxp/mci.c ****  ** Function name:		MCI_Send_ACMD
 895:drivers_nxp/mci.c ****  **
 896:drivers_nxp/mci.c ****  ** Descriptions:		CMD55, before sending an ACMD, call this routine first
 897:drivers_nxp/mci.c ****  **
 898:drivers_nxp/mci.c ****  ** parameters:			None
 899:drivers_nxp/mci.c ****  ** Returned value:		true or false, true if card has responded before timeout.
 900:drivers_nxp/mci.c ****  **						false is timeout.
 901:drivers_nxp/mci.c ****  ** 
 902:drivers_nxp/mci.c ****  ******************************************************************************/
 903:drivers_nxp/mci.c **** // mthomas - static
 904:drivers_nxp/mci.c **** static DWORD MCI_Send_ACMD(void) {
 955              		mov	r4, #20
 956              	.LVL59:
 957              		sub	r6, fp, #48
 958 0000 0DC0A0E1 		.loc 1 925 0
 959              		mov	r7, #0
 960 0004 F0D82DE9 	.LVL60:
 961              	.L91:
 905:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
 906:drivers_nxp/mci.c **** 	DWORD retryCount;
 907:drivers_nxp/mci.c **** 	DWORD CmdArgument;
 908:drivers_nxp/mci.c **** 	DWORD respStatus;
 909:drivers_nxp/mci.c **** 	DWORD respValue[4];
 910:drivers_nxp/mci.c **** 
 911:drivers_nxp/mci.c **** 	// mthomas - warning: MCI_CardType may be set from
 912:drivers_nxp/mci.c **** 	// extern to other than UNKOWN and this
 913:drivers_nxp/mci.c **** 	// will fail on init (workaround: added MCI_CardType = UNKNOWN below)
 914:drivers_nxp/mci.c **** 	// laebi: add CardType SDHC_CARD, otherwise it wouldnt work
 915:drivers_nxp/mci.c **** 	if (MCI_CardType == SD_CARD || MCI_CardType == SDHC_CARD) {
 962              	, #55
 963 0008 B4209FE5 		mov	r1, r5
 964              		mov	r2, #1
 965 000c 04B04CE2 		mov	r3, #0
 966              		bl	MCI_SendCmd
 967 0010 14D04DE2 		.loc 1 926 0
 968              		mov	r0, #55
 969              		mov	r1, #1
 970 0014 003092E5 		mov	r2, r6
 971 0018 020053E3 		bl	MCI_GetCmdResp
 972 001c 2300000A 		.loc 1 927 0
 973 0020 003092E5 		cmp	r0, #0
 974 0024 040053E3 		bne	.L87
 975 0028 0050A013 		ldr	r3, [fp, #-48]
 976              		tst	r3, #32
 977 002c 1F00000A 		bne	.L96
 978              	.L87:
 916:drivers_nxp/mci.c **** 		CmdArgument = CardRCA; /* Use the address from SET_RELATIVE_ADDR cmd */
 979              	r	r7, [fp, #-32]
 980 0030 1440A0E3 	.LVL61:
 981              		ldr	r3, [fp, #-32]
 982 0034 30604BE2 		cmp	r3, #31
 917:drivers_nxp/mci.c **** 	} else /* if MMC or unknown card type, use 0x0. */
 918:drivers_nxp/mci.c **** 	{
 919:drivers_nxp/mci.c **** 		CmdArgument = 0x00000000;
 920:drivers_nxp/mci.c **** 	}
 921:drivers_nxp/mci.c **** 
 922:drivers_nxp/mci.c **** 	retryCount = 20;
 923:drivers_nxp/mci.c **** 	while (retryCount > 0) {
 924:drivers_nxp/mci.c **** 		/* Send CMD55 command followed by an ACMD */
 925:drivers_nxp/mci.c **** 		MCI_SendCmd( APP_CMD, CmdArgument, EXPECT_SHORT_RESP, 0);
 983              		.L89
 984 0038 0070A0E3 	.L93:
 985              		ldr	r3, [fp, #-32]
 986              		add	r3, r3, #1
 987 003c 3700A0E3 	.LVL62:
 988 0040 0510A0E1 		str	r3, [fp, #-32]
 989 0044 0120A0E3 		ldr	r2, [fp, #-32]
 990 0048 0030A0E3 		cmp	r2, #31
 991 004c FEFFFFEB 		bls	.L93
 926:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( APP_CMD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
 992              	L89:
 993 0050 3700A0E3 		.loc 1 923 0
 994 0054 0110A0E3 		subs	r4, r4, #1
 995 0058 0620A0E1 		bne	.L91
 996 005c FEFFFFEB 		mov	r0, r4
 927:drivers_nxp/mci.c **** 		if ( !respStatus && (respValue[0] & CARD_STATUS_ACMD_ENABLE)) /* Check if APP_CMD enabled */
 997              	
 998 0060 000050E3 		.loc 1 937 0
 999 0064 0200001A 		sub	sp, fp, #28
 1000 0068 30301BE5 		ldmfd	sp, {r4, r5, r6, r7, fp, sp, pc}
 1001 006c 200013E3 	.LVL64:
 1002 0070 1100001A 	.L85:
 1003              		.loc 1 916 0
 928:drivers_nxp/mci.c **** 		{
 929:drivers_nxp/mci.c **** 			return ( TRUE );
 930:drivers_nxp/mci.c **** 		}
 931:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++) {
 1004              	3, .L97+4
 1005 0074 20700BE5 		ldr	r5, [r3, #0]
 1006              		b	.L86
 1007 0078 20301BE5 	.LVL65:
 1008 007c 1F0053E3 	.L96:
 1009 0080 0500008A 		.loc 1 927 0
 1010              		add	r0, r0, #1
 1011 0084 20301BE5 		b	.L88
 1012 0088 013083E2 	.L98:
 1013              		.align	2
 1014 008c 20300BE5 	.L97:
 1015 0090 20201BE5 		.word	MCI_CardType
 1016 0094 1F0052E3 		.word	CardRCA
 1017 0098 F9FFFF9A 	.LFE25:
 1019              		.section	.text.MCI_CardInit,"ax",%progbits
 1020              		.align	2
 1021 009c 014054E2 		.global	MCI_CardInit
 1023 00a4 0400A0E1 	MCI_CardInit:
 1024              	.LFB28:
 932:drivers_nxp/mci.c **** 			;
 933:drivers_nxp/mci.c **** 		}
 934:drivers_nxp/mci.c **** 		retryCount--;
 935:drivers_nxp/mci.c **** 	}
 936:drivers_nxp/mci.c **** 	return ( FALSE );
 937:drivers_nxp/mci.c **** }
 1025              	s = 0, pretend = 0, frame = 24
 1026 00a8 1CD04BE2 		@ frame_needed = 1, uses_anonymous_args = 0
 1027 00ac F0A89DE8 		mov	ip, sp
 1028              	.LCFI34:
 1029              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 1030              	.LCFI35:
 1031 00b0 10309FE5 		.loc 1 1056 0
 1032 00b4 005093E5 		ldr	r3, .L143
 1033 00b8 DCFFFFEA 		.loc 1 1050 0
 1034              		sub	fp, ip, #4
 1035              	.LCFI36:
 1036              		sub	sp, sp, #24
 1037 00bc 010080E2 	.LCFI37:
 1038 00c0 F8FFFFEA 		.loc 1 1056 0
 1039              		mov	r5, #0
 1040              		.loc 1 1050 0
 1041              		.loc 1 1056 0
 1042 00c4 00000000 		str	r5, [r3, #0]
 1043 00c8 00000000 		.loc 1 1058 0
 1044              		bl	MCI_Go_Idle_State
 1045              		cmp	r0, #0
 1046              		moveq	r9, r0
 1047              	.LVL66:
 1048              		beq	.L101
 1049              	.LBB51:
 1050              	.LBB53:
 1051              		.loc 1 1014 0
 938:drivers_nxp/mci.c **** 
 939:drivers_nxp/mci.c **** /******************************************************************************
 940:drivers_nxp/mci.c ****  ** Function name:		MCI_Send_ACMD_OP_Cond
 941:drivers_nxp/mci.c ****  **
 942:drivers_nxp/mci.c ****  ** Descriptions:		If Send_OP_Cond is timeout, it's not a MMC card, try 
 943:drivers_nxp/mci.c ****  **						this combination to see if we can communicate with 
 944:drivers_nxp/mci.c ****  **						a SD card.
 945:drivers_nxp/mci.c ****  **
 946:drivers_nxp/mci.c ****  ** parameters:			ACMD41 argument (mthomas)
 947:drivers_nxp/mci.c ****  ** Returned value:		true or false, true if card has been initialized.
 948:drivers_nxp/mci.c ****  **						respValue[0] in resp0
 949:drivers_nxp/mci.c ****  ** 
 950:drivers_nxp/mci.c ****  ** modified by Martin Thomas (in: arg, out resp0)
 951:drivers_nxp/mci.c ****  ******************************************************************************/
 952:drivers_nxp/mci.c **** // mthomas - static
 953:drivers_nxp/mci.c **** static DWORD MCI_Send_ACMD_OP_Cond(DWORD acmd41_arg, DWORD *resp0) {
 954:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
 955:drivers_nxp/mci.c **** 	DWORD retryCount;
 956:drivers_nxp/mci.c **** 	DWORD respStatus;
 957:drivers_nxp/mci.c **** 	DWORD respValue[4];
 958:drivers_nxp/mci.c **** 
 959:drivers_nxp/mci.c **** 	/* timeout on SEND_OP_COND command on MMC, now, try SEND_APP_OP_COND 
 960:drivers_nxp/mci.c **** 	 command to SD */
 961:drivers_nxp/mci.c **** 	// mthomas - less retries retryCount = 0x200;			/* reset retry counter */
 962:drivers_nxp/mci.c **** 	retryCount = 0x50;
 963:drivers_nxp/mci.c **** 	while (retryCount > 0) {
 964:drivers_nxp/mci.c **** 		MCI_POWER &= ~(1 << 6 );
 965:drivers_nxp/mci.c **** 		/* Clear Open Drain output control for SD */
 966:drivers_nxp/mci.c **** 		for (i = 0; i < 0x3000; i++) {
 967:drivers_nxp/mci.c **** 			;
 968:drivers_nxp/mci.c **** 		}
 969:drivers_nxp/mci.c **** 
 970:drivers_nxp/mci.c **** 		if (MCI_Send_ACMD() == FALSE) {
 971:drivers_nxp/mci.c **** 			retryCount--; // mthomas - line added
 972:drivers_nxp/mci.c **** 			continue;
 973:drivers_nxp/mci.c **** 		}
 974:drivers_nxp/mci.c **** 
 975:drivers_nxp/mci.c **** 		/* Send ACMD41 command repeatedly until the response is back correctly */
 976:drivers_nxp/mci.c **** 		// MCI_SendCmd( SEND_APP_OP_COND, OCR_INDEX, EXPECT_SHORT_RESP, 0 );
 977:drivers_nxp/mci.c **** 		MCI_SendCmd( SEND_APP_OP_COND, acmd41_arg, EXPECT_SHORT_RESP, 0);
 978:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( SEND_APP_OP_COND, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
 979:drivers_nxp/mci.c **** 		if ( !(respStatus & MCI_CMD_TIMEOUT) && (respValue[0] & 0x80000000)) {
 980:drivers_nxp/mci.c **** 			if (resp0 != NULL) {
 981:drivers_nxp/mci.c **** 				*resp0 = respValue[0];
 982:drivers_nxp/mci.c **** 			}
 983:drivers_nxp/mci.c **** 			return ( TRUE ); /* response is back and correct. */
 984:drivers_nxp/mci.c **** 		}
 985:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++) {
 986:drivers_nxp/mci.c **** 			;
 987:drivers_nxp/mci.c **** 		}
 988:drivers_nxp/mci.c **** 		retryCount--;
 989:drivers_nxp/mci.c **** 	}
 990:drivers_nxp/mci.c **** 	return ( FALSE );
 991:drivers_nxp/mci.c **** }
 992:drivers_nxp/mci.c **** 
 993:drivers_nxp/mci.c **** /******************************************************************************
 994:drivers_nxp/mci.c ****  ** Function name:		MCI_Send_IF_Cond
 995:drivers_nxp/mci.c ****  **
 996:drivers_nxp/mci.c ****  ** Descriptions:		CMD8 to detect SD-Card >= Version 2.0
 997:drivers_nxp/mci.c ****  **
 998:drivers_nxp/mci.c ****  ** parameters:			None
 999:drivers_nxp/mci.c ****  ** Returned value:		true or false, true if card has response back before
1000:drivers_nxp/mci.c ****  **						timeout, false is timeout on the command.
1001:drivers_nxp/mci.c ****  **
1002:drivers_nxp/mci.c ****  ** added by Martin Thomas with information from Juri Haberland, Chan and
1003:drivers_nxp/mci.c ****  ** the SanDisk Product Manuals V2.2
1004:drivers_nxp/mci.c ****  ******************************************************************************/
1005:drivers_nxp/mci.c **** // mthomas - static
1006:drivers_nxp/mci.c **** static DWORD MCI_Send_IF_Cond(void) {
1007:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1008:drivers_nxp/mci.c **** 	DWORD retryCount;
1009:drivers_nxp/mci.c **** 	DWORD respStatus;
1010:drivers_nxp/mci.c **** 	DWORD respValue[4];
1011:drivers_nxp/mci.c **** 
1012:drivers_nxp/mci.c **** 	retryCount = 20; /* reset retry counter */
1013:drivers_nxp/mci.c **** 	while (retryCount > 0) {
1014:drivers_nxp/mci.c **** 		MCI_POWER &= ~(1 << 6 );
1015:drivers_nxp/mci.c **** 		/* Clear Open Drain output control for SD */
1016:drivers_nxp/mci.c **** 		for (i = 0; i < 0x3000; i++) {
1017:drivers_nxp/mci.c **** 			;
1018:drivers_nxp/mci.c **** 		}
1019:drivers_nxp/mci.c **** 
1020:drivers_nxp/mci.c **** 		/* Send CMD8 command repeatedly until the response is back correctly or timeout */
1021:drivers_nxp/mci.c **** 		MCI_SendCmd( SEND_IF_COND, SEND_IF_COND_ARG , EXPECT_SHORT_RESP, 0);
1022:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( SEND_IF_COND, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
1023:drivers_nxp/mci.c **** 		/* mthomas TODO: check result bits - for now just check if no timeout */
1024:drivers_nxp/mci.c **** 		if ( !(respStatus & MCI_CMD_TIMEOUT)) {
1025:drivers_nxp/mci.c **** 			return ( TRUE ); /* response is back and correct. */
1026:drivers_nxp/mci.c **** 		}
1027:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++)
1028:drivers_nxp/mci.c **** 			;
1029:drivers_nxp/mci.c **** 		retryCount--;
1030:drivers_nxp/mci.c **** 	}
1031:drivers_nxp/mci.c **** 	return ( FALSE );
1032:drivers_nxp/mci.c **** }
1033:drivers_nxp/mci.c **** 
1034:drivers_nxp/mci.c **** #if 1
1035:drivers_nxp/mci.c **** /******************************************************************************
1036:drivers_nxp/mci.c ****  ** Function name:		MCI_CardInit
1037:drivers_nxp/mci.c ****  **
1038:drivers_nxp/mci.c ****  ** Descriptions:		Try CMD1 first for MMC, if it's timeout, try CMD55 
1039:drivers_nxp/mci.c ****  **						and CMD41 for SD, if both failed, initialization faliure, 
1040:drivers_nxp/mci.c ****  **						bailout with unknown card type. Otherwise, return the
1041:drivers_nxp/mci.c ****  **						card type, either MMC or SD.		
1042:drivers_nxp/mci.c ****  **
1043:drivers_nxp/mci.c ****  ** parameters:			None
1044:drivers_nxp/mci.c ****  ** Returned value:		Card type.
1045:drivers_nxp/mci.c ****  ** 
1046:drivers_nxp/mci.c ****  ** extended by Martin Thomas with information from Juri Haberland,
1047:drivers_nxp/mci.c ****  ** public available Information for SDHC, Chan's fat-code and 
1048:drivers_nxp/mci.c ****  ** the SanDisk SD-Card manual V2.2
1049:drivers_nxp/mci.c ****  ******************************************************************************/
1050:drivers_nxp/mci.c **** DWORD MCI_CardInit(void) {
 1052              	1 1016 0
 1053              		mov	r4, #12224
 1054              		mov	r7, r5
 1055 0000 0DC0A0E1 		.loc 1 1014 0
 1056              		add	r6, r6, #573440
 1057 0004 F0DF2DE9 		.loc 1 1016 0
 1058              		add	r4, r4, #63
1051:drivers_nxp/mci.c **** 	volatile DWORD i;
1052:drivers_nxp/mci.c **** 	DWORD CardType= CARD_UNKNOWN;
1053:drivers_nxp/mci.c **** 	DWORD acmd41_arg;
1054:drivers_nxp/mci.c **** 	DWORD resp0;
1055:drivers_nxp/mci.c **** 
1056:drivers_nxp/mci.c **** 	MCI_CardType = CARD_UNKNOWN;
 1059              	
 1060 0008 A0329FE5 	.LBE51:
 1061              		.loc 1 1058 0
 1062 000c 04B04CE2 		mov	r5, #20
 1063              	.LVL67:
 1064 0010 18D04DE2 		sub	sl, fp, #64
 1065              	.LVL68:
 1066              	.L108:
 1067 0014 0050A0E3 	.LBB57:
 1068              	.LBB54:
 1069              		.loc 1 1014 0
 1070 0018 005083E5 		ldr	r3, [r6, #0]
1057:drivers_nxp/mci.c **** 
1058:drivers_nxp/mci.c **** 	if (MCI_Go_Idle_State() == FALSE) {
 1071              	, #64
 1072 001c FEFFFFEB 		str	r3, [r6, #0]
 1073 0020 000050E3 		.loc 1 1016 0
 1074 0024 0090A001 		str	r7, [fp, #-48]
 1075              	.LVL69:
 1076 0028 7800000A 		ldr	r3, [fp, #-48]
 1077              		cmp	r3, r4
 1078              		bhi	.L102
 1079              	.L129:
 1080 002c 0E62A0E3 		ldr	r3, [fp, #-48]
 1081              		add	r3, r3, #1
 1082 0030 BF4DA0E3 		str	r3, [fp, #-48]
 1083 0034 0570A0E1 	.LVL70:
 1084              		ldr	r2, [fp, #-48]
 1085 0038 236986E2 		cmp	r2, r4
 1086              		bls	.L129
 1087 003c 3F4084E2 	.L102:
 1088              		.loc 1 1021 0
 1089              		mov	r1, #424
 1090              		add	r1, r1, #2
 1091 0040 1450A0E3 		mov	r0, #8
 1092              		mov	r2, #1
 1093 0044 40A04BE2 		mov	r3, #0
 1094              		bl	MCI_SendCmd
 1095              	.LBE54:
 1096              		.loc 1 1022 0
 1097              		mov	r0, #8
 1098              		mov	r1, #1
 1099 0048 003096E5 		mov	r2, sl
 1100 004c 4030C3E3 		bl	MCI_GetCmdResp
 1101 0050 003086E5 	.LBB55:
 1102              		.loc 1 1024 0
 1103 0054 30700BE5 		tst	r0, #4
 1104              		beq	.L139
 1105 0058 30301BE5 		.loc 1 1027 0
 1106 005c 040053E1 		str	r7, [fp, #-48]
 1107 0060 0500008A 	.LVL71:
 1108              		ldr	r3, [fp, #-48]
 1109 0064 30301BE5 		cmp	r3, #31
 1110 0068 013083E2 		bhi	.L106
 1111 006c 30300BE5 	.L128:
 1112              		ldr	r3, [fp, #-48]
 1113 0070 30201BE5 		add	r3, r3, #1
 1114 0074 040052E1 		str	r3, [fp, #-48]
 1115 0078 F9FFFF9A 	.LVL72:
 1116              		ldr	r2, [fp, #-48]
 1117              		cmp	r2, #31
 1118 007c 6A1FA0E3 		bls	.L128
 1119 0080 021081E2 	.L106:
 1120 0084 0800A0E3 		.loc 1 1013 0
 1121 0088 0120A0E3 		subs	r5, r5, #1
 1122 008c 0030A0E3 		bne	.L108
 1123 0090 FEFFFFEB 		mov	r8, #16711680
 1124              	.LVL73:
 1125              		mov	r9, r5
 1126 0094 0800A0E3 		add	r8, r8, #32768
 1127 0098 0110A0E3 	.L105:
 1128 009c 0A20A0E1 	.LBE55:
 1129 00a0 FEFFFFEB 	.LBE57:
 1130              	.LBB58:
 1131              	.LBB61:
 1132 00a4 040010E3 		.loc 1 964 0
 1133 00a8 7800000A 		mov	r6, #-536870912
 1134              		.loc 1 966 0
 1135 00ac 30700BE5 		mov	r4, #12224
 1136              		.loc 1 964 0
 1137 00b0 30301BE5 		add	r6, r6, #573440
 1138 00b4 1F0053E3 		.loc 1 966 0
 1139 00b8 0500008A 		add	r4, r4, #63
 1140              	.LBE61:
 1141 00bc 30301BE5 	.LBE58:
 1142 00c0 013083E2 	.LBB64:
 1143 00c4 30300BE5 	.LBB52:
 1144              		.loc 1 1013 0
 1145 00c8 30201BE5 		mov	r5, #79
 1146 00cc 1F0052E3 	.LVL74:
 1147 00d0 F9FFFF9A 	.LBE52:
 1148              	.LBE64:
 1149              	.LBB65:
 1150 00d4 015055E2 	.LBB60:
 1151 00d8 DAFFFF1A 		.loc 1 966 0
 1152 00dc FF88A0E3 		mov	r7, #0
 1153              	.LVL75:
 1154 00e0 0590A0E1 	.L116:
 1155 00e4 028988E2 		.loc 1 964 0
 1156              		ldr	r3, [r6, #0]
 1157              		bic	r3, r3, #64
 1158              		str	r3, [r6, #0]
 1159              		.loc 1 966 0
 1160              		str	r7, [fp, #-48]
 1161              	.LVL76:
 1162 00e8 0E62A0E3 		ldr	r3, [fp, #-48]
 1163              		cmp	r3, r4
 1164 00ec BF4DA0E3 		bhi	.L109
 1165              	.L127:
 1166 00f0 236986E2 		ldr	r3, [fp, #-48]
 1167              		add	r3, r3, #1
 1168 00f4 3F4084E2 		str	r3, [fp, #-48]
 1169              	.LVL77:
 1170              		ldr	r2, [fp, #-48]
 1171              		cmp	r2, r4
 1172              		bls	.L127
 1173              	.L109:
 1174 00f8 4F50A0E3 	.LBE60:
 1175              		.loc 1 970 0
 1176              		bl	MCI_Send_ACMD
 1177              	.LBB59:
 1178              		cmp	r0, #0
 1179              		bne	.L140
 1180              	.L111:
 1181 00fc 0070A0E3 		.loc 1 963 0
 1182              		subs	r5, r5, #1
 1183              		bcs	.L116
 1184              	.LBE59:
 1185 0100 003096E5 	.LBE65:
 1186 0104 4030C3E3 		.loc 1 1083 0
 1187 0108 003086E5 		mov	r2, #-536870912
 1188              		add	r2, r2, #573440
 1189 010c 30700BE5 		ldr	r3, [r2, #0]
 1190              		.loc 1 1085 0
 1191 0110 30301BE5 		mov	r1, #0
 1192 0114 040053E1 		.loc 1 1083 0
 1193 0118 0500008A 		orr	r3, r3, #64
 1194              		str	r3, [r2, #0]
 1195 011c 30301BE5 		.loc 1 1085 0
 1196 0120 013083E2 		str	r1, [fp, #-44]
 1197 0124 30300BE5 	.LVL78:
 1198              		ldr	r3, [fp, #-44]
 1199 0128 30201BE5 		mov	r2, #12224
 1200 012c 040052E1 		add	r2, r2, #63
 1201 0130 F9FFFF9A 		cmp	r3, r2
 1202              		bhi	.L117
 1203              		mov	r1, r2
 1204              	.L125:
 1205 0134 FEFFFFEB 		ldr	r3, [fp, #-44]
 1206              		add	r3, r3, #1
 1207 0138 000050E3 	.LVL79:
 1208 013c 3600001A 		str	r3, [fp, #-44]
 1209              		ldr	r2, [fp, #-44]
 1210              		cmp	r2, r1
 1211 0140 015055E2 		bls	.L125
 1212 0144 EDFFFF2A 	.LVL80:
 1213              	.L117:
 1214              		mov	r4, #512
1059:drivers_nxp/mci.c **** 		mci_debug_printf("Init Go Idle failed\n");
1060:drivers_nxp/mci.c **** 		return ( CARD_UNKNOWN );
1061:drivers_nxp/mci.c **** 	}
1062:drivers_nxp/mci.c **** 
1063:drivers_nxp/mci.c **** 	if (MCI_Send_IF_Cond() == TRUE) {
1064:drivers_nxp/mci.c **** 		mci_debug_printf("no timeout on CMD8 -> SD-Card>=Version 2.0\n");
1065:drivers_nxp/mci.c **** 		CardType = SDV2_CARD;
1066:drivers_nxp/mci.c **** 		acmd41_arg = OCR_CARD_HIGH_CAPACITY | OCR_HIGH_VOLTAGE_RANGE;
1067:drivers_nxp/mci.c **** 	} else {
1068:drivers_nxp/mci.c **** 		mci_debug_printf("timout CMD8 -> SD-Card<Version 2.0 or MMC\n");
1069:drivers_nxp/mci.c **** 		acmd41_arg = OCR_HIGH_VOLTAGE_RANGE;
1070:drivers_nxp/mci.c **** 	}
1071:drivers_nxp/mci.c **** 
1072:drivers_nxp/mci.c **** 	if (MCI_Send_ACMD_OP_Cond(acmd41_arg, &resp0) == TRUE) {
1073:drivers_nxp/mci.c **** 		mci_debug_printf("ACMD41 success -> SD-Card SC or HC\n");
1074:drivers_nxp/mci.c **** 		if (resp0 & OCR_CARD_HIGH_CAPACITY) {
1075:drivers_nxp/mci.c **** 			mci_debug_printf("SDHC detected - EXPERIMENTAL!\n");
1076:drivers_nxp/mci.c **** 			CardType = SDHC_CARD;
1077:drivers_nxp/mci.c **** 		} else {
1078:drivers_nxp/mci.c **** 			mci_debug_printf("SDSC detected\n");
1079:drivers_nxp/mci.c **** 			CardType = SDSC_CARD;
1080:drivers_nxp/mci.c **** 		}
1081:drivers_nxp/mci.c **** 	} else {
1082:drivers_nxp/mci.c **** 		mci_debug_printf("MCI_Send_ACMD failed -> MMC, invalid power-range or no card\n");
1083:drivers_nxp/mci.c **** 		MCI_POWER |= (1 << 6 );
 1215              	MCI_SendCmd
 1216 0148 0E22A0E3 	.LBE68:
 1217 014c 232982E2 		.loc 1 881 0
 1218 0150 003092E5 		mov	r0, #1
1084:drivers_nxp/mci.c **** 		/* Set Open Drain output control for MMC */
1085:drivers_nxp/mci.c **** 		for (i = 0; i < 0x3000; i++) {
 1219              		r1, r0
 1220 0154 0010A0E3 		mov	r2, sl
 1221              		bl	MCI_GetCmdResp
 1222 0158 403083E3 	.LBB67:
 1223 015c 003082E5 		.loc 1 883 0
 1224              		tst	r0, #4
 1225 0160 2C100BE5 		bne	.L119
 1226              		ldr	r3, [fp, #-64]
 1227 0164 2C301BE5 		cmp	r3, #0
 1228 0168 BF2DA0E3 		blt	.L141
 1229 016c 3F2082E2 	.L119:
 1230 0170 020053E1 		.loc 1 886 0
 1231 0174 0600008A 		str	r5, [fp, #-48]
 1232 0178 0210A0E1 	.LVL83:
 1233              		ldr	r3, [fp, #-48]
 1234 017c 2C301BE5 		cmp	r3, #31
 1235 0180 013083E2 		bhi	.L120
 1236              	.L124:
 1237 0184 2C300BE5 		ldr	r3, [fp, #-48]
 1238 0188 2C201BE5 		add	r3, r3, #1
 1239 018c 010052E1 		str	r3, [fp, #-48]
 1240 0190 F9FFFF9A 	.LVL84:
 1241              		ldr	r2, [fp, #-48]
 1242              		cmp	r2, #31
 1243 0194 024CA0E3 		bls	.L124
 1244              	.L120:
 1245              		.loc 1 878 0
 1246              		subs	r4, r4, #1
 1247              		bne	.L122
 1248 0198 0050A0E3 	.L114:
 1249              	.LBE67:
 1250              	.LBE66:
 1251 019c 0100A0E3 		.loc 1 1094 0
 1252 01a0 FF18A0E3 		ldr	r3, .L143
 1253 01a4 0020A0E1 		str	r9, [r3, #0]
 1254 01a8 021981E2 	.L101:
 1255 01ac 0030A0E3 		.loc 1 1097 0
 1256 01b0 FEFFFFEB 		mov	r0, r9
 1257              		sub	sp, fp, #40
 1258              		ldmfd	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
 1259 01b4 0100A0E3 	.LVL85:
 1260 01b8 0010A0E1 	.L140:
 1261 01bc 0A20A0E1 	.LBB70:
 1262 01c0 FEFFFFEB 	.LBB62:
 1263              		.loc 1 977 0
 1264              		mov	r0, #41
 1265 01c4 040010E3 		mov	r1, r8
 1266 01c8 0200001A 		mov	r2, #1
 1267 01cc 40301BE5 		mov	r3, #0
 1268 01d0 000053E3 		bl	MCI_SendCmd
 1269 01d4 290000BA 	.LBE62:
 1270              		.loc 1 978 0
 1271              		mov	r0, #41
 1272 01d8 30500BE5 		mov	r1, #1
 1273              		mov	r2, sl
 1274 01dc 30301BE5 		bl	MCI_GetCmdResp
 1275 01e0 1F0053E3 	.LBB63:
 1276 01e4 0500008A 		.loc 1 979 0
 1277              		tst	r0, #4
 1278 01e8 30301BE5 		bne	.L112
 1279 01ec 013083E2 		ldr	r3, [fp, #-64]
 1280 01f0 30300BE5 		cmp	r3, #0
 1281              		blt	.L142
 1282 01f4 30201BE5 	.L112:
 1283 01f8 1F0052E3 		.loc 1 985 0
 1284 01fc F9FFFF9A 		str	r7, [fp, #-48]
 1285              	.LVL86:
 1286              		ldr	r3, [fp, #-48]
 1287 0200 014054E2 		cmp	r3, #31
 1288 0204 E4FFFF1A 		bhi	.L111
 1289              	.L126:
 1290              		ldr	r3, [fp, #-48]
 1291              		add	r3, r3, #1
1086:drivers_nxp/mci.c **** 			;
1087:drivers_nxp/mci.c **** 		}
1088:drivers_nxp/mci.c **** 		/* try CMD1 of MMC */
1089:drivers_nxp/mci.c **** 		if (MCI_Send_OP_Cond() == TRUE) {
1090:drivers_nxp/mci.c **** 			CardType = MMC_CARD;
1091:drivers_nxp/mci.c **** 		}
1092:drivers_nxp/mci.c **** 	}
1093:drivers_nxp/mci.c **** 
1094:drivers_nxp/mci.c **** 	MCI_CardType = CardType;
 1292              	b	.L111
 1293 0208 A0309FE5 	.LVL88:
 1294 020c 009083E5 	.L141:
 1295              	.LBE63:
1095:drivers_nxp/mci.c **** 
1096:drivers_nxp/mci.c **** 	return (CardType );
1097:drivers_nxp/mci.c **** }
 1296              	70:
 1297 0210 0900A0E1 		.loc 1 1094 0
 1298 0214 28D04BE2 		ldr	r3, .L143
 1299 0218 F0AF9DE8 	.LBB71:
 1300              	.LBB69:
 1301              		.loc 1 883 0
 1302              		mov	r9, #1
 1303              	.LBE69:
 1304              	.LBE71:
 1305 021c 2900A0E3 		.loc 1 1094 0
 1306 0220 0810A0E1 		str	r9, [r3, #0]
 1307 0224 0120A0E3 		b	.L101
 1308 0228 0030A0E3 	.LVL89:
 1309 022c FEFFFFEB 	.L139:
 1310              	.LBB72:
 1311              	.LBB56:
 1312 0230 2900A0E3 		.loc 1 1024 0
 1313 0234 0110A0E3 		mov	r8, #1090519040
 1314 0238 0A20A0E1 	.LVL90:
 1315 023c FEFFFFEB 		sub	r8, r8, #32768
 1316              		mov	r9, #8
 1317              		b	.L105
 1318 0240 040010E3 	.LVL91:
 1319 0244 0200001A 	.L142:
 1320 0248 40301BE5 	.LBE56:
 1321 024c 000053E3 	.LBE72:
 1322 0250 120000BA 		.loc 1 1074 0
 1323              		tst	r3, #1073741824
 1324              		movne	r9, #4
 1325 0254 30700BE5 		moveq	r9, #2
 1326              		b	.L114
 1327 0258 30301BE5 	.L144:
 1328 025c 1F0053E3 		.align	2
 1329 0260 B6FFFF8A 	.L143:
 1330              		.word	MCI_CardType
 1331 0264 30301BE5 	.LFE28:
 1333 026c 30300BE5 		.section	.text.MCI_Check_CID,"ax",%progbits
 1334              		.align	2
 1335 0270 30201BE5 		.global	MCI_Check_CID
 1337 0278 F9FFFF9A 	MCI_Check_CID:
 1338 027c AFFFFFEA 	.LFB29:
 1339              		.loc 1 1163 0
 1340              		@ args = 0, pretend = 0, frame = 20
 1341              		@ frame_needed = 1, uses_anonymous_args = 0
 1342              		mov	ip, sp
 1343              	.LCFI38:
 1344 0280 28309FE5 		stmfd	sp!, {r4, r5, r6, fp, ip, lr, pc}
 1345              	.LCFI39:
 1346              		sub	fp, ip, #4
 1347              	.LCFI40:
 1348 0284 0190A0E3 		sub	sp, sp, #20
 1349              	.LCFI41:
 1350              		.loc 1 1163 0
 1351              		mov	r4, #32
 1352 0288 009083E5 	.LVL92:
 1353 028c DFFFFFEA 		sub	r5, fp, #44
 1354              		.loc 1 1173 0
 1355              		mov	r6, #0
 1356              	.LVL93:
 1357              	.L150:
 1358              		mov	r0, #2
 1359 0290 4184A0E3 		mov	r1, #0
 1360              		mov	r2, r0
 1361 0294 028948E2 		mov	r3, r1
 1362 0298 0890A0E3 		bl	MCI_SendCmd
 1363 029c 91FFFFEA 		.loc 1 1174 0
 1364              		mov	r0, #2
 1365              		mov	r1, r0
 1366              		mov	r2, r5
 1367              		bl	MCI_GetCmdResp
 1368              		.loc 1 1176 0
 1369 02a0 010113E3 		tst	r0, #4
 1370 02a4 0490A013 		beq	.L155
 1371 02a8 0290A003 		.loc 1 1179 0
 1372 02ac D5FFFFEA 		str	r6, [fp, #-28]
 1373              	.LVL94:
 1374              		ldr	r3, [fp, #-28]
 1375              		cmp	r3, #31
 1376 02b0 00000000 		bhi	.L148
 1377              	.L152:
 1378              		ldr	r3, [fp, #-28]
 1379              		add	r3, r3, #1
 1380              	.LVL95:
 1381              		str	r3, [fp, #-28]
 1382              		ldr	r2, [fp, #-28]
 1383              		cmp	r2, #31
 1384              		bls	.L152
1098:drivers_nxp/mci.c **** #else
1099:drivers_nxp/mci.c **** // NXP original:
1100:drivers_nxp/mci.c **** /******************************************************************************
1101:drivers_nxp/mci.c ****  ** Function name:		MCI_CardInit
1102:drivers_nxp/mci.c ****  **
1103:drivers_nxp/mci.c ****  ** Descriptions:		Try CMD1 first for MMC, if it's timeout, try CMD55 
1104:drivers_nxp/mci.c ****  **						and CMD41 for SD, if both failed, initialization faliure, 
1105:drivers_nxp/mci.c ****  **						bailout with unknown card type. Otherwise, return the
1106:drivers_nxp/mci.c ****  **						card type, either MMC or SD.		
1107:drivers_nxp/mci.c ****  **
1108:drivers_nxp/mci.c ****  ** parameters:			None
1109:drivers_nxp/mci.c ****  ** Returned value:		Card type.
1110:drivers_nxp/mci.c ****  **
1111:drivers_nxp/mci.c ****  ******************************************************************************/
1112:drivers_nxp/mci.c **** DWORD MCI_CardInit( void )
1113:drivers_nxp/mci.c **** {
1114:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1115:drivers_nxp/mci.c **** 	DWORD CardType;
1116:drivers_nxp/mci.c **** 
1117:drivers_nxp/mci.c **** 	MCI_CardType = CARD_UNKNOWN; // mthomas - line added
1118:drivers_nxp/mci.c **** 
1119:drivers_nxp/mci.c **** 	if ( MCI_Go_Idle_State() == FALSE )
1120:drivers_nxp/mci.c **** 	{
1121:drivers_nxp/mci.c **** 		mci_debug_printf("Init Go Idle failed\n");
1122:drivers_nxp/mci.c **** 		return( CARD_UNKNOWN );
1123:drivers_nxp/mci.c **** 	}
1124:drivers_nxp/mci.c **** 
1125:drivers_nxp/mci.c **** 	MCI_POWER |= (1 << 6 ); /* Set Open Drain output control for MMC */
1126:drivers_nxp/mci.c **** 	for ( i = 0; i < 0x3000; i++ ) {;}
1127:drivers_nxp/mci.c **** 
1128:drivers_nxp/mci.c **** 	/* Try CMD1 first for MMC, if it's timeout, try CMD55 and CMD41 for SD,
1129:drivers_nxp/mci.c **** 	 if both failed, initialization faliure, bailout. */
1130:drivers_nxp/mci.c **** 	if ( MCI_Send_OP_Cond() == TRUE )
1131:drivers_nxp/mci.c **** 	{
1132:drivers_nxp/mci.c **** 		CardType = MMC_CARD;
1133:drivers_nxp/mci.c **** 		MCI_CardType = MMC_CARD; // mthomas - line added
1134:drivers_nxp/mci.c **** 		return ( CardType ); /* Found the card, it's a MMC */
1135:drivers_nxp/mci.c **** 	}
1136:drivers_nxp/mci.c **** 	else {
1137:drivers_nxp/mci.c **** 		mci_debug_printf("MCI_Send_OP_Conf failed - try ACMD\n");
1138:drivers_nxp/mci.c **** 		// mthomas if ( MCI_Send_ACMD_OP_Cond() == TRUE )
1139:drivers_nxp/mci.c **** 		if ( MCI_Send_ACMD_OP_Cond( OCR_INDEX, NULL ) == TRUE )
1140:drivers_nxp/mci.c **** 		{
1141:drivers_nxp/mci.c **** 			CardType = SD_CARD;
1142:drivers_nxp/mci.c **** 			MCI_CardType = SD_CARD; // mthomas - line added
1143:drivers_nxp/mci.c **** 			return ( CardType ); /* Found the card, it's a SD */
1144:drivers_nxp/mci.c **** 		}
1145:drivers_nxp/mci.c **** 		else {
1146:drivers_nxp/mci.c **** 			mci_debug_printf("MCI_Send_ACMD failed\n");
1147:drivers_nxp/mci.c **** 			/* tried both MMC and SD card, give up */
1148:drivers_nxp/mci.c **** 			return ( CARD_UNKNOWN );
1149:drivers_nxp/mci.c **** 		}
1150:drivers_nxp/mci.c **** 	}
1151:drivers_nxp/mci.c **** }
1152:drivers_nxp/mci.c **** #endif
1153:drivers_nxp/mci.c **** 
1154:drivers_nxp/mci.c **** /******************************************************************************
1155:drivers_nxp/mci.c ****  ** Function name:		MCI_Check_CID
1156:drivers_nxp/mci.c ****  **
1157:drivers_nxp/mci.c ****  ** Descriptions:		Send CMD2, ALL_SEND_CID
1158:drivers_nxp/mci.c ****  **
1159:drivers_nxp/mci.c ****  ** parameters:			None
1160:drivers_nxp/mci.c ****  ** Returned value:		If not timeout, return true.
1161:drivers_nxp/mci.c ****  ** 
1162:drivers_nxp/mci.c ****  ******************************************************************************/
1163:drivers_nxp/mci.c **** DWORD MCI_Check_CID(void) {
 1385              	155:
 1386              		.loc 1 1176 0
 1387              		mov	r0, #1
 1388 0000 0DC0A0E1 	.LVL98:
 1389              	.L147:
 1390 0004 70D82DE9 		.loc 1 1185 0
 1391              		sub	sp, fp, #24
 1392 0008 04B04CE2 		ldmfd	sp, {r4, r5, r6, fp, sp, pc}
 1393              	.LFE29:
 1395              		.section	.text.MCI_Set_Address,"ax",%progbits
 1396              		.align	2
 1397 0010 2040A0E3 		.global	MCI_Set_Address
 1399 0014 2C504BE2 	MCI_Set_Address:
1164:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1165:drivers_nxp/mci.c **** 	DWORD retryCount;
1166:drivers_nxp/mci.c **** 	DWORD respStatus;
1167:drivers_nxp/mci.c **** 	DWORD respValue[4];
1168:drivers_nxp/mci.c **** 
1169:drivers_nxp/mci.c **** 	/* This command is normally after CMD1(MMC) or ACMD41(SD). */
1170:drivers_nxp/mci.c **** 	retryCount = 0x20; /* reset retry counter */
1171:drivers_nxp/mci.c **** 	while (retryCount > 0) {
1172:drivers_nxp/mci.c **** 		/* Send CMD2 command repeatedly until the response is back correctly */
1173:drivers_nxp/mci.c **** 		MCI_SendCmd( ALL_SEND_CID, 0, EXPECT_LONG_RESP, 0);
 1400              	 1197 0
 1401 0018 0060A0E3 		@ args = 0, pretend = 0, frame = 20
 1402              		@ frame_needed = 1, uses_anonymous_args = 0
 1403              		mov	ip, sp
 1404 001c 0200A0E3 	.LCFI42:
 1405 0020 0010A0E3 		stmfd	sp!, {r4, r5, r6, r7, fp, ip, lr, pc}
 1406 0024 0020A0E1 	.LCFI43:
 1407 0028 0130A0E1 		.loc 1 1209 0
 1408 002c FEFFFFEB 		ldr	r2, .L169
1174:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( ALL_SEND_CID, EXPECT_LONG_RESP, (DWORD *)&respValue[0]);
 1409              	197 0
 1410 0030 0200A0E3 		sub	fp, ip, #4
 1411 0034 0010A0E1 	.LCFI44:
 1412 0038 0520A0E1 		sub	sp, sp, #20
 1413 003c FEFFFFEB 	.LCFI45:
1175:drivers_nxp/mci.c **** 		/* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
1176:drivers_nxp/mci.c **** 		if ( !(respStatus & MCI_CMD_TIMEOUT )) {
 1414              	 1 1209 0
 1415 0040 040010E3 		ldr	r3, [r2, #0]
 1416 0044 0D00000A 		ands	r3, r3, #1
1177:drivers_nxp/mci.c **** 			return ( TRUE ); /* response is back and correct. */
1178:drivers_nxp/mci.c **** 		}
1179:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++) {
 1417              	veq	r5, r3
 1418 0048 1C600BE5 		movne	r5, #65536
 1419              	.LVL99:
 1420 004c 1C301BE5 		mov	r4, #32
 1421 0050 1F0053E3 	.LVL100:
 1422 0054 0500008A 		sub	r6, fp, #48
 1423              		.loc 1 1230 0
 1424 0058 1C301BE5 		mov	r7, #0
 1425 005c 013083E2 	.LVL101:
 1426              	.L163:
 1427 0060 1C300BE5 		mov	r0, #3
 1428 0064 1C201BE5 		mov	r1, r5
 1429 0068 1F0052E3 		mov	r2, #1
 1430 006c F9FFFF9A 		mov	r3, #0
 1431              		bl	MCI_SendCmd
 1432              		.loc 1 1231 0
 1433              		mov	r0, #3
 1434 0070 014054E2 		mov	r1, #1
 1435 0074 E8FFFF1A 		mov	r2, r6
 1436 0078 0400A0E1 		bl	MCI_GetCmdResp
 1437 007c 000000EA 		.loc 1 1234 0
 1438              		tst	r0, #4
 1439              		bne	.L159
 1440              		ldr	r2, [fp, #-48]
 1441 0080 0100A0E3 		and	r3, r2, #3840
 1442              		cmp	r3, #1280
 1443              		beq	.L168
1180:drivers_nxp/mci.c **** 			;
1181:drivers_nxp/mci.c **** 		}
1182:drivers_nxp/mci.c **** 		retryCount--;
1183:drivers_nxp/mci.c **** 	}
1184:drivers_nxp/mci.c **** 	return ( FALSE );
1185:drivers_nxp/mci.c **** }
 1444              	r7, [fp, #-32]
 1445 0084 18D04BE2 	.LVL102:
 1446 0088 70A89DE8 		ldr	r3, [fp, #-32]
 1447              		cmp	r3, #31
 1448              		bhi	.L161
 1449              	.L165:
 1450              		ldr	r3, [fp, #-32]
 1451              		add	r3, r3, #1
 1452              	.LVL103:
 1453              		str	r3, [fp, #-32]
 1454              		ldr	r2, [fp, #-32]
1186:drivers_nxp/mci.c **** 
1187:drivers_nxp/mci.c **** /******************************************************************************
1188:drivers_nxp/mci.c ****  ** Function name:		MCI_Set_Address
1189:drivers_nxp/mci.c ****  **
1190:drivers_nxp/mci.c ****  ** Descriptions:		Send CMD3, STE_RELATIVE_ADDR, should after CMD2		
1191:drivers_nxp/mci.c ****  **
1192:drivers_nxp/mci.c ****  ** parameters:			None
1193:drivers_nxp/mci.c ****  ** Returned value:		TRUE if response is back before timeout.
1194:drivers_nxp/mci.c ****  ** 
1195:drivers_nxp/mci.c ****  ** modified by mthomas
1196:drivers_nxp/mci.c ****  ******************************************************************************/
1197:drivers_nxp/mci.c **** DWORD MCI_Set_Address(void) {
 1455              	1
 1456              		bls	.L165
 1457              	.LVL104:
 1458 0000 0DC0A0E1 	.L161:
 1459              		.loc 1 1228 0
 1460 0004 F0D82DE9 		subs	r4, r4, #1
 1461              		bne	.L163
1198:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1199:drivers_nxp/mci.c **** 	DWORD retryCount;
1200:drivers_nxp/mci.c **** 	DWORD respStatus;
1201:drivers_nxp/mci.c **** 	DWORD respValue[4];
1202:drivers_nxp/mci.c **** 	DWORD CmdArgument;
1203:drivers_nxp/mci.c **** 
1204:drivers_nxp/mci.c **** 	/* If it's a SD card, SET_RELATIVE_ADDR is to get the address
1205:drivers_nxp/mci.c **** 	 from the card and use this value in RCA, if it's a MMC, set default
1206:drivers_nxp/mci.c **** 	 RCA addr. 0x00010000. */
1207:drivers_nxp/mci.c **** #if 1
1208:drivers_nxp/mci.c **** 	// mthomas:
1209:drivers_nxp/mci.c **** 	if (MCI_CardType & MMC_CARD) {
 1462              	, r4
 1463 0008 B0209FE5 	.L160:
 1464              		.loc 1 1245 0
 1465 000c 04B04CE2 		sub	sp, fp, #28
 1466              		ldmfd	sp, {r4, r5, r6, r7, fp, sp, pc}
 1467 0010 14D04DE2 	.LVL105:
 1468              	.L168:
 1469              		.loc 1 1236 0
 1470 0014 003092E5 		mov	r3, r2, lsr #16
 1471 0018 013013E2 		ldr	r2, .L169+4
 1472 001c 0350A001 		mov	r3, r3, asl #16
 1473 0020 0158A013 		str	r3, [r2, #0]
 1474              		mov	r0, #1
 1475 0024 2040A0E3 		b	.L160
 1476              	.L170:
 1477 0028 30604BE2 		.align	2
1210:drivers_nxp/mci.c **** 		/* If it's unknown or MMC_CARD, fix the RCA address */
1211:drivers_nxp/mci.c **** 		CmdArgument = 0x00010000;
1212:drivers_nxp/mci.c **** 	} else {
1213:drivers_nxp/mci.c **** 		CmdArgument = 0;
1214:drivers_nxp/mci.c **** 	}
1215:drivers_nxp/mci.c **** #else
1216:drivers_nxp/mci.c **** 	// NXP original:
1217:drivers_nxp/mci.c **** 	if ( MCI_CardType == SD_CARD )
1218:drivers_nxp/mci.c **** 	{
1219:drivers_nxp/mci.c **** 		CmdArgument = 0;
1220:drivers_nxp/mci.c **** 	}
1221:drivers_nxp/mci.c **** 	else /* If it's unknown or MMC_CARD, fix the RCA address */
1222:drivers_nxp/mci.c **** 	{
1223:drivers_nxp/mci.c **** 		CmdArgument = 0x00010000;
1224:drivers_nxp/mci.c **** 	}
1225:drivers_nxp/mci.c **** #endif
1226:drivers_nxp/mci.c **** 
1227:drivers_nxp/mci.c **** 	retryCount = 0x20; /* reset retry counter */
1228:drivers_nxp/mci.c **** 	while (retryCount > 0) {
1229:drivers_nxp/mci.c **** 		/* Send CMD3 command repeatedly until the response is back correctly */
1230:drivers_nxp/mci.c **** 		MCI_SendCmd( SET_RELATIVE_ADDR, CmdArgument, EXPECT_SHORT_RESP, 0);
 1478              	I_CardType
 1479 002c 0070A0E3 		.word	CardRCA
 1480              	.LFE30:
 1482 0030 0300A0E3 		.section	.text.MCI_Send_CSD,"ax",%progbits
 1483 0034 0510A0E1 		.align	2
 1484 0038 0120A0E3 		.global	MCI_Send_CSD
 1486 0040 FEFFFFEB 	MCI_Send_CSD:
1231:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( SET_RELATIVE_ADDR, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
 1487              	.loc 1 1259 0
 1488 0044 0300A0E3 		@ args = 0, pretend = 0, frame = 20
 1489 0048 0110A0E3 		@ frame_needed = 1, uses_anonymous_args = 0
 1490 004c 0620A0E1 	.LVL106:
 1491 0050 FEFFFFEB 		mov	ip, sp
1232:drivers_nxp/mci.c **** 		/* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
1233:drivers_nxp/mci.c **** 		/* It should go to IDEN state and bit 8 should be 1 */
1234:drivers_nxp/mci.c **** 		if ( !(respStatus & MCI_CMD_TIMEOUT) && ((respValue[0] & (0x0F << 8))
 1492              	46:
 1493 0054 040010E3 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, fp, ip, lr, pc}
 1494 0058 0300001A 	.LCFI47:
 1495 005c 30201BE5 		.loc 1 1268 0
 1496 0060 0F3C02E2 		ldr	r3, .L188
 1497 0064 050C53E3 		.loc 1 1259 0
 1498 0068 0E00000A 		sub	fp, ip, #4
 1499              	.LCFI48:
1235:drivers_nxp/mci.c **** 				== 0x0500)) {
1236:drivers_nxp/mci.c **** 			CardRCA = respValue[0] & 0xFFFF0000; /* Save the RCA value from SD card */
1237:drivers_nxp/mci.c **** 			return ( TRUE ); /* response is back and correct. */
1238:drivers_nxp/mci.c **** 		}
1239:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++) {
 1500              	 sp, #20
 1501 006c 20700BE5 	.LCFI49:
 1502              		.loc 1 1268 0
 1503 0070 20301BE5 		ldr	r2, [r3, #0]
 1504 0074 1F0053E3 		tst	r2, #1
 1505 0078 0500008A 		.loc 1 1272 0
 1506              		ldreq	r3, .L188+4
 1507 007c 20301BE5 		.loc 1 1289 0
 1508 0080 013083E2 		mov	r5, #-536870912
 1509              		.loc 1 1272 0
 1510 0084 20300BE5 		ldreq	r6, [r3, #0]
 1511 0088 20201BE5 	.LVL107:
 1512 008c 1F0052E3 		.loc 1 1259 0
 1513 0090 F9FFFF9A 		mov	sl, r0
 1514              		.loc 1 1268 0
 1515              		movne	r6, #65536
 1516              		.loc 1 1289 0
 1517 0094 014054E2 		add	r5, r5, #573440
 1518 0098 E4FFFF1A 		.loc 1 1272 0
 1519 009c 0400A0E1 		mov	r4, #32
 1520              	.LVL108:
1240:drivers_nxp/mci.c **** 			;
1241:drivers_nxp/mci.c **** 		}
1242:drivers_nxp/mci.c **** 		retryCount--;
1243:drivers_nxp/mci.c **** 	}
1244:drivers_nxp/mci.c **** 	return ( FALSE );
1245:drivers_nxp/mci.c **** }
 1521              	c 1 1290 0
 1522 00a0 1CD04BE2 		mov	r8, #0
 1523 00a4 F0A89DE8 	.LVL109:
 1524              	.L179:
 1525              		.loc 1 1289 0
 1526              		ldr	r3, [r5, #56]
 1527 00a8 2238A0E1 		orr	r3, r3, #69
 1528 00ac 10209FE5 		str	r3, [r5, #56]
 1529 00b0 0338A0E1 		.loc 1 1290 0
 1530 00b4 003082E5 		mov	r0, #9
 1531 00b8 0100A0E3 	.LVL110:
 1532 00bc F7FFFFEA 		mov	r1, r6
 1533              		mov	r2, #2
 1534              		mov	r3, #0
 1535              		bl	MCI_SendCmd
 1536 00c0 00000000 		.loc 1 1291 0
 1537 00c4 00000000 		mov	r0, #9
 1538              		mov	r1, #2
 1539              		mov	r2, r7
 1540              		bl	MCI_GetCmdResp
 1541              		.loc 1 1292 0
 1542              		cmp	r0, #0
 1543              	.LVL111:
 1544              		beq	.L187
 1545              		.loc 1 1305 0
1246:drivers_nxp/mci.c **** 
1247:drivers_nxp/mci.c **** /******************************************************************************
1248:drivers_nxp/mci.c ****  ** Function name:		MCI_Send_CSD
1249:drivers_nxp/mci.c ****  **
1250:drivers_nxp/mci.c ****  ** Descriptions:		CMD9, SEND_CSD cmd, it should be sent only at
1251:drivers_nxp/mci.c ****  **						STBY state and after CMD3. See MMC and SD spec. state 
1252:drivers_nxp/mci.c ****  **						diagram.
1253:drivers_nxp/mci.c ****  **
1254:drivers_nxp/mci.c ****  ** parameters:			None
1255:drivers_nxp/mci.c ****  ** Returned value:		Response value
1256:drivers_nxp/mci.c ****  ** 
1257:drivers_nxp/mci.c ****  ******************************************************************************/
1258:drivers_nxp/mci.c **** // DWORD MCI_Send_CSD( void )
1259:drivers_nxp/mci.c **** DWORD MCI_Send_CSD(DWORD *csd) {
 1546              	12:
 1547              		ldr	r3, [fp, #-40]
 1548              		cmp	r3, #31
 1549              		bhi	.L177
 1550 0000 0DC0A0E1 	.L183:
 1551              		ldr	r3, [fp, #-40]
 1552 0004 F0DD2DE9 		add	r3, r3, #1
 1553              	.LVL113:
1260:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1261:drivers_nxp/mci.c **** 	DWORD retryCount;
1262:drivers_nxp/mci.c **** 	DWORD respStatus;
1263:drivers_nxp/mci.c **** 	DWORD respValue[4];
1264:drivers_nxp/mci.c **** 	DWORD CmdArgument;
1265:drivers_nxp/mci.c **** 
1266:drivers_nxp/mci.c **** #if 1
1267:drivers_nxp/mci.c **** 	// mthomas:
1268:drivers_nxp/mci.c **** 	if (MCI_CardType & MMC_CARD) {
 1554              	 [fp, #-40]
 1555 0008 F4309FE5 		ldr	r2, [fp, #-40]
 1556              		cmp	r2, #31
 1557 000c 04B04CE2 		bls	.L183
 1558              	.LVL114:
 1559 0010 14D04DE2 	.L177:
 1560              		.loc 1 1287 0
 1561              		subs	r4, r4, #1
 1562 0014 002093E5 		bne	.L179
 1563 0018 010012E3 		mov	r0, r4
1269:drivers_nxp/mci.c **** 		/* If it's unknown or MMC_CARD, fix the RCA address */
1270:drivers_nxp/mci.c **** 		CmdArgument = 0x00010000;
1271:drivers_nxp/mci.c **** 	} else {
1272:drivers_nxp/mci.c **** 		CmdArgument = CardRCA;
 1564              	b	.L180
 1565 001c E4309F05 	.LVL116:
1273:drivers_nxp/mci.c **** 	}
1274:drivers_nxp/mci.c **** #else
1275:drivers_nxp/mci.c **** 	// NXP original:
1276:drivers_nxp/mci.c **** 	if ( MCI_CardType == SD_CARD )
1277:drivers_nxp/mci.c **** 	{
1278:drivers_nxp/mci.c **** 		CmdArgument = CardRCA;
1279:drivers_nxp/mci.c **** 	}
1280:drivers_nxp/mci.c **** 	else /* if MMC or unknown card type, use default RCA addr. */
1281:drivers_nxp/mci.c **** 	{
1282:drivers_nxp/mci.c **** 		CmdArgument = 0x00010000;
1283:drivers_nxp/mci.c **** 	}
1284:drivers_nxp/mci.c **** #endif
1285:drivers_nxp/mci.c **** 
1286:drivers_nxp/mci.c **** 	retryCount = 0x20;
1287:drivers_nxp/mci.c **** 	while (retryCount > 0) {
1288:drivers_nxp/mci.c **** 		/* Send SET_BLOCK_LEN command before read and write */
1289:drivers_nxp/mci.c **** 		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
 1566              	187:
 1567 0020 0E52A0E3 		.loc 1 1298 0
 1568              		cmp	sl, #0
 1569 0024 00609305 		beq	.L175
 1570              		.loc 1 1299 0
 1571              		str	r0, [fp, #-40]
 1572 0028 00A0A0E1 	.LVL117:
 1573              		ldr	r3, [fp, #-40]
 1574 002c 0168A013 		cmp	r3, #3
 1575              		bhi	.L175
 1576 0030 235985E2 	.L182:
 1577              		.loc 1 1300 0
 1578 0034 2040A0E3 		ldr	r0, [fp, #-40]
 1579              	.LVL118:
 1580 0038 38704BE2 		ldr	r1, [fp, #-40]
1290:drivers_nxp/mci.c **** 		MCI_SendCmd( SEND_CSD, CmdArgument, EXPECT_LONG_RESP, 0);
 1581              		ldr	r3, [fp, #-40]
 1582 003c 0080A0E3 		add	r3, r3, #1
 1583              	.LVL119:
 1584              		str	r3, [fp, #-40]
 1585              		.loc 1 1300 0
 1586 0040 383095E5 		sub	r3, fp, #36
 1587 0044 453083E3 	.LVL120:
 1588 0048 383085E5 		add	r2, r3, r1, asl #2
 1589              		.loc 1 1299 0
 1590 004c 0900A0E3 		ldr	r3, [fp, #-40]
 1591              		.loc 1 1300 0
 1592 0050 0610A0E1 		ldr	r1, [r2, #-20]
 1593 0054 0220A0E3 		.loc 1 1299 0
 1594 0058 0030A0E3 		cmp	r3, #3
 1595 005c FEFFFFEB 		.loc 1 1300 0
1291:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( SEND_CSD, EXPECT_LONG_RESP, (DWORD *)&respValue[0]);
 1596              	0, asl #2]
 1597 0060 0900A0E3 		.loc 1 1299 0
 1598 0064 0210A0E3 		bls	.L182
 1599 0068 0720A0E1 	.LVL121:
 1600 006c FEFFFFEB 	.L175:
1292:drivers_nxp/mci.c **** 		if ( !respStatus) {
 1601              	 1 1287 0
 1602 0070 000050E3 		mov	r0, #1
 1603              	.LVL122:
 1604 0074 0D00000A 	.L180:
1293:drivers_nxp/mci.c **** 			mci_debug_printf("MCI_Send_CSD result: %08x %08x %08x %08x\n",
1294:drivers_nxp/mci.c **** 					respValue[0], respValue[1],
1295:drivers_nxp/mci.c **** 					respValue[2], respValue[3]
1296:drivers_nxp/mci.c **** 			);
1297:drivers_nxp/mci.c **** 
1298:drivers_nxp/mci.c **** 			if (csd) {
1299:drivers_nxp/mci.c **** 				for (i = 0; i < 4; i++) {
1300:drivers_nxp/mci.c **** 					csd[i] = respValue[i];
1301:drivers_nxp/mci.c **** 				}
1302:drivers_nxp/mci.c **** 			}
1303:drivers_nxp/mci.c **** 			return ( TRUE );
1304:drivers_nxp/mci.c **** 		}
1305:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++) {
 1605              	c 1 1311 0
 1606 0078 28800BE5 		sub	sp, fp, #36
 1607              		ldmfd	sp, {r4, r5, r6, r7, r8, sl, fp, sp, pc}
 1608 007c 28301BE5 	.L189:
 1609 0080 1F0053E3 		.align	2
 1610 0084 0500008A 	.L188:
 1611              		.word	MCI_CardType
 1612 0088 28301BE5 		.word	CardRCA
 1613 008c 013083E2 	.LFE31:
 1615 0090 28300BE5 		.section	.text.MCI_Select_Card,"ax",%progbits
 1616 0094 28201BE5 		.align	2
 1617 0098 1F0052E3 		.global	MCI_Select_Card
 1619              	MCI_Select_Card:
 1620              	.LFB32:
 1621              		.loc 1 1325 0
 1622 00a0 014054E2 		@ args = 0, pretend = 0, frame = 20
 1623 00a4 E5FFFF1A 		@ frame_needed = 1, uses_anonymous_args = 0
 1624 00a8 0400A0E1 		mov	ip, sp
 1625              	.LCFI50:
 1626 00ac 120000EA 		stmfd	sp!, {r4, r5, r6, r7, r8, fp, ip, lr, pc}
 1627              	.LCFI51:
 1628              		.loc 1 1334 0
 1629              		ldr	r3, .L205
 1630 00b0 00005AE3 		.loc 1 1325 0
 1631 00b4 0F00000A 		sub	fp, ip, #4
 1632              	.LCFI52:
 1633 00b8 28000BE5 		sub	sp, sp, #20
 1634              	.LCFI53:
 1635 00bc 28301BE5 		.loc 1 1334 0
 1636 00c0 030053E3 		ldr	r1, [r3, #0]
 1637 00c4 0B00008A 		cmp	r1, #0
 1638              		beq	.L191
 1639              		.loc 1 1336 0
 1640 00c8 28001BE5 		ldr	r3, [r3, #0]
 1641              		ands	r0, r3, #1
 1642 00cc 28101BE5 		bne	.L192
 1643              		.loc 1 1340 0
 1644 00d0 28301BE5 		ldr	r2, .L205+4
 1645 00d4 013083E2 		.loc 1 1359 0
 1646              		mov	r1, #-536870912
 1647 00d8 28300BE5 		add	r1, r1, #573440
 1648              		.loc 1 1340 0
 1649 00dc 24304BE2 		ldr	r6, [r2, #0]
 1650              	.LVL123:
 1651 00e0 012183E0 		.loc 1 1359 0
 1652              		ldr	r3, [r1, #56]
 1653 00e4 28301BE5 		orr	r3, r3, #69
 1654              		str	r3, [r1, #56]
 1655 00e8 141012E5 		.loc 1 1360 0
 1656              		mov	r2, #1
 1657 00ec 030053E3 		mov	r3, r0
 1658              		mov	r1, r6
 1659 00f0 00118AE7 		mov	r0, #7
 1660              		.loc 1 1361 0
 1661 00f4 F3FFFF9A 		sub	r7, fp, #52
 1662              		.loc 1 1360 0
 1663              		bl	MCI_SendCmd
 1664              		.loc 1 1361 0
 1665 00f8 0100A0E3 		mov	r0, #7
 1666              		mov	r1, #1
 1667              		mov	r2, r7
1306:drivers_nxp/mci.c **** 			;
1307:drivers_nxp/mci.c **** 		}
1308:drivers_nxp/mci.c **** 		retryCount--;
1309:drivers_nxp/mci.c **** 	}
1310:drivers_nxp/mci.c **** 	return ( FALSE );
1311:drivers_nxp/mci.c **** }
 1668              	
 1669 00fc 24D04BE2 		.loc 1 1359 0
 1670 0100 F0AD9DE8 		mov	r5, #-536870912
 1671              		add	r5, r5, #573440
 1672              		.loc 1 1363 0
 1673              		mov	r4, #32
 1674 0104 00000000 	.LVL124:
 1675 0108 00000000 		.loc 1 1386 0
 1676              		mov	r8, #0
 1677              	.LVL125:
 1678              	.L199:
 1679              		.loc 1 1365 0
 1680              		cmp	r0, #0
 1681              	.LVL126:
 1682              		bne	.L194
 1683              		ldr	r3, [fp, #-52]
1312:drivers_nxp/mci.c **** 
1313:drivers_nxp/mci.c **** /******************************************************************************
1314:drivers_nxp/mci.c ****  ** Function name:		MCI_Select_Card
1315:drivers_nxp/mci.c ****  **
1316:drivers_nxp/mci.c ****  ** Descriptions:		CMD7, SELECT_CARD, should be after CMD9, the state
1317:drivers_nxp/mci.c ****  **						will be inter-changed between STBY and TRANS after 
1318:drivers_nxp/mci.c ****  **						this cmd.
1319:drivers_nxp/mci.c ****  **
1320:drivers_nxp/mci.c ****  ** parameters:			None
1321:drivers_nxp/mci.c ****  ** Returned value:		return false if response times out.
1322:drivers_nxp/mci.c ****  ** 
1323:drivers_nxp/mci.c ****  ** modified by Martin Thomas for unselect (RCA 0)
1324:drivers_nxp/mci.c ****  ******************************************************************************/
1325:drivers_nxp/mci.c **** DWORD MCI_Select_Card(void) {
 1684              	840
 1685              		cmp	r3, #1792
 1686              		beq	.L193
 1687 0000 0DC0A0E1 	.L194:
 1688              		.loc 1 1386 0
 1689 0004 F0D92DE9 		str	r8, [fp, #-36]
 1690              	.LVL127:
1326:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1327:drivers_nxp/mci.c **** 	DWORD retryCount;
1328:drivers_nxp/mci.c **** 	DWORD respStatus;
1329:drivers_nxp/mci.c **** 	DWORD respValue[4];
1330:drivers_nxp/mci.c **** 	DWORD CmdArgument;
1331:drivers_nxp/mci.c **** 
1332:drivers_nxp/mci.c **** #if 1
1333:drivers_nxp/mci.c **** 	// mthomas:
1334:drivers_nxp/mci.c **** 	if (MCI_CardType == CARD_UNKNOWN) {
 1691              	, [fp, #-36]
 1692 0008 88319FE5 		cmp	r3, #31
 1693              		bhi	.L195
 1694 000c 04B04CE2 	.L202:
 1695              		ldr	r3, [fp, #-36]
 1696 0010 14D04DE2 		add	r3, r3, #1
 1697              	.LVL128:
 1698              		str	r3, [fp, #-36]
 1699 0014 001093E5 		ldr	r2, [fp, #-36]
 1700 0018 000051E3 		cmp	r2, #31
 1701 001c 3800000A 		bls	.L202
1335:drivers_nxp/mci.c **** 		CmdArgument = 0; // RCA = 0 -> de-select -> trans to stby
1336:drivers_nxp/mci.c **** 	} else if (MCI_CardType & MMC_CARD) {
 1702              	195:
 1703 0020 003093E5 		.loc 1 1355 0
 1704 0024 010013E2 		subs	r4, r4, #1
 1705 0028 4500001A 		beq	.L204
1337:drivers_nxp/mci.c **** 		/* If it's unknown or MMC_CARD, fix the RCA address */
1338:drivers_nxp/mci.c **** 		CmdArgument = 0x00010000;
1339:drivers_nxp/mci.c **** 	} else {
1340:drivers_nxp/mci.c **** 		CmdArgument = CardRCA;
 1706              	c 1 1359 0
 1707 002c 68219FE5 		ldr	r3, [r5, #56]
1341:drivers_nxp/mci.c **** 	}
1342:drivers_nxp/mci.c **** #else
1343:drivers_nxp/mci.c **** 	// NXP original:
1344:drivers_nxp/mci.c **** 	if ( MCI_CardType == SD_CARD )
1345:drivers_nxp/mci.c **** 	{
1346:drivers_nxp/mci.c **** 		CmdArgument = CardRCA;
1347:drivers_nxp/mci.c **** 	}
1348:drivers_nxp/mci.c **** 	else /* if MMC or unknown card type, use default RCA addr. */
1349:drivers_nxp/mci.c **** 	{
1350:drivers_nxp/mci.c **** 		CmdArgument = 0x00010000;
1351:drivers_nxp/mci.c **** 	}
1352:drivers_nxp/mci.c **** #endif
1353:drivers_nxp/mci.c **** 
1354:drivers_nxp/mci.c **** 	retryCount = 0x20;
1355:drivers_nxp/mci.c **** 	while (retryCount > 0) {
1356:drivers_nxp/mci.c **** #if 1
1357:drivers_nxp/mci.c **** 		// mthomas:
1358:drivers_nxp/mci.c **** 		/* Send SELECT_CARD command before read and write */
1359:drivers_nxp/mci.c **** 		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
 1708              	rr	r3, r3, #69
 1709 0030 0E12A0E3 		str	r3, [r5, #56]
 1710 0034 231981E2 		.loc 1 1360 0
 1711              		mov	r1, r6
 1712 0038 006092E5 		mov	r0, #7
 1713              	.LVL130:
 1714              		mov	r2, #1
 1715 003c 383091E5 		mov	r3, #0
 1716 0040 453083E3 		bl	MCI_SendCmd
 1717 0044 383081E5 		.loc 1 1361 0
1360:drivers_nxp/mci.c **** 		MCI_SendCmd( SELECT_CARD, CmdArgument, EXPECT_SHORT_RESP, 0);
 1718              	1
 1719 0048 0120A0E3 		mov	r2, r7
 1720 004c 0030A0E1 		mov	r0, #7
 1721 0050 0610A0E1 		bl	MCI_GetCmdResp
 1722 0054 0700A0E3 		b	.L199
1361:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( SELECT_CARD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
 1723              	31:
 1724 0058 34704BE2 	.L191:
 1725              		.loc 1 1359 0
 1726 005c FEFFFFEB 		mov	r2, #-536870912
 1727              		add	r2, r2, #573440
 1728 0060 0700A0E3 		ldr	r3, [r2, #56]
 1729 0064 0110A0E3 		orr	r3, r3, #69
 1730 0068 0720A0E1 		str	r3, [r2, #56]
 1731 006c FEFFFFEB 		.loc 1 1360 0
1362:drivers_nxp/mci.c **** 
1363:drivers_nxp/mci.c **** 		if (CmdArgument) {
 1732              	#7
 1733 0070 000056E3 		mov	r3, r1
 1734 0074 4500000A 		mov	r2, #1
 1735              		bl	MCI_SendCmd
 1736              		.loc 1 1361 0
 1737 0078 0E52A0E3 		mov	r0, #7
 1738 007c 235985E2 		mov	r1, #1
 1739              		sub	r2, fp, #52
 1740 0080 2040A0E3 		bl	MCI_GetCmdResp
 1741              		mov	r0, #1
1364:drivers_nxp/mci.c **** 			// select card
1365:drivers_nxp/mci.c **** 			if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0700 )) { /* Should be in STANDBY state n
1366:drivers_nxp/mci.c **** 				/* mthomas: repsValue 0 is the card-status V2.2 p3-20
1367:drivers_nxp/mci.c **** 				 READ_FOR_DATA: ready, CURRENT_STATE=3->stby */
1368:drivers_nxp/mci.c **** 				return ( TRUE );
1369:drivers_nxp/mci.c **** 			}
1370:drivers_nxp/mci.c **** 		} else {
1371:drivers_nxp/mci.c **** 			// TODO: Timeouts - maybe because not card is selected
1372:drivers_nxp/mci.c **** 			return ( TRUE );
1373:drivers_nxp/mci.c **** 		}
1374:drivers_nxp/mci.c **** #else
1375:drivers_nxp/mci.c **** 		// NXP original
1376:drivers_nxp/mci.c **** 		/* Send SELECT_CARD command before read and write */
1377:drivers_nxp/mci.c **** 		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
1378:drivers_nxp/mci.c **** 		MCI_SendCmd( SELECT_CARD, CmdArgument, EXPECT_SHORT_RESP, 0 );
1379:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( SELECT_CARD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0] );
1380:drivers_nxp/mci.c **** 		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0700 ))
1381:drivers_nxp/mci.c **** 		{ /* Should be in STANDBY state now and ready */
1382:drivers_nxp/mci.c **** 			/* mthomas: READ_FOR_DATA: ready, CURRENT_STATE=3->stby */
1383:drivers_nxp/mci.c **** 			return ( TRUE );
1384:drivers_nxp/mci.c **** 		}
1385:drivers_nxp/mci.c **** #endif
1386:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++) {
 1742              	L198:
 1743 0084 0080A0E3 		.loc 1 1393 0
 1744              		sub	sp, fp, #32
 1745              		ldmfd	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
 1746              	.LVL133:
 1747 0088 000050E3 	.L192:
 1748              		.loc 1 1359 0
 1749 008c 0300001A 		mov	r2, #-536870912
 1750 0090 34301BE5 		add	r2, r2, #573440
 1751 0094 0F3C03E2 		ldr	r3, [r2, #56]
 1752 0098 070C53E3 		orr	r3, r3, #69
 1753 009c 3B00000A 		str	r3, [r2, #56]
 1754              		.loc 1 1360 0
 1755              		mov	r0, #7
 1756 00a0 24800BE5 		mov	r1, #65536
 1757              		mov	r2, #1
 1758 00a4 24301BE5 		mov	r3, #0
 1759 00a8 1F0053E3 		.loc 1 1361 0
 1760 00ac 0500008A 		sub	r7, fp, #52
 1761              		.loc 1 1360 0
 1762 00b0 24301BE5 		bl	MCI_SendCmd
 1763 00b4 013083E2 		.loc 1 1361 0
 1764              		mov	r0, #7
 1765 00b8 24300BE5 		mov	r1, #1
 1766 00bc 24201BE5 		mov	r2, r7
 1767 00c0 1F0052E3 		bl	MCI_GetCmdResp
 1768 00c4 F9FFFF9A 		mov	r6, #65536
 1769              	.LVL134:
 1770              		b	.L200
 1771              	.LVL135:
 1772 00c8 014054E2 	.L204:
 1773 00cc 2D00000A 		.loc 1 1355 0
 1774              		mov	r0, r4
 1775 00d0 383095E5 	.LVL136:
 1776 00d4 453083E3 		b	.L198
 1777 00d8 383085E5 	.LVL137:
 1778              	.L193:
 1779 00dc 0610A0E1 		mov	r0, #1
 1780 00e0 0700A0E3 	.LVL138:
 1781              		b	.L198
 1782 00e4 0120A0E3 	.L206:
 1783 00e8 0030A0E3 		.align	2
 1784 00ec FEFFFFEB 	.L205:
 1785              		.word	MCI_CardType
 1786 00f0 0110A0E3 		.word	CardRCA
 1787 00f4 0720A0E1 	.LFE32:
 1789 00fc FEFFFFEB 		.section	.text.MCI_Send_Status,"ax",%progbits
 1790 0100 E0FFFFEA 		.align	2
 1791              		.global	MCI_Send_Status
 1793              	MCI_Send_Status:
 1794 0104 0E22A0E3 	.LFB33:
 1795 0108 232982E2 		.loc 1 1408 0
 1796 010c 383092E5 		@ args = 0, pretend = 0, frame = 16
 1797 0110 453083E3 		@ frame_needed = 1, uses_anonymous_args = 0
 1798 0114 383082E5 		mov	ip, sp
 1799              	.LCFI54:
 1800 0118 0700A0E3 		stmfd	sp!, {r4, r5, r6, r7, fp, ip, lr, pc}
 1801 011c 0130A0E1 	.LCFI55:
 1802 0120 0120A0E3 		.loc 1 1416 0
 1803 0124 FEFFFFEB 		ldr	r3, .L216
 1804              		.loc 1 1408 0
 1805 0128 0700A0E3 		sub	fp, ip, #4
 1806 012c 0110A0E3 	.LCFI56:
 1807 0130 34204BE2 		sub	sp, sp, #16
 1808 0134 FEFFFFEB 	.LCFI57:
 1809 0138 0100A0E3 		.loc 1 1416 0
 1810              		ldr	r2, [r3, #0]
 1811              		tst	r2, #1
1387:drivers_nxp/mci.c **** 			;
1388:drivers_nxp/mci.c **** 		}mci_debug_printf(" Select_Card: arg:%08x respStatus: %08x resp0:%08x resp1:%08x\n",
1389:drivers_nxp/mci.c **** 				CmdArgument, respStatus, respValue[0], respValue[1]);
1390:drivers_nxp/mci.c **** 		retryCount--;
1391:drivers_nxp/mci.c **** 	} /* while retry */
1392:drivers_nxp/mci.c **** 	return ( FALSE );
1393:drivers_nxp/mci.c **** }
 1812              		.loc 1 1416 0
 1813 013c 20D04BE2 		movne	r6, #65536
 1814 0140 F0A99DE8 	.LVL139:
 1815              		.loc 1 1420 0
 1816              		ldreq	r6, [r3, #0]
 1817              		.loc 1 1439 0
 1818 0144 0E22A0E3 		add	r5, r5, #573440
 1819 0148 232982E2 		.loc 1 1420 0
 1820 014c 383092E5 		mov	r4, #8192
 1821 0150 453083E3 	.LVL140:
 1822 0154 383082E5 		sub	r7, fp, #44
 1823              		b	.L212
 1824 0158 0700A0E3 	.L210:
 1825 015c 0118A0E3 		.loc 1 1437 0
 1826 0160 0120A0E3 		subs	r4, r4, #1
 1827 0164 0030A0E3 		beq	.L215
 1828              	.L212:
 1829 0168 34704BE2 		.loc 1 1439 0
 1830              		ldr	r3, [r5, #56]
 1831 016c FEFFFFEB 		orr	r3, r3, #69
 1832              		str	r3, [r5, #56]
 1833 0170 0700A0E3 		.loc 1 1440 0
 1834 0174 0110A0E3 		mov	r0, #13
 1835 0178 0720A0E1 		mov	r1, r6
 1836 017c FEFFFFEB 		mov	r2, #1
 1837 0180 0168A0E3 		mov	r3, #0
 1838              		bl	MCI_SendCmd
 1839 0184 BBFFFFEA 		.loc 1 1441 0
 1840              		mov	r0, #13
 1841              		mov	r1, #1
 1842              		mov	r2, r7
 1843 0188 0400A0E1 		bl	MCI_GetCmdResp
 1844              		.loc 1 1442 0
 1845 018c EAFFFFEA 		cmp	r0, #0
 1846              		bne	.L210
 1847              		ldr	r0, [fp, #-44]
 1848 0190 0100A0E3 		tst	r0, #256
 1849              		beq	.L210
 1850 0194 E8FFFFEA 	.L211:
 1851              		.loc 1 1448 0
 1852              		sub	sp, fp, #28
 1853              		ldmfd	sp, {r4, r5, r6, r7, fp, sp, pc}
 1854 0198 00000000 	.L215:
 1855 019c 00000000 		.loc 1 1437 0
 1856              		mvn	r0, #0
 1857              		b	.L211
 1858              	.L217:
 1859              		.align	2
 1860              	.L216:
 1861              		.word	MCI_CardType
 1862              		.word	CardRCA
 1863              	.LFE33:
1394:drivers_nxp/mci.c **** 
1395:drivers_nxp/mci.c **** /******************************************************************************
1396:drivers_nxp/mci.c ****  ** Function name:		MCI_Send_Status
1397:drivers_nxp/mci.c ****  **
1398:drivers_nxp/mci.c ****  ** Descriptions:		CMD13, SEND_STATUS, the most important cmd to
1399:drivers_nxp/mci.c ****  **						debug the state machine of the card.		
1400:drivers_nxp/mci.c ****  **
1401:drivers_nxp/mci.c ****  ** parameters:			None
1402:drivers_nxp/mci.c ****  ** Returned value:		Response value(card status), true if the ready bit 
1403:drivers_nxp/mci.c ****  **						is set in the card status register, if timeout, return 
1404:drivers_nxp/mci.c ****  **						INVALID_RESPONSE 0xFFFFFFFF.
1405:drivers_nxp/mci.c ****  ** 
1406:drivers_nxp/mci.c ****  ** modified by mthomas
1407:drivers_nxp/mci.c ****  ******************************************************************************/
1408:drivers_nxp/mci.c **** DWORD MCI_Send_Status(void) {
 1864              	.text.MCI_CheckStatus,"ax",%progbits
 1865              		.align	2
 1866              		.global	MCI_CheckStatus
 1868              	MCI_CheckStatus:
 1869 0004 F0D82DE9 	.LFB12:
 1870              		.loc 1 227 0
1409:drivers_nxp/mci.c **** 	DWORD retryCount;
1410:drivers_nxp/mci.c **** 	DWORD respStatus;
1411:drivers_nxp/mci.c **** 	DWORD respValue[4];
1412:drivers_nxp/mci.c **** 	DWORD CmdArgument;
1413:drivers_nxp/mci.c **** 
1414:drivers_nxp/mci.c **** #if 1
1415:drivers_nxp/mci.c **** 	// mthomas:
1416:drivers_nxp/mci.c **** 	if (MCI_CardType & MMC_CARD) {
 1871              	 = 0, pretend = 0, frame = 0
 1872 0008 88309FE5 		@ frame_needed = 1, uses_anonymous_args = 0
 1873              		mov	ip, sp
 1874 000c 04B04CE2 	.LCFI58:
 1875              		stmfd	sp!, {fp, ip, lr, pc}
 1876 0010 10D04DE2 	.LCFI59:
 1877              		sub	fp, ip, #4
 1878              	.LCFI60:
 1879 0014 002093E5 	.LVL141:
 1880 0018 010012E3 	.L221:
1417:drivers_nxp/mci.c **** 		/* If it's unknown or MMC_CARD, fix the RCA address */
1418:drivers_nxp/mci.c **** 		CmdArgument = 0x00010000;
1419:drivers_nxp/mci.c **** 	} else {
1420:drivers_nxp/mci.c **** 		CmdArgument = CardRCA;
 1881              	2 0
 1882 001c 78309F05 		bl	MCI_Send_Status
1421:drivers_nxp/mci.c **** 	}
1422:drivers_nxp/mci.c **** #else
1423:drivers_nxp/mci.c **** 	// NXP original:	
1424:drivers_nxp/mci.c **** 	if ( MCI_CardType == SD_CARD )
1425:drivers_nxp/mci.c **** 	{
1426:drivers_nxp/mci.c **** 		CmdArgument = CardRCA;
1427:drivers_nxp/mci.c **** 	}
1428:drivers_nxp/mci.c **** 	else /* if MMC or unknown card type, use default RCA addr. */
1429:drivers_nxp/mci.c **** 	{
1430:drivers_nxp/mci.c **** 		CmdArgument = 0x00010000;
1431:drivers_nxp/mci.c **** 	}
1432:drivers_nxp/mci.c **** #endif
1433:drivers_nxp/mci.c **** 
1434:drivers_nxp/mci.c **** 	/* Note that, since it's called after the block write and read, this timeout 
1435:drivers_nxp/mci.c **** 	 is important based on the clock you set for the data communication. */
1436:drivers_nxp/mci.c **** 	retryCount = 0x2000;
1437:drivers_nxp/mci.c **** 	while (retryCount > 0) {
1438:drivers_nxp/mci.c **** 		/* Send SELECT_CARD command before read and write */
1439:drivers_nxp/mci.c **** 		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
 1883              	VL142:
 1884 0020 0E52A0E3 		cmn	r0, #1
 1885              	.LVL143:
 1886 0024 0168A013 		.loc 1 239 0
 1887              		and	r3, r0, #3840
 1888              		.loc 1 232 0
 1889 0028 00609305 		beq	.L224
 1890              		.loc 1 239 0
 1891 002c 235985E2 		cmp	r3, #2304
 1892              		bne	.L221
 1893 0030 024AA0E3 		mov	r0, #1
 1894              	.LVL144:
 1895 0034 2C704BE2 		.loc 1 246 0
 1896 0038 010000EA 		ldmfd	sp, {fp, sp, pc}
 1897              	.LVL145:
 1898              	.L224:
 1899 003c 014054E2 		.loc 1 232 0
 1900 0040 1200000A 		add	r0, r0, #1
 1901              	.LVL146:
 1902              		ldmfd	sp, {fp, sp, pc}
 1903 0044 383095E5 	.LFE12:
 1905 004c 383085E5 		.section	.text.MCI_Set_BlockLen,"ax",%progbits
1440:drivers_nxp/mci.c **** 		MCI_SendCmd( SEND_STATUS, CmdArgument, EXPECT_SHORT_RESP, 0);
 1906              	Set_BlockLen
 1908 0054 0610A0E1 	MCI_Set_BlockLen:
 1909 0058 0120A0E3 	.LFB34:
 1910 005c 0030A0E3 		.loc 1 1461 0
 1911 0060 FEFFFFEB 		@ args = 0, pretend = 0, frame = 20
1441:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( SEND_STATUS, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
 1912              	me_needed = 1, uses_anonymous_args = 0
 1913 0064 0D00A0E3 	.LVL147:
 1914 0068 0110A0E3 		mov	ip, sp
 1915 006c 0720A0E1 	.LCFI61:
 1916 0070 FEFFFFEB 		stmfd	sp!, {r4, r5, r6, r7, r8, fp, ip, lr, pc}
1442:drivers_nxp/mci.c **** 		if ( !respStatus && (respValue[0] & (1 << 8))) { /* The ready bit should be set, it should be in 
 1917              	62:
 1918 0074 000050E3 		sub	fp, ip, #4
 1919 0078 EFFFFF1A 	.LCFI63:
 1920 007c 2C001BE5 		sub	sp, sp, #20
 1921 0080 010C10E3 	.LCFI64:
 1922 0084 ECFFFF0A 		.loc 1 1470 0
 1923              		mov	r5, #-536870912
1443:drivers_nxp/mci.c **** 			return (respValue[0] );
1444:drivers_nxp/mci.c **** 		}
1445:drivers_nxp/mci.c **** 		retryCount--;
1446:drivers_nxp/mci.c **** 	}
1447:drivers_nxp/mci.c **** 	return ( INVALID_RESPONSE );
1448:drivers_nxp/mci.c **** }
 1924              	 1461 0
 1925 0088 1CD04BE2 		.loc 1 1461 0
 1926 008c F0A89DE8 		mov	r6, r0
 1927              		.loc 1 1470 0
 1928              		add	r5, r5, #573440
 1929 0090 0000E0E3 		.loc 1 1461 0
 1930 0094 FBFFFFEA 		mov	r4, #32
 1931              	.LVL148:
 1932              		sub	r7, fp, #52
 1933              		.loc 1 1471 0
 1934 0098 00000000 		mov	r8, #0
 1935 009c 00000000 	.LVL149:
 1936              	.L230:
 1937              		.loc 1 1470 0
 1938              		ldr	r3, [r5, #56]
 1939              		orr	r3, r3, #69
 1940              		str	r3, [r5, #56]
 1941              		.loc 1 1471 0
 1942              		mov	r0, #16
 1943              		mov	r1, r6
 1944              		mov	r2, #1
 1945              		mov	r3, #0
 1946              		bl	MCI_SendCmd
 1947 0000 0DC0A0E1 		.loc 1 1472 0
 1948              		mov	r0, #16
 1949 0004 00D82DE9 		mov	r1, #1
 1950              		mov	r2, r7
 1951 0008 04B04CE2 		bl	MCI_GetCmdResp
 1952              		.loc 1 1474 0
 1953              		cmp	r0, #0
 1954              		bne	.L226
 1955              		ldr	r3, [fp, #-52]
 1956 000c FEFFFFEB 		and	r3, r3, #3840
 1957              		cmp	r3, #2304
 1958 0010 010070E3 		beq	.L235
 1959              	.L226:
 1960              		.loc 1 1477 0
 1961 0014 0F3C00E2 		str	r8, [fp, #-36]
 1962              	.LVL150:
 1963 0018 0300000A 		ldr	r3, [fp, #-36]
 1964              		cmp	r3, #31
 1965 001c 090C53E3 		bhi	.L228
 1966 0020 F9FFFF1A 	.L232:
 1967 0024 0100A0E3 		ldr	r3, [fp, #-36]
 1968              		add	r3, r3, #1
 1969              	.LVL151:
 1970 0028 00A89DE8 		str	r3, [fp, #-36]
 1971              		ldr	r2, [fp, #-36]
 1972              		cmp	r2, #31
 1973              		bls	.L232
 1974 002c 010080E2 	.LVL152:
 1975              	.L228:
 1976 0030 00A89DE8 		.loc 1 1468 0
 1977              		subs	r4, r4, #1
 1978              		bne	.L230
 1979              		mov	r0, r4
 1980              	.L227:
 1981              		.loc 1 1483 0
 1982              		sub	sp, fp, #32
 1983              		ldmfd	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
 1984              	.LVL153:
1449:drivers_nxp/mci.c **** 
1450:drivers_nxp/mci.c **** /******************************************************************************
1451:drivers_nxp/mci.c ****  ** Function name:		MCI_Set_BlockLen
1452:drivers_nxp/mci.c ****  **
1453:drivers_nxp/mci.c ****  ** Descriptions:		CMD16, SET_BLOCKLEN, called after CMD7(SELECT_CARD)
1454:drivers_nxp/mci.c ****  **						called in the TRANS state.
1455:drivers_nxp/mci.c ****  **
1456:drivers_nxp/mci.c ****  ** parameters:			The length of the data block to be written or read.
1457:drivers_nxp/mci.c ****  ** Returned value:		true or false, return TRUE if ready bit is set, and it's
1458:drivers_nxp/mci.c ****  **						in TRANS state.
1459:drivers_nxp/mci.c ****  ** 
1460:drivers_nxp/mci.c ****  ******************************************************************************/
1461:drivers_nxp/mci.c **** DWORD MCI_Set_BlockLen(DWORD blockLength) {
 1985              		MCI_Set_BlockLen, .-MCI_Set_BlockLen
 1986              		.section	.text.MCI_Send_ACMD_Bus_Width,"ax",%progbits
 1987              		.align	2
 1988              		.global	MCI_Send_ACMD_Bus_Width
 1990              	MCI_Send_ACMD_Bus_Width:
 1991 0004 F0D92DE9 	.LFB35:
 1992              		.loc 1 1499 0
 1993 0008 04B04CE2 		@ args = 0, pretend = 0, frame = 20
 1994              		@ frame_needed = 1, uses_anonymous_args = 0
 1995 000c 14D04DE2 	.LVL154:
 1996              		mov	ip, sp
1462:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1463:drivers_nxp/mci.c **** 	DWORD retryCount;
1464:drivers_nxp/mci.c **** 	DWORD respStatus;
1465:drivers_nxp/mci.c **** 	DWORD respValue[4];
1466:drivers_nxp/mci.c **** 
1467:drivers_nxp/mci.c **** 	retryCount = 0x20;
1468:drivers_nxp/mci.c **** 	while (retryCount > 0) {
1469:drivers_nxp/mci.c **** 		/* Send SET_BLOCK_LEN command before read and write */
1470:drivers_nxp/mci.c **** 		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
 1997              	mfd	sp!, {r4, r5, r6, r7, fp, ip, lr, pc}
 1998 0010 0E52A0E3 	.LCFI66:
 1999              		sub	fp, ip, #4
 2000              	.LCFI67:
 2001 0014 0060A0E1 		sub	sp, sp, #20
 2002              	.LCFI68:
 2003 0018 235985E2 		.loc 1 1499 0
 2004              		mov	r5, r0
 2005 001c 2040A0E3 		mov	r4, #32
 2006              	.LVL155:
 2007 0020 34704BE2 		sub	r7, fp, #48
1471:drivers_nxp/mci.c **** 		MCI_SendCmd( SET_BLOCK_LEN, blockLength, EXPECT_SHORT_RESP, 0);
 2008              	1 0
 2009 0024 0080A0E3 		mov	r6, #0
 2010              	.LVL156:
 2011              	.L247:
 2012              		.loc 1 1507 0
 2013 0028 383095E5 		bl	MCI_Send_ACMD
 2014 002c 453083E3 		cmp	r0, #0
 2015 0030 383085E5 		beq	.L247
 2016              		.loc 1 1511 0
 2017 0034 1000A0E3 		mov	r0, #6
 2018 0038 0610A0E1 		mov	r1, r5
 2019 003c 0120A0E3 		mov	r2, #1
 2020 0040 0030A0E3 		mov	r3, #0
 2021 0044 FEFFFFEB 		bl	MCI_SendCmd
1472:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( SET_BLOCK_LEN, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
 2022              	
 2023 0048 1000A0E3 		mov	r0, #6
 2024 004c 0110A0E3 		mov	r1, #1
 2025 0050 0720A0E1 		mov	r2, r7
 2026 0054 FEFFFFEB 		bl	MCI_GetCmdResp
1473:drivers_nxp/mci.c **** 		/* bit 9 through 12 should be in transfer state now. bit 8 is ready. */
1474:drivers_nxp/mci.c **** 		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
 2027              	c 1 1513 0
 2028 0058 000050E3 		cmp	r0, #0
 2029 005c 0300001A 		bne	.L238
 2030 0060 34301BE5 		ldr	r3, [fp, #-48]
 2031 0064 0F3C03E2 		and	r3, r3, #3840
 2032 0068 090C53E3 		cmp	r3, #2304
 2033 006c 0E00000A 		beq	.L248
 2034              	.L238:
1475:drivers_nxp/mci.c **** 			return ( TRUE );
1476:drivers_nxp/mci.c **** 		}
1477:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++) {
 2035              	1516 0
 2036 0070 24800BE5 		str	r6, [fp, #-32]
 2037              	.LVL157:
 2038 0074 24301BE5 		ldr	r3, [fp, #-32]
 2039 0078 1F0053E3 		cmp	r3, #31
 2040 007c 0500008A 		bhi	.L240
 2041              	.L244:
 2042 0080 24301BE5 		ldr	r3, [fp, #-32]
 2043 0084 013083E2 		add	r3, r3, #1
 2044              	.LVL158:
 2045 0088 24300BE5 		str	r3, [fp, #-32]
 2046 008c 24201BE5 		ldr	r2, [fp, #-32]
 2047 0090 1F0052E3 		cmp	r2, #31
 2048 0094 F9FFFF9A 		bls	.L244
 2049              	.LVL159:
 2050              	.L240:
 2051              		.loc 1 1506 0
 2052 0098 014054E2 		subs	r4, r4, #1
 2053 009c E1FFFF1A 		bne	.L247
 2054 00a0 0400A0E1 		mov	r0, r4
 2055              	.L239:
1478:drivers_nxp/mci.c **** 			;
1479:drivers_nxp/mci.c **** 		}
1480:drivers_nxp/mci.c **** 		retryCount--;
1481:drivers_nxp/mci.c **** 	}
1482:drivers_nxp/mci.c **** 	return ( FALSE );
1483:drivers_nxp/mci.c **** }
 2056              	p, fp, #28
 2057 00a4 20D04BE2 		ldmfd	sp, {r4, r5, r6, r7, fp, sp, pc}
 2058 00a8 F0A99DE8 	.LVL160:
 2059              	.L248:
 2060              		.loc 1 1513 0
 2061              		add	r0, r0, #1
 2062 00ac 010080E2 		b	.L239
 2063 00b0 FBFFFFEA 	.LFE35:
 2065              		.section	.text.SD_Set_BusWidth,"ax",%progbits
 2066              		.align	2
 2067              		.global	SD_Set_BusWidth
 2069              	SD_Set_BusWidth:
 2070              	.LFB19:
 2071              		.loc 1 542 0
1484:drivers_nxp/mci.c **** 
1485:drivers_nxp/mci.c **** /******************************************************************************
1486:drivers_nxp/mci.c ****  ** Function name:		MCI_Send_ACMD_Bus_Width
1487:drivers_nxp/mci.c ****  **
1488:drivers_nxp/mci.c ****  ** Descriptions:		ACMD6, SET_BUS_WIDTH, if it's SD card, we can
1489:drivers_nxp/mci.c ****  **						use the 4-bit bus instead of 1-bit. This cmd
1490:drivers_nxp/mci.c ****  **						can only be called during TRANS state.
1491:drivers_nxp/mci.c ****  **						Since it's a ACMD, CMD55 APP_CMD needs to be
1492:drivers_nxp/mci.c ****  **						sent out first. 		
1493:drivers_nxp/mci.c ****  **
1494:drivers_nxp/mci.c ****  ** parameters:			Bus width value, 1-bit is 0, 4-bit is 10
1495:drivers_nxp/mci.c ****  ** Returned value:		true or false, true if the card is still in the 
1496:drivers_nxp/mci.c ****  **						TRANS state after the cmd.
1497:drivers_nxp/mci.c ****  ** 
1498:drivers_nxp/mci.c ****  ******************************************************************************/
1499:drivers_nxp/mci.c **** DWORD MCI_Send_ACMD_Bus_Width(DWORD buswidth) {
 2072              	tend = 0, frame = 4
 2073              		@ frame_needed = 1, uses_anonymous_args = 0
 2074              	.LVL161:
 2075              		mov	ip, sp
 2076 0000 0DC0A0E1 	.LCFI69:
 2077              		stmfd	sp!, {fp, ip, lr, pc}
 2078 0004 F0D82DE9 	.LCFI70:
 2079              		.loc 1 545 0
 2080 0008 04B04CE2 		mov	r3, #0
 2081              		.loc 1 542 0
 2082 000c 14D04DE2 		sub	fp, ip, #4
 2083              	.LCFI71:
 2084              		sub	sp, sp, #4
 2085 0010 0050A0E1 	.LCFI72:
 2086 0014 2040A0E3 		.loc 1 545 0
 2087              		str	r3, [fp, #-16]
 2088 0018 30704BE2 	.LVL162:
1500:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1501:drivers_nxp/mci.c **** 	DWORD retryCount;
1502:drivers_nxp/mci.c **** 	DWORD respStatus;
1503:drivers_nxp/mci.c **** 	DWORD respValue[4];
1504:drivers_nxp/mci.c **** 
1505:drivers_nxp/mci.c **** 	retryCount = 0x20; /* reset retry counter */
1506:drivers_nxp/mci.c **** 	while (retryCount > 0) {
1507:drivers_nxp/mci.c **** 		if (MCI_Send_ACMD() == FALSE) {
1508:drivers_nxp/mci.c **** 			continue;
1509:drivers_nxp/mci.c **** 		}
1510:drivers_nxp/mci.c **** 		/* Send ACMD6 command to set the bus width */
1511:drivers_nxp/mci.c **** 		MCI_SendCmd( SET_ACMD_BUS_WIDTH, buswidth, EXPECT_SHORT_RESP, 0);
 2089              	6]
 2090 001c 0060A0E3 		cmp	r2, #15
 2091              		bhi	.L250
 2092              	.L256:
 2093              		ldr	r3, [fp, #-16]
 2094 0020 FEFFFFEB 		add	r3, r3, #1
 2095 0024 000050E3 	.LVL163:
 2096 0028 FCFFFF0A 		str	r3, [fp, #-16]
 2097              		ldr	r2, [fp, #-16]
 2098 002c 0600A0E3 		cmp	r2, #15
 2099 0030 0510A0E1 		bls	.L256
 2100 0034 0120A0E3 	.LVL164:
 2101 0038 0030A0E3 	.L250:
 2102 003c FEFFFFEB 		.loc 1 548 0
1512:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( SET_ACMD_BUS_WIDTH, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
 2103              	ne	.L252
 2104 0040 0600A0E3 		.loc 1 549 0
 2105 0044 0110A0E3 		mov	r2, #-536870912
 2106 0048 0720A0E1 		add	r2, r2, #573440
 2107 004c FEFFFFEB 		ldr	r3, [r2, #4]
1513:drivers_nxp/mci.c **** 		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
 2108              	r3, r3, #2048
 2109 0050 000050E3 		str	r3, [r2, #4]
 2110 0054 0300001A 		add	r0, r0, #1
 2111 0058 30301BE5 	.LVL165:
 2112 005c 0F3C03E2 		ldmfd	sp, {r3, fp, sp, pc}
 2113 0060 090C53E3 	.LVL166:
 2114 0064 0E00000A 	.L252:
 2115              		.loc 1 551 0
1514:drivers_nxp/mci.c **** 			return ( TRUE ); /* response is back and correct. */
1515:drivers_nxp/mci.c **** 		}
1516:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++) {
 2116              	 #1
 2117 0068 20600BE5 		beq	.L258
 2118              		.loc 1 561 0
 2119 006c 20301BE5 		mov	r2, #-536870912
 2120 0070 1F0053E3 		add	r2, r2, #573440
 2121 0074 0500008A 		ldr	r3, [r2, #4]
 2122              		bic	r3, r3, #2048
 2123 0078 20301BE5 		str	r3, [r2, #4]
 2124 007c 013083E2 		mov	r0, #1
 2125              	.LVL167:
 2126 0080 20300BE5 		.loc 1 574 0
 2127 0084 20201BE5 		ldmfd	sp, {r3, fp, sp, pc}
 2128 0088 1F0052E3 	.LVL168:
 2129 008c F9FFFF9A 	.L258:
 2130              		.loc 1 552 0
 2131              		mov	r2, #-536870912
 2132              		add	r2, r2, #573440
 2133 0090 014054E2 		ldr	r3, [r2, #4]
 2134 0094 E1FFFF1A 		orr	r3, r3, #2048
 2135 0098 0400A0E1 		str	r3, [r2, #4]
 2136              		.loc 1 555 0
1517:drivers_nxp/mci.c **** 			;
1518:drivers_nxp/mci.c **** 		}
1519:drivers_nxp/mci.c **** 		retryCount--;
1520:drivers_nxp/mci.c **** 	}
1521:drivers_nxp/mci.c **** 	return ( FALSE );
1522:drivers_nxp/mci.c **** }
 2137              	69:
 2138 009c 1CD04BE2 		bl	MCI_Send_ACMD_Bus_Width
 2139 00a0 F0A89DE8 		subs	r0, r0, #0
 2140              		movne	r0, #1
 2141              		ldmfd	sp, {r3, fp, sp, pc}
 2142              	.LFE19:
 2144 00a8 FBFFFFEA 		.section	.text.MCI_Send_Stop,"ax",%progbits
 2145              		.align	2
 2146              		.global	MCI_Send_Stop
 2148              	MCI_Send_Stop:
 2149              	.LFB36:
 2150              		.loc 1 1535 0
 2151              		@ args = 0, pretend = 0, frame = 20
 2152              		@ frame_needed = 1, uses_anonymous_args = 0
 2153              		mov	ip, sp
 2154              	.LCFI73:
 2155              		stmfd	sp!, {r4, r5, r6, r7, r8, fp, ip, lr, pc}
 2156              	.LCFI74:
 2157 0000 0DC0A0E1 		sub	fp, ip, #4
 2158              	.LCFI75:
 2159 0004 00D82DE9 		sub	sp, sp, #20
 2160              	.LCFI76:
 2161              		.loc 1 1543 0
 2162 0008 0030A0E3 		mov	r6, #-536870912
 2163              		mov	r5, #2032
 2164 000c 04B04CE2 		.loc 1 1535 0
 2165              		.loc 1 1543 0
 2166 0010 04D04DE2 		add	r6, r6, #573440
 2167              		add	r5, r5, #15
 2168              		.loc 1 1535 0
 2169 0014 10300BE5 		mov	r4, #32
 2170              	.LVL170:
 2171 0018 10201BE5 		sub	r7, fp, #52
 2172 001c 0F0052E3 		.loc 1 1544 0
 2173 0020 0500008A 		mov	r8, #0
 2174              	.LVL171:
 2175 0024 10301BE5 	.L264:
 2176 0028 013083E2 		mov	r1, #0
 2177              		mov	r3, r1
 2178 002c 10300BE5 		mov	r0, #12
 2179 0030 10201BE5 		mov	r2, #1
 2180 0034 0F0052E3 		.loc 1 1543 0
 2181 0038 F9FFFF9A 		str	r5, [r6, #56]
 2182              		.loc 1 1544 0
 2183              		bl	MCI_SendCmd
 2184              		.loc 1 1545 0
 2185 003c 000050E3 		mov	r0, #12
 2186 0040 0600001A 		mov	r1, #1
 2187              		mov	r2, r7
 2188 0044 0E22A0E3 		bl	MCI_GetCmdResp
 2189 0048 232982E2 		.loc 1 1547 0
 2190 004c 043092E5 		cmp	r0, #0
 2191 0050 023BC3E3 		bne	.L260
 2192 0054 043082E5 		ldr	r3, [fp, #-52]
 2193 0058 010080E2 		tst	r3, #256
 2194              		bne	.L269
 2195 005c 08A89DE8 	.L260:
 2196              		.loc 1 1550 0
 2197              		str	r8, [fp, #-36]
 2198              	.LVL172:
 2199 0060 010050E3 		ldr	r3, [fp, #-36]
 2200 0064 0600000A 		cmp	r3, #31
 2201              		bhi	.L262
 2202 0068 0E22A0E3 	.L266:
 2203 006c 232982E2 		ldr	r3, [fp, #-36]
 2204 0070 043092E5 		add	r3, r3, #1
 2205 0074 023BC3E3 	.LVL173:
 2206 0078 043082E5 		str	r3, [fp, #-36]
 2207 007c 0100A0E3 		ldr	r2, [fp, #-36]
 2208              		cmp	r2, #31
 2209              		bls	.L266
 2210 0080 08A89DE8 	.LVL174:
 2211              	.L262:
 2212              		.loc 1 1542 0
 2213              		subs	r4, r4, #1
 2214 0084 0E22A0E3 		bne	.L264
 2215 0088 232982E2 		mov	r0, r4
 2216 008c 043092E5 	.L261:
 2217 0090 023B83E3 		.loc 1 1556 0
 2218 0094 043082E5 		sub	sp, fp, #32
 2219              		ldmfd	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
 2220 0098 090080E2 	.LVL175:
 2221              	.L269:
 2222 009c FEFFFFEB 		.loc 1 1547 0
 2223 00a0 000050E2 		add	r0, r0, #1
 2224 00a4 0100A013 		b	.L261
 2225 00a8 08A89DE8 	.LFE36:
 2227              		.section	.text.MCI_Power_Off,"ax",%progbits
 2228              		.align	2
 2229              		.global	MCI_Power_Off
 2231              	MCI_Power_Off:
 2232              	.LFB44:
 2233              		.loc 1 1988 0
1523:drivers_nxp/mci.c **** 
1524:drivers_nxp/mci.c **** /******************************************************************************
1525:drivers_nxp/mci.c ****  ** Function name:		MCI_Send_Stop
1526:drivers_nxp/mci.c ****  **
1527:drivers_nxp/mci.c ****  ** Descriptions:		CMD12, STOP_TRANSMISSION. if that happens, the card is 
1528:drivers_nxp/mci.c ****  **						maybe in a unknown state that need a warm reset.		
1529:drivers_nxp/mci.c ****  **
1530:drivers_nxp/mci.c ****  ** parameters:			None
1531:drivers_nxp/mci.c ****  ** Returned value:		true or false, true if, at least, the card status
1532:drivers_nxp/mci.c ****  **						shows ready bit is set.
1533:drivers_nxp/mci.c ****  ** 
1534:drivers_nxp/mci.c ****  ******************************************************************************/
1535:drivers_nxp/mci.c **** DWORD MCI_Send_Stop(void) {
 2234              	I77:
 2235              		stmfd	sp!, {fp, ip, lr, pc}
 2236              	.LCFI78:
 2237 0000 0DC0A0E1 		.loc 1 1992 0
 2238              		mov	r3, #-536870912
 2239 0004 F0D92DE9 		.loc 1 1988 0
 2240              		sub	fp, ip, #4
 2241 0008 04B04CE2 	.LCFI79:
 2242              		.loc 1 1992 0
 2243 000c 14D04DE2 		add	r3, r3, #573440
 2244              		mov	r2, #0
1536:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1537:drivers_nxp/mci.c **** 	DWORD retryCount;
1538:drivers_nxp/mci.c **** 	DWORD respStatus;
1539:drivers_nxp/mci.c **** 	DWORD respValue[4];
1540:drivers_nxp/mci.c **** 
1541:drivers_nxp/mci.c **** 	retryCount = 0x20;
1542:drivers_nxp/mci.c **** 	while (retryCount > 0) {
1543:drivers_nxp/mci.c **** 		MCI_CLEAR = 0x7FF;
 2245              	8 0
 2246 0010 0E62A0E3 		sub	sp, sp, #4
 2247 0014 7F5EA0E3 	.LCFI80:
 2248              		.loc 1 1992 0
 2249              		str	r2, [r3, #0]
 2250 0018 236986E2 		.loc 1 1993 0
 2251 001c 0F5085E2 		str	r2, [fp, #-16]
 2252              	.LVL176:
 2253 0020 2040A0E3 		ldr	r3, [fp, #-16]
 2254              		cmp	r3, #255
 2255 0024 34704BE2 		ldmhifd	sp, {r3, fp, sp, pc}
1544:drivers_nxp/mci.c **** 		MCI_SendCmd( STOP_TRANSMISSION, 0x00000000, EXPECT_SHORT_RESP, 0);
 2256              		r3, [fp, #-16]
 2257 0028 0080A0E3 		add	r3, r3, #1
 2258              	.LVL177:
 2259              		str	r3, [fp, #-16]
 2260 002c 0010A0E3 		ldr	r2, [fp, #-16]
 2261 0030 0130A0E1 		cmp	r2, #255
 2262 0034 0C00A0E3 		bls	.L274
 2263 0038 0120A0E3 	.LVL178:
 2264              		ldmfd	sp, {r3, fp, sp, pc}
 2265 003c 385086E5 	.LFE44:
 2267 0040 FEFFFFEB 		.section	.text.MCI_Sd_Status,"ax",%progbits
1545:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( STOP_TRANSMISSION, EXPECT_SHORT_RESP, (DWORD *)respValue);
 2268              	global	MCI_Sd_Status
 2270 0048 0110A0E3 	MCI_Sd_Status:
 2271 004c 0720A0E1 	.LFB43:
 2272 0050 FEFFFFEB 		.loc 1 1903 0
1546:drivers_nxp/mci.c **** 		/* ready bit, bit 8, should be set in the card status register */
1547:drivers_nxp/mci.c **** 		if ( !respStatus && (respValue[0] & (1 << 8))) {
 2273              	gs = 0, pretend = 0, frame = 20
 2274 0054 000050E3 		@ frame_needed = 1, uses_anonymous_args = 0
 2275 0058 0200001A 		mov	ip, sp
 2276 005c 34301BE5 	.LCFI81:
 2277 0060 010C13E3 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 2278 0064 0E00001A 	.LCFI82:
 2279              		.loc 1 1911 0
1548:drivers_nxp/mci.c **** 			return ( TRUE );
1549:drivers_nxp/mci.c **** 		}
1550:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++) {
 2280              	, .L299
 2281 0068 24800BE5 		.loc 1 1903 0
 2282              		sub	fp, ip, #4
 2283 006c 24301BE5 	.LCFI83:
 2284 0070 1F0053E3 		sub	sp, sp, #20
 2285 0074 0500008A 	.LCFI84:
 2286              		.loc 1 1911 0
 2287 0078 24301BE5 		ldr	r3, [r2, #0]
 2288 007c 013083E2 		cmp	r3, #0
 2289              		beq	.L277
 2290 0080 24300BE5 		ldr	r3, [r2, #0]
 2291 0084 24201BE5 		cmp	r3, #1
 2292 0088 1F0052E3 		beq	.L277
 2293 008c F9FFFF9A 		.loc 1 1915 0
 2294              		mov	r2, #-536870912
 2295              		mov	r3, #2032
 2296              		add	r2, r2, #573440
 2297 0090 014054E2 		add	r3, r3, #15
 2298 0094 E4FFFF1A 		.loc 1 1916 0
 2299 0098 0400A0E1 		mov	r1, #0
 2300              		.loc 1 1915 0
1551:drivers_nxp/mci.c **** 			;
1552:drivers_nxp/mci.c **** 		}
1553:drivers_nxp/mci.c **** 		retryCount--;
1554:drivers_nxp/mci.c **** 	}
1555:drivers_nxp/mci.c **** 	return ( FALSE );
1556:drivers_nxp/mci.c **** }
 2301              	loc 1 1916 0
 2302 009c 20D04BE2 		str	r1, [r2, #44]
 2303 00a0 F0A99DE8 		.loc 1 1917 0
 2304              		str	r1, [fp, #-44]
 2305              	.LVL179:
 2306              		ldr	r3, [fp, #-44]
 2307 00a4 010080E2 		cmp	r3, #15
 2308 00a8 FBFFFFEA 		bhi	.L278
 2309              	.L292:
 2310              		ldr	r3, [fp, #-44]
 2311              		add	r3, r3, #1
 2312              	.LVL180:
 2313              		str	r3, [fp, #-44]
 2314              		ldr	r2, [fp, #-44]
 2315              		cmp	r2, #15
 2316              		bls	.L292
1557:drivers_nxp/mci.c **** 
1558:drivers_nxp/mci.c **** /******************************************************************************
1559:drivers_nxp/mci.c ****  ** Function name:		MCI_Send_Write_Block
1560:drivers_nxp/mci.c ****  **
1561:drivers_nxp/mci.c ****  ** Descriptions:		CMD24, WRITE_BLOCK, send this cmd in the TRANS state
1562:drivers_nxp/mci.c ****  **						to write a block of data to the card.
1563:drivers_nxp/mci.c ****  **
1564:drivers_nxp/mci.c ****  ** parameters:			block number
1565:drivers_nxp/mci.c ****  ** Returned value:		Response value
1566:drivers_nxp/mci.c ****  ** 
1567:drivers_nxp/mci.c ****  ** modified by mthomas
1568:drivers_nxp/mci.c ****  ******************************************************************************/
1569:drivers_nxp/mci.c **** // mthomas - static
1570:drivers_nxp/mci.c **** static DWORD MCI_Send_Write_Block(DWORD blockNum) {
1571:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1572:drivers_nxp/mci.c **** 	DWORD retryCount;
1573:drivers_nxp/mci.c **** 	DWORD respStatus;
1574:drivers_nxp/mci.c **** 	DWORD respValue[4];
1575:drivers_nxp/mci.c **** 
1576:drivers_nxp/mci.c **** 	retryCount = 0x20;
1577:drivers_nxp/mci.c **** 	while (retryCount > 0) {
1578:drivers_nxp/mci.c **** 		MCI_CLEAR = 0x7FF;
1579:drivers_nxp/mci.c **** #if 1
1580:drivers_nxp/mci.c **** 		// mthomas
1581:drivers_nxp/mci.c **** 		if (MCI_CardType == SDHC_CARD) {
1582:drivers_nxp/mci.c **** 			MCI_SendCmd( WRITE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
1583:drivers_nxp/mci.c **** 		} else {
1584:drivers_nxp/mci.c **** 			MCI_SendCmd( WRITE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
1585:drivers_nxp/mci.c **** 		}
1586:drivers_nxp/mci.c **** #else
1587:drivers_nxp/mci.c **** 		// NXP original
1588:drivers_nxp/mci.c **** 		MCI_SendCmd( WRITE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0 );
1589:drivers_nxp/mci.c **** #endif
1590:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( WRITE_BLOCK, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
1591:drivers_nxp/mci.c **** 		/* it should be in the transfer state, bit 9~12 is 0x0100 and bit 8 is 1 */
1592:drivers_nxp/mci.c **** 		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
1593:drivers_nxp/mci.c **** 			return ( TRUE ); /* ready and in TRAN state */
1594:drivers_nxp/mci.c **** 		}
1595:drivers_nxp/mci.c **** 
1596:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++) {
1597:drivers_nxp/mci.c **** 			;
1598:drivers_nxp/mci.c **** 		}
1599:drivers_nxp/mci.c **** 		retryCount--;
1600:drivers_nxp/mci.c **** 	}
1601:drivers_nxp/mci.c **** 	return ( FALSE ); /* Fatal error */
1602:drivers_nxp/mci.c **** }
1603:drivers_nxp/mci.c **** 
1604:drivers_nxp/mci.c **** /******************************************************************************
1605:drivers_nxp/mci.c ****  ** Function name:		MCI_Send_Write_Multiple_Block
1606:drivers_nxp/mci.c ****  **
1607:drivers_nxp/mci.c ****  ** Descriptions:		CMD25, WRITE_MULTIPLE_BLOCK , send this cmd in the 
1608:drivers_nxp/mci.c ****  **						TRANS state to write several blocks of data to the card.
1609:drivers_nxp/mci.c ****  **
1610:drivers_nxp/mci.c ****  ** parameters:			block number
1611:drivers_nxp/mci.c ****  ** Returned value:		Response value
1612:drivers_nxp/mci.c ****  ** 
1613:drivers_nxp/mci.c ****  ** Added by Lorenz Aebi
1614:drivers_nxp/mci.c ****  ******************************************************************************/
1615:drivers_nxp/mci.c **** // mthomas - static
1616:drivers_nxp/mci.c **** static DWORD MCI_Send_Write_Multiple_Block(DWORD blockNum) {
1617:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1618:drivers_nxp/mci.c **** 	DWORD retryCount;
1619:drivers_nxp/mci.c **** 	DWORD respStatus;
1620:drivers_nxp/mci.c **** 	DWORD respValue[4];
1621:drivers_nxp/mci.c **** 
1622:drivers_nxp/mci.c **** 	retryCount = 0x20;
1623:drivers_nxp/mci.c **** 	while (retryCount > 0) {
1624:drivers_nxp/mci.c **** 		MCI_CLEAR = 0x7FF;
1625:drivers_nxp/mci.c **** #if 1
1626:drivers_nxp/mci.c **** 		// mthomas
1627:drivers_nxp/mci.c **** 		if (MCI_CardType == SDHC_CARD) {
1628:drivers_nxp/mci.c **** 			MCI_SendCmd( WRITE_MULTIPLE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
1629:drivers_nxp/mci.c **** 		} else {
1630:drivers_nxp/mci.c **** 			MCI_SendCmd( WRITE_MULTIPLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
1631:drivers_nxp/mci.c **** 		}
1632:drivers_nxp/mci.c **** #else
1633:drivers_nxp/mci.c **** 		// NXP original
1634:drivers_nxp/mci.c **** 		MCI_SendCmd( WRITE_MULTIPLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0 );
1635:drivers_nxp/mci.c **** #endif
1636:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( WRITE_MULTIPLE_BLOCK, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
1637:drivers_nxp/mci.c **** 		/* it should be in the transfer state, bit 9~12 is 0x0100 and bit 8 is 1 */
1638:drivers_nxp/mci.c **** 		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
1639:drivers_nxp/mci.c **** 			return ( TRUE ); /* ready and in TRAN state */
1640:drivers_nxp/mci.c **** 		}
1641:drivers_nxp/mci.c **** 
1642:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++) {
1643:drivers_nxp/mci.c **** 			;
1644:drivers_nxp/mci.c **** 		}
1645:drivers_nxp/mci.c **** 		retryCount--;
1646:drivers_nxp/mci.c **** 	}
1647:drivers_nxp/mci.c **** 	return ( FALSE ); /* Fatal error */
1648:drivers_nxp/mci.c **** }
1649:drivers_nxp/mci.c **** 
1650:drivers_nxp/mci.c **** /******************************************************************************
1651:drivers_nxp/mci.c ****  ** Function name:		MCI_Send_Read_Block
1652:drivers_nxp/mci.c ****  **
1653:drivers_nxp/mci.c ****  ** Descriptions:		CMD17, READ_SINGLE_BLOCK, send this cmd in the TRANS 
1654:drivers_nxp/mci.c ****  **						state to read a block of data from the card.
1655:drivers_nxp/mci.c ****  **
1656:drivers_nxp/mci.c ****  ** parameters:			block number
1657:drivers_nxp/mci.c ****  ** Returned value:		Response value
1658:drivers_nxp/mci.c ****  **
1659:drivers_nxp/mci.c ****  ** modified by mthomas
1660:drivers_nxp/mci.c ****  ******************************************************************************/
1661:drivers_nxp/mci.c **** // mthomas - static
1662:drivers_nxp/mci.c **** static DWORD MCI_Send_Read_Block(DWORD blockNum) {
1663:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1664:drivers_nxp/mci.c **** 	DWORD retryCount;
1665:drivers_nxp/mci.c **** 	DWORD respStatus;
1666:drivers_nxp/mci.c **** 	DWORD respValue[4];
1667:drivers_nxp/mci.c **** 
1668:drivers_nxp/mci.c **** 	retryCount = 0x20;
1669:drivers_nxp/mci.c **** 	while (retryCount > 0) {
1670:drivers_nxp/mci.c **** 		MCI_CLEAR = 0x7FF;
1671:drivers_nxp/mci.c **** #if 1
1672:drivers_nxp/mci.c **** 		// mthomas
1673:drivers_nxp/mci.c **** 		if (MCI_CardType == SDHC_CARD) {
1674:drivers_nxp/mci.c **** 			MCI_SendCmd( READ_SINGLE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
1675:drivers_nxp/mci.c **** 		} else {
1676:drivers_nxp/mci.c **** 			MCI_SendCmd( READ_SINGLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
1677:drivers_nxp/mci.c **** 		}
1678:drivers_nxp/mci.c **** #else
1679:drivers_nxp/mci.c **** 		// NXP original
1680:drivers_nxp/mci.c **** 		MCI_SendCmd( READ_SINGLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0 );
1681:drivers_nxp/mci.c **** #endif
1682:drivers_nxp/mci.c **** 		respStatus = MCI_GetCmdResp( READ_SINGLE_BLOCK, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
1683:drivers_nxp/mci.c **** 		/* it should be in the transfer state, bit 9~12 is 0x0100 and bit 8 is 1 */
1684:drivers_nxp/mci.c **** 		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
1685:drivers_nxp/mci.c **** 			return ( TRUE ); /* ready and in TRAN state */
1686:drivers_nxp/mci.c **** 		}
1687:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++) {
1688:drivers_nxp/mci.c **** 			;
1689:drivers_nxp/mci.c **** 		}
1690:drivers_nxp/mci.c **** 		retryCount--;
1691:drivers_nxp/mci.c **** 	}
1692:drivers_nxp/mci.c **** 	return ( FALSE ); /* Fatal error */
1693:drivers_nxp/mci.c **** }
1694:drivers_nxp/mci.c **** 
1695:drivers_nxp/mci.c **** /******************************************************************************
1696:drivers_nxp/mci.c ****  ** Function name:		MCI_Write_Block
1697:drivers_nxp/mci.c ****  **
1698:drivers_nxp/mci.c ****  ** Descriptions:		Set MCI data control register, data length and data
1699:drivers_nxp/mci.c ****  **						timeout, send WRITE_BLOCK cmd, finally, enable
1700:drivers_nxp/mci.c ****  **						interrupt. On completion of WRITE_BLOCK cmd, TX_ACTIVE
1701:drivers_nxp/mci.c ****  **						interrupt will occurs, data can be written continuously
1702:drivers_nxp/mci.c ****  **						into the FIFO until the block data length is reached.		
1703:drivers_nxp/mci.c ****  **
1704:drivers_nxp/mci.c ****  ** parameters:			block number
1705:drivers_nxp/mci.c ****  ** Returned value:		true or false, if cmd times out, return false and no 
1706:drivers_nxp/mci.c ****  **						need to continue.
1707:drivers_nxp/mci.c ****  ** 
1708:drivers_nxp/mci.c ****  ******************************************************************************/
1709:drivers_nxp/mci.c **** DWORD MCI_Write_Block(DWORD blockNum) {
1710:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1711:drivers_nxp/mci.c **** 	DWORD DataCtrl = 0;
1712:drivers_nxp/mci.c **** 
1713:drivers_nxp/mci.c **** 	MCI_CLEAR = 0x7FF;
1714:drivers_nxp/mci.c **** 	MCI_DATA_CTRL = 0;
1715:drivers_nxp/mci.c **** 	for (i = 0; i < 0x10; i++) {
1716:drivers_nxp/mci.c **** 		;
1717:drivers_nxp/mci.c **** 	}
1718:drivers_nxp/mci.c **** 
1719:drivers_nxp/mci.c **** 	/* Below status check is redundant, but ensure card is in TRANS state
1720:drivers_nxp/mci.c **** 	 before writing and reading to from the card. */
1721:drivers_nxp/mci.c **** 	if (MCI_CheckStatus() != TRUE) {
1722:drivers_nxp/mci.c **** 		mci_debug_printf("MCI_Wead_Block: not in trans\n");
1723:drivers_nxp/mci.c **** 		MCI_Send_Stop();
1724:drivers_nxp/mci.c **** 		return ( FALSE );
1725:drivers_nxp/mci.c **** 	}
1726:drivers_nxp/mci.c **** 
1727:drivers_nxp/mci.c **** 	MCI_DATA_TMR = DATA_TIMER_VALUE;
1728:drivers_nxp/mci.c **** 	MCI_DATA_LEN = BLOCK_LENGTH;
1729:drivers_nxp/mci.c **** 	MCI_Block_End_Flag = 1;
1730:drivers_nxp/mci.c **** 	MCI_TXEnable();
1731:drivers_nxp/mci.c **** 	if (MCI_Send_Write_Block(blockNum) == FALSE) {
1732:drivers_nxp/mci.c **** 		return ( FALSE );
1733:drivers_nxp/mci.c **** 	}
1734:drivers_nxp/mci.c **** 
1735:drivers_nxp/mci.c **** #if MCI_DMA_ENABLED
1736:drivers_nxp/mci.c **** 	DMA_Move( 0, M2P);
1737:drivers_nxp/mci.c **** 	GPDMA_CH0_CFG |= 0x10001 | (0x00 << 1) | (0x04 << 6) | (0x05 << 11);
1738:drivers_nxp/mci.c **** 	/* Write, block transfer, DMA, and data length */
1739:drivers_nxp/mci.c **** 	DataCtrl |= ((1 << 0) | (1 << 3) | (DATA_BLOCK_LEN << 4));
1740:drivers_nxp/mci.c **** #else
1741:drivers_nxp/mci.c **** 	/* Write, block transfer, and data length */
1742:drivers_nxp/mci.c **** 	DataCtrl |= ((1 << 0) | (DATA_BLOCK_LEN << 4));
1743:drivers_nxp/mci.c **** #endif
1744:drivers_nxp/mci.c **** 	MCI_DATA_CTRL = DataCtrl;
1745:drivers_nxp/mci.c **** 	//laebi - not necessary
1746:drivers_nxp/mci.c **** 	for (i = 0; i < 0x10; i++) {
1747:drivers_nxp/mci.c **** 		;
1748:drivers_nxp/mci.c **** 	}
1749:drivers_nxp/mci.c **** 
1750:drivers_nxp/mci.c **** 	return ( TRUE );
1751:drivers_nxp/mci.c **** }
1752:drivers_nxp/mci.c **** 
1753:drivers_nxp/mci.c **** /******************************************************************************
1754:drivers_nxp/mci.c ****  ** Function name:		MCI_Write_Multiple_Block
1755:drivers_nxp/mci.c ****  **
1756:drivers_nxp/mci.c ****  ** Descriptions:		Set MCI data control register, data length and data
1757:drivers_nxp/mci.c ****  **						timeout, send WRITE_MULTIPLE_BLOCK cmd. Continuously
1758:drivers_nxp/mci.c ****  **						writes blocks of data. At the end a STOP_TRANSMISSION
1759:drivers_nxp/mci.c ****  **						marks the end of the datatransfer. 
1760:drivers_nxp/mci.c ****  ** 							
1761:drivers_nxp/mci.c ****  **
1762:drivers_nxp/mci.c ****  ** parameters:			block number
1763:drivers_nxp/mci.c ****  **						number of blocks
1764:drivers_nxp/mci.c ****  **						first address to the data in the memory
1765:drivers_nxp/mci.c ****  ** Returned value:		true or false, if cmd times out, return false and no 
1766:drivers_nxp/mci.c ****  **						need to continue.
1767:drivers_nxp/mci.c ****  **
1768:drivers_nxp/mci.c ****  ** Added by Lorenz Aebi
1769:drivers_nxp/mci.c ****  ******************************************************************************/
1770:drivers_nxp/mci.c **** DWORD MCI_Write_Multiple_Block(DWORD blockNum, BYTE count, const BYTE *buff) {
1771:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1772:drivers_nxp/mci.c **** 	DWORD DataCtrl = 0;
1773:drivers_nxp/mci.c **** 
1774:drivers_nxp/mci.c **** 	MCI_CLEAR = 0x7FF;
1775:drivers_nxp/mci.c **** 	MCI_DATA_CTRL = 0;
1776:drivers_nxp/mci.c **** 	//laebi - not necessary
1777:drivers_nxp/mci.c **** 	//for ( i = 0; i < 0x10; i++ ) { ; }
1778:drivers_nxp/mci.c **** 
1779:drivers_nxp/mci.c **** 	/* Below status check is redundant, but ensure card is in TRANS state
1780:drivers_nxp/mci.c **** 	 before writing and reading to from the card. */
1781:drivers_nxp/mci.c **** 	if (MCI_CheckStatus() != TRUE) {
1782:drivers_nxp/mci.c **** 		mci_debug_printf("MCI_Wead_Block: not in trans\n");
1783:drivers_nxp/mci.c **** 		MCI_Send_Stop();
1784:drivers_nxp/mci.c **** 		return ( FALSE );
1785:drivers_nxp/mci.c **** 	}
1786:drivers_nxp/mci.c **** 
1787:drivers_nxp/mci.c **** 	MCI_DATA_TMR = DATA_TIMER_VALUE;
1788:drivers_nxp/mci.c **** 	MCI_DATA_LEN = BLOCK_LENGTH;
1789:drivers_nxp/mci.c **** 	MCI_Block_End_Flag = 1;
1790:drivers_nxp/mci.c **** 	MCI_TXEnable();
1791:drivers_nxp/mci.c **** 	if (MCI_Send_Write_Multiple_Block(blockNum) == FALSE) {
1792:drivers_nxp/mci.c **** 		return ( FALSE );
1793:drivers_nxp/mci.c **** 	}
1794:drivers_nxp/mci.c **** 
1795:drivers_nxp/mci.c **** #if MCI_DMA_ENABLED
1796:drivers_nxp/mci.c **** 	do {
1797:drivers_nxp/mci.c **** 		// TODO: avoid copy
1798:drivers_nxp/mci.c **** 		memcpy((void *)DMA_SRC, buff, 512);
1799:drivers_nxp/mci.c **** 		buff += 512;
1800:drivers_nxp/mci.c **** 		GPDMA_INT_TCCLR = 0x01;
1801:drivers_nxp/mci.c **** 		GPDMA_INT_ERR_CLR = 0x01;
1802:drivers_nxp/mci.c **** 		GPDMA_CH0_SRC = DMA_SRC;
1803:drivers_nxp/mci.c **** 		GPDMA_CH0_DEST = DMA_MCIFIFO;
1804:drivers_nxp/mci.c **** 		GPDMA_CONFIG = 0x01;
1805:drivers_nxp/mci.c **** 		/* Enable DMA channels, little endian */
1806:drivers_nxp/mci.c **** 		while ( !(GPDMA_CONFIG & 0x01))
1807:drivers_nxp/mci.c **** 			;
1808:drivers_nxp/mci.c **** 		/* The burst size is set to 8, the size is 8 bit too. */
1809:drivers_nxp/mci.c **** 		/* Terminal Count Int enable */
1810:drivers_nxp/mci.c **** 		GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
1811:drivers_nxp/mci.c **** 		| (0x02 << 18) | (0x02 << 21) | (1 << 26) | 0x80000000;
1812:drivers_nxp/mci.c **** 		//DMA_Move( 0, M2P );
1813:drivers_nxp/mci.c **** 		GPDMA_CH0_CFG |= 0x10001 | (0x00 << 1) | (0x04 << 6) | (0x05 << 11);
1814:drivers_nxp/mci.c **** 		/* Write, block transfer, DMA, and data length */
1815:drivers_nxp/mci.c **** 		DataCtrl |= ((1 << 0) | (1 << 3) | (DATA_BLOCK_LEN << 4));
1816:drivers_nxp/mci.c **** #else
1817:drivers_nxp/mci.c **** 		/* Write, block transfer, and data length */
1818:drivers_nxp/mci.c **** 		DataCtrl |= ((1 << 0) | (DATA_BLOCK_LEN << 4));
1819:drivers_nxp/mci.c **** #endif
1820:drivers_nxp/mci.c **** 		MCI_DATA_CTRL = DataCtrl;
1821:drivers_nxp/mci.c **** 		for (i = 0; i < 0x10; i++) {
1822:drivers_nxp/mci.c **** 			;
1823:drivers_nxp/mci.c **** 		}
1824:drivers_nxp/mci.c **** 	} while (count--);
1825:drivers_nxp/mci.c **** 
1826:drivers_nxp/mci.c **** 	//for (i = 0; i < 0x10; i++) { ; }
1827:drivers_nxp/mci.c **** 
1828:drivers_nxp/mci.c **** 	MCI_Send_Stop();
1829:drivers_nxp/mci.c **** 
1830:drivers_nxp/mci.c **** 	return ( TRUE );
1831:drivers_nxp/mci.c **** }
1832:drivers_nxp/mci.c **** 
1833:drivers_nxp/mci.c **** /******************************************************************************
1834:drivers_nxp/mci.c ****  ** Function name:		MCI_Read_Block
1835:drivers_nxp/mci.c ****  **
1836:drivers_nxp/mci.c ****  ** Descriptions:		Set MCI data control register, data length and data
1837:drivers_nxp/mci.c ****  **						timeout, send READ_SINGLE_BLOCK cmd, finally, enable
1838:drivers_nxp/mci.c ****  **						interrupt. On completion of READ_SINGLE_BLOCK cmd, 
1839:drivers_nxp/mci.c ****  **						RX_ACTIVE interrupt will occurs, data can be read 
1840:drivers_nxp/mci.c ****  **						continuously into the FIFO until the block data 
1841:drivers_nxp/mci.c ****  **						length is reached.		
1842:drivers_nxp/mci.c ****  **
1843:drivers_nxp/mci.c ****  ** parameters:			block number
1844:drivers_nxp/mci.c ****  ** Returned value:		true or false, if cmd times out, return false and no 
1845:drivers_nxp/mci.c ****  **						need to continue.
1846:drivers_nxp/mci.c ****  **
1847:drivers_nxp/mci.c ****  ******************************************************************************/
1848:drivers_nxp/mci.c **** DWORD MCI_Read_Block(DWORD blockNum) {
1849:drivers_nxp/mci.c **** 	volatile DWORD i; // mthomas - volatile
1850:drivers_nxp/mci.c **** 	DWORD DataCtrl = 0;
1851:drivers_nxp/mci.c **** 
1852:drivers_nxp/mci.c **** 	MCI_CLEAR = 0x7FF;
1853:drivers_nxp/mci.c **** 	MCI_DATA_CTRL = 0;
1854:drivers_nxp/mci.c **** 	for (i = 0; i < 0x10; i++) {
1855:drivers_nxp/mci.c **** 		;
1856:drivers_nxp/mci.c **** 	}
1857:drivers_nxp/mci.c **** 
1858:drivers_nxp/mci.c **** 	/* Below status check is redundant, but ensure card is in TRANS state
1859:drivers_nxp/mci.c **** 	 before writing and reading to from the card. */
1860:drivers_nxp/mci.c **** 	if (MCI_CheckStatus() != TRUE) {
1861:drivers_nxp/mci.c **** 		mci_debug_printf("MCI_Read_Block: not in trans\n");
1862:drivers_nxp/mci.c **** 		MCI_Send_Stop();
1863:drivers_nxp/mci.c **** 		return ( FALSE );
1864:drivers_nxp/mci.c **** 	}
1865:drivers_nxp/mci.c **** 	MCI_RXEnable();
1866:drivers_nxp/mci.c **** 
1867:drivers_nxp/mci.c **** 	MCI_DATA_TMR = DATA_TIMER_VALUE;
1868:drivers_nxp/mci.c **** 	MCI_DATA_LEN = BLOCK_LENGTH;
1869:drivers_nxp/mci.c **** 	MCI_Block_End_Flag = 1;
1870:drivers_nxp/mci.c **** 	if (MCI_Send_Read_Block(blockNum) == FALSE) {
1871:drivers_nxp/mci.c **** 		return ( FALSE );
1872:drivers_nxp/mci.c **** 	}
1873:drivers_nxp/mci.c **** 
1874:drivers_nxp/mci.c **** #if MCI_DMA_ENABLED
1875:drivers_nxp/mci.c **** 	DMA_Move( 1, P2M);
1876:drivers_nxp/mci.c **** 	GPDMA_CH1_CFG |= 0x10001 | (0x04 << 1) | (0x00 << 6) | (0x06 << 11);
1877:drivers_nxp/mci.c **** 	/* Write, block transfer, DMA, and data length */
1878:drivers_nxp/mci.c **** 	DataCtrl |= ((1 << 0) | (1 << 1) | (1 << 3) | (DATA_BLOCK_LEN << 4));
1879:drivers_nxp/mci.c **** #else
1880:drivers_nxp/mci.c **** 	/* Read, enable, block transfer, and data length */
1881:drivers_nxp/mci.c **** 	DataCtrl |= ((1 << 0) | (1 << 1) | (DATA_BLOCK_LEN << 4));
1882:drivers_nxp/mci.c **** #endif
1883:drivers_nxp/mci.c **** 	MCI_DATA_CTRL = DataCtrl;
1884:drivers_nxp/mci.c **** 	for (i = 0; i < 0x10; i++) {
1885:drivers_nxp/mci.c **** 		;
1886:drivers_nxp/mci.c **** 	}
1887:drivers_nxp/mci.c **** 
1888:drivers_nxp/mci.c **** 	return ( TRUE );
1889:drivers_nxp/mci.c **** }
1890:drivers_nxp/mci.c **** 
1891:drivers_nxp/mci.c **** /******************************************************************************
1892:drivers_nxp/mci.c ****  ** Function name:		MCI_Sd_Status
1893:drivers_nxp/mci.c ****  **
1894:drivers_nxp/mci.c ****  ** Descriptions:		reads the 512bit SD_STATUS (3-22) using ACMD13 (4-37)
1895:drivers_nxp/mci.c ****  **						Card must be in trans-state for this (4-7)
1896:drivers_nxp/mci.c ****  **						( SD-Status in ReadBlock when MCI_Block_End_Flag==1 )
1897:drivers_nxp/mci.c ****  **
1898:drivers_nxp/mci.c ****  ** parameters:			none
1899:drivers_nxp/mci.c ****  ** Returned value:		true or false 
1900:drivers_nxp/mci.c ****  ** 
1901:drivers_nxp/mci.c ****  ** Added by Martin Thomas
1902:drivers_nxp/mci.c ****  ******************************************************************************/
1903:drivers_nxp/mci.c **** DWORD MCI_Sd_Status(void) {
1904:drivers_nxp/mci.c **** 	volatile DWORD i;
1905:drivers_nxp/mci.c **** 	DWORD retryCount;
1906:drivers_nxp/mci.c **** 	DWORD respStatus;
1907:drivers_nxp/mci.c **** 	DWORD respValue[4];
1908:drivers_nxp/mci.c **** 	DWORD stuffbits = 0x00000000;
1909:drivers_nxp/mci.c **** 	DWORD DataCtrl = 0;
1910:drivers_nxp/mci.c **** 
1911:drivers_nxp/mci.c **** 	if ( (MCI_CardType == CARD_UNKNOWN ) || (MCI_CardType == MMC_CARD )) {
1912:drivers_nxp/mci.c **** 		return ( FALSE ); // unsupported
1913:drivers_nxp/mci.c **** 	}
1914:drivers_nxp/mci.c **** 
1915:drivers_nxp/mci.c **** 	MCI_CLEAR = 0x7FF;
1916:drivers_nxp/mci.c **** 	MCI_DATA_CTRL = 0;
1917:drivers_nxp/mci.c **** 	for (i = 0; i < 0x10; i++) {
1918:drivers_nxp/mci.c **** 		;
1919:drivers_nxp/mci.c **** 	}
1920:drivers_nxp/mci.c **** 
1921:drivers_nxp/mci.c **** 	/* Below status check is redundant, but ensure card is in TRANS state
1922:drivers_nxp/mci.c **** 	 before writing and reading to from the card. */
1923:drivers_nxp/mci.c **** 	if (MCI_CheckStatus() != TRUE) {
1924:drivers_nxp/mci.c **** 		MCI_Send_Stop();mci_debug_printf("Sd_Status: Not in trans-state\n");
1925:drivers_nxp/mci.c **** 		return ( FALSE );
1926:drivers_nxp/mci.c **** 	}
1927:drivers_nxp/mci.c **** 
1928:drivers_nxp/mci.c **** 	MCI_RXEnable();
1929:drivers_nxp/mci.c **** 
1930:drivers_nxp/mci.c **** 	MCI_DATA_TMR = DATA_TIMER_VALUE;
1931:drivers_nxp/mci.c **** 	MCI_DATA_LEN = BLOCK_LENGTH;
1932:drivers_nxp/mci.c **** 	// MCI_DATA_LEN = SD_BLOCK_LENGTH;
1933:drivers_nxp/mci.c **** 	MCI_Block_End_Flag = 1;
1934:drivers_nxp/mci.c **** 	SDStatRead = 1;
1935:drivers_nxp/mci.c **** 
1936:drivers_nxp/mci.c **** 	// "MCI_Send_SD_STATUS":
1937:drivers_nxp/mci.c **** 	retryCount = 0x20;
1938:drivers_nxp/mci.c **** 	while (retryCount > 0) {
1939:drivers_nxp/mci.c **** 		MCI_CLEAR = 0x7FF;
1940:drivers_nxp/mci.c **** 		// prepare for ACMD (with CMD55)
1941:drivers_nxp/mci.c **** 		if (MCI_Send_ACMD() == TRUE) {
1942:drivers_nxp/mci.c **** 			// Send ACMD13
1943:drivers_nxp/mci.c **** 			MCI_SendCmd( SD_STATUS, stuffbits, EXPECT_SHORT_RESP, 0);
1944:drivers_nxp/mci.c **** 			respStatus = MCI_GetCmdResp( SD_STATUS, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
1945:drivers_nxp/mci.c **** 			/* it should be in the transfer state, bit 9~12 is 0x0100 and bit 8 is 1 */
1946:drivers_nxp/mci.c **** 			if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
1947:drivers_nxp/mci.c **** 				break; /* ready and in TRAN state */
1948:drivers_nxp/mci.c **** 			}
1949:drivers_nxp/mci.c **** 		}
1950:drivers_nxp/mci.c **** 		for (i = 0; i < 0x20; i++) {
1951:drivers_nxp/mci.c **** 			;
1952:drivers_nxp/mci.c **** 		}
1953:drivers_nxp/mci.c **** 		retryCount--;
1954:drivers_nxp/mci.c **** 	}
1955:drivers_nxp/mci.c **** 	if (retryCount == 0) {
1956:drivers_nxp/mci.c **** 		mci_debug_printf("Sd_Status: ACMD13 failed\n");
1957:drivers_nxp/mci.c **** 		return ( FALSE ); // error sending ACMD13 or state not trans
1958:drivers_nxp/mci.c **** 	}
1959:drivers_nxp/mci.c **** 
1960:drivers_nxp/mci.c **** #if MCI_DMA_ENABLED
1961:drivers_nxp/mci.c **** 	DMA_Move( 1, P2M);
1962:drivers_nxp/mci.c **** 	GPDMA_CH1_CFG |= 0x10001 | (0x04 << 1) | (0x00 << 6) | (0x06 << 11);
1963:drivers_nxp/mci.c **** 	/* Write, block transfer, DMA, and data length */
1964:drivers_nxp/mci.c **** 	DataCtrl |= ((1 << 0) | (1 << 1) | (1 << 3) | (SD_STATUS_BLOCK_LEN << 4));
1965:drivers_nxp/mci.c **** #else
1966:drivers_nxp/mci.c **** 	/* Read, enable, block transfer, and data length */
1967:drivers_nxp/mci.c **** 	DataCtrl |= ((1 << 0) | (1 << 1) | ( SD_STATUS_BLOCK_LEN << 4 ));
1968:drivers_nxp/mci.c **** #endif
1969:drivers_nxp/mci.c **** 	MCI_DATA_CTRL = DataCtrl;
1970:drivers_nxp/mci.c **** 	// mci_debug_printf("MCI_SD_Status: DATA_CTRL set\n");
1971:drivers_nxp/mci.c **** 	for (i = 0; i < 0x10; i++) {
1972:drivers_nxp/mci.c **** 		;
1973:drivers_nxp/mci.c **** 	}
1974:drivers_nxp/mci.c **** 
1975:drivers_nxp/mci.c **** 	return ( TRUE );
1976:drivers_nxp/mci.c **** }
1977:drivers_nxp/mci.c **** 
1978:drivers_nxp/mci.c **** /******************************************************************************
1979:drivers_nxp/mci.c ****  ** Function name:		MCI_Power_Off
1980:drivers_nxp/mci.c ****  **
1981:drivers_nxp/mci.c ****  ** Descriptions:		disable power to MCI (Power-Reg)
1982:drivers_nxp/mci.c ****  **
1983:drivers_nxp/mci.c ****  ** parameters:			none
1984:drivers_nxp/mci.c ****  ** Returned value:		none
1985:drivers_nxp/mci.c ****  ** 
1986:drivers_nxp/mci.c ****  ** Added by Martin Thomas - but it does not work on MCB2300
1987:drivers_nxp/mci.c ****  ******************************************************************************/
1988:drivers_nxp/mci.c **** void MCI_Power_Off(void) {
 2317              		.loc 1 1923 0
 2318              		bl	MCI_CheckStatus
 2319              		cmp	r0, #1
 2320 0000 0DC0A0E1 		bne	.L297
 2321              	.LBB73:
 2322 0004 00D82DE9 	.LBB74:
 2323              		.loc 1 187 0
1989:drivers_nxp/mci.c **** 	volatile DWORD i;
1990:drivers_nxp/mci.c **** 
1991:drivers_nxp/mci.c **** 	// SCS |= (1<<8);
1992:drivers_nxp/mci.c **** 	MCI_POWER = 0;
 2324              	, #-536870912
 2325 0008 0E32A0E3 		add	r1, r1, #573440
 2326              		ldr	r3, [r1, #60]
 2327 000c 04B04CE2 		orr	r3, r3, #1824
 2328              		orr	r3, r3, #10
 2329              		str	r3, [r1, #60]
 2330 0010 233983E2 		.loc 1 189 0
 2331 0014 0020A0E3 		ldr	r2, [r1, #64]
 2332              		orr	r2, r2, #1824
 2333 0018 04D04DE2 		orr	r2, r2, #10
 2334              		str	r2, [r1, #64]
 2335              	.LBE74:
 2336 001c 002083E5 	.LBE73:
1993:drivers_nxp/mci.c **** 	for (i = 0; i < 0x100; i++)
 2337              	0
 2338 0020 10200BE5 		mov	r3, #131072
 2339              		.loc 1 1931 0
 2340 0024 10301BE5 		mov	r2, #512
 2341 0028 FF0053E3 		.loc 1 1930 0
 2342 002c 08A89D88 		str	r3, [r1, #36]
 2343              		.loc 1 1931 0
 2344 0030 10301BE5 		str	r2, [r1, #40]
 2345 0034 013083E2 		.loc 1 1933 0
 2346              		ldr	r3, .L299+4
 2347 0038 10300BE5 		.loc 1 1934 0
 2348 003c 10201BE5 		ldr	r2, .L299+8
 2349 0040 FF0052E3 		.loc 1 1933 0
 2350 0044 F9FFFF9A 		str	r0, [r3, #0]
 2351              		.loc 1 1939 0
 2352 0048 08A89DE8 		mov	r7, #2032
 2353              		.loc 1 1934 0
 2354              		str	r0, [r2, #0]
 2355              		.loc 1 1939 0
 2356              		mov	sl, r1
 2357              		add	r7, r7, #15
 2358              		.loc 1 1934 0
 2359              		mov	r6, #32
 2360              	.LVL182:
 2361              		.loc 1 1943 0
 2362              		mov	r8, #0
 2363              	.LVL183:
 2364 0000 0DC0A0E1 	.L286:
 2365              		.loc 1 1939 0
 2366 0004 F0DF2DE9 		str	r7, [sl, #56]
 2367              		.loc 1 1941 0
 2368              		bl	MCI_Send_ACMD
 2369 0008 C8219FE5 		.loc 1 1939 0
 2370              		mov	r5, #-536870912
 2371 000c 04B04CE2 		.loc 1 1941 0
 2372              		cmp	r0, #1
 2373 0010 14D04DE2 		mov	r4, r0
 2374              		.loc 1 1939 0
 2375              		add	r5, r5, #573440
 2376 0014 003092E5 		.loc 1 1941 0
 2377 0018 000053E3 		beq	.L298
 2378 001c 4000000A 	.L282:
 2379 0020 003092E5 		.loc 1 1950 0
 2380 0024 010053E3 		str	r8, [fp, #-44]
 2381 0028 3D00000A 	.LVL184:
 2382              		ldr	r3, [fp, #-44]
 2383 002c 0E22A0E3 		cmp	r3, #31
 2384 0030 7F3EA0E3 		bhi	.L284
 2385 0034 232982E2 	.L291:
 2386 0038 0F3083E2 		ldr	r3, [fp, #-44]
 2387              		add	r3, r3, #1
 2388 003c 0010A0E3 	.LVL185:
 2389              		str	r3, [fp, #-44]
 2390 0040 383082E5 		ldr	r2, [fp, #-44]
 2391              		cmp	r2, #31
 2392 0044 2C1082E5 		bls	.L291
 2393              	.LVL186:
 2394 0048 2C100BE5 	.L284:
 2395              		.loc 1 1938 0
 2396 004c 2C301BE5 		subs	r6, r6, #1
 2397 0050 0F0053E3 		bne	.L286
 2398 0054 0500008A 	.L277:
 2399              		.loc 1 1971 0
 2400 0058 2C301BE5 		mov	r0, #0
 2401 005c 013083E2 	.L281:
 2402              		.loc 1 1976 0
 2403 0060 2C300BE5 		sub	sp, fp, #40
 2404 0064 2C201BE5 		ldmfd	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
 2405 0068 0F0052E3 	.LVL187:
 2406 006c F9FFFF9A 	.L298:
 2407              		.loc 1 1943 0
 2408              		mov	r1, #0
 2409              		mov	r3, r1
 2410 0070 FEFFFFEB 		mov	r0, #13
 2411 0074 010050E3 		mov	r2, r4
 2412 0078 5300001A 		bl	MCI_SendCmd
 2413              		.loc 1 1944 0
 2414              		mov	r0, #13
 2415              		mov	r1, r4
 2416 007c 0E12A0E3 		sub	r2, fp, #60
 2417 0080 231981E2 		bl	MCI_GetCmdResp
 2418 0084 3C3091E5 		.loc 1 1946 0
 2419 0088 723E83E3 		subs	r9, r0, #0
 2420 008c 0A3083E3 		bne	.L282
 2421 0090 3C3081E5 		ldr	r3, [fp, #-60]
 2422              		and	r3, r3, #3840
 2423 0094 402091E5 		cmp	r3, #2304
 2424 0098 722E82E3 		bne	.L282
 2425 009c 0A2082E3 		.loc 1 1961 0
 2426 00a0 402081E5 		mov	r1, #2
 2427              		mov	r0, r4
 2428              		bl	DMA_Move
 2429              		.loc 1 1962 0
 2430 00a4 0238A0E3 		mov	r3, #20224
 2431              		add	r3, r3, #255
 2432 00a8 022CA0E3 		orr	r3, r3, r3, asl #21
 2433              		ldr	r2, [r3, #-3791]
 2434 00ac 243081E5 		orr	r2, r2, #77824
 2435              		orr	r2, r2, #9
 2436 00b0 282081E5 		.loc 1 1969 0
 2437              		mov	r1, #107
 2438 00b4 20319FE5 		.loc 1 1962 0
 2439              		str	r2, [r3, #-3791]
 2440 00b8 20219FE5 		.loc 1 1969 0
 2441              		str	r1, [r5, #44]
 2442 00bc 000083E5 		.loc 1 1971 0
 2443              		str	r9, [fp, #-44]
 2444 00c0 7F7EA0E3 	.LVL188:
 2445              		ldr	r3, [fp, #-44]
 2446 00c4 000082E5 		cmp	r3, #15
 2447              		bhi	.L287
 2448 00c8 01A0A0E1 	.L290:
 2449 00cc 0F7087E2 		ldr	r3, [fp, #-44]
 2450              		add	r3, r3, #1
 2451 00d0 2060A0E3 	.LVL189:
 2452              		str	r3, [fp, #-44]
 2453              		ldr	r2, [fp, #-44]
 2454 00d4 0080A0E3 		cmp	r2, #15
 2455              		bls	.L290
 2456              	.LVL190:
 2457              	.L287:
 2458 00d8 38708AE5 		mov	r0, #1
 2459              		b	.L281
 2460 00dc FEFFFFEB 	.LVL191:
 2461              	.L297:
 2462 00e0 0E52A0E3 		.loc 1 1924 0
 2463              		bl	MCI_Send_Stop
 2464 00e4 010050E3 		mov	r0, #0
 2465 00e8 0040A0E1 		b	.L281
 2466              	.L300:
 2467 00ec 235985E2 		.align	2
 2468              	.L299:
 2469 00f0 0E00000A 		.word	MCI_CardType
 2470              		.word	MCI_Block_End_Flag
 2471              		.word	SDStatRead
 2472 00f4 2C800BE5 	.LFE43:
 2474 00f8 2C301BE5 		.section	.text.MCI_Read_Block,"ax",%progbits
 2475 00fc 1F0053E3 		.align	2
 2476 0100 0500008A 		.global	MCI_Read_Block
 2478 0104 2C301BE5 	MCI_Read_Block:
 2479 0108 013083E2 	.LFB42:
 2480              		.loc 1 1848 0
 2481 010c 2C300BE5 		@ args = 0, pretend = 0, frame = 28
 2482 0110 2C201BE5 		@ frame_needed = 1, uses_anonymous_args = 0
 2483 0114 1F0052E3 	.LVL192:
 2484 0118 F9FFFF9A 		mov	ip, sp
 2485              	.LCFI85:
 2486              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 2487              	.LCFI86:
 2488 011c 016056E2 		.loc 1 1852 0
 2489 0120 ECFFFF1A 		mov	r2, #-536870912
 2490              		mov	r3, #2032
 2491              		.loc 1 1848 0
 2492 0124 0000A0E3 		sub	fp, ip, #4
 2493              	.LCFI87:
 2494              		.loc 1 1852 0
 2495 0128 28D04BE2 		add	r2, r2, #573440
 2496 012c F0AF9DE8 		add	r3, r3, #15
 2497              		.loc 1 1853 0
 2498              		mov	r1, #0
 2499              		.loc 1 1848 0
 2500 0130 0010A0E3 		sub	sp, sp, #28
 2501 0134 0130A0E1 	.LCFI88:
 2502 0138 0D00A0E3 		.loc 1 1852 0
 2503 013c 0420A0E1 		str	r3, [r2, #56]
 2504 0140 FEFFFFEB 		.loc 1 1853 0
 2505              		str	r1, [r2, #44]
 2506 0144 0D00A0E3 		.loc 1 1854 0
 2507 0148 0410A0E1 		str	r1, [fp, #-44]
 2508 014c 3C204BE2 	.LVL193:
 2509 0150 FEFFFFEB 		ldr	r3, [fp, #-44]
 2510              		cmp	r3, #15
 2511 0154 009050E2 		.loc 1 1848 0
 2512 0158 E5FFFF1A 		str	r0, [fp, #-68]
 2513 015c 3C301BE5 		.loc 1 1854 0
 2514 0160 0F3C03E2 		bhi	.L302
 2515 0164 090C53E3 	.LVL194:
 2516 0168 E1FFFF1A 	.L318:
 2517              		ldr	r3, [fp, #-44]
 2518 016c 0210A0E3 		add	r3, r3, #1
 2519 0170 0400A0E1 	.LVL195:
 2520 0174 FEFFFFEB 		str	r3, [fp, #-44]
 2521              		ldr	r2, [fp, #-44]
 2522 0178 4F3CA0E3 		cmp	r2, #15
 2523 017c FF3083E2 		bls	.L318
 2524 0180 833A83E1 	.LVL196:
 2525 0184 CF2E13E5 	.L302:
 2526 0188 132A82E3 		.loc 1 1860 0
 2527 018c 092082E3 		bl	MCI_CheckStatus
 2528              		cmp	r0, #1
 2529 0190 6B10A0E3 		bne	.L323
 2530              	.LBB75:
 2531 0194 CF2E03E5 	.LBB76:
 2532              		.loc 1 187 0
 2533 0198 2C1085E5 		mov	r1, #-536870912
 2534              		add	r1, r1, #573440
 2535 019c 2C900BE5 		ldr	r3, [r1, #60]
 2536              		orr	r3, r3, #1824
 2537 01a0 2C301BE5 		orr	r3, r3, #10
 2538 01a4 0F0053E3 		str	r3, [r1, #60]
 2539 01a8 0500008A 		.loc 1 189 0
 2540              		ldr	r2, [r1, #64]
 2541 01ac 2C301BE5 		orr	r2, r2, #1824
 2542 01b0 013083E2 		orr	r2, r2, #10
 2543              	.LBE76:
 2544 01b4 2C300BE5 	.LBE75:
 2545 01b8 2C201BE5 		.loc 1 1867 0
 2546 01bc 0F0052E3 		mov	r3, #131072
 2547 01c0 F9FFFF9A 	.LBB78:
 2548              	.LBB77:
 2549              		.loc 1 189 0
 2550 01c4 0100A0E3 		str	r2, [r1, #64]
 2551 01c8 D6FFFFEA 	.LBE77:
 2552              	.LBE78:
 2553              		.loc 1 1867 0
 2554              		str	r3, [r1, #36]
 2555 01cc FEFFFFEB 		.loc 1 1868 0
 2556 01d0 0000A0E3 		mov	r2, #512
 2557 01d4 D3FFFFEA 		.loc 1 1869 0
 2558              		ldr	r3, .L325
 2559              		.loc 1 1868 0
 2560              		str	r2, [r1, #40]
 2561 01d8 00000000 	.LBB79:
 2562 01dc 00000000 	.LBB82:
 2563 01e0 00000000 		.loc 1 1676 0
 2564              		ldr	r2, [fp, #-68]
 2565              		.loc 1 1670 0
 2566              		mov	r5, #2032
 2567              	.LBE82:
 2568              	.LBE79:
 2569              		.loc 1 1869 0
 2570              		str	r0, [r3, #0]
 2571              	.LBB84:
 2572              	.LBB81:
 2573              		.loc 1 1670 0
 2574              		mov	r9, r1
 2575              		add	r5, r5, #15
 2576 0000 0DC0A0E1 		.loc 1 1676 0
 2577              		mov	r7, r2, asl #9
 2578 0004 F0DF2DE9 		mov	r4, #32
 2579              	.LVL197:
 2580              		sub	r8, fp, #64
 2581 0008 0E22A0E3 		mov	sl, #0
 2582 000c 7F3EA0E3 	.LVL198:
 2583              	.L312:
 2584 0010 04B04CE2 		.loc 1 1670 0
 2585              		str	r5, [r9, #56]
 2586              		.loc 1 1673 0
 2587 0014 232982E2 		ldr	r2, .L325+4
 2588 0018 0F3083E2 		ldr	r3, [r2, #0]
 2589              		cmp	r3, #4
 2590 001c 0010A0E3 		beq	.L324
 2591              		.loc 1 1676 0
 2592 0020 1CD04DE2 		mov	r0, #17
 2593              		mov	r1, r7
 2594              		mov	r2, #1
 2595 0024 383082E5 		mov	r3, #0
 2596              		bl	MCI_SendCmd
 2597 0028 2C1082E5 	.L307:
 2598              	.LBE81:
 2599 002c 2C100BE5 		.loc 1 1682 0
 2600              		mov	r0, #17
 2601 0030 2C301BE5 		mov	r1, #1
 2602 0034 0F0053E3 		mov	r2, r8
 2603              		bl	MCI_GetCmdResp
 2604 0038 44000BE5 	.LBB80:
 2605              		.loc 1 1684 0
 2606 003c 0500008A 		subs	r6, r0, #0
 2607              		bne	.L308
 2608              		ldr	r3, [fp, #-64]
 2609 0040 2C301BE5 		and	r3, r3, #3840
 2610 0044 013083E2 		cmp	r3, #2304
 2611              		beq	.L309
 2612 0048 2C300BE5 	.L308:
 2613 004c 2C201BE5 		.loc 1 1687 0
 2614 0050 0F0052E3 		str	sl, [fp, #-48]
 2615 0054 F9FFFF9A 	.LVL199:
 2616              		ldr	r3, [fp, #-48]
 2617              		cmp	r3, #31
 2618              		bhi	.L310
 2619 0058 FEFFFFEB 	.L317:
 2620 005c 010050E3 		ldr	r3, [fp, #-48]
 2621 0060 4000001A 		add	r3, r3, #1
 2622              		str	r3, [fp, #-48]
 2623              	.LVL200:
 2624              		ldr	r2, [fp, #-48]
 2625 0064 0E12A0E3 		cmp	r2, #31
 2626 0068 231981E2 		bls	.L317
 2627 006c 3C3091E5 	.L310:
 2628 0070 723E83E3 		.loc 1 1669 0
 2629 0074 0A3083E3 		subs	r4, r4, #1
 2630 0078 3C3081E5 		bne	.L312
 2631              		mov	r0, r4
 2632 007c 402091E5 	.LVL201:
 2633 0080 722E82E3 	.L305:
 2634 0084 0A2082E3 	.LBE80:
 2635              	.LBE84:
 2636              		.loc 1 1889 0
 2637              		sub	sp, fp, #40
 2638 0088 0238A0E3 		ldmfd	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
 2639              	.LVL202:
 2640              	.L324:
 2641              	.LBB85:
 2642 008c 402081E5 	.LBB83:
 2643              		.loc 1 1674 0
 2644              		mov	r0, #17
 2645              		ldr	r1, [fp, #-68]
 2646 0090 243081E5 		mov	r2, #1
 2647              		sub	r3, r3, #4
 2648 0094 022CA0E3 		bl	MCI_SendCmd
 2649              		b	.L307
 2650 0098 3C319FE5 	.LVL203:
 2651              	.L323:
 2652 009c 282081E5 	.LBE83:
 2653              	.LBE85:
 2654              		.loc 1 1862 0
 2655              		bl	MCI_Send_Stop
 2656 00a0 44201BE5 		mov	r0, #0
 2657              		b	.L305
 2658 00a4 7F5EA0E3 	.LVL204:
 2659              	.L309:
 2660              		.loc 1 1875 0
 2661              		mov	r1, #2
 2662 00a8 000083E5 		mov	r0, #1
 2663              		bl	DMA_Move
 2664              		.loc 1 1876 0
 2665              		mov	r3, #20224
 2666 00ac 0190A0E1 		add	r3, r3, #255
 2667 00b0 0F5085E2 		orr	r3, r3, r3, asl #21
 2668              		ldr	r2, [r3, #-3791]
 2669 00b4 8274A0E1 		.loc 1 1883 0
 2670 00b8 2040A0E3 		mov	r0, #-536870912
 2671              		.loc 1 1876 0
 2672 00bc 40804BE2 		orr	r2, r2, #77824
 2673 00c0 00A0A0E3 		orr	r2, r2, #9
 2674              		.loc 1 1883 0
 2675              		add	r0, r0, #573440
 2676              		mov	r1, #155
 2677 00c4 385089E5 		.loc 1 1876 0
 2678              		str	r2, [r3, #-3791]
 2679 00c8 10219FE5 		.loc 1 1883 0
 2680 00cc 003092E5 		str	r1, [r0, #44]
 2681 00d0 040053E3 		.loc 1 1884 0
 2682 00d4 1D00000A 		str	r6, [fp, #-44]
 2683              	.LVL205:
 2684 00d8 1100A0E3 		ldr	r3, [fp, #-44]
 2685 00dc 0710A0E1 		cmp	r3, #15
 2686 00e0 0120A0E3 		bhi	.L313
 2687 00e4 0030A0E3 	.LVL206:
 2688 00e8 FEFFFFEB 	.L316:
 2689              		ldr	r3, [fp, #-44]
 2690              		add	r3, r3, #1
 2691              	.LVL207:
 2692 00ec 1100A0E3 		str	r3, [fp, #-44]
 2693 00f0 0110A0E3 		ldr	r2, [fp, #-44]
 2694 00f4 0820A0E1 		cmp	r2, #15
 2695 00f8 FEFFFFEB 		bls	.L316
 2696              	.LVL208:
 2697              	.L313:
 2698 00fc 006050E2 		mov	r0, #1
 2699 0100 0300001A 		b	.L305
 2700 0104 40301BE5 	.L326:
 2701 0108 0F3C03E2 		.align	2
 2702 010c 090C53E3 	.L325:
 2703 0110 1700000A 		.word	MCI_Block_End_Flag
 2704              		.word	MCI_CardType
 2705              	.LFE42:
 2707              		.section	.text.MCI_Write_Block,"ax",%progbits
 2708 0118 30301BE5 		.align	2
 2709 011c 1F0053E3 		.global	MCI_Write_Block
 2711              	MCI_Write_Block:
 2712 0124 30301BE5 	.LFB40:
 2713 0128 013083E2 		.loc 1 1709 0
 2714 012c 30300BE5 		@ args = 0, pretend = 0, frame = 28
 2715              		@ frame_needed = 1, uses_anonymous_args = 0
 2716 0130 30201BE5 	.LVL209:
 2717 0134 1F0052E3 		mov	ip, sp
 2718 0138 F9FFFF9A 	.LCFI89:
 2719              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 2720              	.LCFI90:
 2721 013c 014054E2 		.loc 1 1713 0
 2722 0140 DFFFFF1A 		mov	r2, #-536870912
 2723 0144 0400A0E1 		mov	r3, #2032
 2724              		.loc 1 1709 0
 2725              		sub	fp, ip, #4
 2726              	.LCFI91:
 2727              		.loc 1 1713 0
 2728              		add	r2, r2, #573440
 2729 0148 28D04BE2 		add	r3, r3, #15
 2730 014c F0AF9DE8 		.loc 1 1714 0
 2731              		mov	r1, #0
 2732              		.loc 1 1709 0
 2733              		sub	sp, sp, #28
 2734              	.LCFI92:
 2735              		.loc 1 1713 0
 2736 0150 1100A0E3 		str	r3, [r2, #56]
 2737 0154 44101BE5 		.loc 1 1714 0
 2738 0158 0120A0E3 		str	r1, [r2, #44]
 2739 015c 043043E2 		.loc 1 1715 0
 2740 0160 FEFFFFEB 		str	r1, [fp, #-44]
 2741 0164 E0FFFFEA 	.LVL210:
 2742              		ldr	r3, [fp, #-44]
 2743              		cmp	r3, #15
 2744              		.loc 1 1709 0
 2745              		str	r0, [fp, #-68]
 2746              		.loc 1 1715 0
 2747 0168 FEFFFFEB 		bhi	.L328
 2748 016c 0000A0E3 	.LVL211:
 2749 0170 F4FFFFEA 	.L344:
 2750              		ldr	r3, [fp, #-44]
 2751              		add	r3, r3, #1
 2752              	.LVL212:
 2753 0174 0210A0E3 		str	r3, [fp, #-44]
 2754 0178 0100A0E3 		ldr	r2, [fp, #-44]
 2755 017c FEFFFFEB 		cmp	r2, #15
 2756              		bls	.L344
 2757 0180 4F3CA0E3 	.LVL213:
 2758 0184 FF3083E2 	.L328:
 2759 0188 833A83E1 		.loc 1 1721 0
 2760 018c CF2E13E5 		bl	MCI_CheckStatus
 2761              		cmp	r0, #1
 2762 0190 0E02A0E3 		mov	ip, r0
 2763              		bne	.L349
 2764 0194 132A82E3 		.loc 1 1727 0
 2765 0198 092082E3 		mov	r0, #-536870912
 2766              		.loc 1 1729 0
 2767 019c 230980E2 		ldr	r1, .L351
 2768 01a0 9B10A0E3 		.loc 1 1727 0
 2769              		add	r0, r0, #573440
 2770 01a4 CF2E03E5 		mov	r3, #131072
 2771              		.loc 1 1728 0
 2772 01a8 2C1080E5 		mov	r2, #512
 2773              		.loc 1 1727 0
 2774 01ac 2C600BE5 		str	r3, [r0, #36]
 2775              		.loc 1 1728 0
 2776 01b0 2C301BE5 		str	r2, [r0, #40]
 2777 01b4 0F0053E3 		.loc 1 1729 0
 2778 01b8 0500008A 		str	ip, [r1, #0]
 2779              	.LBB86:
 2780              	.LBB87:
 2781 01bc 2C301BE5 		.loc 1 158 0
 2782 01c0 013083E2 		ldr	r3, [r0, #60]
 2783              		orr	r3, r3, #1808
 2784 01c4 2C300BE5 		orr	r3, r3, #10
 2785 01c8 2C201BE5 		str	r3, [r0, #60]
 2786 01cc 0F0052E3 		.loc 1 160 0
 2787 01d0 F9FFFF9A 		ldr	r2, [r0, #64]
 2788              		orr	r2, r2, #1808
 2789              		orr	r2, r2, #10
 2790 01d4 0100A0E3 		str	r2, [r0, #64]
 2791 01d8 DAFFFFEA 	.LBE87:
 2792              	.LBE86:
 2793              	.LBB88:
 2794              	.LBB90:
 2795 01dc 00000000 		.loc 1 1584 0
 2796 01e0 00000000 		ldr	r2, [fp, #-68]
 2797              		.loc 1 1578 0
 2798              		mov	r5, #2032
 2799              		mov	r9, r0
 2800              		add	r5, r5, #15
 2801              		.loc 1 1584 0
 2802              		mov	r7, r2, asl #9
 2803              		mov	r4, #32
 2804              	.LVL214:
 2805              		sub	r8, fp, #64
 2806              		mov	sl, #0
 2807              	.LVL215:
 2808              	.L338:
 2809 0000 0DC0A0E1 		.loc 1 1578 0
 2810              		str	r5, [r9, #56]
 2811 0004 F0DF2DE9 		.loc 1 1581 0
 2812              		ldr	r2, .L351+4
 2813              		ldr	r3, [r2, #0]
 2814 0008 0E22A0E3 		cmp	r3, #4
 2815 000c 7F3EA0E3 		beq	.L350
 2816              		.loc 1 1584 0
 2817 0010 04B04CE2 		mov	r0, #24
 2818              		mov	r1, r7
 2819              		mov	r2, #1
 2820 0014 232982E2 		mov	r3, #0
 2821 0018 0F3083E2 		bl	MCI_SendCmd
 2822              	.L333:
 2823 001c 0010A0E3 	.LBE90:
 2824              		.loc 1 1590 0
 2825 0020 1CD04DE2 		mov	r0, #24
 2826              		mov	r1, #1
 2827              		mov	r2, r8
 2828 0024 383082E5 		bl	MCI_GetCmdResp
 2829              	.LBB89:
 2830 0028 2C1082E5 		.loc 1 1592 0
 2831              		subs	r6, r0, #0
 2832 002c 2C100BE5 		bne	.L334
 2833              		ldr	r3, [fp, #-64]
 2834 0030 2C301BE5 		and	r3, r3, #3840
 2835 0034 0F0053E3 		cmp	r3, #2304
 2836              		beq	.L335
 2837 0038 44000BE5 	.L334:
 2838              		.loc 1 1596 0
 2839 003c 0500008A 		str	sl, [fp, #-48]
 2840              	.LVL216:
 2841              		ldr	r3, [fp, #-48]
 2842 0040 2C301BE5 		cmp	r3, #31
 2843 0044 013083E2 		bhi	.L336
 2844              	.L343:
 2845 0048 2C300BE5 		ldr	r3, [fp, #-48]
 2846 004c 2C201BE5 		add	r3, r3, #1
 2847 0050 0F0052E3 		str	r3, [fp, #-48]
 2848 0054 F9FFFF9A 	.LVL217:
 2849              		ldr	r2, [fp, #-48]
 2850              		cmp	r2, #31
 2851              		bls	.L343
 2852 0058 FEFFFFEB 	.L336:
 2853 005c 010050E3 		.loc 1 1577 0
 2854 0060 00C0A0E1 		subs	r4, r4, #1
 2855 0064 4000001A 		bne	.L338
 2856              		mov	r0, r4
 2857 0068 0E02A0E3 	.LVL218:
 2858              	.L331:
 2859 006c 6C119FE5 	.LBE89:
 2860              	.LBE88:
 2861 0070 230980E2 		.loc 1 1751 0
 2862 0074 0238A0E3 		sub	sp, fp, #40
 2863              		ldmfd	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
 2864 0078 022CA0E3 	.LVL219:
 2865              	.L350:
 2866 007c 243080E5 	.LBB92:
 2867              	.LBB91:
 2868 0080 282080E5 		.loc 1 1582 0
 2869              		mov	r0, #24
 2870 0084 00C081E5 		ldr	r1, [fp, #-68]
 2871              		mov	r2, #1
 2872              		sub	r3, r3, #4
 2873              		bl	MCI_SendCmd
 2874 0088 3C3090E5 		b	.L333
 2875 008c 713E83E3 	.LVL220:
 2876 0090 0A3083E3 	.L349:
 2877 0094 3C3080E5 	.LBE91:
 2878              	.LBE92:
 2879 0098 402090E5 		.loc 1 1723 0
 2880 009c 712E82E3 		bl	MCI_Send_Stop
 2881 00a0 0A2082E3 		mov	r0, #0
 2882 00a4 402080E5 		b	.L331
 2883              	.LVL221:
 2884              	.L335:
 2885              		.loc 1 1736 0
 2886              		mov	r1, #1
 2887              		bl	DMA_Move
 2888 00a8 44201BE5 		.loc 1 1737 0
 2889              		mov	r2, #20224
 2890 00ac 7F5EA0E3 		add	r2, r2, #255
 2891 00b0 0090A0E1 		orr	r2, r2, r2, asl #21
 2892 00b4 0F5085E2 		ldr	r3, [r2, #-3823]
 2893              		orr	r3, r3, #75776
 2894 00b8 8274A0E1 		orr	r3, r3, #256
 2895 00bc 2040A0E3 		.loc 1 1744 0
 2896              		mov	r0, #-536870912
 2897 00c0 40804BE2 		.loc 1 1737 0
 2898 00c4 00A0A0E3 		orr	r3, r3, #1
 2899              		.loc 1 1744 0
 2900              		add	r0, r0, #573440
 2901              		mov	r1, #153
 2902 00c8 385089E5 		.loc 1 1737 0
 2903              		str	r3, [r2, #-3823]
 2904 00cc 10219FE5 		.loc 1 1744 0
 2905 00d0 003092E5 		str	r1, [r0, #44]
 2906 00d4 040053E3 		.loc 1 1746 0
 2907 00d8 1D00000A 		str	r6, [fp, #-44]
 2908              	.LVL222:
 2909 00dc 1800A0E3 		ldr	r3, [fp, #-44]
 2910 00e0 0710A0E1 		cmp	r3, #15
 2911 00e4 0120A0E3 		bhi	.L339
 2912 00e8 0030A0E3 	.LVL223:
 2913 00ec FEFFFFEB 	.L342:
 2914              		ldr	r3, [fp, #-44]
 2915              		add	r3, r3, #1
 2916              	.LVL224:
 2917 00f0 1800A0E3 		str	r3, [fp, #-44]
 2918 00f4 0110A0E3 		ldr	r2, [fp, #-44]
 2919 00f8 0820A0E1 		cmp	r2, #15
 2920 00fc FEFFFFEB 		bls	.L342
 2921              	.LVL225:
 2922              	.L339:
 2923 0100 006050E2 		mov	r0, #1
 2924 0104 0300001A 		b	.L331
 2925 0108 40301BE5 	.L352:
 2926 010c 0F3C03E2 		.align	2
 2927 0110 090C53E3 	.L351:
 2928 0114 1700000A 		.word	MCI_Block_End_Flag
 2929              		.word	MCI_CardType
 2930              	.LFE40:
 2932              		.section	.text.MCI_Write_Multiple_Block,"ax",%progbits
 2933 011c 30301BE5 		.align	2
 2934 0120 1F0053E3 		.global	MCI_Write_Multiple_Block
 2936              	MCI_Write_Multiple_Block:
 2937 0128 30301BE5 	.LFB41:
 2938 012c 013083E2 		.loc 1 1770 0
 2939 0130 30300BE5 		@ args = 0, pretend = 0, frame = 40
 2940              		@ frame_needed = 1, uses_anonymous_args = 0
 2941 0134 30201BE5 	.LVL226:
 2942 0138 1F0052E3 		mov	ip, sp
 2943 013c F9FFFF9A 	.LCFI93:
 2944              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 2945              	.LCFI94:
 2946 0140 014054E2 		.loc 1 1774 0
 2947 0144 DFFFFF1A 		mov	r4, #-536870912
 2948 0148 0400A0E1 		mov	r5, #2032
 2949              		.loc 1 1770 0
 2950              		sub	fp, ip, #4
 2951              	.LCFI95:
 2952              		sub	sp, sp, #40
 2953              	.LCFI96:
 2954 014c 28D04BE2 		.loc 1 1774 0
 2955 0150 F0AF9DE8 		add	r4, r4, #573440
 2956              		add	r5, r5, #15
 2957              		.loc 1 1775 0
 2958              		mov	r6, #0
 2959              		.loc 1 1770 0
 2960              		.loc 1 1770 0
 2961 0154 1800A0E3 		and	r1, r1, #255
 2962 0158 44101BE5 	.LVL227:
 2963 015c 0120A0E3 		.loc 1 1774 0
 2964 0160 043043E2 		str	r5, [r4, #56]
 2965 0164 FEFFFFEB 		.loc 1 1775 0
 2966 0168 E0FFFFEA 		str	r6, [r4, #44]
 2967              		.loc 1 1770 0
 2968              		str	r0, [fp, #-68]
 2969              		mov	r8, r2
 2970              		str	r1, [fp, #-72]
 2971              	.LVL228:
 2972 016c FEFFFFEB 		.loc 1 1781 0
 2973 0170 0000A0E3 		bl	MCI_CheckStatus
 2974 0174 F4FFFFEA 	.LVL229:
 2975              		cmp	r0, #1
 2976              		bne	.L375
 2977              		.loc 1 1789 0
 2978 0178 0110A0E3 		ldr	r1, .L377
 2979 017c FEFFFFEB 		.loc 1 1787 0
 2980              		mov	r3, #131072
 2981 0180 4F2CA0E3 		.loc 1 1788 0
 2982 0184 FF2082E2 		mov	r2, #512
 2983 0188 822A82E1 		.loc 1 1787 0
 2984 018c EF3E12E5 		str	r3, [r4, #36]
 2985 0190 4A3B83E3 		.loc 1 1788 0
 2986 0194 013C83E3 		str	r2, [r4, #40]
 2987              		.loc 1 1789 0
 2988 0198 0E02A0E3 		str	r0, [r1, #0]
 2989              	.LBB93:
 2990 019c 013083E3 	.LBB94:
 2991              		.loc 1 158 0
 2992 01a0 230980E2 		ldr	r3, [r4, #60]
 2993 01a4 9910A0E3 		orr	r3, r3, #1808
 2994              		orr	r3, r3, #10
 2995 01a8 EF3E02E5 		str	r3, [r4, #60]
 2996              		.loc 1 160 0
 2997 01ac 2C1080E5 		ldr	r2, [r4, #64]
 2998              		orr	r2, r2, #1808
 2999 01b0 2C600BE5 		orr	r2, r2, #10
 3000              		str	r2, [r4, #64]
 3001 01b4 2C301BE5 	.LBE94:
 3002 01b8 0F0053E3 	.LBE93:
 3003 01bc 0500008A 	.LBB95:
 3004              	.LBB97:
 3005              		.loc 1 1630 0
 3006 01c0 2C301BE5 		ldr	r2, [fp, #-68]
 3007 01c4 013083E2 		.loc 1 1624 0
 3008              		mov	r7, r4
 3009 01c8 2C300BE5 		mov	sl, r5
 3010 01cc 2C201BE5 		.loc 1 1630 0
 3011 01d0 0F0052E3 		mov	r9, r6
 3012 01d4 F9FFFF9A 		mov	r5, r2, asl #9
 3013              		mov	r4, #32
 3014              	.LVL230:
 3015 01d8 0100A0E3 		sub	r6, fp, #64
 3016 01dc DAFFFFEA 	.LVL231:
 3017              	.L362:
 3018              		.loc 1 1624 0
 3019              		str	sl, [r7, #56]
 3020 01e0 00000000 		.loc 1 1627 0
 3021 01e4 00000000 		ldr	r2, .L377+4
 3022              		ldr	r3, [r2, #0]
 3023              		cmp	r3, #4
 3024              		beq	.L376
 3025              		.loc 1 1630 0
 3026              		mov	r0, #25
 3027              	.LVL232:
 3028              		mov	r1, r5
 3029              		mov	r2, #1
 3030              		mov	r3, #0
 3031              		bl	MCI_SendCmd
 3032              	.L357:
 3033              	.LBE97:
 3034 0000 0DC0A0E1 		.loc 1 1636 0
 3035              		mov	r0, #25
 3036 0004 F0DF2DE9 		mov	r1, #1
 3037              		mov	r2, r6
 3038              		bl	MCI_GetCmdResp
 3039 0008 0E42A0E3 	.LBB98:
 3040 000c 7F5EA0E3 		.loc 1 1638 0
 3041              		cmp	r0, #0
 3042 0010 04B04CE2 	.LVL233:
 3043              		bne	.L358
 3044 0014 28D04DE2 		ldr	r3, [fp, #-64]
 3045              		and	r3, r3, #3840
 3046              		cmp	r3, #2304
 3047 0018 234984E2 		beq	.L359
 3048 001c 0F5085E2 	.L358:
 3049              		.loc 1 1642 0
 3050 0020 0060A0E3 		str	r9, [fp, #-48]
 3051              	.LVL234:
 3052              		ldr	r3, [fp, #-48]
 3053 0024 FF1001E2 		cmp	r3, #31
 3054              		bhi	.L360
 3055              	.L370:
 3056 0028 385084E5 		ldr	r3, [fp, #-48]
 3057              		add	r3, r3, #1
 3058 002c 2C6084E5 		str	r3, [fp, #-48]
 3059              	.LVL235:
 3060 0030 44000BE5 		ldr	r2, [fp, #-48]
 3061 0034 0280A0E1 		cmp	r2, #31
 3062 0038 48100BE5 		bls	.L370
 3063              	.L360:
 3064              		.loc 1 1623 0
 3065 003c FEFFFFEB 		subs	r4, r4, #1
 3066              		bne	.L362
 3067 0040 010050E3 		mov	r0, r4
 3068 0044 3D00001A 	.LVL236:
 3069              	.L355:
 3070 0048 F4119FE5 	.LBE98:
 3071              	.LBE95:
 3072 004c 0238A0E3 		.loc 1 1831 0
 3073              		sub	sp, fp, #40
 3074 0050 022CA0E3 		ldmfd	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
 3075              	.LVL237:
 3076 0054 243084E5 	.L376:
 3077              	.LBB100:
 3078 0058 282084E5 	.LBB96:
 3079              		.loc 1 1628 0
 3080 005c 000081E5 		mov	r0, #25
 3081              	.LVL238:
 3082              		ldr	r1, [fp, #-68]
 3083              		mov	r2, #1
 3084 0060 3C3094E5 		sub	r3, r3, #4
 3085 0064 713E83E3 		bl	MCI_SendCmd
 3086 0068 0A3083E3 		b	.L357
 3087 006c 3C3084E5 	.LVL239:
 3088              	.L375:
 3089 0070 402094E5 	.LBE96:
 3090 0074 712E82E3 	.LBE100:
 3091 0078 0A2082E3 		.loc 1 1783 0
 3092 007c 402084E5 		bl	MCI_Send_Stop
 3093              		mov	r0, r6
 3094              		b	.L355
 3095              	.LVL240:
 3096              	.L359:
 3097              		.loc 1 1810 0
 3098 0080 44201BE5 		mov	r3, #-2080374784
 3099              		.loc 1 1800 0
 3100 0084 0470A0E1 		mov	r4, #20224
 3101 0088 05A0A0E1 	.LVL241:
 3102              		.loc 1 1810 0
 3103 008c 0690A0E1 		add	r3, r3, #4784128
 3104 0090 8254A0E1 		.loc 1 1820 0
 3105 0094 2040A0E3 		mov	r2, #-536870912
 3106              		.loc 1 1800 0
 3107 0098 40604BE2 		add	r4, r4, #255
 3108              		.loc 1 1803 0
 3109              		mov	r9, #-536870912
 3110              		.loc 1 1810 0
 3111 009c 38A087E5 		add	r3, r3, #16896
 3112              		.loc 1 1820 0
 3113 00a0 A0219FE5 		add	r2, r2, #573440
 3114 00a4 003092E5 		.loc 1 1800 0
 3115 00a8 040053E3 		orr	r4, r4, r4, asl #21
 3116 00ac 1D00000A 		.loc 1 1803 0
 3117              		add	r9, r9, #573440
 3118 00b0 1900A0E3 		.loc 1 1798 0
 3119              		mov	sl, #2130706432
 3120 00b4 0510A0E1 		.loc 1 1810 0
 3121 00b8 0120A0E3 		str	r3, [fp, #-76]
 3122 00bc 0030A0E3 		.loc 1 1820 0
 3123 00c0 FEFFFFEB 		str	r2, [fp, #-80]
 3124              	.LBB101:
 3125              	.LBB99:
 3126              		.loc 1 1623 0
 3127 00c4 1900A0E3 		mov	r5, r0
 3128 00c8 0110A0E3 	.LVL242:
 3129 00cc 0620A0E1 	.LBE99:
 3130 00d0 FEFFFFEB 	.LBE101:
 3131              		.loc 1 1798 0
 3132              		add	sl, sl, #13631488
 3133 00d4 000050E3 		.loc 1 1803 0
 3134              		add	r9, r9, #128
 3135 00d8 0300001A 		.loc 1 1800 0
 3136 00dc 40301BE5 		mov	r7, #1
 3137 00e0 0F3C03E2 		.loc 1 1806 0
 3138 00e4 090C53E3 		mov	r6, r4
 3139 00e8 1700000A 	.LVL243:
 3140              	.L367:
 3141              		.loc 1 1798 0
 3142 00ec 30900BE5 		mov	r0, #2130706432
 3143              	.LVL244:
 3144 00f0 30301BE5 		mov	r1, r8
 3145 00f4 1F0053E3 		add	r0, r0, #13631488
 3146 00f8 0500008A 		mov	r2, #512
 3147              		bl	memcpy
 3148 00fc 30301BE5 		.loc 1 1800 0
 3149 0100 013083E2 		str	r7, [r4, #-4087]
 3150 0104 30300BE5 		.loc 1 1801 0
 3151              		str	r7, [r4, #-4079]
 3152 0108 30201BE5 		.loc 1 1802 0
 3153 010c 1F0052E3 		str	sl, [r4, #-3839]
 3154 0110 F9FFFF9A 		.loc 1 1803 0
 3155              		str	r9, [r4, #-3835]
 3156              		.loc 1 1804 0
 3157 0114 014054E2 		str	r7, [r4, #-4047]
 3158 0118 DFFFFF1A 		.loc 1 1799 0
 3159 011c 0400A0E1 		add	r8, r8, #512
 3160              	.L363:
 3161              		.loc 1 1806 0
 3162              		ldr	r3, [r4, #-4047]
 3163              		tst	r3, #1
 3164              		beq	.L363
 3165 0120 28D04BE2 		.loc 1 1810 0
 3166 0124 F0AF9DE8 		ldr	r3, [fp, #-76]
 3167              		str	r3, [r6, #-3827]
 3168              		.loc 1 1813 0
 3169              		ldr	r3, [r6, #-3823]
 3170              		orr	r3, r3, #75776
 3171              		orr	r3, r3, #256
 3172 0128 1900A0E3 		orr	r3, r3, #1
 3173              		.loc 1 1820 0
 3174 012c 44101BE5 		ldr	r2, [fp, #-80]
 3175 0130 0120A0E3 		.loc 1 1813 0
 3176 0134 043043E2 		str	r3, [r6, #-3823]
 3177 0138 FEFFFFEB 		.loc 1 1815 0
 3178 013c E0FFFFEA 		orr	r5, r5, #153
 3179              		.loc 1 1821 0
 3180              		mov	r3, #0
 3181              		.loc 1 1820 0
 3182              		str	r5, [r2, #44]
 3183              		.loc 1 1821 0
 3184 0140 FEFFFFEB 		str	r3, [fp, #-44]
 3185 0144 0600A0E1 	.LVL245:
 3186 0148 F4FFFFEA 		ldr	r3, [fp, #-44]
 3187              		cmp	r3, #15
 3188              		bhi	.L364
 3189              	.LVL246:
 3190 014c 2133A0E3 	.L369:
 3191              		ldr	r3, [fp, #-44]
 3192 0150 4F4CA0E3 		add	r3, r3, #1
 3193              	.LVL247:
 3194              		str	r3, [fp, #-44]
 3195 0154 493883E2 		ldr	r2, [fp, #-44]
 3196              		cmp	r2, #15
 3197 0158 0E22A0E3 		bls	.L369
 3198              	.LVL248:
 3199 015c FF4084E2 	.L364:
 3200              		.loc 1 1824 0
 3201 0160 0E92A0E3 		ldr	r2, [fp, #-72]
 3202              		cmp	r2, #0
 3203 0164 423C83E2 		subne	r3, r2, #1
 3204              		andne	r3, r3, #255
 3205 0168 232982E2 		strne	r3, [fp, #-72]
 3206              	.LVL249:
 3207 016c 844A84E1 		bne	.L367
 3208              	.LVL250:
 3209 0170 239989E2 	.L366:
 3210              		.loc 1 1828 0
 3211 0174 7FA4A0E3 		bl	MCI_Send_Stop
 3212              		mov	r0, #1
 3213 0178 4C300BE5 		b	.L355
 3214              	.L378:
 3215 017c 50200BE5 		.align	2
 3216              	.L377:
 3217              		.word	MCI_Block_End_Flag
 3218              		.word	MCI_CardType
 3219 0180 0050A0E1 	.LFE41:
 3221              		.section	.text.MCI_Init,"ax",%progbits
 3222              		.align	2
 3223              		.global	MCI_Init
 3225              	MCI_Init:
 3226 0188 809089E2 	.LFB20:
 3227              		.loc 1 588 0
 3228 018c 0170A0E3 		@ args = 0, pretend = 0, frame = 4
 3229              		@ frame_needed = 1, uses_anonymous_args = 0
 3230 0190 0460A0E1 		mov	ip, sp
 3231              	.LCFI97:
 3232              		stmfd	sp!, {fp, ip, lr, pc}
 3233              	.LCFI98:
 3234 0194 7F04A0E3 		.loc 1 591 0
 3235              		mov	r3, #-536870912
 3236 0198 0810A0E1 		.loc 1 588 0
 3237 019c 0D0680E2 		sub	fp, ip, #4
 3238 01a0 022CA0E3 	.LCFI99:
 3239 01a4 FEFFFFEB 		sub	sp, sp, #4
 3240              	.LCFI100:
 3241 01a8 F77F04E5 		.loc 1 591 0
 3242              		add	r3, r3, #2080768
 3243 01ac EF7F04E5 		ldr	r2, [r3, #196]
 3244              		orr	r2, r2, #268435456
 3245 01b0 FFAE04E5 		str	r2, [r3, #196]
 3246              		.loc 1 594 0
 3247 01b4 FB9E04E5 		mov	r2, #-536870912
 3248              		add	r2, r2, #573440
 3249 01b8 CF7F04E5 		ldr	r3, [r2, #4]
 3250              		tst	r3, #256
 3251 01bc 028C88E2 		.loc 1 595 0
 3252              		ldrne	r3, [r2, #4]
 3253              		bicne	r3, r3, #256
 3254 01c0 CF3F14E5 		strne	r3, [r2, #4]
 3255 01c4 010013E3 		.loc 1 597 0
 3256 01c8 FCFFFF0A 		mov	r2, #-536870912
 3257              		add	r2, r2, #573440
 3258 01cc 4C301BE5 		ldr	r3, [r2, #0]
 3259 01d0 F33E06E5 		tst	r3, #2
 3260              		.loc 1 598 0
 3261 01d4 EF3E16E5 		movne	r3, #0
 3262 01d8 4A3B83E3 		strne	r3, [r2, #0]
 3263 01dc 013C83E3 		.loc 1 600 0
 3264 01e0 013083E3 		mov	r3, #0
 3265              		str	r3, [fp, #-16]
 3266 01e4 50201BE5 	.LVL251:
 3267              		ldr	r2, [fp, #-16]
 3268 01e8 EF3E06E5 		add	r3, r3, #4080
 3269              		add	r3, r3, #15
 3270 01ec 995085E3 		cmp	r2, r3
 3271              		bhi	.L382
 3272 01f0 0030A0E3 		mov	r1, r3
 3273              	.L392:
 3274 01f4 2C5082E5 		ldr	r3, [fp, #-16]
 3275              		add	r3, r3, #1
 3276 01f8 2C300BE5 	.LVL252:
 3277              		str	r3, [fp, #-16]
 3278 01fc 2C301BE5 		ldr	r2, [fp, #-16]
 3279 0200 0F0053E3 		cmp	r2, r1
 3280 0204 0500008A 		bls	.L392
 3281              	.LVL253:
 3282              	.L382:
 3283 0208 2C301BE5 		.loc 1 604 0
 3284 020c 013083E2 		mov	ip, #-536870912
 3285              		add	ip, ip, #573440
 3286 0210 2C300BE5 		mov	lr, #0
 3287 0214 2C201BE5 		str	lr, [ip, #60]
 3288 0218 0F0052E3 		.loc 1 605 0
 3289 021c F9FFFF9A 		ldr	r3, [ip, #60]
 3290              		.loc 1 624 0
 3291              		mov	r1, #-536870912
 3292              		.loc 1 605 0
 3293 0220 48201BE5 		str	r3, [ip, #64]
 3294 0224 000052E3 		.loc 1 624 0
 3295 0228 01304212 		add	r1, r1, #180224
 3296 022c FF300312 		ldr	r3, [r1, #4]
 3297 0230 48300B15 		bic	r3, r3, #16320
 3298              		str	r3, [r1, #4]
 3299 0234 D6FFFF1A 		.loc 1 625 0
 3300              		ldr	r2, [r1, #4]
 3301              		orr	r2, r2, #10880
 3302              		str	r2, [r1, #4]
 3303 0238 FEFFFFEB 		.loc 1 627 0
 3304 023c 0100A0E3 		ldr	r3, [r1, #8]
 3305 0240 B6FFFFEA 		bic	r3, r3, #41943040
 3306              		bic	r3, r3, #32768
 3307              		str	r3, [r1, #8]
 3308              		.loc 1 628 0
 3309 0244 00000000 		ldr	r2, [r1, #8]
 3310 0248 00000000 		orr	r2, r2, #41943040
 3311              		orr	r2, r2, #32768
 3312              		str	r2, [r1, #8]
 3313              		.loc 1 646 0
 3314              		mov	r0, #-536870912
 3315              		add	r0, r0, #2080768
 3316              		ldr	r3, [r0, #416]
 3317              		.loc 1 656 0
 3318              		mov	r2, #2032
 3319              		.loc 1 646 0
 3320              		bic	r3, r3, #8
 3321              		str	r3, [r0, #416]
 3322 0000 0DC0A0E1 		.loc 1 656 0
 3323              		add	r2, r2, #15
 3324 0004 00D82DE9 		.loc 1 659 0
 3325              		mov	r3, #2
 3326              		.loc 1 654 0
 3327 0008 0E32A0E3 		str	lr, [ip, #12]
 3328              		.loc 1 655 0
 3329 000c 04B04CE2 		str	lr, [ip, #44]
 3330              		.loc 1 656 0
 3331 0010 04D04DE2 		str	r2, [ip, #56]
 3332              		.loc 1 659 0
 3333              		str	r3, [ip, #0]
 3334 0014 7F3983E2 	.L384:
 3335 0018 C42093E5 		.loc 1 661 0
 3336 001c 012282E3 		ldr	r3, [ip, #0]
 3337 0020 C42083E5 		tst	r3, #2
 3338              		beq	.L384
 3339 0024 0E22A0E3 		.loc 1 664 0
 3340 0028 232982E2 		mov	r3, #0
 3341 002c 043092E5 		str	r3, [fp, #-16]
 3342 0030 010C13E3 	.LVL254:
 3343              		ldr	r2, [fp, #-16]
 3344 0034 04309215 		cmp	r2, #255
 3345 0038 013CC313 		bhi	.L385
 3346 003c 04308215 	.L391:
 3347              		ldr	r3, [fp, #-16]
 3348 0040 0E22A0E3 		add	r3, r3, #1
 3349 0044 232982E2 	.LVL255:
 3350 0048 003092E5 		str	r3, [fp, #-16]
 3351 004c 020013E3 		ldr	r2, [fp, #-16]
 3352              		cmp	r2, #255
 3353 0050 0030A013 		bls	.L391
 3354 0054 00308215 	.LVL256:
 3355              	.L385:
 3356 0058 0030A0E3 		.loc 1 671 0
 3357 005c 10300BE5 		mov	r0, #1
 3358              		bl	MCI_Set_MCIClock
 3359 0060 10201BE5 		.loc 1 672 0
 3360 0064 FF3E83E2 		mov	r2, #-536870912
 3361 0068 0F3083E2 		add	r2, r2, #573440
 3362 006c 030052E1 		ldr	r3, [r2, #0]
 3363 0070 0600008A 		.loc 1 675 0
 3364 0074 0310A0E1 		mov	r1, #0
 3365              		.loc 1 672 0
 3366 0078 10301BE5 		orr	r3, r3, #1
 3367 007c 013083E2 		str	r3, [r2, #0]
 3368              		.loc 1 675 0
 3369 0080 10300BE5 		str	r1, [fp, #-16]
 3370 0084 10201BE5 	.LVL257:
 3371 0088 010052E1 		ldr	r3, [fp, #-16]
 3372 008c F9FFFF9A 		mov	r2, #8128
 3373              		add	r2, r2, #63
 3374              		cmp	r3, r2
 3375              		bhi	.L387
 3376 0090 0EC2A0E3 		mov	r1, r2
 3377 0094 23C98CE2 	.L390:
 3378 0098 00E0A0E3 		ldr	r3, [fp, #-16]
 3379 009c 3CE08CE5 		add	r3, r3, #1
 3380              	.LVL258:
 3381 00a0 3C309CE5 		str	r3, [fp, #-16]
 3382              		ldr	r2, [fp, #-16]
 3383 00a4 0E12A0E3 		cmp	r2, r1
 3384              		bls	.L390
 3385 00a8 40308CE5 	.LVL259:
 3386              	.L387:
 3387 00ac 0B1981E2 		.loc 1 678 0
 3388 00b0 043091E5 		ldr	r1, .L397
 3389 00b4 FF3DC3E3 		mov	r2, #2
 3390 00b8 043081E5 		mov	r0, #24
 3391              		bl	install_irq
 3392 00bc 042091E5 		.loc 1 691 0
 3393 00c0 AA2D82E3 		subs	r0, r0, #0
 3394 00c4 042081E5 		movne	r0, #1
 3395              		ldmfd	sp, {r3, fp, sp, pc}
 3396 00c8 083091E5 	.L398:
 3397 00cc 0A35C3E3 		.align	2
 3398 00d0 0239C3E3 	.L397:
 3399 00d4 083081E5 		.word	MCI_IRQHandler
 3400              	.LFE20:
 3402 00dc 0A2582E3 		.global	MCI_DataErrorProcess_count
 3403 00e0 022982E3 		.section	.bss.MCI_DataErrorProcess_count,"aw",%nobits
 3404 00e4 082081E5 		.align	2
 3407 00ec 7F0980E2 	MCI_DataErrorProcess_count:
 3408 00f0 A03190E5 		.space	4
 3409              		.global	MCI_DATA_END_InterruptService_count
 3410 00f4 7F2EA0E3 		.section	.bss.MCI_DATA_END_InterruptService_count,"aw",%nobits
 3411              		.align	2
 3414              	MCI_DATA_END_InterruptService_count:
 3415 0100 0F2082E2 		.space	4
 3416              		.global	MCI_FIFOInterruptService_count
 3417 0104 0230A0E3 		.section	.bss.MCI_FIFOInterruptService_count,"aw",%nobits
 3418              		.align	2
 3421 010c 2CE08CE5 	MCI_FIFOInterruptService_count:
 3422              		.space	4
 3423 0110 38208CE5 		.global	MCI_CmdProcess_count
 3424              		.section	.bss.MCI_CmdProcess_count,"aw",%nobits
 3425 0114 00308CE5 		.align	2
 3428 0118 00309CE5 	MCI_CmdProcess_count:
 3429 011c 020013E3 		.space	4
 3430 0120 FCFFFF0A 		.global	CmdCRCErrCount
 3431              		.section	.bss.CmdCRCErrCount,"aw",%nobits
 3432 0124 0030A0E3 		.align	2
 3435 012c 10201BE5 	CmdCRCErrCount:
 3436 0130 FF0052E3 		.space	4
 3437 0134 0500008A 		.global	CmdTimeoutErrCount
 3438              		.section	.bss.CmdTimeoutErrCount,"aw",%nobits
 3439 0138 10301BE5 		.align	2
 3442 0140 10300BE5 	CmdTimeoutErrCount:
 3443 0144 10201BE5 		.space	4
 3444 0148 FF0052E3 		.global	CmdRespEndCount
 3445 014c F9FFFF9A 		.section	.bss.CmdRespEndCount,"aw",%nobits
 3446              		.align	2
 3449 0150 0100A0E3 	CmdRespEndCount:
 3450 0154 FEFFFFEB 		.space	4
 3451              		.global	CmdSentCount
 3452 0158 0E22A0E3 		.section	.bss.CmdSentCount,"aw",%nobits
 3453 015c 232982E2 		.align	2
 3456 0164 0010A0E3 	CmdSentCount:
 3457              		.space	4
 3458 0168 013083E3 		.global	CmdActiveCount
 3459 016c 003082E5 		.section	.bss.CmdActiveCount,"aw",%nobits
 3460              		.align	2
 3463 0174 10301BE5 	CmdActiveCount:
 3464 0178 7F2DA0E3 		.space	4
 3465 017c 3F2082E2 		.global	DataCRCErrCount
 3466 0180 020053E1 		.section	.bss.DataCRCErrCount,"aw",%nobits
 3467 0184 0600008A 		.align	2
 3470 018c 10301BE5 	DataCRCErrCount:
 3471 0190 013083E2 		.space	4
 3472              		.global	DataTimeoutErrCount
 3473 0194 10300BE5 		.section	.bss.DataTimeoutErrCount,"aw",%nobits
 3474 0198 10201BE5 		.align	2
 3477              	DataTimeoutErrCount:
 3478              		.space	4
 3479              		.global	DataTxUnderrunErrCount
 3480 01a4 14109FE5 		.section	.bss.DataTxUnderrunErrCount,"aw",%nobits
 3481 01a8 0220A0E3 		.align	2
 3484              	DataTxUnderrunErrCount:
 3485 01b4 000050E2 		.space	4
 3486 01b8 0100A013 		.global	DataRxOverrunErrCount
 3487 01bc 08A89DE8 		.section	.bss.DataRxOverrunErrCount,"aw",%nobits
 3488              		.align	2
 3491 01c0 00000000 	DataRxOverrunErrCount:
 3492              		.space	4
 3493              		.global	DataStartbitErrCount
 3494              		.section	.bss.DataStartbitErrCount,"aw",%nobits
 3495              		.align	2
 3498              	DataStartbitErrCount:
 3499              		.space	4
 3500 0000 00000000 		.global	DataEndCount
 3501              		.section	.bss.DataEndCount,"aw",%nobits
 3502              		.align	2
 3505              	DataEndCount:
 3506              		.space	4
 3507 0000 00000000 		.global	DataBlockEndCount
 3508              		.section	.bss.DataBlockEndCount,"aw",%nobits
 3509              		.align	2
 3512              	DataBlockEndCount:
 3513              		.space	4
 3514 0000 00000000 		.global	MCI_Block_End_Flag
 3515              		.section	.bss.MCI_Block_End_Flag,"aw",%nobits
 3516              		.align	2
 3519              	MCI_Block_End_Flag:
 3520              		.space	4
 3521 0000 00000000 		.global	DataTxActiveCount
 3522              		.section	.bss.DataTxActiveCount,"aw",%nobits
 3523              		.align	2
 3526              	DataTxActiveCount:
 3527              		.space	4
 3528 0000 00000000 		.global	DataRxActiveCount
 3529              		.section	.bss.DataRxActiveCount,"aw",%nobits
 3530              		.align	2
 3533              	DataRxActiveCount:
 3534              		.space	4
 3535 0000 00000000 		.global	DataFIFOCount
 3536              		.section	.bss.DataFIFOCount,"aw",%nobits
 3537              		.align	2
 3540              	DataFIFOCount:
 3541              		.space	4
 3542 0000 00000000 		.global	DataRxFIFOCount
 3543              		.section	.bss.DataRxFIFOCount,"aw",%nobits
 3544              		.align	2
 3547              	DataRxFIFOCount:
 3548              		.space	4
 3549 0000 00000000 		.global	DataTxFIFOCount
 3550              		.section	.bss.DataTxFIFOCount,"aw",%nobits
 3551              		.align	2
 3554              	DataTxFIFOCount:
 3555              		.space	4
 3556 0000 00000000 		.global	WriteBlock
 3557              		.section	.data.WriteBlock,"aw",%progbits
 3558              		.align	2
 3561              	WriteBlock:
 3562              		.word	2144337920
 3563 0000 00000000 		.global	ReadBlock
 3564              		.section	.data.ReadBlock,"aw",%progbits
 3565              		.align	2
 3568              	ReadBlock:
 3569              		.word	2144342016
 3570 0000 00000000 		.global	TXBlockCounter
 3571              		.section	.bss.TXBlockCounter,"aw",%nobits
 3572              		.align	2
 3575              	TXBlockCounter:
 3576              		.space	4
 3577 0000 00000000 		.global	RXBlockCounter
 3578              		.section	.bss.RXBlockCounter,"aw",%nobits
 3579              		.align	2
 3582              	RXBlockCounter:
 3583              		.space	4
 3584 0000 00000000 		.global	SDStatRead
 3585              		.section	.bss.SDStatRead,"aw",%nobits
 3586              		.align	2
 3589              	SDStatRead:
 3590              		.space	4
 3591 0000 00000000 		.comm	CardRCA,4,4
 3592              		.comm	MCI_CardType,4,4
 3593              		.section	.debug_frame,"",%progbits
 3594              	.Lframe0:
 3595              		.4byte	.LECIE0-.LSCIE0
 3596              	.LSCIE0:
 3597              		.4byte	0xffffffff
 3598 0000 00000000 		.byte	0x1
 3599              		.ascii	"\000"
 3600              		.uleb128 0x1
 3601              		.sleb128 -4
 3602              		.byte	0xe
 3603              		.byte	0xc
 3604              		.uleb128 0xd
 3605 0000 00000000 		.uleb128 0x0
 3606              		.align	2
 3607              	.LECIE0:
 3608              	.LSFDE0:
 3609              		.4byte	.LEFDE0-.LASFDE0
 3610              	.LASFDE0:
 3611              		.4byte	.Lframe0
 3612 0000 00000000 		.4byte	.LFB8
 3613              		.4byte	.LFE8-.LFB8
 3614              		.byte	0x4
 3615              		.4byte	.LCFI0-.LFB8
 3616              		.byte	0xd
 3617              		.uleb128 0xc
 3618              		.byte	0x4
 3619 0000 00000000 		.4byte	.LCFI1-.LCFI0
 3620              		.byte	0x8e
 3621              		.uleb128 0x2
 3622              		.byte	0x8d
 3623              		.uleb128 0x3
 3624              		.byte	0x8b
 3625              		.uleb128 0x4
 3626 0000 00000000 		.byte	0x4
 3627              		.4byte	.LCFI2-.LCFI1
 3628              		.byte	0xc
 3629              		.uleb128 0xb
 3630              		.uleb128 0x4
 3631              		.align	2
 3632              	.LEFDE0:
 3633 0000 00000000 	.LSFDE2:
 3634              		.4byte	.LEFDE2-.LASFDE2
 3635              	.LASFDE2:
 3636              		.4byte	.Lframe0
 3637              		.4byte	.LFB9
 3638              		.4byte	.LFE9-.LFB9
 3639              		.byte	0x4
 3640 0000 00000000 		.4byte	.LCFI3-.LFB9
 3641              		.byte	0xd
 3642              		.uleb128 0xc
 3643              		.byte	0x4
 3644              		.4byte	.LCFI4-.LCFI3
 3645              		.byte	0x8e
 3646              		.uleb128 0x2
 3647 0000 00000000 		.byte	0x8d
 3648              		.uleb128 0x3
 3649              		.byte	0x8b
 3650              		.uleb128 0x4
 3651              		.byte	0x4
 3652              		.4byte	.LCFI5-.LCFI4
 3653              		.byte	0xc
 3654 0000 0000D07F 		.uleb128 0xb
 3655              		.uleb128 0x4
 3656              		.align	2
 3657              	.LEFDE2:
 3658              	.LSFDE4:
 3659              		.4byte	.LEFDE4-.LASFDE4
 3660              	.LASFDE4:
 3661 0000 0010D07F 		.4byte	.Lframe0
 3662              		.4byte	.LFB10
 3663              		.4byte	.LFE10-.LFB10
 3664              		.byte	0x4
 3665              		.4byte	.LCFI6-.LFB10
 3666              		.byte	0xd
 3667              		.uleb128 0xc
 3668 0000 00000000 		.byte	0x4
 3669              		.4byte	.LCFI7-.LCFI6
 3670              		.byte	0x8e
 3671              		.uleb128 0x2
 3672              		.byte	0x8d
 3673              		.uleb128 0x3
 3674              		.byte	0x8b
 3675 0000 00000000 		.uleb128 0x4
 3676              		.byte	0x4
 3677              		.4byte	.LCFI8-.LCFI7
 3678              		.byte	0xc
 3679              		.uleb128 0xb
 3680              		.uleb128 0x4
 3681              		.align	2
 3682 0000 00000000 	.LEFDE4:
 3683              	.LSFDE6:
 3684              		.4byte	.LEFDE6-.LASFDE6
 4548              		.4byte	.LVL5
DEFINED SYMBOLS
                            *ABS*:00000000 mci.c
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:14     .text.MCI_TXEnable:00000000 MCI_TXEnable
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:21     .text.MCI_TXEnable:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:51     .text.MCI_TXDisable:00000000 MCI_TXDisable
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:57     .text.MCI_TXDisable:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:87     .text.MCI_RXEnable:00000000 MCI_RXEnable
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:93     .text.MCI_RXEnable:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:123    .text.MCI_RXDisable:00000000 MCI_RXDisable
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:129    .text.MCI_RXDisable:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:159    .text.MCI_IRQHandler:00000000 MCI_IRQHandler
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:165    .text.MCI_IRQHandler:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:554    .text.MCI_IRQHandler:00000308 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3562   .bss.DataCRCErrCount:00000000 DataCRCErrCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3569   .bss.DataTimeoutErrCount:00000000 DataTimeoutErrCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3576   .bss.DataTxUnderrunErrCount:00000000 DataTxUnderrunErrCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3583   .bss.DataRxOverrunErrCount:00000000 DataRxOverrunErrCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3590   .bss.DataStartbitErrCount:00000000 DataStartbitErrCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3499   .bss.MCI_DataErrorProcess_count:00000000 MCI_DataErrorProcess_count
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3604   .bss.DataBlockEndCount:00000000 DataBlockEndCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3611   .bss.MCI_Block_End_Flag:00000000 MCI_Block_End_Flag
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3506   .bss.MCI_DATA_END_InterruptService_count:00000000 MCI_DATA_END_InterruptService_count
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3527   .bss.CmdCRCErrCount:00000000 CmdCRCErrCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3534   .bss.CmdTimeoutErrCount:00000000 CmdTimeoutErrCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3541   .bss.CmdRespEndCount:00000000 CmdRespEndCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3548   .bss.CmdSentCount:00000000 CmdSentCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3555   .bss.CmdActiveCount:00000000 CmdActiveCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3520   .bss.MCI_CmdProcess_count:00000000 MCI_CmdProcess_count
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3597   .bss.DataEndCount:00000000 DataEndCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3632   .bss.DataFIFOCount:00000000 DataFIFOCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3513   .bss.MCI_FIFOInterruptService_count:00000000 MCI_FIFOInterruptService_count
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3618   .bss.DataTxActiveCount:00000000 DataTxActiveCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3625   .bss.DataRxActiveCount:00000000 DataRxActiveCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:580    .text.MCI_Set_MCIClock:00000000 MCI_Set_MCIClock
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:586    .text.MCI_Set_MCIClock:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:645    .text.MCI_SendCmd:00000000 MCI_SendCmd
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:651    .text.MCI_SendCmd:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:751    .text.MCI_GetCmdResp:00000000 MCI_GetCmdResp
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:757    .text.MCI_GetCmdResp:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:902    .text.MCI_Go_Idle_State:00000000 MCI_Go_Idle_State
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:907    .text.MCI_Go_Idle_State:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:953    .text.MCI_Send_ACMD:00000000 MCI_Send_ACMD
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:958    .text.MCI_Send_ACMD:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1042   .text.MCI_Send_ACMD:000000c4 $d
                            *COM*:00000004 MCI_CardType
                            *COM*:00000004 CardRCA
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1050   .text.MCI_CardInit:00000000 MCI_CardInit
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1055   .text.MCI_CardInit:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1376   .text.MCI_CardInit:000002b0 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1383   .text.MCI_Check_CID:00000000 MCI_Check_CID
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1388   .text.MCI_Check_CID:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1453   .text.MCI_Set_Address:00000000 MCI_Set_Address
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1458   .text.MCI_Set_Address:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1536   .text.MCI_Set_Address:000000c0 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1544   .text.MCI_Send_CSD:00000000 MCI_Send_CSD
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1550   .text.MCI_Send_CSD:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1674   .text.MCI_Send_CSD:00000104 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1682   .text.MCI_Select_Card:00000000 MCI_Select_Card
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1687   .text.MCI_Select_Card:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1854   .text.MCI_Select_Card:00000198 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1862   .text.MCI_Send_Status:00000000 MCI_Send_Status
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1867   .text.MCI_Send_Status:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1934   .text.MCI_Send_Status:00000098 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1942   .text.MCI_CheckStatus:00000000 MCI_CheckStatus
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1947   .text.MCI_CheckStatus:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1983   .text.MCI_Set_BlockLen:00000000 MCI_Set_BlockLen
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:1989   .text.MCI_Set_BlockLen:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2070   .text.MCI_Send_ACMD_Bus_Width:00000000 MCI_Send_ACMD_Bus_Width
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2076   .text.MCI_Send_ACMD_Bus_Width:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2151   .text.SD_Set_BusWidth:00000000 SD_Set_BusWidth
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2157   .text.SD_Set_BusWidth:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2232   .text.MCI_Send_Stop:00000000 MCI_Send_Stop
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2237   .text.MCI_Send_Stop:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2315   .text.MCI_Power_Off:00000000 MCI_Power_Off
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2320   .text.MCI_Power_Off:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2359   .text.MCI_Sd_Status:00000000 MCI_Sd_Status
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2364   .text.MCI_Sd_Status:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2561   .text.MCI_Sd_Status:000001d8 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3681   .bss.SDStatRead:00000000 SDStatRead
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2570   .text.MCI_Read_Block:00000000 MCI_Read_Block
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2576   .text.MCI_Read_Block:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2795   .text.MCI_Read_Block:000001dc $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2803   .text.MCI_Write_Block:00000000 MCI_Write_Block
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:2809   .text.MCI_Write_Block:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3020   .text.MCI_Write_Block:000001e0 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3028   .text.MCI_Write_Multiple_Block:00000000 MCI_Write_Multiple_Block
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3034   .text.MCI_Write_Multiple_Block:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3309   .text.MCI_Write_Multiple_Block:00000244 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3317   .text.MCI_Init:00000000 MCI_Init
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3322   .text.MCI_Init:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3491   .text.MCI_Init:000001c0 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3639   .bss.DataRxFIFOCount:00000000 DataRxFIFOCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3646   .bss.DataTxFIFOCount:00000000 DataTxFIFOCount
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3653   .data.WriteBlock:00000000 WriteBlock
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3654   .data.WriteBlock:00000000 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3660   .data.ReadBlock:00000000 ReadBlock
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3661   .data.ReadBlock:00000000 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3667   .bss.TXBlockCounter:00000000 TXBlockCounter
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3674   .bss.RXBlockCounter:00000000 RXBlockCounter
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:3687   .debug_frame:00000000 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccDEpdde.s:4552   .debug_loc:00000000 $d

UNDEFINED SYMBOLS
DMA_Move
memcpy
install_irq
