
UAC_MAIN.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000057a4  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000004c  40000000  000057a4  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006a8  4000004c  000057f0  0001004c  2**2
                  ALLOC
  3 .bss.takeSnapshot 00000004  400006f4  00005e98  0001004c  2**2
                  ALLOC
  4 .bss.startRecording 00000004  400006f8  00005e9c  0001004c  2**2
                  ALLOC
  5 .bss.stopRecording 00000004  400006fc  00005ea0  0001004c  2**2
                  ALLOC
  6 .bss.FatFs    00000004  40000700  00005ea4  0001004c  2**2
                  ALLOC
  7 .bss.fsid     00000002  40000704  00005ea8  0001004c  2**1
                  ALLOC
  8 .bss.Timer2   00000004  40000708  00005eac  0001004c  2**2
                  ALLOC
  9 .bss.CardType 00000004  4000070c  00005eb0  0001004c  2**2
                  ALLOC
 10 .bss.csd      00000010  40000710  00005eb4  0001004c  2**0
                  ALLOC
 11 .bss.sd_status 00000010  40000720  00005ec4  0001004c  2**0
                  ALLOC
 12 .bss.MCI_DataErrorProcess_count 00000004  40000730  00005ed4  0001004c  2**2
                  ALLOC
 13 .bss.MCI_DATA_END_InterruptService_count 00000004  40000734  00005ed8  0001004c  2**2
                  ALLOC
 14 .bss.MCI_FIFOInterruptService_count 00000004  40000738  00005edc  0001004c  2**2
                  ALLOC
 15 .bss.MCI_CmdProcess_count 00000004  4000073c  00005ee0  0001004c  2**2
                  ALLOC
 16 .bss.CmdCRCErrCount 00000004  40000740  00005ee4  0001004c  2**2
                  ALLOC
 17 .bss.CmdTimeoutErrCount 00000004  40000744  00005ee8  0001004c  2**2
                  ALLOC
 18 .bss.CmdRespEndCount 00000004  40000748  00005eec  0001004c  2**2
                  ALLOC
 19 .bss.CmdSentCount 00000004  4000074c  00005ef0  0001004c  2**2
                  ALLOC
 20 .bss.CmdActiveCount 00000004  40000750  00005ef4  0001004c  2**2
                  ALLOC
 21 .bss.DataCRCErrCount 00000004  40000754  00005ef8  0001004c  2**2
                  ALLOC
 22 .bss.DataTimeoutErrCount 00000004  40000758  00005efc  0001004c  2**2
                  ALLOC
 23 .bss.DataTxUnderrunErrCount 00000004  4000075c  00005f00  0001004c  2**2
                  ALLOC
 24 .bss.DataRxOverrunErrCount 00000004  40000760  00005f04  0001004c  2**2
                  ALLOC
 25 .bss.DataStartbitErrCount 00000004  40000764  00005f08  0001004c  2**2
                  ALLOC
 26 .bss.DataEndCount 00000004  40000768  00005f0c  0001004c  2**2
                  ALLOC
 27 .bss.DataBlockEndCount 00000004  4000076c  00005f10  0001004c  2**2
                  ALLOC
 28 .bss.MCI_Block_End_Flag 00000004  40000770  00005f14  0001004c  2**2
                  ALLOC
 29 .bss.DataTxActiveCount 00000004  40000774  00005f18  0001004c  2**2
                  ALLOC
 30 .bss.DataRxActiveCount 00000004  40000778  00005f1c  0001004c  2**2
                  ALLOC
 31 .bss.DataFIFOCount 00000004  4000077c  00005f20  0001004c  2**2
                  ALLOC
 32 .bss.SDStatRead 00000004  40000780  00005f24  0001004c  2**2
                  ALLOC
 33 .bss.DMAErrCount.1312 00000004  40000784  00005f28  0001004c  2**2
                  ALLOC
 34 .bss.DMATCCount.1311 00000004  40000788  00005f2c  0001004c  2**2
                  ALLOC
 35 .bss.TxCounter 00000004  4000078c  00005f30  0001004c  2**2
                  ALLOC
 36 .bss.recvI    00000004  40000790  00005f34  0001004c  2**2
                  ALLOC
 37 .bss.AckCounter 00000001  40000794  00005f38  0001004c  2**0
                  ALLOC
 38 .stack        00000800  40000800  00005fa4  0001004c  2**0
                  ALLOC
 39 .comment      0000017a  00000000  00000000  0001004c  2**0
                  CONTENTS, READONLY
 40 .debug_aranges 000006e0  00000000  00000000  000101c8  2**3
                  CONTENTS, READONLY, DEBUGGING
 41 .debug_pubnames 00000d4a  00000000  00000000  000108a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 42 .debug_info   000052c4  00000000  00000000  000115f2  2**0
                  CONTENTS, READONLY, DEBUGGING
 43 .debug_abbrev 000017e6  00000000  00000000  000168b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 44 .debug_line   00002646  00000000  00000000  0001809c  2**0
                  CONTENTS, READONLY, DEBUGGING
 45 .debug_frame  00001530  00000000  00000000  0001a6e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 46 .debug_str    00001424  00000000  00000000  0001bc14  2**0
                  CONTENTS, READONLY, DEBUGGING
 47 .debug_loc    00004c72  00000000  00000000  0001d038  2**0
                  CONTENTS, READONLY, DEBUGGING
 48 .ARM.attributes 00000010  00000000  00000000  00021caa  2**0
                  CONTENTS, READONLY
 49 .debug_ranges 00000a08  00000000  00000000  00021cba  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_boot>:
_boot:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
       0:	ea000012 	b	50 <_mainCRTStartup>
        ldr   pc,_undf                  // undefined - _undf
       4:	e59ff014 	ldr	pc, [pc, #20]	; 20 <_undf>
        ldr   pc,_swi                   // SWI - _swi
       8:	e59ff014 	ldr	pc, [pc, #20]	; 24 <_swi>
        ldr   pc,_pabt                  // program abort - _pabt
       c:	e59ff014 	ldr	pc, [pc, #20]	; 28 <_pabt>
        ldr   pc,_dabt                  // data abort - _dabt
      10:	e59ff014 	ldr	pc, [pc, #20]	; 2c <_dabt>
        nop                             // reserved
      14:	e1a00000 	nop			(mov r0,r0)
        ldr   pc,[pc,#-0x120]           // IRQ - read the VIC
      18:	e51ff120 	ldr	pc, [pc, #-288]	; ffffff00 <_end+0xbfffef00>
        ldr   pc,_fiq                   // FIQ - _fiq
      1c:	e59ff010 	ldr	pc, [pc, #16]	; 34 <_fiq>

00000020 <_undf>:
      20:	00000038 	.word	0x00000038

00000024 <_swi>:
      24:	0000003c 	.word	0x0000003c

00000028 <_pabt>:
      28:	00000040 	.word	0x00000040

0000002c <_dabt>:
      2c:	00000044 	.word	0x00000044

00000030 <_irq>:
      30:	00000048 	.word	0x00000048

00000034 <_fiq>:
      34:	0000004c 	.word	0x0000004c

00000038 <__undf>:
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
      38:	eafffffe 	b	38 <__undf>

0000003c <__swi>:
__swi:  b     .                         // SWI
      3c:	eafffffe 	b	3c <__swi>

00000040 <__pabt>:
__pabt: b     .                         // program abort
      40:	eafffffe 	b	40 <__pabt>

00000044 <__dabt>:
__dabt: b     .                         // data abort
      44:	eafffffe 	b	44 <__dabt>

00000048 <__irq>:
__irq:  b     .                         // IRQ
      48:	eafffffe 	b	48 <__irq>

0000004c <__fiq>:
__fiq:  b     .                         // FIQ
      4c:	eafffffe 	b	4c <__fiq>

00000050 <_mainCRTStartup>:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack
      50:	e59f00c0 	ldr	r0, [pc, #192]	; 118 <_reset+0x4>
        msr   CPSR_c,#MODE_UND|I_BIT|F_BIT // Undefined Instruction Mode
      54:	e321f0db 	msr	CPSR_c, #219	; 0xdb
        mov   sp,r0
      58:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#UND_STACK_SIZE
      5c:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_ABT|I_BIT|F_BIT // Abort Mode
      60:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
        mov   sp,r0
      64:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#ABT_STACK_SIZE
      68:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_FIQ|I_BIT|F_BIT // FIQ Mode
      6c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
        mov   sp,r0
      70:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#FIQ_STACK_SIZE
      74:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_IRQ|I_BIT|F_BIT // IRQ Mode
      78:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
        mov   sp,r0
      7c:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#IRQ_STACK_SIZE
      80:	e2400080 	sub	r0, r0, #128	; 0x80
        msr   CPSR_c,#MODE_SVC|I_BIT|F_BIT // Supervisor Mode
      84:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
        mov   sp,r0
      88:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#SVC_STACK_SIZE
      8c:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_SYS|I_BIT|F_BIT // System Mode
      90:	e321f0df 	msr	CPSR_c, #223	; 0xdf
        mov   sp,r0
      94:	e1a0d000 	mov	sp, r0

// Clear .bss
// ----------
        mov   r0,#0                     // get a zero
      98:	e3a00000 	mov	r0, #0	; 0x0
        ldr   r1,=__bss_start           // -> bss start
      9c:	e59f1078 	ldr	r1, [pc, #120]	; 11c <_reset+0x8>
        ldr   r2,=__bss_end__           // -> bss end
      a0:	e59f2078 	ldr	r2, [pc, #120]	; 120 <_reset+0xc>
2:      cmp   r1,r2                     // check if data to clear
      a4:	e1510002 	cmp	r1, r2
        strlo r0,[r1],#4                // clear 4 bytes
      a8:	34810004 	strcc	r0, [r1], #4
        blo   2b                        // loop until done
      ac:	3afffffc 	bcc	a4 <IRQ_STACK_SIZE+0x24>

// Copy initialized data to its execution address in RAM
// -----------------------------------------------------
#ifdef ROM_RUN
        ldr   r1,=_etext                // -> ROM data start
      b0:	e59f106c 	ldr	r1, [pc, #108]	; 124 <_reset+0x10>
        ldr   r2,=_data                 // -> data start
      b4:	e59f206c 	ldr	r2, [pc, #108]	; 128 <_reset+0x14>
        ldr   r3,=_edata                // -> end of data
      b8:	e59f306c 	ldr	r3, [pc, #108]	; 12c <_reset+0x18>
1:      cmp   r2,r3                     // check if data to move
      bc:	e1520003 	cmp	r2, r3
        ldrlo r0,[r1],#4                // copy it
      c0:	34910004 	ldrcc	r0, [r1], #4
        strlo r0,[r2],#4
      c4:	34820004 	strcc	r0, [r2], #4
        blo   1b                        // loop until done
      c8:	3afffffb 	bcc	bc <IRQ_STACK_SIZE+0x3c>
   Call C++ constructors (for objects in "global scope")
   ctor loop added by Martin Thomas 4/2005 
   based on a Anglia Design example-application for ST ARM
*/

		LDR 	r0, =__ctors_start__
      cc:	e59f005c 	ldr	r0, [pc, #92]	; 130 <_reset+0x1c>
		LDR 	r1, =__ctors_end__
      d0:	e59f105c 	ldr	r1, [pc, #92]	; 134 <_reset+0x20>

000000d4 <ctor_loop>:
ctor_loop:
		CMP 	r0, r1
      d4:	e1500001 	.word	0xe1500001
		BEQ 	ctor_end
      d8:	0a000005 	.word	0x0a000005
		LDR 	r2, [r0], #4
      dc:	e4902004 	.word	0xe4902004
		STMFD 	sp!, {r0-r1}
      e0:	e92d0003 	.word	0xe92d0003
		MOV 	lr, pc
      e4:	e1a0e00f 	.word	0xe1a0e00f
		MOV 	pc, r2
      e8:	e1a0f002 	.word	0xe1a0f002
		LDMFD 	sp!, {r0-r1}
      ec:	e8bd0003 	.word	0xe8bd0003
		B 		ctor_loop
      f0:	eafffff7 	.word	0xeafffff7

000000f4 <ctor_end>:
ctor_end:

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
      f4:	e3a00000 	.word	0xe3a00000
        mov   r1,r0
      f8:	e1a01000 	.word	0xe1a01000
        mov   r2,r0
      fc:	e1a02000 	.word	0xe1a02000
        mov   fp,r0                     // null frame pointer
     100:	e1a0b000 	.word	0xe1a0b000
        mov   r7,r0                     // null frame pointer for thumb
     104:	e1a07000 	.word	0xe1a07000
        ldr   r10,=main
     108:	e59fa028 	.word	0xe59fa028
        mov   lr,pc
     10c:	e1a0e00f 	.word	0xe1a0e00f

/* Enter the C code, use BX instruction so as to never return */
/* use BLX (?) main if you want to use c++ destructors below */

        bx    r10                       // enter main()
     110:	e12fff1a 	.word	0xe12fff1a

00000114 <_reset>:
        ldr   r0,=(1<<23)               // P23
        str   r0,[r1,#PIO_PER_OFF]      // make sure pin is contolled by PIO
        str   r0,[r1,#PIO_CODR_OFF]     // set the pin low
        str   r0,[r1,#PIO_OER_OFF]      // make it an output
#endif
        b     .                         // loop until reset
     114:	eafffffe 	.word	0xeafffffe
     118:	40001000 	.word	0x40001000
     11c:	4000004c 	.word	0x4000004c
     120:	40000798 	.word	0x40000798
     124:	000057a4 	.word	0x000057a4
     128:	40000000 	.word	0x40000000
     12c:	4000004c 	.word	0x4000004c
     130:	000057a4 	.word	0x000057a4
     134:	000057a4 	.word	0x000057a4
     138:	000001e8 	.word	0x000001e8

0000013c <SRAMInit>:
int takeSnapshot=0;
int startRecording=0;
int stopRecording=0;

void SRAMInit(){
	  PINSEL6 = 0x55555555;
     13c:	e3a02c55 	mov	r2, #21760	; 0x5500
     140:	e2822055 	add	r2, r2, #85	; 0x55
     144:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
     148:	e281190b 	add	r1, r1, #180224	; 0x2c000
     14c:	e1822802 	orr	r2, r2, r2, lsl #16
     150:	e5812018 	str	r2, [r1, #24]
//Global flags that are set by the external interrupt
int takeSnapshot=0;
int startRecording=0;
int stopRecording=0;

void SRAMInit(){
     154:	e1a0c00d 	mov	ip, sp
     158:	e92dd800 	push	{fp, ip, lr, pc}
     15c:	e24cb004 	sub	fp, ip, #4	; 0x4
	  PINSEL6 = 0x55555555;
	  PINSEL8 = PINSEL8 & 0x00000000;
     160:	e3a0c000 	mov	ip, #0	; 0x0
     164:	e5913020 	ldr	r3, [r1, #32]
     168:	e581c020 	str	ip, [r1, #32]
	  PINSEL8 = PINSEL8 | 0x55555555; 	  //Set all 32:0 pins to 01 for address P4[0] - P4[15]
     16c:	e5913020 	ldr	r3, [r1, #32]
     170:	e1833002 	orr	r3, r3, r2
     174:	e5813020 	str	r3, [r1, #32]

	  PINSEL9 = PINSEL9 & 0x0F00FF00;	  //Set 7:0 pins to 01 for address P4[16] - P4[19]
     178:	e3a0340f 	mov	r3, #251658240	; 0xf000000
     17c:	e5912024 	ldr	r2, [r1, #36]
     180:	e2833cff 	add	r3, r3, #65280	; 0xff00
     184:	e0022003 	and	r2, r2, r3
     188:	e5812024 	str	r2, [r1, #36]
	  PINSEL9 = PINSEL9 | 0x50550055;
     18c:	e3a03205 	mov	r3, #1342177280	; 0x50000000
     190:	e5910024 	ldr	r0, [r1, #36]
     194:	e2833855 	add	r3, r3, #5570560	; 0x550000
     198:	e2833055 	add	r3, r3, #85	; 0x55
     19c:	e1800003 	orr	r0, r0, r3

	  EMC_CTRL &= ~2;					// select normal memory map (enables CS0 operation)
     1a0:	e3a02a09 	mov	r2, #36864	; 0x9000
	  PINSEL6 = 0x55555555;
	  PINSEL8 = PINSEL8 & 0x00000000;
	  PINSEL8 = PINSEL8 | 0x55555555; 	  //Set all 32:0 pins to 01 for address P4[0] - P4[15]

	  PINSEL9 = PINSEL9 & 0x0F00FF00;	  //Set 7:0 pins to 01 for address P4[16] - P4[19]
	  PINSEL9 = PINSEL9 | 0x50550055;
     1a4:	e5810024 	str	r0, [r1, #36]

	  EMC_CTRL &= ~2;					// select normal memory map (enables CS0 operation)
     1a8:	e2422001 	sub	r2, r2, #1	; 0x1
     1ac:	e1822a82 	orr	r2, r2, r2, lsl #21
     1b0:	e5123fff 	ldr	r3, [r2, #-4095]
     1b4:	e3c33002 	bic	r3, r3, #2	; 0x2
     1b8:	e5023fff 	str	r3, [r2, #-4095]
	  EMC_STA_CFG0 = 0x81;
	  EMC_STA_WAITWEN0 = 0x0;			// Keil had 2
	  EMC_STA_WAITOEN0 = 0x0;			//          3
	  EMC_STA_WAITRD0 = 0x1;			//          2
	  EMC_STA_WAITPAGE0 = 0x2;
     1bc:	e3a00002 	mov	r0, #2	; 0x2

	  PINSEL9 = PINSEL9 & 0x0F00FF00;	  //Set 7:0 pins to 01 for address P4[16] - P4[19]
	  PINSEL9 = PINSEL9 | 0x50550055;

	  EMC_CTRL &= ~2;					// select normal memory map (enables CS0 operation)
	  EMC_STA_CFG0 = 0x81;
     1c0:	e3a01081 	mov	r1, #129	; 0x81
	  EMC_STA_WAITWEN0 = 0x0;			// Keil had 2
	  EMC_STA_WAITOEN0 = 0x0;			//          3
	  EMC_STA_WAITRD0 = 0x1;			//          2
     1c4:	e3a03001 	mov	r3, #1	; 0x1

	  PINSEL9 = PINSEL9 & 0x0F00FF00;	  //Set 7:0 pins to 01 for address P4[16] - P4[19]
	  PINSEL9 = PINSEL9 | 0x50550055;

	  EMC_CTRL &= ~2;					// select normal memory map (enables CS0 operation)
	  EMC_STA_CFG0 = 0x81;
     1c8:	e5021dff 	str	r1, [r2, #-3583]
	  EMC_STA_WAITWEN0 = 0x0;			// Keil had 2
     1cc:	e502cdfb 	str	ip, [r2, #-3579]
	  EMC_STA_WAITOEN0 = 0x0;			//          3
     1d0:	e502cdf7 	str	ip, [r2, #-3575]
	  EMC_STA_WAITRD0 = 0x1;			//          2
     1d4:	e5023df3 	str	r3, [r2, #-3571]
	  EMC_STA_WAITPAGE0 = 0x2;
     1d8:	e5020def 	str	r0, [r2, #-3567]
	  EMC_STA_WAITWR0 = 0x0;			//          2
     1dc:	e502cdeb 	str	ip, [r2, #-3563]
	  EMC_STA_WAITTURN0 = 0x2;
     1e0:	e5020de7 	str	r0, [r2, #-3559]
}
     1e4:	e89da800 	ldm	sp, {fp, sp, pc}

000001e8 <main>:
	enable_interrupt();
	initSDCard();
}

int main (void)
{
     1e8:	e1a0c00d 	mov	ip, sp
     1ec:	e92ddff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
     1f0:	e24cb004 	sub	fp, ip, #4	; 0x4


static
void IoInit (void)
{
	systemInit();
     1f4:	eb000108 	bl	61c <systemInit>
	uart0Init(B115200 ,UART_8N1 , UART_FIFO_8);
     1f8:	e3a01003 	mov	r1, #3	; 0x3
     1fc:	e3a02081 	mov	r2, #129	; 0x81
     200:	e3a0000a 	mov	r0, #10	; 0xa
     204:	eb000137 	bl	6e8 <uart0Init>
	SPIInit();		/* initialize SPI 0 */
     208:	eb0011ea 	bl	49b8 <SPIInit>
	setupCamera();
     20c:	eb001385 	bl	5028 <setupCamera>
	init_VIC();
     210:	eb000170 	bl	7d8 <init_VIC>
	EINTInit();
     214:	eb0013c5 	bl	5130 <EINTInit>
	SRAMInit();
     218:	ebffffc7 	bl	13c <SRAMInit>

#ifndef __thumb
static inline uint32_t __get_CPSR(void)
{
	uint32_t temp;
	asm volatile ("mrs %0,CPSR":"=r" (temp):) ;
     21c:	e10f3000 	mrs	r3, CPSR
	return temp;
}

static inline void __set_CPSR(uint32_t save_cpsr)
{
	asm volatile (" msr CPSR_cxsf,%0"::"r"(save_cpsr) );
     220:	e3c330c0 	bic	r3, r3, #192	; 0xc0
     224:	e12ff003 	msr	CPSR_fsxc, r3
	enable_interrupt();
	initSDCard();
     228:	eb0011d9 	bl	4994 <initSDCard>
}

int main (void)
{
	IoInit();
	xprintf("HelloWorld\r\n");
     22c:	e59f00f0 	ldr	r0, [pc, #240]	; 324 <main+0x13c>
     230:	eb00009a 	bl	4a0 <xprintf>
     234:	e59fa0ec 	ldr	sl, [pc, #236]	; 328 <main+0x140>
     238:	e3a05000 	mov	r5, #0	; 0x0
     23c:	e59f60e8 	ldr	r6, [pc, #232]	; 32c <main+0x144>
     240:	e59f70e8 	ldr	r7, [pc, #232]	; 330 <main+0x148>
	int size=10000;
	int i=0;
	while(1)
	{
		if(takeSnapshot)
     244:	e1a0900a 	mov	r9, sl
			getSnapshot();
			size=getPic();
			xprintf("\nsize: %d\r",size);
			writeToSDCard(size);
			closeFile();
			takeSnapshot=0;
     248:	e1a08005 	mov	r8, r5
	xprintf("HelloWorld\r\n");
	int size=10000;
	int i=0;
	while(1)
	{
		if(takeSnapshot)
     24c:	e59a3000 	ldr	r3, [sl]
     250:	e3530000 	cmp	r3, #0	; 0x0
     254:	1a000009 	bne	280 <main+0x98>
			writeToSDCard(size);
			closeFile();
			takeSnapshot=0;
			xprintf("\nend\r\n");
		}
		if(startRecording)
     258:	e5973000 	ldr	r3, [r7]
     25c:	e3530000 	cmp	r3, #0	; 0x0
     260:	1a000018 	bne	2c8 <main+0xe0>
			closeFile();
			startRecording=0;
			stopRecording=0;
			xprintf("\nimages stored=%d\r\n",i);
		}
		if(startRecording==0 && stopRecording)
     264:	e5963000 	ldr	r3, [r6]
     268:	e3530000 	cmp	r3, #0	; 0x0
			stopRecording=0;
     26c:	159f30b8 	ldrne	r3, [pc, #184]	; 32c <main+0x144>
     270:	15838000 	strne	r8, [r3]
	xprintf("HelloWorld\r\n");
	int size=10000;
	int i=0;
	while(1)
	{
		if(takeSnapshot)
     274:	e59a3000 	ldr	r3, [sl]
     278:	e3530000 	cmp	r3, #0	; 0x0
     27c:	0afffff5 	beq	258 <main+0x70>
		{
			xprintf("\ntake snapshot\r");
     280:	e59f00ac 	ldr	r0, [pc, #172]	; 334 <main+0x14c>
     284:	eb000085 	bl	4a0 <xprintf>
			SDOpenSnapshot();
     288:	eb0011b2 	bl	4958 <SDOpenSnapshot>
			getSnapshot();
     28c:	eb0012b5 	bl	4d68 <getSnapshot>
			size=getPic();
     290:	eb00126a 	bl	4c40 <getPic>
			xprintf("\nsize: %d\r",size);
     294:	e1a01000 	mov	r1, r0
		if(takeSnapshot)
		{
			xprintf("\ntake snapshot\r");
			SDOpenSnapshot();
			getSnapshot();
			size=getPic();
     298:	e1a04000 	mov	r4, r0
			xprintf("\nsize: %d\r",size);
     29c:	e59f0094 	ldr	r0, [pc, #148]	; 338 <main+0x150>
     2a0:	eb00007e 	bl	4a0 <xprintf>
			writeToSDCard(size);
     2a4:	e1a00004 	mov	r0, r4
     2a8:	eb001147 	bl	47cc <writeToSDCard>
			closeFile();
     2ac:	eb001183 	bl	48c0 <closeFile>
			takeSnapshot=0;
			xprintf("\nend\r\n");
     2b0:	e59f0084 	ldr	r0, [pc, #132]	; 33c <main+0x154>
			getSnapshot();
			size=getPic();
			xprintf("\nsize: %d\r",size);
			writeToSDCard(size);
			closeFile();
			takeSnapshot=0;
     2b4:	e5898000 	str	r8, [r9]
			xprintf("\nend\r\n");
     2b8:	eb000078 	bl	4a0 <xprintf>
		}
		if(startRecording)
     2bc:	e5973000 	ldr	r3, [r7]
     2c0:	e3530000 	cmp	r3, #0	; 0x0
     2c4:	0affffe6 	beq	264 <main+0x7c>
		{
			xprintf("\nstartRecording\r");
     2c8:	e59f0070 	ldr	r0, [pc, #112]	; 340 <main+0x158>
     2cc:	eb000073 	bl	4a0 <xprintf>
			SDOpenVideo();
     2d0:	eb001186 	bl	48f0 <SDOpenVideo>
			while(stopRecording!=1)
     2d4:	e5963000 	ldr	r3, [r6]
     2d8:	e3530001 	cmp	r3, #1	; 0x1
     2dc:	0a000006 	beq	2fc <main+0x114>
			{
				getSnapshot();
     2e0:	eb0012a0 	bl	4d68 <getSnapshot>
				size=getPic();
     2e4:	eb001255 	bl	4c40 <getPic>
				writeToSDCard(size);
     2e8:	eb001137 	bl	47cc <writeToSDCard>
		}
		if(startRecording)
		{
			xprintf("\nstartRecording\r");
			SDOpenVideo();
			while(stopRecording!=1)
     2ec:	e5963000 	ldr	r3, [r6]
     2f0:	e3530001 	cmp	r3, #1	; 0x1
			{
				getSnapshot();
				size=getPic();
				writeToSDCard(size);
				i++;
     2f4:	e2855001 	add	r5, r5, #1	; 0x1
		}
		if(startRecording)
		{
			xprintf("\nstartRecording\r");
			SDOpenVideo();
			while(stopRecording!=1)
     2f8:	1afffff8 	bne	2e0 <main+0xf8>
				getSnapshot();
				size=getPic();
				writeToSDCard(size);
				i++;
			}
			closeFile();
     2fc:	eb00116f 	bl	48c0 <closeFile>
			startRecording=0;
			stopRecording=0;
			xprintf("\nimages stored=%d\r\n",i);
     300:	e59f003c 	ldr	r0, [pc, #60]	; 344 <main+0x15c>
     304:	e1a01005 	mov	r1, r5
				size=getPic();
				writeToSDCard(size);
				i++;
			}
			closeFile();
			startRecording=0;
     308:	e5878000 	str	r8, [r7]
			stopRecording=0;
     30c:	e5868000 	str	r8, [r6]
			xprintf("\nimages stored=%d\r\n",i);
     310:	eb000062 	bl	4a0 <xprintf>
		}
		if(startRecording==0 && stopRecording)
     314:	e5973000 	ldr	r3, [r7]
     318:	e3530000 	cmp	r3, #0	; 0x0
     31c:	1affffca 	bne	24c <main+0x64>
     320:	eaffffcf 	b	264 <main+0x7c>
     324:	00005644 	.word	0x00005644
     328:	400006f4 	.word	0x400006f4
     32c:	400006fc 	.word	0x400006fc
     330:	400006f8 	.word	0x400006f8
     334:	00005654 	.word	0x00005654
     338:	00005664 	.word	0x00005664
     33c:	00005670 	.word	0x00005670
     340:	00005678 	.word	0x00005678
     344:	0000568c 	.word	0x0000568c

00000348 <xitoa>:




void xitoa (signed long val, signed char radix, signed char len)
{
     348:	e1a0c00d 	mov	ip, sp
     34c:	e92dddf0 	push	{r4, r5, r6, r7, r8, sl, fp, ip, lr, pc}
     350:	e1a01c01 	lsl	r1, r1, #24
     354:	e24cb004 	sub	fp, ip, #4	; 0x4
     358:	e24dd014 	sub	sp, sp, #20	; 0x14
     35c:	e1a02c02 	lsl	r2, r2, #24
	BYTE c, r, sgn = 0, pad = ' ';
	BYTE s[20], i = 0;
	DWORD v;


	if (radix < 0) {
     360:	e1b01c41 	asrs	r1, r1, #24




void xitoa (signed long val, signed char radix, signed char len)
{
     364:	e1a07c42 	asr	r7, r2, #24
	BYTE c, r, sgn = 0, pad = ' ';
	BYTE s[20], i = 0;
	DWORD v;


	if (radix < 0) {
     368:	4a000037 	bmi	44c <xitoa+0x104>
		radix = -radix;
		if (val < 0) {
			val = -val;
     36c:	e3a0a000 	mov	sl, #0	; 0x0
			sgn = '-';
		}
	}
	v = val;
	r = radix;
	if (len < 0) {
     370:	e3570000 	cmp	r7, #0	; 0x0
		len = -len;
     374:	b2673000 	rsblt	r3, r7, #0	; 0x0
     378:	b1a03c03 	lsllt	r3, r3, #24
     37c:	b1a07c43 	asrlt	r7, r3, #24
			sgn = '-';
		}
	}
	v = val;
	r = radix;
	if (len < 0) {
     380:	a3a08020 	movge	r8, #32	; 0x20
		len = -len;
     384:	b3a08030 	movlt	r8, #48	; 0x30
		pad = '0';
	}
	if (len > 20) return;
     388:	e3570014 	cmp	r7, #20	; 0x14
     38c:	ca00002c 	bgt	444 <xitoa+0xfc>
		if (val < 0) {
			val = -val;
			sgn = '-';
		}
	}
	v = val;
     390:	e1a05000 	mov	r5, r0
     394:	e20160ff 	and	r6, r1, #255	; 0xff
     398:	e3a04000 	mov	r4, #0	; 0x0
		len = -len;
		pad = '0';
	}
	if (len > 20) return;
	do {
		c = (BYTE)(v % r);
     39c:	e1a00005 	mov	r0, r5
     3a0:	e1a01006 	mov	r1, r6
     3a4:	eb001472 	bl	5574 <__umodsi3>
     3a8:	e1a02000 	mov	r2, r0
     3ac:	e20220ff 	and	r2, r2, #255	; 0xff
		if (c >= 10) c += 7;
		c += '0';
		s[i++] = c;
     3b0:	e2843001 	add	r3, r4, #1	; 0x1
     3b4:	e24b1024 	sub	r1, fp, #36	; 0x24
     3b8:	e081c004 	add	ip, r1, r4
		pad = '0';
	}
	if (len > 20) return;
	do {
		c = (BYTE)(v % r);
		if (c >= 10) c += 7;
     3bc:	e3520009 	cmp	r2, #9	; 0x9
		c += '0';
		s[i++] = c;
     3c0:	e20340ff 	and	r4, r3, #255	; 0xff
		pad = '0';
	}
	if (len > 20) return;
	do {
		c = (BYTE)(v % r);
		if (c >= 10) c += 7;
     3c4:	e2823007 	add	r3, r2, #7	; 0x7
     3c8:	820320ff 	andhi	r2, r3, #255	; 0xff
		c += '0';
		s[i++] = c;
     3cc:	e2823030 	add	r3, r2, #48	; 0x30
		v /= r;
     3d0:	e1a00005 	mov	r0, r5
     3d4:	e1a01006 	mov	r1, r6
	if (len > 20) return;
	do {
		c = (BYTE)(v % r);
		if (c >= 10) c += 7;
		c += '0';
		s[i++] = c;
     3d8:	e54c3014 	strb	r3, [ip, #-20]
		v /= r;
     3dc:	eb001420 	bl	5464 <__aeabi_uidiv>
	} while (v);
     3e0:	e2505000 	subs	r5, r0, #0	; 0x0
     3e4:	1affffec 	bne	39c <xitoa+0x54>
	if (sgn) s[i++] = sgn;
     3e8:	e35a0000 	cmp	sl, #0	; 0x0
     3ec:	124b2024 	subne	r2, fp, #36	; 0x24
     3f0:	10823004 	addne	r3, r2, r4
     3f4:	12842001 	addne	r2, r4, #1	; 0x1
     3f8:	120240ff 	andne	r4, r2, #255	; 0xff
     3fc:	1543a014 	strbne	sl, [r3, #-20]
	while (i < len)
     400:	e1570004 	cmp	r7, r4
     404:	da000006 	ble	424 <xitoa+0xdc>
		s[i++] = pad;
     408:	e2843001 	add	r3, r4, #1	; 0x1
     40c:	e24b1024 	sub	r1, fp, #36	; 0x24
     410:	e0812004 	add	r2, r1, r4
     414:	e20340ff 	and	r4, r3, #255	; 0xff
		c += '0';
		s[i++] = c;
		v /= r;
	} while (v);
	if (sgn) s[i++] = sgn;
	while (i < len)
     418:	e1540007 	cmp	r4, r7
		s[i++] = pad;
     41c:	e5428014 	strb	r8, [r2, #-20]
		c += '0';
		s[i++] = c;
		v /= r;
	} while (v);
	if (sgn) s[i++] = sgn;
	while (i < len)
     420:	bafffff8 	blt	408 <xitoa+0xc0>
		s[i++] = pad;
	do
		xputc(s[--i]);
     424:	e2443001 	sub	r3, r4, #1	; 0x1
     428:	e20340ff 	and	r4, r3, #255	; 0xff
     42c:	e24b3024 	sub	r3, fp, #36	; 0x24
     430:	e0832004 	add	r2, r3, r4
     434:	e5520014 	ldrb	r0, [r2, #-20]
     438:	eb0000cd 	bl	774 <uart_put>
	while (i);
     43c:	e3540000 	cmp	r4, #0	; 0x0
     440:	1afffff7 	bne	424 <xitoa+0xdc>
}
     444:	e24bd024 	sub	sp, fp, #36	; 0x24
     448:	e89dadf0 	ldm	sp, {r4, r5, r6, r7, r8, sl, fp, sp, pc}
	BYTE s[20], i = 0;
	DWORD v;


	if (radix < 0) {
		radix = -radix;
     44c:	e2613000 	rsb	r3, r1, #0	; 0x0
		if (val < 0) {
     450:	e3500000 	cmp	r0, #0	; 0x0
	BYTE s[20], i = 0;
	DWORD v;


	if (radix < 0) {
		radix = -radix;
     454:	e1a03c03 	lsl	r3, r3, #24
     458:	e1a01c43 	asr	r1, r3, #24
		if (val < 0) {
			val = -val;
     45c:	b2600000 	rsblt	r0, r0, #0	; 0x0
     460:	b3a0a02d 	movlt	sl, #45	; 0x2d
	DWORD v;


	if (radix < 0) {
		radix = -radix;
		if (val < 0) {
     464:	aaffffc0 	bge	36c <xitoa+0x24>
     468:	eaffffc0 	b	370 <xitoa+0x28>

0000046c <xputs>:




void xputs (const char* str)
{
     46c:	e1a0c00d 	mov	ip, sp
     470:	e92dd810 	push	{r4, fp, ip, lr, pc}
     474:	e1a03000 	mov	r3, r0
	while (*str)
     478:	e5d00000 	ldrb	r0, [r0]
     47c:	e3500000 	cmp	r0, #0	; 0x0




void xputs (const char* str)
{
     480:	e24cb004 	sub	fp, ip, #4	; 0x4
	while (*str)
     484:	089da810 	ldmeq	sp, {r4, fp, sp, pc}
     488:	e1a04003 	mov	r4, r3
		xputc(*str++);
     48c:	eb0000b8 	bl	774 <uart_put>



void xputs (const char* str)
{
	while (*str)
     490:	e5f40001 	ldrb	r0, [r4, #1]!
     494:	e3500000 	cmp	r0, #0	; 0x0
     498:	1afffffb 	bne	48c <xputs+0x20>
     49c:	e89da810 	ldm	sp, {r4, fp, sp, pc}

000004a0 <xprintf>:




void xprintf (const char* str, ...)
{
     4a0:	e1a0c00d 	mov	ip, sp
     4a4:	e92d000f 	push	{r0, r1, r2, r3}
     4a8:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
     4ac:	e24cb014 	sub	fp, ip, #20	; 0x14
     4b0:	e59b5004 	ldr	r5, [fp, #4]
	char d, r, w, s, l;


	va_start(arp, str);

	while ((d = *str++) != 0) {
     4b4:	e5d50000 	ldrb	r0, [r5]
     4b8:	e3500000 	cmp	r0, #0	; 0x0




void xprintf (const char* str, ...)
{
     4bc:	e28b6008 	add	r6, fp, #8	; 0x8
	char d, r, w, s, l;


	va_start(arp, str);

	while ((d = *str++) != 0) {
     4c0:	0a000008 	beq	4e8 <xprintf+0x48>
		if (d != '%') {
     4c4:	e3500025 	cmp	r0, #37	; 0x25
	char d, r, w, s, l;


	va_start(arp, str);

	while ((d = *str++) != 0) {
     4c8:	e2855001 	add	r5, r5, #1	; 0x1
		if (d != '%') {
     4cc:	0a000007 	beq	4f0 <xprintf+0x50>
			xputc(d); continue;
     4d0:	eb0000a7 	bl	774 <uart_put>
     4d4:	e1a04006 	mov	r4, r6
		if (!r) break;
		if (l) {
			xitoa((long)va_arg(arp, long), r, w);
		} else {
			if (r > 0)
				xitoa((unsigned long)va_arg(arp, int), r, w);
     4d8:	e1a06004 	mov	r6, r4
	char d, r, w, s, l;


	va_start(arp, str);

	while ((d = *str++) != 0) {
     4dc:	e5d50000 	ldrb	r0, [r5]
     4e0:	e3500000 	cmp	r0, #0	; 0x0
     4e4:	1afffff6 	bne	4c4 <xprintf+0x24>
				xitoa((long)va_arg(arp, int), r, w);
		}
	}

	va_end(arp);
}
     4e8:	e24bd01c 	sub	sp, fp, #28	; 0x1c
     4ec:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}

	while ((d = *str++) != 0) {
		if (d != '%') {
			xputc(d); continue;
		}
		d = *str++; w = r = s = l = 0;
     4f0:	e1a04005 	mov	r4, r5
     4f4:	e4d40001 	ldrb	r0, [r4], #1
		if (d == '0') {
     4f8:	e3500030 	cmp	r0, #48	; 0x30
			d = *str++; s = 1;
     4fc:	05d50001 	ldrbeq	r0, [r5, #1]
		}
		while ((d >= '0')&&(d <= '9')) {
     500:	e2403030 	sub	r3, r0, #48	; 0x30
		if (d != '%') {
			xputc(d); continue;
		}
		d = *str++; w = r = s = l = 0;
		if (d == '0') {
			d = *str++; s = 1;
     504:	02844001 	addeq	r4, r4, #1	; 0x1
	while ((d = *str++) != 0) {
		if (d != '%') {
			xputc(d); continue;
		}
		d = *str++; w = r = s = l = 0;
		if (d == '0') {
     508:	13a07000 	movne	r7, #0	; 0x0
			d = *str++; s = 1;
     50c:	03a07001 	moveq	r7, #1	; 0x1
		}
		while ((d >= '0')&&(d <= '9')) {
     510:	e3530009 	cmp	r3, #9	; 0x9
     514:	83a03000 	movhi	r3, #0	; 0x0
     518:	81a05004 	movhi	r5, r4
     51c:	81a0c003 	movhi	ip, r3
     520:	8a00000d 	bhi	55c <xprintf+0xbc>
     524:	e3a0c000 	mov	ip, #0	; 0x0
			w += w * 10 + (d - '0');
     528:	e08c1000 	add	r1, ip, r0
			d = *str++;
     52c:	e4d40001 	ldrb	r0, [r4], #1
		d = *str++; w = r = s = l = 0;
		if (d == '0') {
			d = *str++; s = 1;
		}
		while ((d >= '0')&&(d <= '9')) {
			w += w * 10 + (d - '0');
     530:	e1a0318c 	lsl	r3, ip, #3
     534:	e1a0208c 	lsl	r2, ip, #1
     538:	e0822003 	add	r2, r2, r3
     53c:	e2411030 	sub	r1, r1, #48	; 0x30
		}
		d = *str++; w = r = s = l = 0;
		if (d == '0') {
			d = *str++; s = 1;
		}
		while ((d >= '0')&&(d <= '9')) {
     540:	e2403030 	sub	r3, r0, #48	; 0x30
			w += w * 10 + (d - '0');
     544:	e0811002 	add	r1, r1, r2
		}
		d = *str++; w = r = s = l = 0;
		if (d == '0') {
			d = *str++; s = 1;
		}
		while ((d >= '0')&&(d <= '9')) {
     548:	e3530009 	cmp	r3, #9	; 0x9
			w += w * 10 + (d - '0');
     54c:	e201c0ff 	and	ip, r1, #255	; 0xff
		}
		d = *str++; w = r = s = l = 0;
		if (d == '0') {
			d = *str++; s = 1;
		}
		while ((d >= '0')&&(d <= '9')) {
     550:	9afffff4 	bls	528 <xprintf+0x88>
     554:	e1a0300c 	mov	r3, ip
     558:	e1a05004 	mov	r5, r4
			w += w * 10 + (d - '0');
			d = *str++;
		}
		if (s) w = -w;
     55c:	e3570000 	cmp	r7, #0	; 0x0
     560:	12633000 	rsbne	r3, r3, #0	; 0x0
     564:	1203c0ff 	andne	ip, r3, #255	; 0xff
		if (d == 'l') {
     568:	e350006c 	cmp	r0, #108	; 0x6c
			l = 1;
			d = *str++;
     56c:	01a05004 	moveq	r5, r4
     570:	04d50001 	ldrbeq	r0, [r5], #1
		}
		if (!d) break;
     574:	e3500000 	cmp	r0, #0	; 0x0
     578:	0affffda 	beq	4e8 <xprintf+0x48>
		if (d == 's') {
     57c:	e3500073 	cmp	r0, #115	; 0x73
     580:	0a000014 	beq	5d8 <xprintf+0x138>
			xputs(va_arg(arp, char*));
			continue;
		}
		if (d == 'c') {
     584:	e3500063 	cmp	r0, #99	; 0x63
     588:	0a000017 	beq	5ec <xprintf+0x14c>
			// xputc(va_arg(arp, char));
			xputc(va_arg(arp, int));
			continue;
		}
		if (d == 'u') r = 10;
     58c:	e3500075 	cmp	r0, #117	; 0x75
     590:	0a00000e 	beq	5d0 <xprintf+0x130>
		if (d == 'd') r = -10;
     594:	e3500064 	cmp	r0, #100	; 0x64
     598:	03a030f6 	moveq	r3, #246	; 0xf6
     59c:	0a000002 	beq	5ac <xprintf+0x10c>
		if (d == 'X') r = 16;
     5a0:	e3500058 	cmp	r0, #88	; 0x58
     5a4:	03a03010 	moveq	r3, #16	; 0x10
     5a8:	1a000014 	bne	600 <xprintf+0x160>
		if (d == 'x') r = 16;
		if (d == 'b') r = 2;
		if (!r) break;
     5ac:	e1a03c03 	lsl	r3, r3, #24
     5b0:	e1a01c43 	asr	r1, r3, #24
		if (l) {
			xitoa((long)va_arg(arp, long), r, w);
		} else {
			if (r > 0)
				xitoa((unsigned long)va_arg(arp, int), r, w);
     5b4:	e1a02c0c 	lsl	r2, ip, #24
     5b8:	e5960000 	ldr	r0, [r6]
     5bc:	e1a02c42 	asr	r2, r2, #24
     5c0:	e2864004 	add	r4, r6, #4	; 0x4
     5c4:	ebffff5f 	bl	348 <xitoa>
     5c8:	e1a06004 	mov	r6, r4
     5cc:	eaffffc2 	b	4dc <xprintf+0x3c>
				xitoa((long)va_arg(arp, int), r, w);
		}
	}

	va_end(arp);
}
     5d0:	e3a0300a 	mov	r3, #10	; 0xa
     5d4:	eafffff4 	b	5ac <xprintf+0x10c>
			l = 1;
			d = *str++;
		}
		if (!d) break;
		if (d == 's') {
			xputs(va_arg(arp, char*));
     5d8:	e5960000 	ldr	r0, [r6]
     5dc:	e2864004 	add	r4, r6, #4	; 0x4
     5e0:	ebffffa1 	bl	46c <xputs>
		if (!r) break;
		if (l) {
			xitoa((long)va_arg(arp, long), r, w);
		} else {
			if (r > 0)
				xitoa((unsigned long)va_arg(arp, int), r, w);
     5e4:	e1a06004 	mov	r6, r4
     5e8:	eaffffbb 	b	4dc <xprintf+0x3c>
			xputs(va_arg(arp, char*));
			continue;
		}
		if (d == 'c') {
			// xputc(va_arg(arp, char));
			xputc(va_arg(arp, int));
     5ec:	e5d60000 	ldrb	r0, [r6]
     5f0:	e2864004 	add	r4, r6, #4	; 0x4
     5f4:	eb00005e 	bl	774 <uart_put>
		if (!r) break;
		if (l) {
			xitoa((long)va_arg(arp, long), r, w);
		} else {
			if (r > 0)
				xitoa((unsigned long)va_arg(arp, int), r, w);
     5f8:	e1a06004 	mov	r6, r4
     5fc:	eaffffb6 	b	4dc <xprintf+0x3c>
			continue;
		}
		if (d == 'u') r = 10;
		if (d == 'd') r = -10;
		if (d == 'X') r = 16;
		if (d == 'x') r = 16;
     600:	e3500078 	cmp	r0, #120	; 0x78
     604:	03a01010 	moveq	r1, #16	; 0x10
     608:	0affffe9 	beq	5b4 <xprintf+0x114>
		if (d == 'b') r = 2;
     60c:	e3500062 	cmp	r0, #98	; 0x62
     610:	1affffb4 	bne	4e8 <xprintf+0x48>
     614:	e3a01002 	mov	r1, #2	; 0x2
     618:	eaffffe5 	b	5b4 <xprintf+0x114>

0000061c <systemInit>:

void systemInit(void)
{


	  if ( PLLSTAT & (1 << 25) )	// is PLL "connected"?
     61c:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
     620:	e281197f 	add	r1, r1, #2080768	; 0x1fc000
     624:	e5913088 	ldr	r3, [r1, #136]
*/

#include "LPC24xx.h"

void systemInit(void)
{
     628:	e1a0c00d 	mov	ip, sp


	  if ( PLLSTAT & (1 << 25) )	// is PLL "connected"?
     62c:	e3130402 	tst	r3, #33554432	; 0x2000000
*/

#include "LPC24xx.h"

void systemInit(void)
{
     630:	e92dd800 	push	{fp, ip, lr, pc}
     634:	e24cb004 	sub	fp, ip, #4	; 0x4


	  if ( PLLSTAT & (1 << 25) )	// is PLL "connected"?
     638:	0a000005 	beq	654 <systemInit+0x38>
	  {
		PLLCON = 1;			// Enable PLL, disconnected
     63c:	e3a03001 	mov	r3, #1	; 0x1
     640:	e5813080 	str	r3, [r1, #128]
		PLLFEED = 0xaa;
     644:	e3a020aa 	mov	r2, #170	; 0xaa
		PLLFEED = 0x55;
     648:	e2833054 	add	r3, r3, #84	; 0x54


	  if ( PLLSTAT & (1 << 25) )	// is PLL "connected"?
	  {
		PLLCON = 1;			// Enable PLL, disconnected
		PLLFEED = 0xaa;
     64c:	e581208c 	str	r2, [r1, #140]
		PLLFEED = 0x55;
     650:	e581308c 	str	r3, [r1, #140]
	  }

	  PLLCON = 0;			// Disable PLL, disconnected
     654:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
	  // for RTC OSC, use M = 6750 and N = 1 
	  // for internal 4MHz osc, use M=144 and N=4 

	  //PLLCFG = 143 | (24 << 16);			// pg. 49: Main OSC PLL Setup
	  //PLLCFG = 6750 | (1 << 16);			// pg. 49: RTC OSC PLL Setup 
	  PLLCFG = (144-1) | ((4-1) << 16);		// pg. 49: Internal OSC PLL Setup 
     658:	e3a02803 	mov	r2, #196608	; 0x30000
		PLLCON = 1;			// Enable PLL, disconnected
		PLLFEED = 0xaa;
		PLLFEED = 0x55;
	  }

	  PLLCON = 0;			// Disable PLL, disconnected
     65c:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
	  PLLFEED = 0xaa;
     660:	e3a000aa 	mov	r0, #170	; 0xaa
	  PLLFEED = 0x55;
     664:	e3a0c055 	mov	ip, #85	; 0x55
	  // for RTC OSC, use M = 6750 and N = 1 
	  // for internal 4MHz osc, use M=144 and N=4 

	  //PLLCFG = 143 | (24 << 16);			// pg. 49: Main OSC PLL Setup
	  //PLLCFG = 6750 | (1 << 16);			// pg. 49: RTC OSC PLL Setup 
	  PLLCFG = (144-1) | ((4-1) << 16);		// pg. 49: Internal OSC PLL Setup 
     668:	e282208f 	add	r2, r2, #143	; 0x8f
		PLLCON = 1;			// Enable PLL, disconnected
		PLLFEED = 0xaa;
		PLLFEED = 0x55;
	  }

	  PLLCON = 0;			// Disable PLL, disconnected
     66c:	e3a01000 	mov	r1, #0	; 0x0
     670:	e5831080 	str	r1, [r3, #128]
	  PLLFEED = 0xaa;
     674:	e583008c 	str	r0, [r3, #140]
	  PLLFEED = 0x55;
     678:	e583c08c 	str	ip, [r3, #140]

//	  SCS |= 1;				//  Enable fast GPIO access 
//	  while( !(SCS & 0x40) );	// Wait until main OSC is usable

	  CLKSRCSEL = 0;		// pg. 46: select internal OSC, 4MHz, as the PLL clock source
     67c:	e583110c 	str	r1, [r3, #268]
	  // for RTC OSC, use M = 6750 and N = 1 
	  // for internal 4MHz osc, use M=144 and N=4 

	  //PLLCFG = 143 | (24 << 16);			// pg. 49: Main OSC PLL Setup
	  //PLLCFG = 6750 | (1 << 16);			// pg. 49: RTC OSC PLL Setup 
	  PLLCFG = (144-1) | ((4-1) << 16);		// pg. 49: Internal OSC PLL Setup 
     680:	e5832084 	str	r2, [r3, #132]
	  PLLFEED = 0xaa;
	  PLLFEED = 0x55;

	  PLLCON = 1;					// pg. 49: Enable PLL, disconnected
     684:	e3a02001 	mov	r2, #1	; 0x1
	  // for internal 4MHz osc, use M=144 and N=4 

	  //PLLCFG = 143 | (24 << 16);			// pg. 49: Main OSC PLL Setup
	  //PLLCFG = 6750 | (1 << 16);			// pg. 49: RTC OSC PLL Setup 
	  PLLCFG = (144-1) | ((4-1) << 16);		// pg. 49: Internal OSC PLL Setup 
	  PLLFEED = 0xaa;
     688:	e583008c 	str	r0, [r3, #140]
	  PLLFEED = 0x55;
     68c:	e583c08c 	str	ip, [r3, #140]

	  PLLCON = 1;					// pg. 49: Enable PLL, disconnected
     690:	e5832080 	str	r2, [r3, #128]
	  PLLFEED = 0xaa;				// pg. 53
	  PLLFEED = 0x55;				// pg. 53

	  //CCLKCFG = CCLKDivValue;	/* Set clock divider */

	  CCLKCFG = (4-1);	/* pg. 57: Set clock divider (meant for Main OSC) */
     694:	e2822002 	add	r2, r2, #2	; 0x2
	  PLLCFG = (144-1) | ((4-1) << 16);		// pg. 49: Internal OSC PLL Setup 
	  PLLFEED = 0xaa;
	  PLLFEED = 0x55;

	  PLLCON = 1;					// pg. 49: Enable PLL, disconnected
	  PLLFEED = 0xaa;				// pg. 53
     698:	e583008c 	str	r0, [r3, #140]
	  PLLFEED = 0x55;				// pg. 53
     69c:	e583c08c 	str	ip, [r3, #140]

	  //CCLKCFG = CCLKDivValue;	/* Set clock divider */

	  CCLKCFG = (4-1);	/* pg. 57: Set clock divider (meant for Main OSC) */
     6a0:	e5832104 	str	r2, [r3, #260]

	//#if USE_USB
	//  USBCLKCFG = USBCLKDivValue;		/* usbclk = 288 MHz/6 = 48 MHz */
	//#endif

	  while ( ((PLLSTAT & (1 << 26)) == 0) );	// wait for PLL to lock
     6a4:	e1a02003 	mov	r2, r3
     6a8:	e5923088 	ldr	r3, [r2, #136]
     6ac:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
     6b0:	e3130301 	tst	r3, #67108864	; 0x4000000
     6b4:	e281197f 	add	r1, r1, #2080768	; 0x1fc000
     6b8:	0afffffa 	beq	6a8 <systemInit+0x8c>
//	  MValue = PLLSTAT & 0x00007FFF;		/* pg. 52: seems to just read in current M value */
//	  NValue = (PLLSTAT & 0x00FF0000) >> 16;		/* pg. 52: seems to just read in current N value */
	  //while ((MValue != 72) && ( NValue != 25) );		/* Main OSC */
	  //while ((MValue != 6750) && ( NValue != 1) );	/* RTC OSC */

	  PLLCON = 3;								// enable and connect PLL
     6bc:	e3a03003 	mov	r3, #3	; 0x3
     6c0:	e5813080 	str	r3, [r1, #128]
	  PLLFEED = 0xaa;
     6c4:	e3a020aa 	mov	r2, #170	; 0xaa
	  PLLFEED = 0x55;
     6c8:	e2833052 	add	r3, r3, #82	; 0x52
//	  NValue = (PLLSTAT & 0x00FF0000) >> 16;		/* pg. 52: seems to just read in current N value */
	  //while ((MValue != 72) && ( NValue != 25) );		/* Main OSC */
	  //while ((MValue != 6750) && ( NValue != 1) );	/* RTC OSC */

	  PLLCON = 3;								// enable and connect PLL
	  PLLFEED = 0xaa;
     6cc:	e581208c 	str	r2, [r1, #140]
	  PLLFEED = 0x55;
     6d0:	e581308c 	str	r3, [r1, #140]
	  while ( ((PLLSTAT & (1 << 25)) == 0) );	// Check connect status
     6d4:	e1a02001 	mov	r2, r1
     6d8:	e5923088 	ldr	r3, [r2, #136]
     6dc:	e3130402 	tst	r3, #33554432	; 0x2000000
     6e0:	0afffffc 	beq	6d8 <systemInit+0xbc>
	  return;
	
}
     6e4:	e89da800 	ldm	sp, {fp, sp, pc}

000006e8 <uart0Init>:
 *    fmode - see typical fmodes (uart.h)
 *    NOTE: uart0Init(UART_BAUD(9600), UART_8N1, UART_FIFO_8); 
 */

void uart0Init(uint16_t baud, uint8_t mode, uint8_t fmode)
{
     6e8:	e1a0c00d 	mov	ip, sp
     6ec:	e92dd870 	push	{r4, r5, r6, fp, ip, lr, pc}
	 U0IER = 0x00;             	// disable all interrupts
     6f0:	e3a0420e 	mov	r4, #-536870912	; 0xe0000000
     6f4:	e2845903 	add	r5, r4, #49152	; 0xc000
     6f8:	e3a03000 	mov	r3, #0	; 0x0
     6fc:	e5853004 	str	r3, [r5, #4]
	 U0IIR = 0x00;             	// clear interrupt ID register
     700:	e5853008 	str	r3, [r5, #8]
	 U0LSR = 0x00;             	// clear line status register
     704:	e5853014 	str	r3, [r5, #20]
 *    fmode - see typical fmodes (uart.h)
 *    NOTE: uart0Init(UART_BAUD(9600), UART_8N1, UART_FIFO_8); 
 */

void uart0Init(uint16_t baud, uint8_t mode, uint8_t fmode)
{
     708:	e24cb004 	sub	fp, ip, #4	; 0x4
	 U0IER = 0x00;             	// disable all interrupts
	 U0IIR = 0x00;             	// clear interrupt ID register
	 U0LSR = 0x00;             	// clear line status register
  	 PCONP = (PCONP | 8); 		// enables uart0 on reset
     70c:	e284c97f 	add	ip, r4, #2080768	; 0x1fc000
     710:	e59c30c4 	ldr	r3, [ip, #196]
     714:	e3833008 	orr	r3, r3, #8	; 0x8
     718:	e58c30c4 	str	r3, [ip, #196]

	//PCLK_UART0 on reset the value is 00 so pclk = cclk/4 = 18MHz
	// setup Pin Function Select Register (Pin Connect Block) 
	// make sure old values of Bits 0-4 are masked out and
	// set them according to UART0-Pin-Selection
  	PINSEL0 = (PINSEL0 & ~UART0_PINMASK) | UART0_PINSEL;
     71c:	e284490b 	add	r4, r4, #180224	; 0x2c000
     720:	e5943000 	ldr	r3, [r4]
     724:	e3c330f0 	bic	r3, r3, #240	; 0xf0
     728:	e3833050 	orr	r3, r3, #80	; 0x50
     72c:	e5843000 	str	r3, [r4]
	PINMODE0= (PINMODE0& ~UART0_PINMASK) | UART0_PINMODE;
     730:	e594c040 	ldr	ip, [r4, #64]
 *    fmode - see typical fmodes (uart.h)
 *    NOTE: uart0Init(UART_BAUD(9600), UART_8N1, UART_FIFO_8); 
 */

void uart0Init(uint16_t baud, uint8_t mode, uint8_t fmode)
{
     734:	e1a00800 	lsl	r0, r0, #16
     738:	e1a06820 	lsr	r6, r0, #16
	//PCLK_UART0 on reset the value is 00 so pclk = cclk/4 = 18MHz
	// setup Pin Function Select Register (Pin Connect Block) 
	// make sure old values of Bits 0-4 are masked out and
	// set them according to UART0-Pin-Selection
  	PINSEL0 = (PINSEL0 & ~UART0_PINMASK) | UART0_PINSEL;
	PINMODE0= (PINMODE0& ~UART0_PINMASK) | UART0_PINMODE;
     73c:	e3ccc0f0 	bic	ip, ip, #240	; 0xf0
 *    fmode - see typical fmodes (uart.h)
 *    NOTE: uart0Init(UART_BAUD(9600), UART_8N1, UART_FIFO_8); 
 */

void uart0Init(uint16_t baud, uint8_t mode, uint8_t fmode)
{
     740:	e20220ff 	and	r2, r2, #255	; 0xff
	//PCLK_UART0 on reset the value is 00 so pclk = cclk/4 = 18MHz
	// setup Pin Function Select Register (Pin Connect Block) 
	// make sure old values of Bits 0-4 are masked out and
	// set them according to UART0-Pin-Selection
  	PINSEL0 = (PINSEL0 & ~UART0_PINMASK) | UART0_PINSEL;
	PINMODE0= (PINMODE0& ~UART0_PINMASK) | UART0_PINMODE;
     744:	e38cc0a0 	orr	ip, ip, #160	; 0xa0

  	// set the baudrate - DLAB must be set to access DLL/DLM
  	U0LCR = ULCR_DLAB_ENABLE; 	 // set divisor latches (DLAB)
  	U0DLL = (uint8_t)baud;       // set for baud low byte
     748:	e20660ff 	and	r6, r6, #255	; 0xff
  	U0DLM = (uint8_t)(baud >> 8);// set for baud high byte
     74c:	e1a00c20 	lsr	r0, r0, #24
  
  	// set the number of characters and other
  	// user specified operating parameters
  	// Databits, Parity, Stopbits - Settings in Line Control Register
  	U0LCR = (mode & ~(ULCR_DLAB_ENABLE)); // clear DLAB "on-the-fly"
     750:	e201107f 	and	r1, r1, #127	; 0x7f
	// set them according to UART0-Pin-Selection
  	PINSEL0 = (PINSEL0 & ~UART0_PINMASK) | UART0_PINSEL;
	PINMODE0= (PINMODE0& ~UART0_PINMASK) | UART0_PINMODE;

  	// set the baudrate - DLAB must be set to access DLL/DLM
  	U0LCR = ULCR_DLAB_ENABLE; 	 // set divisor latches (DLAB)
     754:	e3a03080 	mov	r3, #128	; 0x80
	//PCLK_UART0 on reset the value is 00 so pclk = cclk/4 = 18MHz
	// setup Pin Function Select Register (Pin Connect Block) 
	// make sure old values of Bits 0-4 are masked out and
	// set them according to UART0-Pin-Selection
  	PINSEL0 = (PINSEL0 & ~UART0_PINMASK) | UART0_PINSEL;
	PINMODE0= (PINMODE0& ~UART0_PINMASK) | UART0_PINMODE;
     758:	e584c040 	str	ip, [r4, #64]

  	// set the baudrate - DLAB must be set to access DLL/DLM
  	U0LCR = ULCR_DLAB_ENABLE; 	 // set divisor latches (DLAB)
     75c:	e585300c 	str	r3, [r5, #12]
  	U0DLL = (uint8_t)baud;       // set for baud low byte
     760:	e5856000 	str	r6, [r5]
  	U0DLM = (uint8_t)(baud >> 8);// set for baud high byte
     764:	e5850004 	str	r0, [r5, #4]
  
  	// set the number of characters and other
  	// user specified operating parameters
  	// Databits, Parity, Stopbits - Settings in Line Control Register
  	U0LCR = (mode & ~(ULCR_DLAB_ENABLE)); // clear DLAB "on-the-fly"
     768:	e585100c 	str	r1, [r5, #12]
  	// setup FIFO Control Register (fifo-enabled + xx trig) 
  	U0FCR = fmode;
     76c:	e5852008 	str	r2, [r5, #8]
}
     770:	e89da870 	ldm	sp, {r4, r5, r6, fp, sp, pc}

00000774 <uart_put>:
	uart_xmit( ch );
	return 1;
}

void uart_put (BYTE d)
{
     774:	e20000ff 	and	r0, r0, #255	; 0xff
     778:	e1a0c00d 	mov	ip, sp
// (used during tests until eval-version-limit
//  forced early migration to GNU-tools)
int sendchar( int ch );
int sendchar( int ch )
{
	if ( ch == '\n' ) {
     77c:	e350000a 	cmp	r0, #10	; 0xa
	uart_xmit( ch );
	return 1;
}

void uart_put (BYTE d)
{
     780:	e92dd800 	push	{fp, ip, lr, pc}
     784:	e24cb004 	sub	fp, ip, #4	; 0x4
// (used during tests until eval-version-limit
//  forced early migration to GNU-tools)
int sendchar( int ch );
int sendchar( int ch )
{
	if ( ch == '\n' ) {
     788:	0a000008 	beq	7b0 <uart_put+0x3c>
	return U0RBR;
}

static void uart_xmit( BYTE d )
{
	while ( !( U0LSR & 0x20 ) ) {
     78c:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
     790:	e2822903 	add	r2, r2, #49152	; 0xc000
     794:	e5923014 	ldr	r3, [r2, #20]
     798:	e3130020 	tst	r3, #32	; 0x20
     79c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
     7a0:	e2833903 	add	r3, r3, #49152	; 0xc000
     7a4:	0afffffa 	beq	794 <uart_put+0x20>
		// wait for send possible
		;
	}
	U0THR = d;
     7a8:	e5830000 	str	r0, [r3]
}

void uart_put (BYTE d)
{
	sendchar( d );
}
     7ac:	e89da800 	ldm	sp, {fp, sp, pc}
	return U0RBR;
}

static void uart_xmit( BYTE d )
{
	while ( !( U0LSR & 0x20 ) ) {
     7b0:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
     7b4:	e2811903 	add	r1, r1, #49152	; 0xc000
     7b8:	e5913014 	ldr	r3, [r1, #20]
     7bc:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
     7c0:	e3130020 	tst	r3, #32	; 0x20
     7c4:	e2822903 	add	r2, r2, #49152	; 0xc000
     7c8:	0afffffa 	beq	7b8 <uart_put+0x44>
		// wait for send possible
		;
	}
	U0THR = d;
     7cc:	e3a0300d 	mov	r3, #13	; 0xd
     7d0:	e5823000 	str	r3, [r2]
     7d4:	eaffffec 	b	78c <uart_put+0x18>

000007d8 <init_VIC>:
{
    DWORD i = 0;
    DWORD *vect_addr, *vect_prio;
   	
    /* initialize VIC*/
    VICIntEnClr = 0xffffffff;
     7d8:	e3e03000 	mvn	r3, #0	; 0x0
    VICVectAddr = 0;
     7dc:	e3a02000 	mov	r2, #0	; 0x0
{
    DWORD i = 0;
    DWORD *vect_addr, *vect_prio;
   	
    /* initialize VIC*/
    VICIntEnClr = 0xffffffff;
     7e0:	e5033feb 	str	r3, [r3, #-4075]
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
void init_VIC(void) 
{
     7e4:	e1a0c00d 	mov	ip, sp
    DWORD i = 0;
    DWORD *vect_addr, *vect_prio;
   	
    /* initialize VIC*/
    VICIntEnClr = 0xffffffff;
    VICVectAddr = 0;
     7e8:	e50320ff 	str	r2, [r3, #-255]
    VICIntSelect = 0;
     7ec:	e5032ff3 	str	r2, [r3, #-4083]
     7f0:	e2833362 	add	r3, r3, #-2013265919	; 0x88000001
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
void init_VIC(void) 
{
     7f4:	e92dd800 	push	{fp, ip, lr, pc}
    DWORD *vect_addr, *vect_prio;
   	
    /* initialize VIC*/
    VICIntEnClr = 0xffffffff;
    VICVectAddr = 0;
    VICIntSelect = 0;
     7f8:	e1a039c3 	asr	r3, r3, #19
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
void init_VIC(void) 
{
     7fc:	e24cb004 	sub	fp, ip, #4	; 0x4
    for ( i = 0; i < VIC_SIZE; i++ )
    {
		vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + i*4);
		vect_prio = (DWORD *)(VIC_BASE_ADDR + VECT_PRIO_INDEX + i*4);
		*vect_addr = 0x0;	
		*vect_prio = 0xF;
     800:	e3a0100f 	mov	r1, #15	; 0xf
    /* set all the vector and vector control register to 0 */
    for ( i = 0; i < VIC_SIZE; i++ )
    {
		vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + i*4);
		vect_prio = (DWORD *)(VIC_BASE_ADDR + VECT_PRIO_INDEX + i*4);
		*vect_addr = 0x0;	
     804:	e5832000 	str	r2, [r3]
		*vect_prio = 0xF;
     808:	e5831100 	str	r1, [r3, #256]
     80c:	e2833004 	add	r3, r3, #4	; 0x4
    VICIntEnClr = 0xffffffff;
    VICVectAddr = 0;
    VICIntSelect = 0;

    /* set all the vector and vector control register to 0 */
    for ( i = 0; i < VIC_SIZE; i++ )
     810:	e3730d3a 	cmn	r3, #3712	; 0xe80
     814:	1afffffa 	bne	804 <STACK_SIZE+0x4>
		vect_prio = (DWORD *)(VIC_BASE_ADDR + VECT_PRIO_INDEX + i*4);
		*vect_addr = 0x0;	
		*vect_prio = 0xF;
    }
    return;
}
     818:	e89da800 	ldm	sp, {fp, sp, pc}

0000081c <install_irq>:
**						interrupt priority
** Returned value:		true or false, return false if IntNum is out of range
** 
******************************************************************************/
DWORD install_irq( DWORD IntNumber, void *HandlerAddr, DWORD Priority )
{
     81c:	e1a0c00d 	mov	ip, sp
     820:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
    DWORD *vect_addr;
    DWORD *vect_prio;
      
    VICIntEnClr = 1 << IntNumber;	/* Disable Interrupt */
     824:	e3a05001 	mov	r5, #1	; 0x1
**						interrupt priority
** Returned value:		true or false, return false if IntNum is out of range
** 
******************************************************************************/
DWORD install_irq( DWORD IntNumber, void *HandlerAddr, DWORD Priority )
{
     828:	e24cb004 	sub	fp, ip, #4	; 0x4
    DWORD *vect_addr;
    DWORD *vect_prio;
      
    VICIntEnClr = 1 << IntNumber;	/* Disable Interrupt */
     82c:	e1a0c015 	lsl	ip, r5, r0
    if ( IntNumber >= VIC_SIZE )
     830:	e350001f 	cmp	r0, #31	; 0x1f
		return ( FALSE );
    }
    else
    {
		/* find first un-assigned VIC address for the handler */
		vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + IntNumber*4);
     834:	91a03100 	lslls	r3, r0, #2
DWORD install_irq( DWORD IntNumber, void *HandlerAddr, DWORD Priority )
{
    DWORD *vect_addr;
    DWORD *vect_prio;
      
    VICIntEnClr = 1 << IntNumber;	/* Disable Interrupt */
     838:	e3e04000 	mvn	r4, #0	; 0x0
     83c:	e504cfeb 	str	ip, [r4, #-4075]
    if ( IntNumber >= VIC_SIZE )
     840:	83a00000 	movhi	r0, #0	; 0x0
    {
		/* find first un-assigned VIC address for the handler */
		vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + IntNumber*4);
		vect_prio = (DWORD *)(VIC_BASE_ADDR + VECT_PRIO_INDEX + IntNumber*4);
		*vect_addr = (DWORD)HandlerAddr;	/* set interrupt vector */
		*vect_prio = Priority;
     844:	95032e00 	strls	r2, [r3, #-3584]
    else
    {
		/* find first un-assigned VIC address for the handler */
		vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + IntNumber*4);
		vect_prio = (DWORD *)(VIC_BASE_ADDR + VECT_PRIO_INDEX + IntNumber*4);
		*vect_addr = (DWORD)HandlerAddr;	/* set interrupt vector */
     848:	95031f00 	strls	r1, [r3, #-3840]
		*vect_prio = Priority;
		VICIntEnable = 1 << IntNumber;	/* Enable Interrupt */
     84c:	91a00005 	movls	r0, r5
     850:	9504cfef 	strls	ip, [r4, #-4079]
		return( TRUE );
    }
}
     854:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}

00000858 <RTCGetTime>:
** parameters:			ptr to RTCTime object
** Returned value:		updated object
**
*****************************************************************************/
void RTCGetTime( RTCTime* LocalTime ) 
{
     858:	e1a0c00d 	mov	ip, sp
	if ( LocalTime == NULL ) return;
     85c:	e3500000 	cmp	r0, #0	; 0x0
** parameters:			ptr to RTCTime object
** Returned value:		updated object
**
*****************************************************************************/
void RTCGetTime( RTCTime* LocalTime ) 
{
     860:	e92dd800 	push	{fp, ip, lr, pc}
     864:	e24cb004 	sub	fp, ip, #4	; 0x4
	if ( LocalTime == NULL ) return;
     868:	089da800 	ldmeq	sp, {fp, sp, pc}

	LocalTime->RTC_Sec  = RTC_SEC;
     86c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
     870:	e2833909 	add	r3, r3, #147456	; 0x24000
     874:	e5932020 	ldr	r2, [r3, #32]
     878:	e5802000 	str	r2, [r0]
	LocalTime->RTC_Min  = RTC_MIN;
     87c:	e5931024 	ldr	r1, [r3, #36]
     880:	e5801004 	str	r1, [r0, #4]
	LocalTime->RTC_Hour = RTC_HOUR;
     884:	e5932028 	ldr	r2, [r3, #40]
     888:	e5802008 	str	r2, [r0, #8]
	LocalTime->RTC_Mday = RTC_DOM;
     88c:	e593102c 	ldr	r1, [r3, #44]
     890:	e580100c 	str	r1, [r0, #12]
	LocalTime->RTC_Wday = RTC_DOW;
     894:	e5932030 	ldr	r2, [r3, #48]
     898:	e5802018 	str	r2, [r0, #24]
	LocalTime->RTC_Yday = RTC_DOY;
     89c:	e5931034 	ldr	r1, [r3, #52]
     8a0:	e580101c 	str	r1, [r0, #28]
	LocalTime->RTC_Mon  = RTC_MONTH;
     8a4:	e5932038 	ldr	r2, [r3, #56]
     8a8:	e5802010 	str	r2, [r0, #16]
	LocalTime->RTC_Year = RTC_YEAR;
     8ac:	e593103c 	ldr	r1, [r3, #60]
     8b0:	e5801014 	str	r1, [r0, #20]
     8b4:	e89da800 	ldm	sp, {fp, sp, pc}

000008b8 <f_mount>:

FRESULT f_mount (
	BYTE drv,		/* Logical drive number to be mounted/unmounted */
	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
)
{
     8b8:	e1a0c00d 	mov	ip, sp
	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
     8bc:	e21020ff 	ands	r2, r0, #255	; 0xff

FRESULT f_mount (
	BYTE drv,		/* Logical drive number to be mounted/unmounted */
	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
)
{
     8c0:	e92dd800 	push	{fp, ip, lr, pc}
     8c4:	e1a00001 	mov	r0, r1
     8c8:	e24cb004 	sub	fp, ip, #4	; 0x4
	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
     8cc:	13a00005 	movne	r0, #5	; 0x5
     8d0:	189da800 	ldmne	sp, {fp, sp, pc}

	if (FatFs[drv]) FatFs[drv]->fs_type = 0;	/* Clear old object */
     8d4:	e59f1020 	ldr	r1, [pc, #32]	; 8fc <f_mount+0x44>
     8d8:	e5913000 	ldr	r3, [r1]
     8dc:	e3530000 	cmp	r3, #0	; 0x0
     8e0:	15c3202a 	strbne	r2, [r3, #42]

	FatFs[drv] = fs;			/* Register and clear new object */
	if (fs) fs->fs_type = 0;
     8e4:	e3500000 	cmp	r0, #0	; 0x0
     8e8:	13a03000 	movne	r3, #0	; 0x0
{
	if (drv >= _DRIVES) return FR_INVALID_DRIVE;

	if (FatFs[drv]) FatFs[drv]->fs_type = 0;	/* Clear old object */

	FatFs[drv] = fs;			/* Register and clear new object */
     8ec:	e5810000 	str	r0, [r1]
	if (fs) fs->fs_type = 0;
     8f0:	15c0302a 	strbne	r3, [r0, #42]
     8f4:	11a00003 	movne	r0, r3

	return FR_OK;
}
     8f8:	e89da800 	ldm	sp, {fp, sp, pc}
     8fc:	40000700 	.word	0x40000700

00000900 <validate>:
static
FRESULT validate (		/* FR_OK(0): The object is valid, !=0: Invalid */
	const FATFS *fs,	/* Pointer to the file system object */
	WORD id				/* Member id of the target object to be checked */
)
{
     900:	e1a0c00d 	mov	ip, sp
     904:	e1a01801 	lsl	r1, r1, #16
	if (!fs || !fs->fs_type || fs->id != id)
     908:	e3500000 	cmp	r0, #0	; 0x0
static
FRESULT validate (		/* FR_OK(0): The object is valid, !=0: Invalid */
	const FATFS *fs,	/* Pointer to the file system object */
	WORD id				/* Member id of the target object to be checked */
)
{
     90c:	e92dd800 	push	{fp, ip, lr, pc}
     910:	e1a01821 	lsr	r1, r1, #16
     914:	e24cb004 	sub	fp, ip, #4	; 0x4
	if (!fs || !fs->fs_type || fs->id != id)
     918:	0a000005 	beq	934 <validate+0x34>
     91c:	e5d0302a 	ldrb	r3, [r0, #42]
     920:	e3530000 	cmp	r3, #0	; 0x0
     924:	0a000002 	beq	934 <validate+0x34>
     928:	e1d030b0 	ldrh	r3, [r0]
     92c:	e1530001 	cmp	r3, r1
     930:	0a000001 	beq	93c <validate+0x3c>
		return FR_INVALID_OBJECT;
	if (disk_status(fs->drive) & STA_NOINIT)
     934:	e3a0000c 	mov	r0, #12	; 0xc
		return FR_NOT_READY;

	return FR_OK;
}
     938:	e89da800 	ldm	sp, {fp, sp, pc}
	WORD id				/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
		return FR_INVALID_OBJECT;
	if (disk_status(fs->drive) & STA_NOINIT)
     93c:	e5d0002d 	ldrb	r0, [r0, #45]
     940:	eb00063d 	bl	223c <disk_status>
     944:	e2000001 	and	r0, r0, #1	; 0x1
     948:	e89da800 	ldm	sp, {fp, sp, pc}

0000094c <move_window>:
static
BOOL move_window (	/* TRUE: successful, FALSE: failed */
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make apperance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
     94c:	e1a0c00d 	mov	ip, sp
     950:	e92dd9f0 	push	{r4, r5, r6, r7, r8, fp, ip, lr, pc}
	DWORD wsect;


	wsect = fs->winsect;
     954:	e5906004 	ldr	r6, [r0, #4]
	if (wsect != sector) {	/* Changed current window */
     958:	e1560001 	cmp	r6, r1
static
BOOL move_window (	/* TRUE: successful, FALSE: failed */
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make apperance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
     95c:	e24cb004 	sub	fp, ip, #4	; 0x4
     960:	e1a04000 	mov	r4, r0
     964:	e1a07001 	mov	r7, r1
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
     968:	0a000004 	beq	980 <move_window+0x34>
#if !_FS_READONLY
		BYTE n;
		if (fs->winflag) {	/* Write back dirty window if needed */
     96c:	e5d0302e 	ldrb	r3, [r0, #46]
     970:	e3530000 	cmp	r3, #0	; 0x0
     974:	1a000003 	bne	988 <move_window+0x3c>
					disk_write(fs->drive, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
     978:	e3570000 	cmp	r7, #0	; 0x0
     97c:	1a00001f 	bne	a00 <move_window+0xb4>
			if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
				return FALSE;
			fs->winsect = sector;
     980:	e3a00001 	mov	r0, #1	; 0x1
		}
	}
	return TRUE;
}
     984:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		BYTE n;
		if (fs->winflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
     988:	e2808030 	add	r8, r0, #48	; 0x30
     98c:	e1a01008 	mov	r1, r8
     990:	e5d0002d 	ldrb	r0, [r0, #45]
     994:	e1a02006 	mov	r2, r6
     998:	e3a03001 	mov	r3, #1	; 0x1
     99c:	eb0006ec 	bl	2554 <disk_write>
     9a0:	e3500000 	cmp	r0, #0	; 0x0
     9a4:	1a00001e 	bne	a24 <move_window+0xd8>
				return FALSE;
			fs->winflag = 0;
			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
     9a8:	e5942008 	ldr	r2, [r4, #8]
     9ac:	e5943010 	ldr	r3, [r4, #16]
     9b0:	e0823003 	add	r3, r2, r3
     9b4:	e1560003 	cmp	r6, r3
#if !_FS_READONLY
		BYTE n;
		if (fs->winflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
				return FALSE;
			fs->winflag = 0;
     9b8:	e5c4002e 	strb	r0, [r4, #46]
			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
     9bc:	2affffed 	bcs	978 <move_window+0x2c>
				for (n = fs->n_fats; n >= 2; n--) {	/* Refrect the change to FAT copy */
     9c0:	e5d4502c 	ldrb	r5, [r4, #44]
     9c4:	e3550001 	cmp	r5, #1	; 0x1
     9c8:	8a000001 	bhi	9d4 <move_window+0x88>
     9cc:	eaffffe9 	b	978 <move_window+0x2c>
     9d0:	e5942008 	ldr	r2, [r4, #8]
					wsect += fs->sects_fat;
     9d4:	e0866002 	add	r6, r6, r2
					disk_write(fs->drive, fs->win, wsect, 1);
     9d8:	e3a03001 	mov	r3, #1	; 0x1
     9dc:	e5d4002d 	ldrb	r0, [r4, #45]
     9e0:	e1a01008 	mov	r1, r8
     9e4:	e1a02006 	mov	r2, r6
     9e8:	eb0006d9 	bl	2554 <disk_write>
		if (fs->winflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
				return FALSE;
			fs->winflag = 0;
			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
				for (n = fs->n_fats; n >= 2; n--) {	/* Refrect the change to FAT copy */
     9ec:	e2453001 	sub	r3, r5, #1	; 0x1
     9f0:	e20350ff 	and	r5, r3, #255	; 0xff
     9f4:	e3550001 	cmp	r5, #1	; 0x1
     9f8:	8afffff4 	bhi	9d0 <move_window+0x84>
     9fc:	eaffffdd 	b	978 <move_window+0x2c>
				}
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
     a00:	e5d4002d 	ldrb	r0, [r4, #45]
     a04:	e2841030 	add	r1, r4, #48	; 0x30
     a08:	e1a02007 	mov	r2, r7
     a0c:	e3a03001 	mov	r3, #1	; 0x1
     a10:	eb000708 	bl	2638 <disk_read>
     a14:	e3500000 	cmp	r0, #0	; 0x0
				return FALSE;
			fs->winsect = sector;
     a18:	05847004 	streq	r7, [r4, #4]
     a1c:	02800001 	addeq	r0, r0, #1	; 0x1
				}
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
     a20:	089da9f0 	ldmeq	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
				return FALSE;
			fs->winsect = sector;
     a24:	e3a00000 	mov	r0, #0	; 0x0
     a28:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}

00000a2c <get_cluster>:
static
DWORD get_cluster (	/* 0,>=2: successful, 1: failed */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to get the link information */
)
{
     a2c:	e1a0c00d 	mov	ip, sp
	WORD wc, bc;
	DWORD fatsect;


	if (clust >= 2 && clust < fs->max_clust) {		/* Is it a valid cluster#? */
     a30:	e3510001 	cmp	r1, #1	; 0x1
static
DWORD get_cluster (	/* 0,>=2: successful, 1: failed */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to get the link information */
)
{
     a34:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
     a38:	e24cb004 	sub	fp, ip, #4	; 0x4
     a3c:	e1a04001 	mov	r4, r1
     a40:	e1a05000 	mov	r5, r0
	WORD wc, bc;
	DWORD fatsect;


	if (clust >= 2 && clust < fs->max_clust) {		/* Is it a valid cluster#? */
     a44:	9a000014 	bls	a9c <get_cluster+0x70>
     a48:	e590300c 	ldr	r3, [r0, #12]
     a4c:	e1510003 	cmp	r1, r3
     a50:	2a000011 	bcs	a9c <get_cluster+0x70>
		fatsect = fs->fatbase;
		switch (fs->fs_type) {
     a54:	e5d0302a 	ldrb	r3, [r0, #42]
     a58:	e3530002 	cmp	r3, #2	; 0x2
	WORD wc, bc;
	DWORD fatsect;


	if (clust >= 2 && clust < fs->max_clust) {		/* Is it a valid cluster#? */
		fatsect = fs->fatbase;
     a5c:	e5906010 	ldr	r6, [r0, #16]
		switch (fs->fs_type) {
     a60:	0a000023 	beq	af4 <get_cluster+0xc8>
     a64:	e3530003 	cmp	r3, #3	; 0x3
     a68:	0a00000d 	beq	aa4 <get_cluster+0x78>
     a6c:	e3530001 	cmp	r3, #1	; 0x1
     a70:	1a000009 	bne	a9c <get_cluster+0x70>
		case FS_FAT12 :
			bc = (WORD)clust * 3 / 2;
     a74:	e1a02801 	lsl	r2, r1, #16
     a78:	e1a03822 	lsr	r3, r2, #16
     a7c:	e08337a2 	add	r3, r3, r2, lsr #15
     a80:	e1a030c3 	asr	r3, r3, #1
     a84:	e1a03803 	lsl	r3, r3, #16
			if (!move_window(fs, fatsect + (bc / SS(fs)))) break;
     a88:	e0861ca3 	add	r1, r6, r3, lsr #25

	if (clust >= 2 && clust < fs->max_clust) {		/* Is it a valid cluster#? */
		fatsect = fs->fatbase;
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (WORD)clust * 3 / 2;
     a8c:	e1a07823 	lsr	r7, r3, #16
			if (!move_window(fs, fatsect + (bc / SS(fs)))) break;
     a90:	ebffffad 	bl	94c <move_window>
     a94:	e3500000 	cmp	r0, #0	; 0x0
     a98:	1a000023 	bne	b2c <get_cluster+0x100>
			if (!move_window(fs, fatsect + (clust / (SS(fs) / 2)))) break;
			return LD_WORD(&fs->win[((WORD)clust * 2) & (SS(fs) - 1)]);

		case FS_FAT32 :
			if (!move_window(fs, fatsect + (clust / (SS(fs) / 4)))) break;
			return LD_DWORD(&fs->win[((WORD)clust * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
     a9c:	e3a00001 	mov	r0, #1	; 0x1
		}
	}

	return 1;	/* Out of cluster range, or an error occured */
}
     aa0:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
		case FS_FAT16 :
			if (!move_window(fs, fatsect + (clust / (SS(fs) / 2)))) break;
			return LD_WORD(&fs->win[((WORD)clust * 2) & (SS(fs) - 1)]);

		case FS_FAT32 :
			if (!move_window(fs, fatsect + (clust / (SS(fs) / 4)))) break;
     aa4:	e08613a1 	add	r1, r6, r1, lsr #7
     aa8:	ebffffa7 	bl	94c <move_window>
     aac:	e3500000 	cmp	r0, #0	; 0x0
     ab0:	0afffff9 	beq	a9c <get_cluster+0x70>
			return LD_DWORD(&fs->win[((WORD)clust * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
     ab4:	e1a01104 	lsl	r1, r4, #2
     ab8:	e2011f7f 	and	r1, r1, #508	; 0x1fc
     abc:	e2850030 	add	r0, r5, #48	; 0x30
     ac0:	e2812003 	add	r2, r1, #3	; 0x3
     ac4:	e281c002 	add	ip, r1, #2	; 0x2
     ac8:	e7d05002 	ldrb	r5, [r0, r2]
     acc:	e7d0300c 	ldrb	r3, [r0, ip]
     ad0:	e2812001 	add	r2, r1, #1	; 0x1
     ad4:	e7d04002 	ldrb	r4, [r0, r2]
     ad8:	e1a03803 	lsl	r3, r3, #16
     adc:	e7d0c001 	ldrb	ip, [r0, r1]
     ae0:	e1833c05 	orr	r3, r3, r5, lsl #24
     ae4:	e183300c 	orr	r3, r3, ip
     ae8:	e1833404 	orr	r3, r3, r4, lsl #8
     aec:	e3c3020f 	bic	r0, r3, #-268435456	; 0xf0000000
     af0:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
			if (!move_window(fs, fatsect + (bc / SS(fs)))) break;
			wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
			return (clust & 1) ? (wc >> 4) : (wc & 0xFFF);

		case FS_FAT16 :
			if (!move_window(fs, fatsect + (clust / (SS(fs) / 2)))) break;
     af4:	e0861421 	add	r1, r6, r1, lsr #8
     af8:	ebffff93 	bl	94c <move_window>
     afc:	e3500000 	cmp	r0, #0	; 0x0
     b00:	0affffe5 	beq	a9c <get_cluster+0x70>
			return LD_WORD(&fs->win[((WORD)clust * 2) & (SS(fs) - 1)]);
     b04:	e1a03084 	lsl	r3, r4, #1
     b08:	e3c33001 	bic	r3, r3, #1	; 0x1
     b0c:	e1a03b83 	lsl	r3, r3, #23
     b10:	e1a03ba3 	lsr	r3, r3, #23
     b14:	e2850030 	add	r0, r5, #48	; 0x30
     b18:	e2832001 	add	r2, r3, #1	; 0x1
     b1c:	e7d0c002 	ldrb	ip, [r0, r2]
     b20:	e7d01003 	ldrb	r1, [r0, r3]
     b24:	e181040c 	orr	r0, r1, ip, lsl #8
     b28:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
		fatsect = fs->fatbase;
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (WORD)clust * 3 / 2;
			if (!move_window(fs, fatsect + (bc / SS(fs)))) break;
			wc = fs->win[bc & (SS(fs) - 1)]; bc++;
     b2c:	e2872001 	add	r2, r7, #1	; 0x1
     b30:	e1a03b87 	lsl	r3, r7, #23
     b34:	e1a02802 	lsl	r2, r2, #16
     b38:	e1a03ba3 	lsr	r3, r3, #23
			if (!move_window(fs, fatsect + (bc / SS(fs)))) break;
     b3c:	e0861ca2 	add	r1, r6, r2, lsr #25
		fatsect = fs->fatbase;
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (WORD)clust * 3 / 2;
			if (!move_window(fs, fatsect + (bc / SS(fs)))) break;
			wc = fs->win[bc & (SS(fs) - 1)]; bc++;
     b40:	e0853003 	add	r3, r5, r3
			if (!move_window(fs, fatsect + (bc / SS(fs)))) break;
     b44:	e1a00005 	mov	r0, r5
		fatsect = fs->fatbase;
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (WORD)clust * 3 / 2;
			if (!move_window(fs, fatsect + (bc / SS(fs)))) break;
			wc = fs->win[bc & (SS(fs) - 1)]; bc++;
     b48:	e5d37030 	ldrb	r7, [r3, #48]
     b4c:	e1a06822 	lsr	r6, r2, #16
			if (!move_window(fs, fatsect + (bc / SS(fs)))) break;
     b50:	ebffff7d 	bl	94c <move_window>
     b54:	e3500000 	cmp	r0, #0	; 0x0
     b58:	0affffcf 	beq	a9c <get_cluster+0x70>
			wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
     b5c:	e1a03b86 	lsl	r3, r6, #23
     b60:	e1a03ba3 	lsr	r3, r3, #23
     b64:	e0853003 	add	r3, r5, r3
     b68:	e5d32030 	ldrb	r2, [r3, #48]
     b6c:	e1872402 	orr	r2, r7, r2, lsl #8
     b70:	e1a00802 	lsl	r0, r2, #16
     b74:	e1a02820 	lsr	r2, r0, #16
			return (clust & 1) ? (wc >> 4) : (wc & 0xFFF);
     b78:	e3140001 	tst	r4, #1	; 0x1
     b7c:	01a00a02 	lsleq	r0, r2, #20
     b80:	e1a00a20 	lsr	r0, r0, #20
     b84:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}

00000b88 <next_dir_entry>:
{
	DWORD clust;
	WORD idx;


	idx = dj->index + 1;
     b88:	e1d030b2 	ldrh	r3, [r0, #2]
     b8c:	e2833001 	add	r3, r3, #1	; 0x1

static
BOOL next_dir_entry (	/* TRUE: successful, FALSE: could not move next */
	DIR *dj				/* Pointer to directory object */
)
{
     b90:	e1a0c00d 	mov	ip, sp
	DWORD clust;
	WORD idx;


	idx = dj->index + 1;
     b94:	e1a02803 	lsl	r2, r3, #16

static
BOOL next_dir_entry (	/* TRUE: successful, FALSE: could not move next */
	DIR *dj				/* Pointer to directory object */
)
{
     b98:	e92dd870 	push	{r4, r5, r6, fp, ip, lr, pc}
	DWORD clust;
	WORD idx;


	idx = dj->index + 1;
     b9c:	e1a05822 	lsr	r5, r2, #16
	if ((idx & ((SS(dj->fs) - 1) / 32)) == 0) {		/* Table sector changed? */
     ba0:	e315000f 	tst	r5, #15	; 0xf

static
BOOL next_dir_entry (	/* TRUE: successful, FALSE: could not move next */
	DIR *dj				/* Pointer to directory object */
)
{
     ba4:	e24cb004 	sub	fp, ip, #4	; 0x4
     ba8:	e1a04000 	mov	r4, r0
	DWORD clust;
	WORD idx;


	idx = dj->index + 1;
	if ((idx & ((SS(dj->fs) - 1) / 32)) == 0) {		/* Table sector changed? */
     bac:	1a000009 	bne	bd8 <next_dir_entry+0x50>
		dj->sect++;				/* Next sector */
     bb0:	e280100c 	add	r1, r0, #12	; 0xc
     bb4:	e891000a 	ldm	r1, {r1, r3}
     bb8:	e2833001 	add	r3, r3, #1	; 0x1
		if (dj->clust == 0) {	/* In static table */
     bbc:	e3510000 	cmp	r1, #0	; 0x0
	WORD idx;


	idx = dj->index + 1;
	if ((idx & ((SS(dj->fs) - 1) / 32)) == 0) {		/* Table sector changed? */
		dj->sect++;				/* Next sector */
     bc0:	e5803010 	str	r3, [r0, #16]
		if (dj->clust == 0) {	/* In static table */
     bc4:	1a000006 	bne	be4 <next_dir_entry+0x5c>
			if (idx >= dj->fs->n_rootdir) return FALSE;	/* Reached to end of table */
     bc8:	e5903004 	ldr	r3, [r0, #4]
     bcc:	e1d320b2 	ldrh	r2, [r3, #2]
     bd0:	e1520005 	cmp	r2, r5
     bd4:	9a000019 	bls	c40 <next_dir_entry+0xb8>
				dj->clust = clust;				/* Initialize for new cluster */
				dj->sect = clust2sect(dj->fs, clust);
			}
		}
	}
	dj->index = idx;	/* Lower several bits of dj->index indicates offset in dj->sect */
     bd8:	e1c450b2 	strh	r5, [r4, #2]
     bdc:	e3a00001 	mov	r0, #1	; 0x1
     be0:	e89da870 	ldm	sp, {r4, r5, r6, fp, sp, pc}
	if ((idx & ((SS(dj->fs) - 1) / 32)) == 0) {		/* Table sector changed? */
		dj->sect++;				/* Next sector */
		if (dj->clust == 0) {	/* In static table */
			if (idx >= dj->fs->n_rootdir) return FALSE;	/* Reached to end of table */
		} else {					/* In dynamic table */
			if (((idx / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
     be4:	e5900004 	ldr	r0, [r0, #4]
     be8:	e5d0302b 	ldrb	r3, [r0, #43]
     bec:	e2433001 	sub	r3, r3, #1	; 0x1
     bf0:	e0136a22 	ands	r6, r3, r2, lsr #20
     bf4:	1afffff7 	bne	bd8 <next_dir_entry+0x50>
				clust = get_cluster(dj->fs, dj->clust);			/* Get next cluster */
     bf8:	ebffff8b 	bl	a2c <get_cluster>
				if (clust < 2 || clust >= dj->fs->max_clust)	/* Reached to end of table */
     bfc:	e3500001 	cmp	r0, #1	; 0x1
     c00:	9a00000e 	bls	c40 <next_dir_entry+0xb8>
     c04:	e5941004 	ldr	r1, [r4, #4]
     c08:	e591300c 	ldr	r3, [r1, #12]
     c0c:	e1500003 	cmp	r0, r3
     c10:	2a00000a 	bcs	c40 <next_dir_entry+0xb8>
					return FALSE;
				dj->clust = clust;				/* Initialize for new cluster */
     c14:	e584000c 	str	r0, [r4, #12]
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
     c18:	e591300c 	ldr	r3, [r1, #12]
DWORD clust2sect (	/* !=0: sector number, 0: failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
     c1c:	e2400002 	sub	r0, r0, #2	; 0x2
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
     c20:	e2433002 	sub	r3, r3, #2	; 0x2
     c24:	e1500003 	cmp	r0, r3
	return clust * fs->csize + fs->database;
     c28:	35912018 	ldrcc	r2, [r1, #24]
     c2c:	35d1302b 	ldrbcc	r3, [r1, #43]
     c30:	30212093 	mlacc	r1, r3, r0, r2
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
     c34:	21a01006 	movcs	r1, r6
			if (((idx / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clust = get_cluster(dj->fs, dj->clust);			/* Get next cluster */
				if (clust < 2 || clust >= dj->fs->max_clust)	/* Reached to end of table */
					return FALSE;
				dj->clust = clust;				/* Initialize for new cluster */
				dj->sect = clust2sect(dj->fs, clust);
     c38:	e5841010 	str	r1, [r4, #16]
     c3c:	eaffffe5 	b	bd8 <next_dir_entry+0x50>
			}
		}
	}
	dj->index = idx;	/* Lower several bits of dj->index indicates offset in dj->sect */
	return TRUE;
     c40:	e3a00000 	mov	r0, #0	; 0x0
}
     c44:	e89da870 	ldm	sp, {r4, r5, r6, fp, sp, pc}

00000c48 <put_cluster>:
BOOL put_cluster (	/* TRUE: successful, FALSE: failed */
	FATFS *fs,		/* File system object */
	DWORD clust,	/* Cluster# to change (must be 2 to fs->max_clust-1) */
	DWORD val		/* New value to mark the cluster */
)
{
     c48:	e1a0c00d 	mov	ip, sp
     c4c:	e92dddf0 	push	{r4, r5, r6, r7, r8, sl, fp, ip, lr, pc}
	BYTE *p;
	DWORD fatsect;


	fatsect = fs->fatbase;
	switch (fs->fs_type) {
     c50:	e5d0302a 	ldrb	r3, [r0, #42]
     c54:	e3530002 	cmp	r3, #2	; 0x2
BOOL put_cluster (	/* TRUE: successful, FALSE: failed */
	FATFS *fs,		/* File system object */
	DWORD clust,	/* Cluster# to change (must be 2 to fs->max_clust-1) */
	DWORD val		/* New value to mark the cluster */
)
{
     c58:	e24cb004 	sub	fp, ip, #4	; 0x4
     c5c:	e1a08000 	mov	r8, r0
     c60:	e1a04001 	mov	r4, r1
     c64:	e1a0a002 	mov	sl, r2
	WORD bc;
	BYTE *p;
	DWORD fatsect;


	fatsect = fs->fatbase;
     c68:	e5905010 	ldr	r5, [r0, #16]
	switch (fs->fs_type) {
     c6c:	0a00004a 	beq	d9c <put_cluster+0x154>
     c70:	e3530003 	cmp	r3, #3	; 0x3
     c74:	0a000030 	beq	d3c <put_cluster+0xf4>
     c78:	e3530001 	cmp	r3, #1	; 0x1
     c7c:	0a000001 	beq	c88 <put_cluster+0x40>

	default :
		return FALSE;
	}
	fs->winflag = 1;
	return TRUE;
     c80:	e3a00000 	mov	r0, #0	; 0x0
}
     c84:	e89dadf0 	ldm	sp, {r4, r5, r6, r7, r8, sl, fp, sp, pc}


	fatsect = fs->fatbase;
	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (WORD)clust * 3 / 2;
     c88:	e1a02801 	lsl	r2, r1, #16
     c8c:	e1a03822 	lsr	r3, r2, #16
     c90:	e08337a2 	add	r3, r3, r2, lsr #15
     c94:	e1a030c3 	asr	r3, r3, #1
     c98:	e1a03803 	lsl	r3, r3, #16
		if (!move_window(fs, fatsect + (bc / SS(fs)))) return FALSE;
     c9c:	e0851ca3 	add	r1, r5, r3, lsr #25


	fatsect = fs->fatbase;
	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (WORD)clust * 3 / 2;
     ca0:	e1a06823 	lsr	r6, r3, #16
		if (!move_window(fs, fatsect + (bc / SS(fs)))) return FALSE;
     ca4:	ebffff28 	bl	94c <move_window>
     ca8:	e3500000 	cmp	r0, #0	; 0x0
     cac:	0afffff3 	beq	c80 <put_cluster+0x38>
		p = &fs->win[bc & (SS(fs) - 1)];
     cb0:	e1a03b86 	lsl	r3, r6, #23
		*p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
     cb4:	e2147001 	ands	r7, r4, #1	; 0x1
	fatsect = fs->fatbase;
	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (WORD)clust * 3 / 2;
		if (!move_window(fs, fatsect + (bc / SS(fs)))) return FALSE;
		p = &fs->win[bc & (SS(fs) - 1)];
     cb8:	e1a03ba3 	lsr	r3, r3, #23
		*p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
     cbc:	10881003 	addne	r1, r8, r3
     cc0:	15d13030 	ldrbne	r3, [r1, #48]
     cc4:	120a20ff 	andne	r2, sl, #255	; 0xff
     cc8:	1203300f 	andne	r3, r3, #15	; 0xf
     ccc:	11833202 	orrne	r3, r3, r2, lsl #4
     cd0:	00881003 	addeq	r1, r8, r3
     cd4:	120330ff 	andne	r3, r3, #255	; 0xff
     cd8:	020a30ff 	andeq	r3, sl, #255	; 0xff
		bc++;
     cdc:	e2862001 	add	r2, r6, #1	; 0x1
     ce0:	e1a02802 	lsl	r2, r2, #16
	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (WORD)clust * 3 / 2;
		if (!move_window(fs, fatsect + (bc / SS(fs)))) return FALSE;
		p = &fs->win[bc & (SS(fs) - 1)];
		*p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
     ce4:	e5c13030 	strb	r3, [r1, #48]
		bc++;
		fs->winflag = 1;
     ce8:	e3a03001 	mov	r3, #1	; 0x1
     cec:	e5c8302e 	strb	r3, [r8, #46]
		if (!move_window(fs, fatsect + (bc / SS(fs)))) return FALSE;
     cf0:	e0851ca2 	add	r1, r5, r2, lsr #25
     cf4:	e1a00008 	mov	r0, r8
	case FS_FAT12 :
		bc = (WORD)clust * 3 / 2;
		if (!move_window(fs, fatsect + (bc / SS(fs)))) return FALSE;
		p = &fs->win[bc & (SS(fs) - 1)];
		*p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
		bc++;
     cf8:	e1a04822 	lsr	r4, r2, #16
		fs->winflag = 1;
		if (!move_window(fs, fatsect + (bc / SS(fs)))) return FALSE;
     cfc:	ebffff12 	bl	94c <move_window>
     d00:	e3500000 	cmp	r0, #0	; 0x0
     d04:	0affffdd 	beq	c80 <put_cluster+0x38>
		p = &fs->win[bc & (SS(fs) - 1)];
     d08:	e1a02b84 	lsl	r2, r4, #23
		*p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
     d0c:	e3570000 	cmp	r7, #0	; 0x0
		p = &fs->win[bc & (SS(fs) - 1)];
		*p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
		bc++;
		fs->winflag = 1;
		if (!move_window(fs, fatsect + (bc / SS(fs)))) return FALSE;
		p = &fs->win[bc & (SS(fs) - 1)];
     d10:	e1a02ba2 	lsr	r2, r2, #23
		*p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
     d14:	0088e002 	addeq	lr, r8, r2
     d18:	05de3030 	ldrbeq	r3, [lr, #48]
     d1c:	11a0322a 	lsrne	r3, sl, #4
     d20:	01a02a0a 	lsleq	r2, sl, #20
     d24:	03c3300f 	biceq	r3, r3, #15	; 0xf
     d28:	120300ff 	andne	r0, r3, #255	; 0xff
     d2c:	1088e002 	addne	lr, r8, r2
     d30:	01830e22 	orreq	r0, r3, r2, lsr #28
     d34:	e5ce0030 	strb	r0, [lr, #48]
     d38:	ea000026 	b	dd8 <put_cluster+0x190>
		if (!move_window(fs, fatsect + (clust / (SS(fs) / 2)))) return FALSE;
		ST_WORD(&fs->win[((WORD)clust * 2) & (SS(fs) - 1)], (WORD)val);
		break;

	case FS_FAT32 :
		if (!move_window(fs, fatsect + (clust / (SS(fs) / 4)))) return FALSE;
     d3c:	e08513a1 	add	r1, r5, r1, lsr #7
     d40:	ebffff01 	bl	94c <move_window>
     d44:	e3500000 	cmp	r0, #0	; 0x0
     d48:	0affffcc 	beq	c80 <put_cluster+0x38>
		ST_DWORD(&fs->win[((WORD)clust * 4) & (SS(fs) - 1)], val);
     d4c:	e1a02104 	lsl	r2, r4, #2
     d50:	e2022f7f 	and	r2, r2, #508	; 0x1fc
     d54:	e1a0180a 	lsl	r1, sl, #16
     d58:	e1a0082a 	lsr	r0, sl, #16
     d5c:	e2883030 	add	r3, r8, #48	; 0x30
     d60:	e20000ff 	and	r0, r0, #255	; 0xff
     d64:	e1a01c21 	lsr	r1, r1, #24
     d68:	e2827003 	add	r7, r2, #3	; 0x3
     d6c:	e1a06c2a 	lsr	r6, sl, #24
     d70:	e20ac0ff 	and	ip, sl, #255	; 0xff
     d74:	e2824001 	add	r4, r2, #1	; 0x1
     d78:	e2825002 	add	r5, r2, #2	; 0x2
     d7c:	e7c3c002 	strb	ip, [r3, r2]
     d80:	e7c31004 	strb	r1, [r3, r4]
     d84:	e7c30005 	strb	r0, [r3, r5]
     d88:	e7c36007 	strb	r6, [r3, r7]
		break;

	default :
		return FALSE;
	}
	fs->winflag = 1;
     d8c:	e3a03001 	mov	r3, #1	; 0x1
     d90:	e5c8302e 	strb	r3, [r8, #46]
     d94:	e1a00003 	mov	r0, r3
     d98:	e89dadf0 	ldm	sp, {r4, r5, r6, r7, r8, sl, fp, sp, pc}
		p = &fs->win[bc & (SS(fs) - 1)];
		*p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
		break;

	case FS_FAT16 :
		if (!move_window(fs, fatsect + (clust / (SS(fs) / 2)))) return FALSE;
     d9c:	e0851421 	add	r1, r5, r1, lsr #8
     da0:	ebfffee9 	bl	94c <move_window>
     da4:	e3500000 	cmp	r0, #0	; 0x0
     da8:	0affffb4 	beq	c80 <put_cluster+0x38>
		ST_WORD(&fs->win[((WORD)clust * 2) & (SS(fs) - 1)], (WORD)val);
     dac:	e1a03084 	lsl	r3, r4, #1
     db0:	e3c33001 	bic	r3, r3, #1	; 0x1
     db4:	e1a03b83 	lsl	r3, r3, #23
     db8:	e1a03ba3 	lsr	r3, r3, #23
     dbc:	e1a0180a 	lsl	r1, sl, #16
     dc0:	e2880030 	add	r0, r8, #48	; 0x30
     dc4:	e283c001 	add	ip, r3, #1	; 0x1
     dc8:	e1a01c21 	lsr	r1, r1, #24
     dcc:	e20a20ff 	and	r2, sl, #255	; 0xff
     dd0:	e7c02003 	strb	r2, [r0, r3]
     dd4:	e7c0100c 	strb	r1, [r0, ip]
		break;

	default :
		return FALSE;
	}
	fs->winflag = 1;
     dd8:	e3a03001 	mov	r3, #1	; 0x1
     ddc:	e5c8302e 	strb	r3, [r8, #46]
     de0:	e1a00003 	mov	r0, r3
     de4:	e89dadf0 	ldm	sp, {r4, r5, r6, r7, r8, sl, fp, sp, pc}

00000de8 <create_chain>:
static
DWORD create_chain (	/* 0: No free cluster, 1: Error, >=2: New cluster number */
	FATFS *fs,			/* File system object */
	DWORD clust			/* Cluster# to stretch, 0 means create new */
)
{
     de8:	e1a0c00d 	mov	ip, sp
     dec:	e92dd9f0 	push	{r4, r5, r6, r7, r8, fp, ip, lr, pc}
	DWORD cstat, ncl, scl, mcl = fs->max_clust;


	if (clust == 0) {		/* Create new chain */
     df0:	e2518000 	subs	r8, r1, #0	; 0x0
static
DWORD create_chain (	/* 0: No free cluster, 1: Error, >=2: New cluster number */
	FATFS *fs,			/* File system object */
	DWORD clust			/* Cluster# to stretch, 0 means create new */
)
{
     df4:	e24cb004 	sub	fp, ip, #4	; 0x4
     df8:	e1a07000 	mov	r7, r0
	DWORD cstat, ncl, scl, mcl = fs->max_clust;
     dfc:	e590600c 	ldr	r6, [r0, #12]


	if (clust == 0) {		/* Create new chain */
     e00:	1a000015 	bne	e5c <create_chain+0x74>
		scl = fs->last_clust;			/* Get suggested start point */
     e04:	e590501c 	ldr	r5, [r0, #28]
		if (scl == 0 || scl >= mcl) scl = 1;
     e08:	e3550000 	cmp	r5, #0	; 0x0
     e0c:	11550006 	cmpne	r5, r6
     e10:	23a05001 	movcs	r5, #1	; 0x1
	}
	else {					/* Stretch existing chain */
		cstat = get_cluster(fs, clust);	/* Check the cluster status */
		if (cstat < 2) return 1;		/* It is an invalid cluster */
		if (cstat < mcl) return cstat;	/* It is already followed by next cluster */
     e14:	e1a04005 	mov	r4, r5
		scl = clust;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
     e18:	e2844001 	add	r4, r4, #1	; 0x1
		if (ncl >= mcl) {				/* Wrap around */
     e1c:	e1560004 	cmp	r6, r4
			ncl = 2;
			if (ncl > scl) return 0;	/* No free custer */
		}
		cstat = get_cluster(fs, ncl);	/* Get the cluster status */
     e20:	e1a00007 	mov	r0, r7
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= mcl) {				/* Wrap around */
     e24:	8a000002 	bhi	e34 <create_chain+0x4c>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free custer */
     e28:	e3550001 	cmp	r5, #1	; 0x1
     e2c:	9a000008 	bls	e54 <create_chain+0x6c>
     e30:	e3a04002 	mov	r4, #2	; 0x2
		}
		cstat = get_cluster(fs, ncl);	/* Get the cluster status */
     e34:	e1a01004 	mov	r1, r4
     e38:	ebfffefb 	bl	a2c <get_cluster>
		if (cstat == 0) break;			/* Found a free cluster */
     e3c:	e3500000 	cmp	r0, #0	; 0x0
     e40:	0a00000c 	beq	e78 <create_chain+0x90>
		if (cstat == 1) return 1;		/* Any error occured */
     e44:	e3500001 	cmp	r0, #1	; 0x1
     e48:	089da9f0 	ldmeq	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
		if (ncl == scl) return 0;		/* No free custer */
     e4c:	e1540005 	cmp	r4, r5
     e50:	1afffff0 	bne	e18 <create_chain+0x30>

	fs->last_clust = ncl;				/* Update fsinfo */
	if (fs->free_clust != 0xFFFFFFFF) {
		fs->free_clust--;
#if _USE_FSINFO
		fs->fsi_flag = 1;
     e54:	e3a00000 	mov	r0, #0	; 0x0
#endif
	}

	return ncl;		/* Return new cluster number */
}
     e58:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
	if (clust == 0) {		/* Create new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (scl == 0 || scl >= mcl) scl = 1;
	}
	else {					/* Stretch existing chain */
		cstat = get_cluster(fs, clust);	/* Check the cluster status */
     e5c:	ebfffef2 	bl	a2c <get_cluster>
		if (cstat < 2) return 1;		/* It is an invalid cluster */
     e60:	e3500001 	cmp	r0, #1	; 0x1
     e64:	9a000011 	bls	eb0 <create_chain+0xc8>
		if (cstat < mcl) return cstat;	/* It is already followed by next cluster */
     e68:	e1560000 	cmp	r6, r0
     e6c:	889da9f0 	ldmhi	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
     e70:	e1a05008 	mov	r5, r8
     e74:	eaffffe6 	b	e14 <create_chain+0x2c>
		if (cstat == 0) break;			/* Found a free cluster */
		if (cstat == 1) return 1;		/* Any error occured */
		if (ncl == scl) return 0;		/* No free custer */
	}

	if (!put_cluster(fs, ncl, 0x0FFFFFFF)) return 1;			/* Mark the new cluster "in use" */
     e78:	e1a00007 	mov	r0, r7
     e7c:	e1a01004 	mov	r1, r4
     e80:	e3e0220f 	mvn	r2, #-268435456	; 0xf0000000
     e84:	ebffff6f 	bl	c48 <put_cluster>
     e88:	e3500000 	cmp	r0, #0	; 0x0
     e8c:	0a000007 	beq	eb0 <create_chain+0xc8>
	if (clust != 0 && !put_cluster(fs, clust, ncl)) return 1;	/* Link it to previous one if needed */
     e90:	e3580000 	cmp	r8, #0	; 0x0
     e94:	0a000007 	beq	eb8 <create_chain+0xd0>
     e98:	e1a01008 	mov	r1, r8
     e9c:	e1a00007 	mov	r0, r7
     ea0:	e1a02004 	mov	r2, r4
     ea4:	ebffff67 	bl	c48 <put_cluster>
     ea8:	e3500000 	cmp	r0, #0	; 0x0
     eac:	1a000001 	bne	eb8 <create_chain+0xd0>

	fs->last_clust = ncl;				/* Update fsinfo */
	if (fs->free_clust != 0xFFFFFFFF) {
		fs->free_clust--;
#if _USE_FSINFO
		fs->fsi_flag = 1;
     eb0:	e3a00001 	mov	r0, #1	; 0x1
     eb4:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}

	if (!put_cluster(fs, ncl, 0x0FFFFFFF)) return 1;			/* Mark the new cluster "in use" */
	if (clust != 0 && !put_cluster(fs, clust, ncl)) return 1;	/* Link it to previous one if needed */

	fs->last_clust = ncl;				/* Update fsinfo */
	if (fs->free_clust != 0xFFFFFFFF) {
     eb8:	e5972020 	ldr	r2, [r7, #32]
     ebc:	e3720001 	cmn	r2, #1	; 0x1
		fs->free_clust--;
     ec0:	12422001 	subne	r2, r2, #1	; 0x1
#if _USE_FSINFO
		fs->fsi_flag = 1;
     ec4:	13a03001 	movne	r3, #1	; 0x1
	}

	if (!put_cluster(fs, ncl, 0x0FFFFFFF)) return 1;			/* Mark the new cluster "in use" */
	if (clust != 0 && !put_cluster(fs, clust, ncl)) return 1;	/* Link it to previous one if needed */

	fs->last_clust = ncl;				/* Update fsinfo */
     ec8:	e587401c 	str	r4, [r7, #28]
	if (fs->free_clust != 0xFFFFFFFF) {
		fs->free_clust--;
#if _USE_FSINFO
		fs->fsi_flag = 1;
     ecc:	15c73028 	strbne	r3, [r7, #40]
	if (!put_cluster(fs, ncl, 0x0FFFFFFF)) return 1;			/* Mark the new cluster "in use" */
	if (clust != 0 && !put_cluster(fs, clust, ncl)) return 1;	/* Link it to previous one if needed */

	fs->last_clust = ncl;				/* Update fsinfo */
	if (fs->free_clust != 0xFFFFFFFF) {
		fs->free_clust--;
     ed0:	15872020 	strne	r2, [r7, #32]
#if _USE_FSINFO
		fs->fsi_flag = 1;
     ed4:	e1a00004 	mov	r0, r4
     ed8:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}

00000edc <remove_chain>:
static
BOOL remove_chain (	/* TRUE: successful, FALSE: failed */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to remove chain from */
)
{
     edc:	e1a0c00d 	mov	ip, sp
	DWORD nxt;


	while (clust >= 2 && clust < fs->max_clust) {
     ee0:	e3510001 	cmp	r1, #1	; 0x1
static
BOOL remove_chain (	/* TRUE: successful, FALSE: failed */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to remove chain from */
)
{
     ee4:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
     ee8:	e24cb004 	sub	fp, ip, #4	; 0x4
     eec:	e1a06001 	mov	r6, r1
     ef0:	e1a04000 	mov	r4, r0
	DWORD nxt;


	while (clust >= 2 && clust < fs->max_clust) {
     ef4:	9a00001d 	bls	f70 <remove_chain+0x94>
     ef8:	e590300c 	ldr	r3, [r0, #12]
     efc:	e1510003 	cmp	r1, r3
     f00:	2a00001a 	bcs	f70 <remove_chain+0x94>
		if (nxt == 1) return FALSE;
		if (!put_cluster(fs, clust, 0)) return FALSE;
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust++;
#if _USE_FSINFO
			fs->fsi_flag = 1;
     f04:	e3a07001 	mov	r7, #1	; 0x1
     f08:	ea00000c 	b	f40 <remove_chain+0x64>


	while (clust >= 2 && clust < fs->max_clust) {
		nxt = get_cluster(fs, clust);
		if (nxt == 1) return FALSE;
		if (!put_cluster(fs, clust, 0)) return FALSE;
     f0c:	ebffff4d 	bl	c48 <put_cluster>
     f10:	e3500000 	cmp	r0, #0	; 0x0
     f14:	0a000013 	beq	f68 <remove_chain+0x8c>
		if (fs->free_clust != 0xFFFFFFFF) {
     f18:	e5943020 	ldr	r3, [r4, #32]
     f1c:	e3730001 	cmn	r3, #1	; 0x1
			fs->free_clust++;
     f20:	e2833001 	add	r3, r3, #1	; 0x1
     f24:	15843020 	strne	r3, [r4, #32]
#if _USE_FSINFO
			fs->fsi_flag = 1;
     f28:	15c47028 	strbne	r7, [r4, #40]
)
{
	DWORD nxt;


	while (clust >= 2 && clust < fs->max_clust) {
     f2c:	e3550001 	cmp	r5, #1	; 0x1
     f30:	9a00000e 	bls	f70 <remove_chain+0x94>
     f34:	e594300c 	ldr	r3, [r4, #12]
     f38:	e1530005 	cmp	r3, r5
     f3c:	9a00000b 	bls	f70 <remove_chain+0x94>
		nxt = get_cluster(fs, clust);
     f40:	e1a01006 	mov	r1, r6
     f44:	e1a00004 	mov	r0, r4
     f48:	ebfffeb7 	bl	a2c <get_cluster>
     f4c:	e1a05000 	mov	r5, r0
		if (nxt == 1) return FALSE;
     f50:	e3550001 	cmp	r5, #1	; 0x1
		if (!put_cluster(fs, clust, 0)) return FALSE;
     f54:	e1a01006 	mov	r1, r6
     f58:	e3a02000 	mov	r2, #0	; 0x0
)
{
	DWORD nxt;


	while (clust >= 2 && clust < fs->max_clust) {
     f5c:	e1a06000 	mov	r6, r0
		nxt = get_cluster(fs, clust);
		if (nxt == 1) return FALSE;
		if (!put_cluster(fs, clust, 0)) return FALSE;
     f60:	e1a00004 	mov	r0, r4
	DWORD nxt;


	while (clust >= 2 && clust < fs->max_clust) {
		nxt = get_cluster(fs, clust);
		if (nxt == 1) return FALSE;
     f64:	1affffe8 	bne	f0c <remove_chain+0x30>
)
{
	DWORD nxt;


	while (clust >= 2 && clust < fs->max_clust) {
     f68:	e3a00000 	mov	r0, #0	; 0x0
     f6c:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
     f70:	e3a00001 	mov	r0, #1	; 0x1
#endif
		}
		clust = nxt;
	}
	return TRUE;
}
     f74:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}

00000f78 <reserve_direntry>:
static
FRESULT reserve_direntry (	/* FR_OK: successful, FR_DENIED: no free entry, FR_RW_ERROR: a disk error occured */
	DIR *dj,				/* Target directory to create new entry */
	BYTE **dir				/* Pointer to pointer to created entry to retutn */
)
{
     f78:	e1a0c00d 	mov	ip, sp
     f7c:	e92dd9f0 	push	{r4, r5, r6, r7, r8, fp, ip, lr, pc}
	BYTE c, n, *dptr;
	FATFS *fs = dj->fs;


	/* Re-initialize directory object */
	clust = dj->sclust;
     f80:	e99000a0 	ldmib	r0, {r5, r7}
	if (clust != 0) {	/* Dyanmic directory table */
     f84:	e3570000 	cmp	r7, #0	; 0x0
		dj->clust = clust;
		dj->sect = clust2sect(fs, clust);
	} else {			/* Static directory table */
		dj->sect = fs->dirbase;
     f88:	05953014 	ldreq	r3, [r5, #20]
static
FRESULT reserve_direntry (	/* FR_OK: successful, FR_DENIED: no free entry, FR_RW_ERROR: a disk error occured */
	DIR *dj,				/* Target directory to create new entry */
	BYTE **dir				/* Pointer to pointer to created entry to retutn */
)
{
     f8c:	e24cb004 	sub	fp, ip, #4	; 0x4
     f90:	e1a04000 	mov	r4, r0
     f94:	e1a08001 	mov	r8, r1
	clust = dj->sclust;
	if (clust != 0) {	/* Dyanmic directory table */
		dj->clust = clust;
		dj->sect = clust2sect(fs, clust);
	} else {			/* Static directory table */
		dj->sect = fs->dirbase;
     f98:	05803010 	streq	r3, [r0, #16]
	FATFS *fs = dj->fs;


	/* Re-initialize directory object */
	clust = dj->sclust;
	if (clust != 0) {	/* Dyanmic directory table */
     f9c:	0a000009 	beq	fc8 <reserve_direntry+0x50>
		dj->clust = clust;
     fa0:	e580700c 	str	r7, [r0, #12]
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
     fa4:	e595300c 	ldr	r3, [r5, #12]
DWORD clust2sect (	/* !=0: sector number, 0: failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
     fa8:	e2470002 	sub	r0, r7, #2	; 0x2
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
     fac:	e2433002 	sub	r3, r3, #2	; 0x2
     fb0:	e1500003 	cmp	r0, r3
	return clust * fs->csize + fs->database;
     fb4:	35d5202b 	ldrbcc	r2, [r5, #43]
     fb8:	35953018 	ldrcc	r3, [r5, #24]
     fbc:	30213290 	mlacc	r1, r0, r2, r3
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
     fc0:	23a01000 	movcs	r1, #0	; 0x0

	/* Re-initialize directory object */
	clust = dj->sclust;
	if (clust != 0) {	/* Dyanmic directory table */
		dj->clust = clust;
		dj->sect = clust2sect(fs, clust);
     fc4:	e5841010 	str	r1, [r4, #16]
	} else {			/* Static directory table */
		dj->sect = fs->dirbase;
	}
	dj->index = 0;
     fc8:	e3a03000 	mov	r3, #0	; 0x0
     fcc:	e1c430b2 	strh	r3, [r4, #2]

	do {
		if (!move_window(fs, dj->sect)) return FR_RW_ERROR;
     fd0:	e5941010 	ldr	r1, [r4, #16]
     fd4:	e1a00005 	mov	r0, r5
     fd8:	ebfffe5b 	bl	94c <move_window>
     fdc:	e3500000 	cmp	r0, #0	; 0x0
		dptr = &fs->win[(dj->index & ((SS(dj->fs) - 1) / 32)) * 32];	/* Pointer to the directory entry */
		c = dptr[DIR_Name];
		if (c == 0 || c == 0xE5) {		/* Found an empty entry */
			*dir = dptr; return FR_OK;
		}
	} while (next_dir_entry(dj));		/* Next directory pointer */
     fe0:	e1a00004 	mov	r0, r4
		dj->sect = fs->dirbase;
	}
	dj->index = 0;

	do {
		if (!move_window(fs, dj->sect)) return FR_RW_ERROR;
     fe4:	0a000038 	beq	10cc <reserve_direntry+0x154>
		dptr = &fs->win[(dj->index & ((SS(dj->fs) - 1) / 32)) * 32];	/* Pointer to the directory entry */
     fe8:	e1d430b2 	ldrh	r3, [r4, #2]
     fec:	e203300f 	and	r3, r3, #15	; 0xf
     ff0:	e1a03283 	lsl	r3, r3, #5
		c = dptr[DIR_Name];
     ff4:	e0851003 	add	r1, r5, r3
     ff8:	e5d12030 	ldrb	r2, [r1, #48]
	}
	dj->index = 0;

	do {
		if (!move_window(fs, dj->sect)) return FR_RW_ERROR;
		dptr = &fs->win[(dj->index & ((SS(dj->fs) - 1) / 32)) * 32];	/* Pointer to the directory entry */
     ffc:	e2833030 	add	r3, r3, #48	; 0x30
		c = dptr[DIR_Name];
		if (c == 0 || c == 0xE5) {		/* Found an empty entry */
    1000:	e35200e5 	cmp	r2, #229	; 0xe5
    1004:	13520000 	cmpne	r2, #0	; 0x0
	}
	dj->index = 0;

	do {
		if (!move_window(fs, dj->sect)) return FR_RW_ERROR;
		dptr = &fs->win[(dj->index & ((SS(dj->fs) - 1) / 32)) * 32];	/* Pointer to the directory entry */
    1008:	e0853003 	add	r3, r5, r3
		c = dptr[DIR_Name];
		if (c == 0 || c == 0xE5) {		/* Found an empty entry */
    100c:	0a000030 	beq	10d4 <reserve_direntry+0x15c>
			*dir = dptr; return FR_OK;
		}
	} while (next_dir_entry(dj));		/* Next directory pointer */
    1010:	ebfffedc 	bl	b88 <next_dir_entry>
    1014:	e2506000 	subs	r6, r0, #0	; 0x0
    1018:	1affffec 	bne	fd0 <reserve_direntry+0x58>
	/* Reached to end of the directory table */

	/* Abort when it is a static table or could not stretch dynamic table */
	if (clust == 0 || !(clust = create_chain(fs, dj->clust))) return FR_DENIED;
    101c:	e3570000 	cmp	r7, #0	; 0x0
    1020:	1a000001 	bne	102c <reserve_direntry+0xb4>
		sector++;
	}
	fs->winflag = 1;
	*dir = fs->win;

	return FR_OK;
    1024:	e3a00006 	mov	r0, #6	; 0x6
}
    1028:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
		}
	} while (next_dir_entry(dj));		/* Next directory pointer */
	/* Reached to end of the directory table */

	/* Abort when it is a static table or could not stretch dynamic table */
	if (clust == 0 || !(clust = create_chain(fs, dj->clust))) return FR_DENIED;
    102c:	e594100c 	ldr	r1, [r4, #12]
    1030:	e1a00005 	mov	r0, r5
    1034:	ebffff6b 	bl	de8 <create_chain>
    1038:	e2504000 	subs	r4, r0, #0	; 0x0
    103c:	0afffff8 	beq	1024 <reserve_direntry+0xac>
	if (clust == 1 || !move_window(fs, 0)) return FR_RW_ERROR;
    1040:	e3540001 	cmp	r4, #1	; 0x1
    1044:	0a000020 	beq	10cc <reserve_direntry+0x154>
    1048:	e1a00005 	mov	r0, r5
    104c:	e1a01006 	mov	r1, r6
    1050:	ebfffe3d 	bl	94c <move_window>
    1054:	e3500000 	cmp	r0, #0	; 0x0
    1058:	0a00001b 	beq	10cc <reserve_direntry+0x154>
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    105c:	e595300c 	ldr	r3, [r5, #12]
DWORD clust2sect (	/* !=0: sector number, 0: failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
    1060:	e2440002 	sub	r0, r4, #2	; 0x2
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    1064:	e2433002 	sub	r3, r3, #2	; 0x2
    1068:	e1500003 	cmp	r0, r3
	return clust * fs->csize + fs->database;
    106c:	35d5202b 	ldrbcc	r2, [r5, #43]
    1070:	35953018 	ldrcc	r3, [r5, #24]
    1074:	30263092 	mlacc	r6, r2, r0, r3
	if (clust == 0 || !(clust = create_chain(fs, dj->clust))) return FR_DENIED;
	if (clust == 1 || !move_window(fs, 0)) return FR_RW_ERROR;

	/* Cleanup the expanded table */
	fs->winsect = sector = clust2sect(fs, clust);
	memset(fs->win, 0, SS(fs));
    1078:	e2857030 	add	r7, r5, #48	; 0x30
	/* Abort when it is a static table or could not stretch dynamic table */
	if (clust == 0 || !(clust = create_chain(fs, dj->clust))) return FR_DENIED;
	if (clust == 1 || !move_window(fs, 0)) return FR_RW_ERROR;

	/* Cleanup the expanded table */
	fs->winsect = sector = clust2sect(fs, clust);
    107c:	e5856004 	str	r6, [r5, #4]
	memset(fs->win, 0, SS(fs));
    1080:	e1a00007 	mov	r0, r7
    1084:	e3a01000 	mov	r1, #0	; 0x0
    1088:	e3a02c02 	mov	r2, #512	; 0x200
    108c:	eb0010b2 	bl	535c <memset>
	for (n = fs->csize; n; n--) {
    1090:	e5d5402b 	ldrb	r4, [r5, #43]
    1094:	e3540000 	cmp	r4, #0	; 0x0
    1098:	1a000002 	bne	10a8 <reserve_direntry+0x130>
    109c:	ea00000f 	b	10e0 <reserve_direntry+0x168>
    10a0:	e21340ff 	ands	r4, r3, #255	; 0xff
    10a4:	0a00000d 	beq	10e0 <reserve_direntry+0x168>
		if (disk_write(fs->drive, fs->win, sector, 1) != RES_OK)
    10a8:	e1a02006 	mov	r2, r6
    10ac:	e3a03001 	mov	r3, #1	; 0x1
    10b0:	e5d5002d 	ldrb	r0, [r5, #45]
    10b4:	e1a01007 	mov	r1, r7
    10b8:	eb000525 	bl	2554 <disk_write>
    10bc:	e3500000 	cmp	r0, #0	; 0x0
	if (clust == 1 || !move_window(fs, 0)) return FR_RW_ERROR;

	/* Cleanup the expanded table */
	fs->winsect = sector = clust2sect(fs, clust);
	memset(fs->win, 0, SS(fs));
	for (n = fs->csize; n; n--) {
    10c0:	e2443001 	sub	r3, r4, #1	; 0x1
		if (disk_write(fs->drive, fs->win, sector, 1) != RES_OK)
			return FR_RW_ERROR;
		sector++;
    10c4:	e2866001 	add	r6, r6, #1	; 0x1

	/* Cleanup the expanded table */
	fs->winsect = sector = clust2sect(fs, clust);
	memset(fs->win, 0, SS(fs));
	for (n = fs->csize; n; n--) {
		if (disk_write(fs->drive, fs->win, sector, 1) != RES_OK)
    10c8:	0afffff4 	beq	10a0 <reserve_direntry+0x128>
		sector++;
	}
	fs->winflag = 1;
	*dir = fs->win;

	return FR_OK;
    10cc:	e3a00008 	mov	r0, #8	; 0x8
    10d0:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
	do {
		if (!move_window(fs, dj->sect)) return FR_RW_ERROR;
		dptr = &fs->win[(dj->index & ((SS(dj->fs) - 1) / 32)) * 32];	/* Pointer to the directory entry */
		c = dptr[DIR_Name];
		if (c == 0 || c == 0xE5) {		/* Found an empty entry */
			*dir = dptr; return FR_OK;
    10d4:	e5883000 	str	r3, [r8]
    10d8:	e3a00000 	mov	r0, #0	; 0x0
    10dc:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
	for (n = fs->csize; n; n--) {
		if (disk_write(fs->drive, fs->win, sector, 1) != RES_OK)
			return FR_RW_ERROR;
		sector++;
	}
	fs->winflag = 1;
    10e0:	e3a03001 	mov	r3, #1	; 0x1
    10e4:	e5c5302e 	strb	r3, [r5, #46]
	*dir = fs->win;
    10e8:	e3a00000 	mov	r0, #0	; 0x0
    10ec:	e5887000 	str	r7, [r8]
    10f0:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}

000010f4 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_RW_ERROR: failed */
	FATFS *fs	/* File system object */
)
{
    10f4:	e1a0c00d 	mov	ip, sp
    10f8:	e92ddff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
    10fc:	e24cb004 	sub	fp, ip, #4	; 0x4
    1100:	e24dd01c 	sub	sp, sp, #28	; 0x1c
	fs->winflag = 1;
    1104:	e3a09001 	mov	r9, #1	; 0x1
	if (!move_window(fs, 0)) return FR_RW_ERROR;
    1108:	e3a01000 	mov	r1, #0	; 0x0
static
FRESULT sync (	/* FR_OK: successful, FR_RW_ERROR: failed */
	FATFS *fs	/* File system object */
)
{
	fs->winflag = 1;
    110c:	e5c0902e 	strb	r9, [r0, #46]
	if (!move_window(fs, 0)) return FR_RW_ERROR;
    1110:	e50b0044 	str	r0, [fp, #-68]
    1114:	ebfffe0c 	bl	94c <move_window>
    1118:	e3500000 	cmp	r0, #0	; 0x0
    111c:	e51bc044 	ldr	ip, [fp, #-68]
    1120:	0a00000a 	beq	1150 <sync+0x5c>
#if _USE_FSINFO
	/* Update FSInfo sector if needed */
	if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    1124:	e5dc302a 	ldrb	r3, [ip, #42]
    1128:	e3530003 	cmp	r3, #3	; 0x3
    112c:	0a000009 	beq	1158 <sync+0x64>
		disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
		fs->fsi_flag = 0;
	}
#endif
	/* Make sure that no pending write process in the physical drive */
	if (disk_ioctl(fs->drive, CTRL_SYNC, NULL) != RES_OK)
    1130:	e3a01000 	mov	r1, #0	; 0x0
    1134:	e5dc002d 	ldrb	r0, [ip, #45]
    1138:	e1a02001 	mov	r2, r1
    113c:	eb000479 	bl	2328 <disk_ioctl>
    1140:	e3500000 	cmp	r0, #0	; 0x0
    1144:	1a000001 	bne	1150 <sync+0x5c>
		return FR_RW_ERROR;
	return FR_OK;
}
    1148:	e24bd028 	sub	sp, fp, #40	; 0x28
    114c:	e89daff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
		disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
		fs->fsi_flag = 0;
	}
#endif
	/* Make sure that no pending write process in the physical drive */
	if (disk_ioctl(fs->drive, CTRL_SYNC, NULL) != RES_OK)
    1150:	e3a00008 	mov	r0, #8	; 0x8
    1154:	eafffffb 	b	1148 <sync+0x54>
{
	fs->winflag = 1;
	if (!move_window(fs, 0)) return FR_RW_ERROR;
#if _USE_FSINFO
	/* Update FSInfo sector if needed */
	if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    1158:	e5dc3028 	ldrb	r3, [ip, #40]
    115c:	e3530000 	cmp	r3, #0	; 0x0
    1160:	0afffff2 	beq	1130 <sync+0x3c>
		fs->winsect = 0;
		memset(fs->win, 0, 512);
    1164:	e28c7030 	add	r7, ip, #48	; 0x30
	fs->winflag = 1;
	if (!move_window(fs, 0)) return FR_RW_ERROR;
#if _USE_FSINFO
	/* Update FSInfo sector if needed */
	if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
		fs->winsect = 0;
    1168:	e3a06000 	mov	r6, #0	; 0x0
    116c:	e58c6004 	str	r6, [ip, #4]
		memset(fs->win, 0, 512);
    1170:	e1a01006 	mov	r1, r6
    1174:	e3a02c02 	mov	r2, #512	; 0x200
    1178:	e1a00007 	mov	r0, r7
    117c:	eb001076 	bl	535c <memset>
		ST_WORD(&fs->win[BS_55AA], 0xAA55);
		ST_DWORD(&fs->win[FSI_LeadSig], 0x41615252);
		ST_DWORD(&fs->win[FSI_StrucSig], 0x61417272);
		ST_DWORD(&fs->win[FSI_Free_Count], fs->free_clust);
    1180:	e51bc044 	ldr	ip, [fp, #-68]
    1184:	e5dc2022 	ldrb	r2, [ip, #34]
    1188:	e5dc3023 	ldrb	r3, [ip, #35]
    118c:	e50b2040 	str	r2, [fp, #-64]
    1190:	e50b303c 	str	r3, [fp, #-60]
		ST_DWORD(&fs->win[FSI_Nxt_Free], fs->last_clust);
    1194:	e5dc201c 	ldrb	r2, [ip, #28]
    1198:	e5dc301d 	ldrb	r3, [ip, #29]
    119c:	e50b2038 	str	r2, [fp, #-56]
    11a0:	e50b3034 	str	r3, [fp, #-52]
    11a4:	e5dc201e 	ldrb	r2, [ip, #30]
    11a8:	e5dc301f 	ldrb	r3, [ip, #31]
		fs->winsect = 0;
		memset(fs->win, 0, 512);
		ST_WORD(&fs->win[BS_55AA], 0xAA55);
		ST_DWORD(&fs->win[FSI_LeadSig], 0x41615252);
		ST_DWORD(&fs->win[FSI_StrucSig], 0x61417272);
		ST_DWORD(&fs->win[FSI_Free_Count], fs->free_clust);
    11ac:	e5dc8020 	ldrb	r8, [ip, #32]
    11b0:	e5dca021 	ldrb	sl, [ip, #33]
		ST_DWORD(&fs->win[FSI_Nxt_Free], fs->last_clust);
    11b4:	e50b2030 	str	r2, [fp, #-48]
    11b8:	e50b302c 	str	r3, [fp, #-44]
	/* Update FSInfo sector if needed */
	if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
		fs->winsect = 0;
		memset(fs->win, 0, 512);
		ST_WORD(&fs->win[BS_55AA], 0xAA55);
		ST_DWORD(&fs->win[FSI_LeadSig], 0x41615252);
    11bc:	e3a00052 	mov	r0, #82	; 0x52
		ST_DWORD(&fs->win[FSI_StrucSig], 0x61417272);
    11c0:	e3a0e072 	mov	lr, #114	; 0x72
	/* Update FSInfo sector if needed */
	if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
		fs->winsect = 0;
		memset(fs->win, 0, 512);
		ST_WORD(&fs->win[BS_55AA], 0xAA55);
		ST_DWORD(&fs->win[FSI_LeadSig], 0x41615252);
    11c4:	e3a05061 	mov	r5, #97	; 0x61
    11c8:	e3a04041 	mov	r4, #65	; 0x41
#if _USE_FSINFO
	/* Update FSInfo sector if needed */
	if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
		fs->winsect = 0;
		memset(fs->win, 0, 512);
		ST_WORD(&fs->win[BS_55AA], 0xAA55);
    11cc:	e3a03055 	mov	r3, #85	; 0x55
    11d0:	e3e02055 	mvn	r2, #85	; 0x55
    11d4:	e5cc322e 	strb	r3, [ip, #558]
    11d8:	e5cc222f 	strb	r2, [ip, #559]
		ST_DWORD(&fs->win[FSI_LeadSig], 0x41615252);
    11dc:	e5cc0030 	strb	r0, [ip, #48]
    11e0:	e5cc0031 	strb	r0, [ip, #49]
    11e4:	e5cc5032 	strb	r5, [ip, #50]
    11e8:	e5cc4033 	strb	r4, [ip, #51]
		ST_DWORD(&fs->win[FSI_StrucSig], 0x61417272);
    11ec:	e5cce214 	strb	lr, [ip, #532]
    11f0:	e5cce215 	strb	lr, [ip, #533]
    11f4:	e5cc4216 	strb	r4, [ip, #534]
    11f8:	e5cc5217 	strb	r5, [ip, #535]
		ST_DWORD(&fs->win[FSI_Free_Count], fs->free_clust);
    11fc:	e5cc8218 	strb	r8, [ip, #536]
    1200:	e5cca219 	strb	sl, [ip, #537]
    1204:	e51b2040 	ldr	r2, [fp, #-64]
    1208:	e5cc221a 	strb	r2, [ip, #538]
    120c:	e51b203c 	ldr	r2, [fp, #-60]
    1210:	e5cc221b 	strb	r2, [ip, #539]
		ST_DWORD(&fs->win[FSI_Nxt_Free], fs->last_clust);
    1214:	e51b2038 	ldr	r2, [fp, #-56]
    1218:	e5cc221c 	strb	r2, [ip, #540]
    121c:	e51b2034 	ldr	r2, [fp, #-52]
    1220:	e5cc221d 	strb	r2, [ip, #541]
    1224:	e51b2030 	ldr	r2, [fp, #-48]
    1228:	e5cc221e 	strb	r2, [ip, #542]
    122c:	e51b202c 	ldr	r2, [fp, #-44]
		disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
    1230:	e5dc002d 	ldrb	r0, [ip, #45]
		memset(fs->win, 0, 512);
		ST_WORD(&fs->win[BS_55AA], 0xAA55);
		ST_DWORD(&fs->win[FSI_LeadSig], 0x41615252);
		ST_DWORD(&fs->win[FSI_StrucSig], 0x61417272);
		ST_DWORD(&fs->win[FSI_Free_Count], fs->free_clust);
		ST_DWORD(&fs->win[FSI_Nxt_Free], fs->last_clust);
    1234:	e5cc221f 	strb	r2, [ip, #543]
		disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
    1238:	e1a01007 	mov	r1, r7
    123c:	e59c2024 	ldr	r2, [ip, #36]
    1240:	e1a03009 	mov	r3, r9
    1244:	e50bc044 	str	ip, [fp, #-68]
    1248:	eb0004c1 	bl	2554 <disk_write>
		fs->fsi_flag = 0;
    124c:	e51bc044 	ldr	ip, [fp, #-68]
    1250:	e5cc6028 	strb	r6, [ip, #40]
    1254:	eaffffb5 	b	1130 <sync+0x3c>

00001258 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
    1258:	e1a0c00d 	mov	ip, sp
    125c:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
    1260:	e1a05000 	mov	r5, r0
    1264:	e24cb004 	sub	fp, ip, #4	; 0x4
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    1268:	e5900004 	ldr	r0, [r0, #4]
    126c:	e1d510b0 	ldrh	r1, [r5]
    1270:	ebfffda2 	bl	900 <validate>
	if (res == FR_OK) {
    1274:	e3500000 	cmp	r0, #0	; 0x0
    1278:	189da830 	ldmne	sp, {r4, r5, fp, sp, pc}
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    127c:	e5d53002 	ldrb	r3, [r5, #2]
    1280:	e3130020 	tst	r3, #32	; 0x20
    1284:	089da830 	ldmeq	sp, {r4, r5, fp, sp, pc}
			/* Write back data buffer if needed */
			if (fp->flag & FA__DIRTY) {
    1288:	e3130040 	tst	r3, #64	; 0x40
    128c:	0a00000a 	beq	12bc <f_sync+0x64>
				if (disk_write(fp->fs->drive, fp->buffer, fp->curr_sect, 1) != RES_OK)
    1290:	e5953004 	ldr	r3, [r5, #4]
    1294:	e2851024 	add	r1, r5, #36	; 0x24
    1298:	e5d3002d 	ldrb	r0, [r3, #45]
    129c:	e5952018 	ldr	r2, [r5, #24]
    12a0:	e3a03001 	mov	r3, #1	; 0x1
    12a4:	eb0004aa 	bl	2554 <disk_write>
    12a8:	e3500000 	cmp	r0, #0	; 0x0
    12ac:	1a000007 	bne	12d0 <f_sync+0x78>
					return FR_RW_ERROR;
				fp->flag &= (BYTE)~FA__DIRTY;
    12b0:	e5d53002 	ldrb	r3, [r5, #2]
    12b4:	e3c33040 	bic	r3, r3, #64	; 0x40
    12b8:	e5c53002 	strb	r3, [r5, #2]
			}
			/* Update the directory entry */
			if (!move_window(fp->fs, fp->dir_sect))
    12bc:	e5950004 	ldr	r0, [r5, #4]
    12c0:	e595101c 	ldr	r1, [r5, #28]
    12c4:	ebfffda0 	bl	94c <move_window>
    12c8:	e3500000 	cmp	r0, #0	; 0x0
    12cc:	1a000001 	bne	12d8 <f_sync+0x80>
			ST_WORD(&dir[DIR_FstClusLO], fp->org_clust);	/* Update start cluster */
			ST_WORD(&dir[DIR_FstClusHI], fp->org_clust >> 16);
			tim = get_fattime();					/* Updated time */
			ST_DWORD(&dir[DIR_WrtTime], tim);
			fp->flag &= (BYTE)~FA__WRITTEN;
			res = sync(fp->fs);
    12d0:	e3a00008 	mov	r0, #8	; 0x8
		}
	}
	return res;
}
    12d4:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
				fp->flag &= (BYTE)~FA__DIRTY;
			}
			/* Update the directory entry */
			if (!move_window(fp->fs, fp->dir_sect))
				return FR_RW_ERROR;
			dir = fp->dir_ptr;
    12d8:	e5954020 	ldr	r4, [r5, #32]
			dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
    12dc:	e5d4300b 	ldrb	r3, [r4, #11]
    12e0:	e3833020 	orr	r3, r3, #32	; 0x20
    12e4:	e5c4300b 	strb	r3, [r4, #11]
			ST_DWORD(&dir[DIR_FileSize], fp->fsize);		/* Update file size */
    12e8:	e5d5200c 	ldrb	r2, [r5, #12]
    12ec:	e5c4201c 	strb	r2, [r4, #28]
    12f0:	e5d5300d 	ldrb	r3, [r5, #13]
    12f4:	e5c4301d 	strb	r3, [r4, #29]
    12f8:	e5d5200e 	ldrb	r2, [r5, #14]
    12fc:	e5c4201e 	strb	r2, [r4, #30]
    1300:	e5d5300f 	ldrb	r3, [r5, #15]
    1304:	e5c4301f 	strb	r3, [r4, #31]
			ST_WORD(&dir[DIR_FstClusLO], fp->org_clust);	/* Update start cluster */
    1308:	e5d52010 	ldrb	r2, [r5, #16]
    130c:	e5c4201a 	strb	r2, [r4, #26]
    1310:	e5d53011 	ldrb	r3, [r5, #17]
    1314:	e5c4301b 	strb	r3, [r4, #27]
			ST_WORD(&dir[DIR_FstClusHI], fp->org_clust >> 16);
    1318:	e5d52012 	ldrb	r2, [r5, #18]
    131c:	e5c42014 	strb	r2, [r4, #20]
    1320:	e5d53013 	ldrb	r3, [r5, #19]
    1324:	e5c43015 	strb	r3, [r4, #21]
			tim = get_fattime();					/* Updated time */
    1328:	eb000584 	bl	2940 <get_fattime>
			ST_DWORD(&dir[DIR_WrtTime], tim);
    132c:	e1a03800 	lsl	r3, r0, #16
    1330:	e1a02820 	lsr	r2, r0, #16
    1334:	e1a01c20 	lsr	r1, r0, #24
    1338:	e1a03c23 	lsr	r3, r3, #24
    133c:	e20220ff 	and	r2, r2, #255	; 0xff
    1340:	e20000ff 	and	r0, r0, #255	; 0xff
    1344:	e5c40016 	strb	r0, [r4, #22]
    1348:	e5c43017 	strb	r3, [r4, #23]
    134c:	e5c42018 	strb	r2, [r4, #24]
    1350:	e5c41019 	strb	r1, [r4, #25]
			fp->flag &= (BYTE)~FA__WRITTEN;
    1354:	e5d53002 	ldrb	r3, [r5, #2]
			res = sync(fp->fs);
    1358:	e5950004 	ldr	r0, [r5, #4]
			ST_DWORD(&dir[DIR_FileSize], fp->fsize);		/* Update file size */
			ST_WORD(&dir[DIR_FstClusLO], fp->org_clust);	/* Update start cluster */
			ST_WORD(&dir[DIR_FstClusHI], fp->org_clust >> 16);
			tim = get_fattime();					/* Updated time */
			ST_DWORD(&dir[DIR_WrtTime], tim);
			fp->flag &= (BYTE)~FA__WRITTEN;
    135c:	e3c33020 	bic	r3, r3, #32	; 0x20
    1360:	e5c53002 	strb	r3, [r5, #2]
			res = sync(fp->fs);
		}
	}
	return res;
}
    1364:	e89d6830 	ldm	sp, {r4, r5, fp, sp, lr}
			ST_WORD(&dir[DIR_FstClusLO], fp->org_clust);	/* Update start cluster */
			ST_WORD(&dir[DIR_FstClusHI], fp->org_clust >> 16);
			tim = get_fattime();					/* Updated time */
			ST_DWORD(&dir[DIR_WrtTime], tim);
			fp->flag &= (BYTE)~FA__WRITTEN;
			res = sync(fp->fs);
    1368:	eaffff61 	b	10f4 <sync>

0000136c <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    136c:	e1a0c00d 	mov	ip, sp
    1370:	e92dd810 	push	{r4, fp, ip, lr, pc}
    1374:	e24cb004 	sub	fp, ip, #4	; 0x4
    1378:	e1a04000 	mov	r4, r0
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);
    137c:	ebffffb5 	bl	1258 <f_sync>
#else
	res = validate(fp->fs, fp->id);
#endif
	if (res == FR_OK) fp->fs = NULL;
    1380:	e3500000 	cmp	r0, #0	; 0x0
    1384:	05840004 	streq	r0, [r4, #4]
	return res;
}
    1388:	e89da810 	ldm	sp, {r4, fp, sp, pc}

0000138c <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
    138c:	e1a0c00d 	mov	ip, sp
    1390:	e92ddff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
    1394:	e24cb004 	sub	fp, ip, #4	; 0x4
    1398:	e24dd004 	sub	sp, sp, #4	; 0x4
    139c:	e1a05000 	mov	r5, r0
    13a0:	e1a0a003 	mov	sl, r3
	DWORD clust, sect;
	UINT wcnt, cc;
	const BYTE *wbuff = buff;


	*bw = 0;
    13a4:	e3a03000 	mov	r3, #0	; 0x0
    13a8:	e58a3000 	str	r3, [sl]
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
    13ac:	e1a04001 	mov	r4, r1
	UINT wcnt, cc;
	const BYTE *wbuff = buff;


	*bw = 0;
	res = validate(fp->fs, fp->id);					/* Check validity of the object */
    13b0:	e5900004 	ldr	r0, [r0, #4]
    13b4:	e1d510b0 	ldrh	r1, [r5]
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
    13b8:	e1a06002 	mov	r6, r2
	UINT wcnt, cc;
	const BYTE *wbuff = buff;


	*bw = 0;
	res = validate(fp->fs, fp->id);					/* Check validity of the object */
    13bc:	ebfffd4f 	bl	900 <validate>
	if (res != FR_OK) return res;
    13c0:	e2509000 	subs	r9, r0, #0	; 0x0
    13c4:	1a00005f 	bne	1548 <f_write+0x1bc>
	if (fp->flag & FA__ERROR) return FR_RW_ERROR;	/* Check error flag */
    13c8:	e5d53002 	ldrb	r3, [r5, #2]
    13cc:	e3130080 	tst	r3, #128	; 0x80
    13d0:	1a000097 	bne	1634 <f_write+0x2a8>
	if (!(fp->flag & FA_WRITE)) return FR_DENIED;	/* Check access mode */
    13d4:	e3130002 	tst	r3, #2	; 0x2
    13d8:	03a09006 	moveq	r9, #6	; 0x6
    13dc:	0a000059 	beq	1548 <f_write+0x1bc>
	if (fp->fsize + btw < fp->fsize) return FR_OK;	/* File size cannot reach 4GB */
    13e0:	e595200c 	ldr	r2, [r5, #12]
    13e4:	e1760002 	cmn	r6, r2
    13e8:	2a000056 	bcs	1548 <f_write+0x1bc>

	for ( ;  btw;									/* Repeat until all data transferred */
    13ec:	e3560000 	cmp	r6, #0	; 0x0
    13f0:	0a00006f 	beq	15b4 <f_write+0x228>
				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
				continue;
			}
			if (sect != fp->curr_sect) {			/* Is window offset changed? */
				if (fp->flag & FA__DIRTY) {			/* Write back file I/O buffer if needed */
					if (disk_write(fp->fs->drive, fp->buffer, fp->curr_sect, 1) != RES_OK)
    13f4:	e2853024 	add	r3, r5, #36	; 0x24
    13f8:	e5951008 	ldr	r1, [r5, #8]
)
{
	FRESULT res;
	DWORD clust, sect;
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
    13fc:	e1a08004 	mov	r8, r4
				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
				continue;
			}
			if (sect != fp->curr_sect) {			/* Is window offset changed? */
				if (fp->flag & FA__DIRTY) {			/* Write back file I/O buffer if needed */
					if (disk_write(fp->fs->drive, fp->buffer, fp->curr_sect, 1) != RES_OK)
    1400:	e50b302c 	str	r3, [fp, #-44]
    1404:	ea000038 	b	14ec <f_write+0x160>
	if (fp->fsize + btw < fp->fsize) return FR_OK;	/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
    1408:	e595e004 	ldr	lr, [r5, #4]
    140c:	e5d5c003 	ldrb	ip, [r5, #3]
    1410:	e5de302b 	ldrb	r3, [lr, #43]
    1414:	e153000c 	cmp	r3, ip
    1418:	8a00000f 	bhi	145c <f_write+0xd0>
				if (fp->fptr == 0) {				/* On the top of the file? */
    141c:	e3510000 	cmp	r1, #0	; 0x0
    1420:	1a00005c 	bne	1598 <f_write+0x20c>
					clust = fp->org_clust;			/* Follow from the origin */
    1424:	e5950010 	ldr	r0, [r5, #16]
					if (clust == 0)					/* When there is no cluster chain, */
    1428:	e3500000 	cmp	r0, #0	; 0x0
    142c:	0a000062 	beq	15bc <f_write+0x230>
						fp->org_clust = clust = create_chain(fp->fs, 0);	/* Create a new cluster chain */
				} else {							/* Middle or end of the file */
					clust = create_chain(fp->fs, fp->curr_clust);			/* Trace or streach cluster chain */
				}
				if (clust == 0) break;				/* Could not allocate a new cluster (disk full) */
				if (clust == 1 || clust >= fp->fs->max_clust) goto fw_error;
    1430:	e3500001 	cmp	r0, #1	; 0x1
    1434:	0a00007a 	beq	1624 <f_write+0x298>
    1438:	e5952004 	ldr	r2, [r5, #4]
    143c:	e592300c 	ldr	r3, [r2, #12]
    1440:	e1530000 	cmp	r3, r0
    1444:	9a000076 	bls	1624 <f_write+0x298>
				fp->curr_clust = clust;				/* Update current cluster */
				fp->csect = 0;						/* Reset sector address in the cluster */
    1448:	e3a03000 	mov	r3, #0	; 0x0
				} else {							/* Middle or end of the file */
					clust = create_chain(fp->fs, fp->curr_clust);			/* Trace or streach cluster chain */
				}
				if (clust == 0) break;				/* Could not allocate a new cluster (disk full) */
				if (clust == 1 || clust >= fp->fs->max_clust) goto fw_error;
				fp->curr_clust = clust;				/* Update current cluster */
    144c:	e5850014 	str	r0, [r5, #20]
				fp->csect = 0;						/* Reset sector address in the cluster */
    1450:	e5c53003 	strb	r3, [r5, #3]
    1454:	e1a0e002 	mov	lr, r2
    1458:	e3a0c000 	mov	ip, #0	; 0x0
DWORD clust2sect (	/* !=0: sector number, 0: failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
    145c:	e5952014 	ldr	r2, [r5, #20]
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    1460:	e59e300c 	ldr	r3, [lr, #12]
DWORD clust2sect (	/* !=0: sector number, 0: failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
    1464:	e2420002 	sub	r0, r2, #2	; 0x2
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    1468:	e2433002 	sub	r3, r3, #2	; 0x2
    146c:	e1500003 	cmp	r0, r3
	return clust * fs->csize + fs->database;
    1470:	35de202b 	ldrbcc	r2, [lr, #43]
    1474:	359e3018 	ldrcc	r3, [lr, #24]
    1478:	30213290 	mlacc	r1, r0, r2, r3
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    147c:	23a01000 	movcs	r1, #0	; 0x0
				fp->curr_clust = clust;				/* Update current cluster */
				fp->csect = 0;						/* Reset sector address in the cluster */
			}
			sect = clust2sect(fp->fs, fp->curr_clust) + fp->csect;	/* Get current sector */
			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
			if (cc) {								/* Write maximum contiguous sectors directly */
    1480:	e1b044a6 	lsrs	r4, r6, #9
				if (clust == 0) break;				/* Could not allocate a new cluster (disk full) */
				if (clust == 1 || clust >= fp->fs->max_clust) goto fw_error;
				fp->curr_clust = clust;				/* Update current cluster */
				fp->csect = 0;						/* Reset sector address in the cluster */
			}
			sect = clust2sect(fp->fs, fp->curr_clust) + fp->csect;	/* Get current sector */
    1484:	e081700c 	add	r7, r1, ip
			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
			if (cc) {								/* Write maximum contiguous sectors directly */
    1488:	0a000030 	beq	1550 <f_write+0x1c4>
				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    148c:	e5de202b 	ldrb	r2, [lr, #43]
    1490:	e08c3004 	add	r3, ip, r4
    1494:	e1530002 	cmp	r3, r2
					cc = fp->fs->csize - fp->csect;
    1498:	806c4002 	rsbhi	r4, ip, r2
				if (disk_write(fp->fs->drive, wbuff, sect, (BYTE)cc) != RES_OK)
    149c:	e20430ff 	and	r3, r4, #255	; 0xff
    14a0:	e5de002d 	ldrb	r0, [lr, #45]
    14a4:	e1a02007 	mov	r2, r7
    14a8:	e1a01008 	mov	r1, r8
    14ac:	eb000428 	bl	2554 <disk_write>
    14b0:	e3500000 	cmp	r0, #0	; 0x0
    14b4:	1a00005a 	bne	1624 <f_write+0x298>
					goto fw_error;
				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
    14b8:	e5d53003 	ldrb	r3, [r5, #3]
    14bc:	e0843003 	add	r3, r4, r3
    14c0:	e5c53003 	strb	r3, [r5, #3]
				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
    14c4:	e1a04484 	lsl	r4, r4, #9
	if (fp->flag & FA__ERROR) return FR_RW_ERROR;	/* Check error flag */
	if (!(fp->flag & FA_WRITE)) return FR_DENIED;	/* Check access mode */
	if (fp->fsize + btw < fp->fsize) return FR_OK;	/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    14c8:	e5951008 	ldr	r1, [r5, #8]
    14cc:	e59a3000 	ldr	r3, [sl]
    14d0:	e0811004 	add	r1, r1, r4
    14d4:	e0833004 	add	r3, r3, r4
	if (res != FR_OK) return res;
	if (fp->flag & FA__ERROR) return FR_RW_ERROR;	/* Check error flag */
	if (!(fp->flag & FA_WRITE)) return FR_DENIED;	/* Check access mode */
	if (fp->fsize + btw < fp->fsize) return FR_OK;	/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
    14d8:	e0566004 	subs	r6, r6, r4
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    14dc:	e58a3000 	str	r3, [sl]
    14e0:	e5851008 	str	r1, [r5, #8]
	if (res != FR_OK) return res;
	if (fp->flag & FA__ERROR) return FR_RW_ERROR;	/* Check error flag */
	if (!(fp->flag & FA_WRITE)) return FR_DENIED;	/* Check access mode */
	if (fp->fsize + btw < fp->fsize) return FR_OK;	/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
    14e4:	0a000011 	beq	1530 <f_write+0x1a4>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    14e8:	e0888004 	add	r8, r8, r4
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
    14ec:	e1a00b81 	lsl	r0, r1, #23
    14f0:	e1a00ba0 	lsr	r0, r0, #23
    14f4:	e3500000 	cmp	r0, #0	; 0x0
    14f8:	0affffc2 	beq	1408 <f_write+0x7c>
						goto fw_error;
				fp->curr_sect = sect;
			}
			fp->csect++;							/* Next sector address in the cluster */
		}
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Put partial sector into file I/O buffer */
    14fc:	e2603c02 	rsb	r3, r0, #512	; 0x200
    1500:	e1530006 	cmp	r3, r6
    1504:	31a04003 	movcc	r4, r3
    1508:	21a04006 	movcs	r4, r6
		if (wcnt > btw) wcnt = btw;
		memcpy(&fp->buffer[fp->fptr % SS(fp->fs)], wbuff, wcnt);
    150c:	e2800024 	add	r0, r0, #36	; 0x24
    1510:	e0850000 	add	r0, r5, r0
    1514:	e1a01008 	mov	r1, r8
    1518:	e1a02004 	mov	r2, r4
    151c:	eb000f4f 	bl	5260 <memcpy>
		fp->flag |= FA__DIRTY;
    1520:	e5d53002 	ldrb	r3, [r5, #2]
    1524:	e3833040 	orr	r3, r3, #64	; 0x40
    1528:	e5c53002 	strb	r3, [r5, #2]
    152c:	eaffffe5 	b	14c8 <f_write+0x13c>
	if (fp->flag & FA__ERROR) return FR_RW_ERROR;	/* Check error flag */
	if (!(fp->flag & FA_WRITE)) return FR_DENIED;	/* Check access mode */
	if (fp->fsize + btw < fp->fsize) return FR_OK;	/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    1530:	e595200c 	ldr	r2, [r5, #12]
    1534:	e5d53002 	ldrb	r3, [r5, #2]
		if (wcnt > btw) wcnt = btw;
		memcpy(&fp->buffer[fp->fptr % SS(fp->fs)], wbuff, wcnt);
		fp->flag |= FA__DIRTY;
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    1538:	e1520001 	cmp	r2, r1
	fp->flag |= FA__WRITTEN;						/* Set file changed flag */
    153c:	e3833020 	orr	r3, r3, #32	; 0x20
		if (wcnt > btw) wcnt = btw;
		memcpy(&fp->buffer[fp->fptr % SS(fp->fs)], wbuff, wcnt);
		fp->flag |= FA__DIRTY;
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    1540:	3585100c 	strcc	r1, [r5, #12]
	fp->flag |= FA__WRITTEN;						/* Set file changed flag */
    1544:	e5c53002 	strb	r3, [r5, #2]
	return FR_OK;

fw_error:	/* Abort this file due to an unrecoverable error */
	fp->flag |= FA__ERROR;
	return FR_RW_ERROR;
}
    1548:	e1a00009 	mov	r0, r9
    154c:	e89daff8 	ldm	sp, {r3, r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
					goto fw_error;
				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
				continue;
			}
			if (sect != fp->curr_sect) {			/* Is window offset changed? */
    1550:	e5952018 	ldr	r2, [r5, #24]
    1554:	e1520007 	cmp	r2, r7
    1558:	05951008 	ldreq	r1, [r5, #8]
    155c:	0a000008 	beq	1584 <f_write+0x1f8>
				if (fp->flag & FA__DIRTY) {			/* Write back file I/O buffer if needed */
    1560:	e5d53002 	ldrb	r3, [r5, #2]
    1564:	e3130040 	tst	r3, #64	; 0x40
    1568:	1a000017 	bne	15cc <f_write+0x240>
					if (disk_write(fp->fs->drive, fp->buffer, fp->curr_sect, 1) != RES_OK)
						goto fw_error;
					fp->flag &= (BYTE)~FA__DIRTY;
				}
				if (fp->fptr < fp->fsize &&  		/* Fill file I/O buffer with file data */
    156c:	e2851008 	add	r1, r5, #8	; 0x8
    1570:	e891000a 	ldm	r1, {r1, r3}
    1574:	e1510003 	cmp	r1, r3
    1578:	3a000020 	bcc	1600 <f_write+0x274>
					disk_read(fp->fs->drive, fp->buffer, sect, 1) != RES_OK)
						goto fw_error;
				fp->curr_sect = sect;
    157c:	e5857018 	str	r7, [r5, #24]
    1580:	e5d5c003 	ldrb	ip, [r5, #3]
			}
			fp->csect++;							/* Next sector address in the cluster */
    1584:	e28c3001 	add	r3, ip, #1	; 0x1
    1588:	e1a00b81 	lsl	r0, r1, #23
    158c:	e5c53003 	strb	r3, [r5, #3]
    1590:	e1a00ba0 	lsr	r0, r0, #23
    1594:	eaffffd8 	b	14fc <f_write+0x170>
				if (fp->fptr == 0) {				/* On the top of the file? */
					clust = fp->org_clust;			/* Follow from the origin */
					if (clust == 0)					/* When there is no cluster chain, */
						fp->org_clust = clust = create_chain(fp->fs, 0);	/* Create a new cluster chain */
				} else {							/* Middle or end of the file */
					clust = create_chain(fp->fs, fp->curr_clust);			/* Trace or streach cluster chain */
    1598:	e1a0000e 	mov	r0, lr
    159c:	e5951014 	ldr	r1, [r5, #20]
    15a0:	ebfffe10 	bl	de8 <create_chain>
				}
				if (clust == 0) break;				/* Could not allocate a new cluster (disk full) */
    15a4:	e3500000 	cmp	r0, #0	; 0x0
    15a8:	1affffa0 	bne	1430 <f_write+0xa4>
    15ac:	e595200c 	ldr	r2, [r5, #12]
    15b0:	e5d53002 	ldrb	r3, [r5, #2]
    15b4:	e5951008 	ldr	r1, [r5, #8]
    15b8:	eaffffde 	b	1538 <f_write+0x1ac>
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
				if (fp->fptr == 0) {				/* On the top of the file? */
					clust = fp->org_clust;			/* Follow from the origin */
					if (clust == 0)					/* When there is no cluster chain, */
						fp->org_clust = clust = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    15bc:	e1a0000e 	mov	r0, lr
    15c0:	ebfffe08 	bl	de8 <create_chain>
    15c4:	e5850010 	str	r0, [r5, #16]
    15c8:	eafffff5 	b	15a4 <f_write+0x218>
				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
				continue;
			}
			if (sect != fp->curr_sect) {			/* Is window offset changed? */
				if (fp->flag & FA__DIRTY) {			/* Write back file I/O buffer if needed */
					if (disk_write(fp->fs->drive, fp->buffer, fp->curr_sect, 1) != RES_OK)
    15cc:	e5de002d 	ldrb	r0, [lr, #45]
    15d0:	e51b102c 	ldr	r1, [fp, #-44]
    15d4:	e3a03001 	mov	r3, #1	; 0x1
    15d8:	eb0003dd 	bl	2554 <disk_write>
    15dc:	e3500000 	cmp	r0, #0	; 0x0
    15e0:	1a00000f 	bne	1624 <f_write+0x298>
						goto fw_error;
					fp->flag &= (BYTE)~FA__DIRTY;
    15e4:	e5d53002 	ldrb	r3, [r5, #2]
    15e8:	e3c33040 	bic	r3, r3, #64	; 0x40
    15ec:	e5c53002 	strb	r3, [r5, #2]
				}
				if (fp->fptr < fp->fsize &&  		/* Fill file I/O buffer with file data */
    15f0:	e2851008 	add	r1, r5, #8	; 0x8
    15f4:	e891000a 	ldm	r1, {r1, r3}
    15f8:	e1510003 	cmp	r1, r3
    15fc:	2affffde 	bcs	157c <f_write+0x1f0>
    1600:	e5953004 	ldr	r3, [r5, #4]
    1604:	e51b102c 	ldr	r1, [fp, #-44]
    1608:	e5d3002d 	ldrb	r0, [r3, #45]
    160c:	e1a02007 	mov	r2, r7
    1610:	e3a03001 	mov	r3, #1	; 0x1
    1614:	eb000407 	bl	2638 <disk_read>
    1618:	e3500000 	cmp	r0, #0	; 0x0
    161c:	05951008 	ldreq	r1, [r5, #8]
    1620:	0affffd5 	beq	157c <f_write+0x1f0>
	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file changed flag */
	return FR_OK;

fw_error:	/* Abort this file due to an unrecoverable error */
	fp->flag |= FA__ERROR;
    1624:	e5d53002 	ldrb	r3, [r5, #2]
    1628:	e1e03c83 	mvn	r3, r3, lsl #25
    162c:	e1e03ca3 	mvn	r3, r3, lsr #25
    1630:	e5c53002 	strb	r3, [r5, #2]
    1634:	e3a09008 	mov	r9, #8	; 0x8
	return FR_RW_ERROR;
}
    1638:	e1a00009 	mov	r0, r9
    163c:	e89daff8 	ldm	sp, {r3, r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}

00001640 <check_fs>:
static
BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record or error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    1640:	e1a0c00d 	mov	ip, sp
    1644:	e92dd810 	push	{r4, fp, ip, lr, pc}
    1648:	e1a04000 	mov	r4, r0
    164c:	e1a02001 	mov	r2, r1
    1650:	e24cb004 	sub	fp, ip, #4	; 0x4
	//xprintf(" fspass1 ");
	if (disk_read(fs->drive, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    1654:	e5d0002d 	ldrb	r0, [r0, #45]
    1658:	e2841030 	add	r1, r4, #48	; 0x30
    165c:	e3a03001 	mov	r3, #1	; 0x1
    1660:	eb0003f4 	bl	2638 <disk_read>
    1664:	e3500000 	cmp	r0, #0	; 0x0
    1668:	1a000006 	bne	1688 <check_fs+0x48>
		return 2;
	//xprintf(" fspass2 ");
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)				/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    166c:	e5d4122f 	ldrb	r1, [r4, #559]
    1670:	e5d4222e 	ldrb	r2, [r4, #558]
    1674:	e3a03caa 	mov	r3, #43520	; 0xaa00
    1678:	e1822401 	orr	r2, r2, r1, lsl #8
    167c:	e2833055 	add	r3, r3, #85	; 0x55
    1680:	e1520003 	cmp	r2, r3
    1684:	0a000001 	beq	1690 <check_fs+0x50>
		return 2;
	//xprintf(" fspass3 ");
	if (!memcmp(&fs->win[BS_FilSysType], "FAT", 3))			/* Check FAT signature */
		return 0;
	//xprintf(" fspass4 ");
	if (!memcmp(&fs->win[BS_FilSysType32], "FAT32", 5) && !(fs->win[BPB_ExtFlags] & 0x80))
    1688:	e3a00002 	mov	r0, #2	; 0x2
		return 0;

	return 1;
}
    168c:	e89da810 	ldm	sp, {r4, fp, sp, pc}
		return 2;
	//xprintf(" fspass2 ");
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)				/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
	//xprintf(" fspass3 ");
	if (!memcmp(&fs->win[BS_FilSysType], "FAT", 3))			/* Check FAT signature */
    1690:	e2840066 	add	r0, r4, #102	; 0x66
    1694:	e59f1030 	ldr	r1, [pc, #48]	; 16cc <check_fs+0x8c>
    1698:	e3a02003 	mov	r2, #3	; 0x3
    169c:	eb000ec4 	bl	51b4 <memcmp>
    16a0:	e3500000 	cmp	r0, #0	; 0x0
    16a4:	089da810 	ldmeq	sp, {r4, fp, sp, pc}
		return 0;
	//xprintf(" fspass4 ");
	if (!memcmp(&fs->win[BS_FilSysType32], "FAT32", 5) && !(fs->win[BPB_ExtFlags] & 0x80))
    16a8:	e2840082 	add	r0, r4, #130	; 0x82
    16ac:	e59f101c 	ldr	r1, [pc, #28]	; 16d0 <check_fs+0x90>
    16b0:	e3a02005 	mov	r2, #5	; 0x5
    16b4:	eb000ebe 	bl	51b4 <memcmp>
    16b8:	e3500000 	cmp	r0, #0	; 0x0
    16bc:	05d43058 	ldrbeq	r3, [r4, #88]
    16c0:	13a00001 	movne	r0, #1	; 0x1
    16c4:	01a003a3 	lsreq	r0, r3, #7
    16c8:	e89da810 	ldm	sp, {r4, fp, sp, pc}
    16cc:	000056c8 	.word	0x000056c8
    16d0:	000056cc 	.word	0x000056cc

000016d4 <auto_mount>:
FRESULT auto_mount (	/* FR_OK(0): successful, !=0: any error occured */
	const char **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
    16d4:	e1a0c00d 	mov	ip, sp
    16d8:	e92dd9f0 	push	{r4, r5, r6, r7, r8, fp, ip, lr, pc}
    16dc:	e24cb004 	sub	fp, ip, #4	; 0x4
	BYTE drv, fmt, *tbl;
	DSTATUS stat;
	DWORD bootsect, fatsize, totalsect, maxclust;
	const char *p = *path;
    16e0:	e590c000 	ldr	ip, [r0]
	FATFS *fs;

	//xprintf("pass3");
	/* Get drive number from the path name */
	while (*p == ' ') p++;		/* Strip leading spaces */
    16e4:	e5dc4000 	ldrb	r4, [ip]
    16e8:	e3540020 	cmp	r4, #32	; 0x20
FRESULT auto_mount (	/* FR_OK(0): successful, !=0: any error occured */
	const char **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
    16ec:	e20250ff 	and	r5, r2, #255	; 0xff
	const char *p = *path;
	FATFS *fs;

	//xprintf("pass3");
	/* Get drive number from the path name */
	while (*p == ' ') p++;		/* Strip leading spaces */
    16f0:	1a000002 	bne	1700 <auto_mount+0x2c>
    16f4:	e5fc4001 	ldrb	r4, [ip, #1]!
    16f8:	e3540020 	cmp	r4, #32	; 0x20
    16fc:	0afffffc 	beq	16f4 <auto_mount+0x20>
	drv = p[0] - '0';			/* Is there a drive number? */
    1700:	e2443030 	sub	r3, r4, #48	; 0x30
    1704:	e20320ff 	and	r2, r3, #255	; 0xff
	if (drv <= 9 && p[1] == ':')
    1708:	e3520009 	cmp	r2, #9	; 0x9
    170c:	8a000003 	bhi	1720 <auto_mount+0x4c>
    1710:	e5dc3001 	ldrb	r3, [ip, #1]
    1714:	e353003a 	cmp	r3, #58	; 0x3a
    1718:	05fc4002 	ldrbeq	r4, [ip, #2]!
    171c:	0a000000 	beq	1724 <auto_mount+0x50>
    1720:	e3a02000 	mov	r2, #0	; 0x0
		p += 2;				/* Found a drive number, get and strip it */
	else
		drv = 0;			/* No drive number is given, use drive number 0 as default */
	if (*p == '/') p++;		/* Strip heading slash */
    1724:	e354002f 	cmp	r4, #47	; 0x2f
    1728:	028cc001 	addeq	ip, ip, #1	; 0x1
	*path = p;				/* Return pointer to the path name */
	//xprintf("pass4");
	/* Check if the drive number is valid or not */
	if (drv >= _DRIVES) return FR_INVALID_DRIVE;	/* Is the drive number valid? */
    172c:	e3520000 	cmp	r2, #0	; 0x0
	if (drv <= 9 && p[1] == ':')
		p += 2;				/* Found a drive number, get and strip it */
	else
		drv = 0;			/* No drive number is given, use drive number 0 as default */
	if (*p == '/') p++;		/* Strip heading slash */
	*path = p;				/* Return pointer to the path name */
    1730:	e580c000 	str	ip, [r0]
	//xprintf("pass4");
	/* Check if the drive number is valid or not */
	if (drv >= _DRIVES) return FR_INVALID_DRIVE;	/* Is the drive number valid? */
    1734:	13a00005 	movne	r0, #5	; 0x5
    1738:	189da9f0 	ldmne	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
	*rfs = fs = FatFs[drv];					/* Return pointer to the corresponding file system object */
    173c:	e59f3370 	ldr	r3, [pc, #880]	; 1ab4 <auto_mount+0x3e0>
    1740:	e5937000 	ldr	r7, [r3]
	if (!fs) return FR_NOT_ENABLED;			/* Is the file system object registered? */
    1744:	e3570000 	cmp	r7, #0	; 0x0
	if (*p == '/') p++;		/* Strip heading slash */
	*path = p;				/* Return pointer to the path name */
	//xprintf("pass4");
	/* Check if the drive number is valid or not */
	if (drv >= _DRIVES) return FR_INVALID_DRIVE;	/* Is the drive number valid? */
	*rfs = fs = FatFs[drv];					/* Return pointer to the corresponding file system object */
    1748:	e5817000 	str	r7, [r1]
	if (!fs) return FR_NOT_ENABLED;			/* Is the file system object registered? */
    174c:	03a0000a 	moveq	r0, #10	; 0xa
    1750:	089da9f0 	ldmeq	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
	//xprintf("pass5");
	if (fs->fs_type) {						/* If the logical drive has been mounted */
    1754:	e5d7302a 	ldrb	r3, [r7, #42]
    1758:	e3530000 	cmp	r3, #0	; 0x0
    175c:	1a00001c 	bne	17d4 <auto_mount+0x100>
		}
	}
	//xprintf("pass6");
	/* The logical drive must be re-mounted. Following code attempts to mount the logical drive */

	memset(fs, 0, sizeof(FATFS));		/* Clean-up the file system object */
    1760:	e3a01000 	mov	r1, #0	; 0x0
    1764:	e3a02e23 	mov	r2, #560	; 0x230
    1768:	e1a00007 	mov	r0, r7
    176c:	eb000efa 	bl	535c <memset>
	fs->drive = LD2PD(drv);				/* Bind the logical drive and a physical drive */
    1770:	e3a00000 	mov	r0, #0	; 0x0
    1774:	e5c7002d 	strb	r0, [r7, #45]
	stat = disk_initialize(fs->drive);	/* Initialize low level disk I/O layer */
    1778:	eb0003db 	bl	26ec <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the drive is ready */
    177c:	e3100001 	tst	r0, #1	; 0x1
    1780:	13a00001 	movne	r0, #1	; 0x1
    1784:	189da9f0 	ldmne	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
#if S_MAX_SIZ > 512						/* Get disk sector size if needed */
	if (disk_ioctl(drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > S_MAX_SIZ)
		return FR_NO_FILESYSTEM;
#endif
#if !_FS_READONLY
	if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
    1788:	e3550000 	cmp	r5, #0	; 0x0
    178c:	0a000001 	beq	1798 <auto_mount+0xc4>
    1790:	e3100004 	tst	r0, #4	; 0x4
    1794:	1a000016 	bne	17f4 <auto_mount+0x120>
		return FR_WRITE_PROTECTED;
#endif
	//xprintf("pass7");
	/* Search FAT partition on the drive */
	fmt = check_fs(fs, bootsect = 0);	/* Check sector 0 as an SFD format */
    1798:	e1a00007 	mov	r0, r7
    179c:	e3a01000 	mov	r1, #0	; 0x0
    17a0:	ebffffa6 	bl	1640 <check_fs>

	//xprintf("pass8");
	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
    17a4:	e3500001 	cmp	r0, #1	; 0x1
    17a8:	13a08000 	movne	r8, #0	; 0x0
    17ac:	0a000014 	beq	1804 <auto_mount+0x130>
		if (tbl[4]) {									/* Is the partition existing? */
			bootsect = LD_DWORD(&tbl[8]);				/* Partition offset in LBA */
			fmt = check_fs(fs, bootsect);				/* Check the partition */
		}
	}
	if (fmt || LD_WORD(&fs->win[BPB_BytsPerSec]) != SS(fs))	/* No valid FAT patition is found */
    17b0:	e3500000 	cmp	r0, #0	; 0x0
    17b4:	1a000004 	bne	17cc <auto_mount+0xf8>
    17b8:	e5d7203c 	ldrb	r2, [r7, #60]
    17bc:	e5d7303b 	ldrb	r3, [r7, #59]
    17c0:	e1833402 	orr	r3, r3, r2, lsl #8
    17c4:	e3530c02 	cmp	r3, #512	; 0x200
    17c8:	0a00001c 	beq	1840 <auto_mount+0x16c>
#endif
#endif
	//xprintf("pass10");
	fs->fs_type = fmt;			/* FAT syb-type */
	fs->id = ++fsid;			/* File system mount ID */
	return FR_OK;
    17cc:	e3a0000b 	mov	r0, #11	; 0xb
}
    17d0:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
	if (drv >= _DRIVES) return FR_INVALID_DRIVE;	/* Is the drive number valid? */
	*rfs = fs = FatFs[drv];					/* Return pointer to the corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;			/* Is the file system object registered? */
	//xprintf("pass5");
	if (fs->fs_type) {						/* If the logical drive has been mounted */
		stat = disk_status(fs->drive);
    17d4:	e5d7002d 	ldrb	r0, [r7, #45]
    17d8:	eb000297 	bl	223c <disk_status>
		if (!(stat & STA_NOINIT)) {			/* and physical drive is kept initialized (has not been changed), */
    17dc:	e3100001 	tst	r0, #1	; 0x1
    17e0:	1affffde 	bne	1760 <auto_mount+0x8c>
#if !_FS_READONLY
			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
    17e4:	e3550000 	cmp	r5, #0	; 0x0
    17e8:	0a000003 	beq	17fc <auto_mount+0x128>
    17ec:	e3100004 	tst	r0, #4	; 0x4
    17f0:	0a000001 	beq	17fc <auto_mount+0x128>
#endif
#endif
	//xprintf("pass10");
	fs->fs_type = fmt;			/* FAT syb-type */
	fs->id = ++fsid;			/* File system mount ID */
	return FR_OK;
    17f4:	e3a00009 	mov	r0, #9	; 0x9
    17f8:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
    17fc:	e3a00000 	mov	r0, #0	; 0x0
    1800:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}

	//xprintf("pass8");
	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
		/* Check a partition listed in top of the partition table */
		tbl = &fs->win[MBR_Table + LD2PT(drv) * 16];	/* Partition table */
		if (tbl[4]) {									/* Is the partition existing? */
    1804:	e5d731f2 	ldrb	r3, [r7, #498]
    1808:	e3530000 	cmp	r3, #0	; 0x0
    180c:	0affffee 	beq	17cc <auto_mount+0xf8>
			bootsect = LD_DWORD(&tbl[8]);				/* Partition offset in LBA */
    1810:	e5d711f9 	ldrb	r1, [r7, #505]
    1814:	e5d731f8 	ldrb	r3, [r7, #504]
    1818:	e5d701f7 	ldrb	r0, [r7, #503]
    181c:	e1a03803 	lsl	r3, r3, #16
    1820:	e5d721f6 	ldrb	r2, [r7, #502]
    1824:	e1833c01 	orr	r3, r3, r1, lsl #24
    1828:	e1833002 	orr	r3, r3, r2
    182c:	e1838400 	orr	r8, r3, r0, lsl #8
			fmt = check_fs(fs, bootsect);				/* Check the partition */
    1830:	e1a01008 	mov	r1, r8
    1834:	e1a00007 	mov	r0, r7
    1838:	ebffff80 	bl	1640 <check_fs>
    183c:	eaffffdb 	b	17b0 <auto_mount+0xdc>
		}
	}
	if (fmt || LD_WORD(&fs->win[BPB_BytsPerSec]) != SS(fs))	/* No valid FAT patition is found */
		return FR_NO_FILESYSTEM;
	/* Initialize the file system object */
	fatsize = LD_WORD(&fs->win[BPB_FATSz16]);			/* Number of sectors per FAT */
    1840:	e5d72047 	ldrb	r2, [r7, #71]
    1844:	e5d73046 	ldrb	r3, [r7, #70]
	if (!fatsize) fatsize = LD_DWORD(&fs->win[BPB_FATSz32]);
    1848:	e1935402 	orrs	r5, r3, r2, lsl #8
    184c:	1a000007 	bne	1870 <auto_mount+0x19c>
    1850:	e5d71057 	ldrb	r1, [r7, #87]
    1854:	e5d73056 	ldrb	r3, [r7, #86]
    1858:	e5d70055 	ldrb	r0, [r7, #85]
    185c:	e1a03803 	lsl	r3, r3, #16
    1860:	e5d72054 	ldrb	r2, [r7, #84]
    1864:	e1833c01 	orr	r3, r3, r1, lsl #24
    1868:	e1833002 	orr	r3, r3, r2
    186c:	e1835400 	orr	r5, r3, r0, lsl #8
	fs->sects_fat = fatsize;
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	fatsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
	fs->fatbase = bootsect + LD_WORD(&fs->win[BPB_RsvdSecCnt]); /* FAT start sector (lba) */
    1870:	e5d7003f 	ldrb	r0, [r7, #63]
    1874:	e5d7303e 	ldrb	r3, [r7, #62]
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(&fs->win[BPB_RootEntCnt]);	/* Nmuber of root directory entries */
    1878:	e5d74042 	ldrb	r4, [r7, #66]
    187c:	e5d7c041 	ldrb	ip, [r7, #65]
	totalsect = LD_WORD(&fs->win[BPB_TotSec16]);		/* Number of sectors on the file system */
    1880:	e5d71044 	ldrb	r1, [r7, #68]
    1884:	e5d72043 	ldrb	r2, [r7, #67]
	fatsize = LD_WORD(&fs->win[BPB_FATSz16]);			/* Number of sectors per FAT */
	if (!fatsize) fatsize = LD_DWORD(&fs->win[BPB_FATSz32]);
	fs->sects_fat = fatsize;
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	fatsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
	fs->fatbase = bootsect + LD_WORD(&fs->win[BPB_RsvdSecCnt]); /* FAT start sector (lba) */
    1888:	e1833400 	orr	r3, r3, r0, lsl #8
		return FR_NO_FILESYSTEM;
	/* Initialize the file system object */
	fatsize = LD_WORD(&fs->win[BPB_FATSz16]);			/* Number of sectors per FAT */
	if (!fatsize) fatsize = LD_DWORD(&fs->win[BPB_FATSz32]);
	fs->sects_fat = fatsize;
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
    188c:	e5d7e040 	ldrb	lr, [r7, #64]
	fatsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
	fs->fatbase = bootsect + LD_WORD(&fs->win[BPB_RsvdSecCnt]); /* FAT start sector (lba) */
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
    1890:	e5d7003d 	ldrb	r0, [r7, #61]
	fs->n_rootdir = LD_WORD(&fs->win[BPB_RootEntCnt]);	/* Nmuber of root directory entries */
    1894:	e18cc404 	orr	ip, ip, r4, lsl #8
	fatsize = LD_WORD(&fs->win[BPB_FATSz16]);			/* Number of sectors per FAT */
	if (!fatsize) fatsize = LD_DWORD(&fs->win[BPB_FATSz32]);
	fs->sects_fat = fatsize;
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	fatsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
	fs->fatbase = bootsect + LD_WORD(&fs->win[BPB_RsvdSecCnt]); /* FAT start sector (lba) */
    1898:	e0883003 	add	r3, r8, r3
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(&fs->win[BPB_RootEntCnt]);	/* Nmuber of root directory entries */
	totalsect = LD_WORD(&fs->win[BPB_TotSec16]);		/* Number of sectors on the file system */
	if (!totalsect) totalsect = LD_DWORD(&fs->win[BPB_TotSec32]);
    189c:	e1922401 	orrs	r2, r2, r1, lsl #8
	/* Initialize the file system object */
	fatsize = LD_WORD(&fs->win[BPB_FATSz16]);			/* Number of sectors per FAT */
	if (!fatsize) fatsize = LD_DWORD(&fs->win[BPB_FATSz32]);
	fs->sects_fat = fatsize;
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	fatsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
    18a0:	e006059e 	mul	r6, lr, r5
	fs->fatbase = bootsect + LD_WORD(&fs->win[BPB_RsvdSecCnt]); /* FAT start sector (lba) */
    18a4:	e5873010 	str	r3, [r7, #16]
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
    18a8:	e5c7002b 	strb	r0, [r7, #43]
	if (fmt || LD_WORD(&fs->win[BPB_BytsPerSec]) != SS(fs))	/* No valid FAT patition is found */
		return FR_NO_FILESYSTEM;
	/* Initialize the file system object */
	fatsize = LD_WORD(&fs->win[BPB_FATSz16]);			/* Number of sectors per FAT */
	if (!fatsize) fatsize = LD_DWORD(&fs->win[BPB_FATSz32]);
	fs->sects_fat = fatsize;
    18ac:	e5875008 	str	r5, [r7, #8]
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
    18b0:	e5c7e02c 	strb	lr, [r7, #44]
	fatsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
	fs->fatbase = bootsect + LD_WORD(&fs->win[BPB_RsvdSecCnt]); /* FAT start sector (lba) */
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(&fs->win[BPB_RootEntCnt]);	/* Nmuber of root directory entries */
    18b4:	e1c7c0b2 	strh	ip, [r7, #2]
	totalsect = LD_WORD(&fs->win[BPB_TotSec16]);		/* Number of sectors on the file system */
	if (!totalsect) totalsect = LD_DWORD(&fs->win[BPB_TotSec32]);
    18b8:	1a000007 	bne	18dc <auto_mount+0x208>
    18bc:	e5d71053 	ldrb	r1, [r7, #83]
    18c0:	e5d73052 	ldrb	r3, [r7, #82]
    18c4:	e5d70051 	ldrb	r0, [r7, #81]
    18c8:	e1a03803 	lsl	r3, r3, #16
    18cc:	e5d72050 	ldrb	r2, [r7, #80]
    18d0:	e1833c01 	orr	r3, r3, r1, lsl #24
    18d4:	e1833002 	orr	r3, r3, r2
    18d8:	e1832400 	orr	r2, r3, r0, lsl #8
	fs->max_clust = maxclust = (totalsect				/* max_clust = Last cluster# + 1 */
    18dc:	e5d7303f 	ldrb	r3, [r7, #63]
    18e0:	e5d7003e 	ldrb	r0, [r7, #62]
    18e4:	e1800403 	orr	r0, r0, r3, lsl #8
    18e8:	e0600002 	rsb	r0, r0, r2
    18ec:	e0660000 	rsb	r0, r6, r0
    18f0:	e5d7102b 	ldrb	r1, [r7, #43]
    18f4:	e040022c 	sub	r0, r0, ip, lsr #4
    18f8:	eb000ed9 	bl	5464 <__aeabi_uidiv>
		- LD_WORD(&fs->win[BPB_RsvdSecCnt]) - fatsize - fs->n_rootdir / (SS(fs)/32)
		) / fs->csize + 2;
	fmt = FS_FAT12;										/* Determine the FAT sub type */
	if (maxclust >= 0xFF7) fmt = FS_FAT16;
    18fc:	e3a03eff 	mov	r3, #4080	; 0xff0
	fs->fatbase = bootsect + LD_WORD(&fs->win[BPB_RsvdSecCnt]); /* FAT start sector (lba) */
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(&fs->win[BPB_RootEntCnt]);	/* Nmuber of root directory entries */
	totalsect = LD_WORD(&fs->win[BPB_TotSec16]);		/* Number of sectors on the file system */
	if (!totalsect) totalsect = LD_DWORD(&fs->win[BPB_TotSec32]);
	fs->max_clust = maxclust = (totalsect				/* max_clust = Last cluster# + 1 */
    1900:	e2800002 	add	r0, r0, #2	; 0x2
		- LD_WORD(&fs->win[BPB_RsvdSecCnt]) - fatsize - fs->n_rootdir / (SS(fs)/32)
		) / fs->csize + 2;
	fmt = FS_FAT12;										/* Determine the FAT sub type */
	if (maxclust >= 0xFF7) fmt = FS_FAT16;
    1904:	e2833006 	add	r3, r3, #6	; 0x6
    1908:	e1500003 	cmp	r0, r3
	fs->fatbase = bootsect + LD_WORD(&fs->win[BPB_RsvdSecCnt]); /* FAT start sector (lba) */
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(&fs->win[BPB_RootEntCnt]);	/* Nmuber of root directory entries */
	totalsect = LD_WORD(&fs->win[BPB_TotSec16]);		/* Number of sectors on the file system */
	if (!totalsect) totalsect = LD_DWORD(&fs->win[BPB_TotSec32]);
	fs->max_clust = maxclust = (totalsect				/* max_clust = Last cluster# + 1 */
    190c:	e587000c 	str	r0, [r7, #12]
		- LD_WORD(&fs->win[BPB_RsvdSecCnt]) - fatsize - fs->n_rootdir / (SS(fs)/32)
		) / fs->csize + 2;
	fmt = FS_FAT12;										/* Determine the FAT sub type */
	if (maxclust >= 0xFF7) fmt = FS_FAT16;
    1910:	93a01001 	movls	r1, #1	; 0x1
    1914:	8a000012 	bhi	1964 <auto_mount+0x290>
	if (maxclust >= 0xFFF7) fmt = FS_FAT32;

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(&fs->win[BPB_RootClus]);	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fatsize;			/* Root directory start sector (lba) */
    1918:	e5973010 	ldr	r3, [r7, #16]
	fs->database = fs->fatbase + fatsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
    191c:	e1d720b2 	ldrh	r2, [r7, #2]
    1920:	e0832222 	add	r2, r3, r2, lsr #4
	if (maxclust >= 0xFFF7) fmt = FS_FAT32;

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(&fs->win[BPB_RootClus]);	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fatsize;			/* Root directory start sector (lba) */
    1924:	e0863003 	add	r3, r6, r3
	fs->database = fs->fatbase + fatsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
    1928:	e0822006 	add	r2, r2, r6
	if (maxclust >= 0xFFF7) fmt = FS_FAT32;

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(&fs->win[BPB_RootClus]);	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fatsize;			/* Root directory start sector (lba) */
    192c:	e5873014 	str	r3, [r7, #20]
	fs->database = fs->fatbase + fatsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
	//xprintf("pass9");
#if !_FS_READONLY
	/* Initialize allocation information */
	fs->free_clust = 0xFFFFFFFF;
    1930:	e3e03000 	mvn	r3, #0	; 0x0

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(&fs->win[BPB_RootClus]);	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fatsize;			/* Root directory start sector (lba) */
	fs->database = fs->fatbase + fatsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
    1934:	e5872018 	str	r2, [r7, #24]
	//xprintf("pass9");
#if !_FS_READONLY
	/* Initialize allocation information */
	fs->free_clust = 0xFFFFFFFF;
    1938:	e5873020 	str	r3, [r7, #32]
		}
	}
#endif
#endif
	//xprintf("pass10");
	fs->fs_type = fmt;			/* FAT syb-type */
    193c:	e5c7102a 	strb	r1, [r7, #42]
	fs->id = ++fsid;			/* File system mount ID */
    1940:	e59f2170 	ldr	r2, [pc, #368]	; 1ab8 <auto_mount+0x3e4>
    1944:	e1d230b0 	ldrh	r3, [r2]
    1948:	e2833001 	add	r3, r3, #1	; 0x1
    194c:	e1a03803 	lsl	r3, r3, #16
    1950:	e1a03823 	lsr	r3, r3, #16
    1954:	e1c230b0 	strh	r3, [r2]
    1958:	e3a00000 	mov	r0, #0	; 0x0
    195c:	e1c730b0 	strh	r3, [r7]
    1960:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
	fs->max_clust = maxclust = (totalsect				/* max_clust = Last cluster# + 1 */
		- LD_WORD(&fs->win[BPB_RsvdSecCnt]) - fatsize - fs->n_rootdir / (SS(fs)/32)
		) / fs->csize + 2;
	fmt = FS_FAT12;										/* Determine the FAT sub type */
	if (maxclust >= 0xFF7) fmt = FS_FAT16;
	if (maxclust >= 0xFFF7) fmt = FS_FAT32;
    1964:	e3a03cff 	mov	r3, #65280	; 0xff00
    1968:	e28330f6 	add	r3, r3, #246	; 0xf6
    196c:	e1500003 	cmp	r0, r3
    1970:	9a00004d 	bls	1aac <auto_mount+0x3d8>

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(&fs->win[BPB_RootClus]);	/* Root directory start cluster */
    1974:	e5d7e05f 	ldrb	lr, [r7, #95]
    1978:	e5d7305e 	ldrb	r3, [r7, #94]
    197c:	e5d7505d 	ldrb	r5, [r7, #93]
    1980:	e1a03803 	lsl	r3, r3, #16
    1984:	e5d7005c 	ldrb	r0, [r7, #92]
	else
		fs->dirbase = fs->fatbase + fatsize;			/* Root directory start sector (lba) */
	fs->database = fs->fatbase + fatsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
    1988:	e1d740b2 	ldrh	r4, [r7, #2]
	/* Initialize allocation information */
	fs->free_clust = 0xFFFFFFFF;
#if _USE_FSINFO
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
		fs->fsi_sector = bootsect + LD_WORD(&fs->win[BPB_FSInfo]);
    198c:	e5d7c061 	ldrb	ip, [r7, #97]

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(&fs->win[BPB_RootClus]);	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fatsize;			/* Root directory start sector (lba) */
	fs->database = fs->fatbase + fatsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
    1990:	e5971010 	ldr	r1, [r7, #16]
	/* Initialize allocation information */
	fs->free_clust = 0xFFFFFFFF;
#if _USE_FSINFO
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
		fs->fsi_sector = bootsect + LD_WORD(&fs->win[BPB_FSInfo]);
    1994:	e5d72060 	ldrb	r2, [r7, #96]
	fmt = FS_FAT12;										/* Determine the FAT sub type */
	if (maxclust >= 0xFF7) fmt = FS_FAT16;
	if (maxclust >= 0xFFF7) fmt = FS_FAT32;

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(&fs->win[BPB_RootClus]);	/* Root directory start cluster */
    1998:	e1833c0e 	orr	r3, r3, lr, lsl #24
    199c:	e1833000 	orr	r3, r3, r0
	/* Initialize allocation information */
	fs->free_clust = 0xFFFFFFFF;
#if _USE_FSINFO
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
		fs->fsi_sector = bootsect + LD_WORD(&fs->win[BPB_FSInfo]);
    19a0:	e182240c 	orr	r2, r2, ip, lsl #8
	fmt = FS_FAT12;										/* Determine the FAT sub type */
	if (maxclust >= 0xFF7) fmt = FS_FAT16;
	if (maxclust >= 0xFFF7) fmt = FS_FAT32;

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(&fs->win[BPB_RootClus]);	/* Root directory start cluster */
    19a4:	e1833405 	orr	r3, r3, r5, lsl #8
	else
		fs->dirbase = fs->fatbase + fatsize;			/* Root directory start sector (lba) */
	fs->database = fs->fatbase + fatsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
    19a8:	e0811224 	add	r1, r1, r4, lsr #4
	/* Initialize allocation information */
	fs->free_clust = 0xFFFFFFFF;
#if _USE_FSINFO
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
		fs->fsi_sector = bootsect + LD_WORD(&fs->win[BPB_FSInfo]);
    19ac:	e0882002 	add	r2, r8, r2

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(&fs->win[BPB_RootClus]);	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fatsize;			/* Root directory start sector (lba) */
	fs->database = fs->fatbase + fatsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
    19b0:	e0811006 	add	r1, r1, r6
	fmt = FS_FAT12;										/* Determine the FAT sub type */
	if (maxclust >= 0xFF7) fmt = FS_FAT16;
	if (maxclust >= 0xFFF7) fmt = FS_FAT32;

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(&fs->win[BPB_RootClus]);	/* Root directory start cluster */
    19b4:	e5873014 	str	r3, [r7, #20]
		fs->dirbase = fs->fatbase + fatsize;			/* Root directory start sector (lba) */
	fs->database = fs->fatbase + fatsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
	//xprintf("pass9");
#if !_FS_READONLY
	/* Initialize allocation information */
	fs->free_clust = 0xFFFFFFFF;
    19b8:	e3e03000 	mvn	r3, #0	; 0x0

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(&fs->win[BPB_RootClus]);	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fatsize;			/* Root directory start sector (lba) */
	fs->database = fs->fatbase + fatsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
    19bc:	e5871018 	str	r1, [r7, #24]
	//xprintf("pass9");
#if !_FS_READONLY
	/* Initialize allocation information */
	fs->free_clust = 0xFFFFFFFF;
    19c0:	e5873020 	str	r3, [r7, #32]
#if _USE_FSINFO
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
		fs->fsi_sector = bootsect + LD_WORD(&fs->win[BPB_FSInfo]);
    19c4:	e5872024 	str	r2, [r7, #36]
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
    19c8:	e5d7002d 	ldrb	r0, [r7, #45]
    19cc:	e2871030 	add	r1, r7, #48	; 0x30
    19d0:	e2833002 	add	r3, r3, #2	; 0x2
    19d4:	eb000317 	bl	2638 <disk_read>
    19d8:	e3500000 	cmp	r0, #0	; 0x0
    19dc:	1a000006 	bne	19fc <auto_mount+0x328>
    19e0:	e5d7122f 	ldrb	r1, [r7, #559]
    19e4:	e5d7222e 	ldrb	r2, [r7, #558]
    19e8:	e3a03caa 	mov	r3, #43520	; 0xaa00
    19ec:	e1822401 	orr	r2, r2, r1, lsl #8
    19f0:	e2833055 	add	r3, r3, #85	; 0x55
    19f4:	e1520003 	cmp	r2, r3
    19f8:	0a000001 	beq	1a04 <auto_mount+0x330>
			LD_WORD(&fs->win[BS_55AA]) == 0xAA55 &&
			LD_DWORD(&fs->win[FSI_LeadSig]) == 0x41615252 &&
			LD_DWORD(&fs->win[FSI_StrucSig]) == 0x61417272) {
			fs->last_clust = LD_DWORD(&fs->win[FSI_Nxt_Free]);
			fs->free_clust = LD_DWORD(&fs->win[FSI_Free_Count]);
    19fc:	e3a01003 	mov	r1, #3	; 0x3
    1a00:	eaffffcd 	b	193c <auto_mount+0x268>
	fs->free_clust = 0xFFFFFFFF;
#if _USE_FSINFO
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
		fs->fsi_sector = bootsect + LD_WORD(&fs->win[BPB_FSInfo]);
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
    1a04:	e5d71033 	ldrb	r1, [r7, #51]
    1a08:	e5d73032 	ldrb	r3, [r7, #50]
    1a0c:	e5d70031 	ldrb	r0, [r7, #49]
    1a10:	e1a03803 	lsl	r3, r3, #16
    1a14:	e5d72030 	ldrb	r2, [r7, #48]
    1a18:	e1833c01 	orr	r3, r3, r1, lsl #24
    1a1c:	e1833002 	orr	r3, r3, r2
    1a20:	e59f2094 	ldr	r2, [pc, #148]	; 1abc <auto_mount+0x3e8>
    1a24:	e1833400 	orr	r3, r3, r0, lsl #8
    1a28:	e1530002 	cmp	r3, r2
    1a2c:	1afffff2 	bne	19fc <auto_mount+0x328>
    1a30:	e5d71217 	ldrb	r1, [r7, #535]
    1a34:	e5d73216 	ldrb	r3, [r7, #534]
    1a38:	e5d70215 	ldrb	r0, [r7, #533]
    1a3c:	e1a03803 	lsl	r3, r3, #16
    1a40:	e5d72214 	ldrb	r2, [r7, #532]
    1a44:	e1833c01 	orr	r3, r3, r1, lsl #24
    1a48:	e1833002 	orr	r3, r3, r2
    1a4c:	e59f206c 	ldr	r2, [pc, #108]	; 1ac0 <auto_mount+0x3ec>
    1a50:	e1833400 	orr	r3, r3, r0, lsl #8
    1a54:	e1530002 	cmp	r3, r2
    1a58:	1affffe7 	bne	19fc <auto_mount+0x328>
			LD_WORD(&fs->win[BS_55AA]) == 0xAA55 &&
			LD_DWORD(&fs->win[FSI_LeadSig]) == 0x41615252 &&
			LD_DWORD(&fs->win[FSI_StrucSig]) == 0x61417272) {
			fs->last_clust = LD_DWORD(&fs->win[FSI_Nxt_Free]);
    1a5c:	e5d7021f 	ldrb	r0, [r7, #543]
    1a60:	e5d7221e 	ldrb	r2, [r7, #542]
    1a64:	e5d7621d 	ldrb	r6, [r7, #541]
    1a68:	e5d7c21c 	ldrb	ip, [r7, #540]
			fs->free_clust = LD_DWORD(&fs->win[FSI_Free_Count]);
    1a6c:	e5d7421b 	ldrb	r4, [r7, #539]
    1a70:	e5d7321a 	ldrb	r3, [r7, #538]
		fs->fsi_sector = bootsect + LD_WORD(&fs->win[BPB_FSInfo]);
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(&fs->win[BS_55AA]) == 0xAA55 &&
			LD_DWORD(&fs->win[FSI_LeadSig]) == 0x41615252 &&
			LD_DWORD(&fs->win[FSI_StrucSig]) == 0x61417272) {
			fs->last_clust = LD_DWORD(&fs->win[FSI_Nxt_Free]);
    1a74:	e1a02802 	lsl	r2, r2, #16
			fs->free_clust = LD_DWORD(&fs->win[FSI_Free_Count]);
    1a78:	e5d75219 	ldrb	r5, [r7, #537]
    1a7c:	e1a03803 	lsl	r3, r3, #16
    1a80:	e5d71218 	ldrb	r1, [r7, #536]
		fs->fsi_sector = bootsect + LD_WORD(&fs->win[BPB_FSInfo]);
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(&fs->win[BS_55AA]) == 0xAA55 &&
			LD_DWORD(&fs->win[FSI_LeadSig]) == 0x41615252 &&
			LD_DWORD(&fs->win[FSI_StrucSig]) == 0x61417272) {
			fs->last_clust = LD_DWORD(&fs->win[FSI_Nxt_Free]);
    1a84:	e1822c00 	orr	r2, r2, r0, lsl #24
			fs->free_clust = LD_DWORD(&fs->win[FSI_Free_Count]);
    1a88:	e1833c04 	orr	r3, r3, r4, lsl #24
    1a8c:	e1833001 	orr	r3, r3, r1
		fs->fsi_sector = bootsect + LD_WORD(&fs->win[BPB_FSInfo]);
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(&fs->win[BS_55AA]) == 0xAA55 &&
			LD_DWORD(&fs->win[FSI_LeadSig]) == 0x41615252 &&
			LD_DWORD(&fs->win[FSI_StrucSig]) == 0x61417272) {
			fs->last_clust = LD_DWORD(&fs->win[FSI_Nxt_Free]);
    1a90:	e182200c 	orr	r2, r2, ip
    1a94:	e1822406 	orr	r2, r2, r6, lsl #8
			fs->free_clust = LD_DWORD(&fs->win[FSI_Free_Count]);
    1a98:	e1833405 	orr	r3, r3, r5, lsl #8
		fs->fsi_sector = bootsect + LD_WORD(&fs->win[BPB_FSInfo]);
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(&fs->win[BS_55AA]) == 0xAA55 &&
			LD_DWORD(&fs->win[FSI_LeadSig]) == 0x41615252 &&
			LD_DWORD(&fs->win[FSI_StrucSig]) == 0x61417272) {
			fs->last_clust = LD_DWORD(&fs->win[FSI_Nxt_Free]);
    1a9c:	e587201c 	str	r2, [r7, #28]
			fs->free_clust = LD_DWORD(&fs->win[FSI_Free_Count]);
    1aa0:	e5873020 	str	r3, [r7, #32]
    1aa4:	e3a01003 	mov	r1, #3	; 0x3
    1aa8:	eaffffa3 	b	193c <auto_mount+0x268>
	fs->max_clust = maxclust = (totalsect				/* max_clust = Last cluster# + 1 */
		- LD_WORD(&fs->win[BPB_RsvdSecCnt]) - fatsize - fs->n_rootdir / (SS(fs)/32)
		) / fs->csize + 2;
	fmt = FS_FAT12;										/* Determine the FAT sub type */
	if (maxclust >= 0xFF7) fmt = FS_FAT16;
	if (maxclust >= 0xFFF7) fmt = FS_FAT32;
    1aac:	e3a01002 	mov	r1, #2	; 0x2
    1ab0:	eaffff98 	b	1918 <auto_mount+0x244>
    1ab4:	40000700 	.word	0x40000700
    1ab8:	40000704 	.word	0x40000704
    1abc:	41615252 	.word	0x41615252
    1ac0:	61417272 	.word	0x61417272

00001ac4 <trace_path>:
	DIR *dj,			/* Pointer to directory object to return last directory */
	char *fn,			/* Pointer to last segment name to return {file(8),ext(3),attr(1)} */
	const char *path,	/* Full-path string to trace a file or directory */
	BYTE **dir			/* Pointer to pointer to found entry to retutn */
)
{
    1ac4:	e1a0c00d 	mov	ip, sp
    1ac8:	e92ddff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
    1acc:	e24cb004 	sub	fp, ip, #4	; 0x4
    1ad0:	e24dd004 	sub	sp, sp, #4	; 0x4
	DWORD clust;
	char ds;
	BYTE *dptr = NULL;
	FATFS *fs = dj->fs;
    1ad4:	e5908004 	ldr	r8, [r0, #4]
	DIR *dj,			/* Pointer to directory object to return last directory */
	char *fn,			/* Pointer to last segment name to return {file(8),ext(3),attr(1)} */
	const char *path,	/* Full-path string to trace a file or directory */
	BYTE **dir			/* Pointer to pointer to found entry to retutn */
)
{
    1ad8:	e1a07000 	mov	r7, r0
	FATFS *fs = dj->fs;


	/* Initialize directory object */
	clust = fs->dirbase;
	if (fs->fs_type == FS_FAT32) {
    1adc:	e5d8002a 	ldrb	r0, [r8, #42]
	DIR *dj,			/* Pointer to directory object to return last directory */
	char *fn,			/* Pointer to last segment name to return {file(8),ext(3),attr(1)} */
	const char *path,	/* Full-path string to trace a file or directory */
	BYTE **dir			/* Pointer to pointer to found entry to retutn */
)
{
    1ae0:	e1a0a002 	mov	sl, r2
	FATFS *fs = dj->fs;


	/* Initialize directory object */
	clust = fs->dirbase;
	if (fs->fs_type == FS_FAT32) {
    1ae4:	e3500003 	cmp	r0, #3	; 0x3
	BYTE *dptr = NULL;
	FATFS *fs = dj->fs;


	/* Initialize directory object */
	clust = fs->dirbase;
    1ae8:	e5982014 	ldr	r2, [r8, #20]
	DIR *dj,			/* Pointer to directory object to return last directory */
	char *fn,			/* Pointer to last segment name to return {file(8),ext(3),attr(1)} */
	const char *path,	/* Full-path string to trace a file or directory */
	BYTE **dir			/* Pointer to pointer to found entry to retutn */
)
{
    1aec:	e50b302c 	str	r3, [fp, #-44]
	clust = fs->dirbase;
	if (fs->fs_type == FS_FAT32) {
		dj->clust = dj->sclust = clust;
		dj->sect = clust2sect(fs, clust);
	} else {
		dj->clust = dj->sclust = 0;
    1af0:	13a03000 	movne	r3, #0	; 0x0
	DIR *dj,			/* Pointer to directory object to return last directory */
	char *fn,			/* Pointer to last segment name to return {file(8),ext(3),attr(1)} */
	const char *path,	/* Full-path string to trace a file or directory */
	BYTE **dir			/* Pointer to pointer to found entry to retutn */
)
{
    1af4:	e1a09001 	mov	r9, r1
	clust = fs->dirbase;
	if (fs->fs_type == FS_FAT32) {
		dj->clust = dj->sclust = clust;
		dj->sect = clust2sect(fs, clust);
	} else {
		dj->clust = dj->sclust = 0;
    1af8:	1587300c 	strne	r3, [r7, #12]
		dj->sect = clust;
    1afc:	15872010 	strne	r2, [r7, #16]
	clust = fs->dirbase;
	if (fs->fs_type == FS_FAT32) {
		dj->clust = dj->sclust = clust;
		dj->sect = clust2sect(fs, clust);
	} else {
		dj->clust = dj->sclust = 0;
    1b00:	15873008 	strne	r3, [r7, #8]
	FATFS *fs = dj->fs;


	/* Initialize directory object */
	clust = fs->dirbase;
	if (fs->fs_type == FS_FAT32) {
    1b04:	0a00005e 	beq	1c84 <trace_path+0x1c0>
		dj->sect = clust2sect(fs, clust);
	} else {
		dj->clust = dj->sclust = 0;
		dj->sect = clust;
	}
	dj->index = 0;
    1b08:	e3a03000 	mov	r3, #0	; 0x0
    1b0c:	e1c730b2 	strh	r3, [r7, #2]

	if (*path == '\0') {					/* Null path means the root directory */
    1b10:	e5da0000 	ldrb	r0, [sl]
    1b14:	e3500000 	cmp	r0, #0	; 0x0
		*dir = NULL; return FR_OK;
    1b18:	051b302c 	ldreq	r3, [fp, #-44]
    1b1c:	05830000 	streq	r0, [r3]
		dj->clust = dj->sclust = 0;
		dj->sect = clust;
	}
	dj->index = 0;

	if (*path == '\0') {					/* Null path means the root directory */
    1b20:	089daff8 	ldmeq	sp, {r3, r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
)
{
	BYTE n, t, c, a, b;


	memset(dirname, ' ', 8+3);	/* Fill buffer with spaces */
    1b24:	e3a01020 	mov	r1, #32	; 0x20
    1b28:	e1a00009 	mov	r0, r9
    1b2c:	e3a0200b 	mov	r2, #11	; 0xb
    1b30:	eb000e09 	bl	535c <memset>
    1b34:	e3a00000 	mov	r0, #0	; 0x0
    1b38:	e3a0e018 	mov	lr, #24	; 0x18
    1b3c:	e3a0c008 	mov	ip, #8	; 0x8
    1b40:	e1a01000 	mov	r1, r0
	a = 0; b = 0x18;	/* NT flag */
	n = 0; t = 8;
	for (;;) {
		c = *(*path)++;
    1b44:	e4da4001 	ldrb	r4, [sl], #1
		if (c == '\0' || c == '/') {		/* Reached to end of str or directory separator */
    1b48:	e354002f 	cmp	r4, #47	; 0x2f
    1b4c:	13540000 	cmpne	r4, #0	; 0x0
    1b50:	0a000018 	beq	1bb8 <trace_path+0xf4>
			if (n == 0) break;
			dirname[11] = _USE_NTFLAG ? (a & b) : 0;
			return c;
		}
		if (c <= ' ' || c == 0x7F) break;		/* Reject invisible chars */
    1b54:	e354007f 	cmp	r4, #127	; 0x7f
    1b58:	13540020 	cmpne	r4, #32	; 0x20
    1b5c:	9a000017 	bls	1bc0 <trace_path+0xfc>
		if (c == '.') {
    1b60:	e354002e 	cmp	r4, #46	; 0x2e
    1b64:	0a00003b 	beq	1c58 <trace_path+0x194>
			if (!(a & 1) && n >= 1 && n <= 8) {	/* Enter extension part */
				n = 8; t = 11; continue;
			}
			break;
		}
		if (_USE_SJIS &&
    1b68:	e284207f 	add	r2, r4, #127	; 0x7f
    1b6c:	e2843020 	add	r3, r4, #32	; 0x20
    1b70:	e20220ff 	and	r2, r2, #255	; 0xff
    1b74:	e20330ff 	and	r3, r3, #255	; 0xff
    1b78:	e353001c 	cmp	r3, #28	; 0x1c
    1b7c:	8352001e 	cmphi	r2, #30	; 0x1e
    1b80:	8a000010 	bhi	1bc8 <trace_path+0x104>
			((c >= 0x81 && c <= 0x9F) ||	/* Accept S-JIS code */
		    (c >= 0xE0 && c <= 0xFC))) {
			if (n == 0 && c == 0xE5)		/* Change heading \xE5 to \x05 */
    1b84:	e3510000 	cmp	r1, #0	; 0x0
    1b88:	035400e5 	cmpeq	r4, #229	; 0xe5
    1b8c:	03a04005 	moveq	r4, #5	; 0x5
				c = 0x05;
			a ^= 0x01; goto md_l2;
    1b90:	e2200001 	eor	r0, r0, #1	; 0x1
			}
		}
	md_l1:
		a &= 0xFE;
	md_l2:
		if (n >= t) break;
    1b94:	e151000c 	cmp	r1, ip
    1b98:	2a000008 	bcs	1bc0 <trace_path+0xfc>
		dirname[n++] = c;
    1b9c:	e7c94001 	strb	r4, [r9, r1]

	memset(dirname, ' ', 8+3);	/* Fill buffer with spaces */
	a = 0; b = 0x18;	/* NT flag */
	n = 0; t = 8;
	for (;;) {
		c = *(*path)++;
    1ba0:	e4da4001 	ldrb	r4, [sl], #1
		}
	md_l1:
		a &= 0xFE;
	md_l2:
		if (n >= t) break;
		dirname[n++] = c;
    1ba4:	e2813001 	add	r3, r1, #1	; 0x1
	memset(dirname, ' ', 8+3);	/* Fill buffer with spaces */
	a = 0; b = 0x18;	/* NT flag */
	n = 0; t = 8;
	for (;;) {
		c = *(*path)++;
		if (c == '\0' || c == '/') {		/* Reached to end of str or directory separator */
    1ba8:	e354002f 	cmp	r4, #47	; 0x2f
    1bac:	13540000 	cmpne	r4, #0	; 0x0
		}
	md_l1:
		a &= 0xFE;
	md_l2:
		if (n >= t) break;
		dirname[n++] = c;
    1bb0:	e20310ff 	and	r1, r3, #255	; 0xff
	memset(dirname, ' ', 8+3);	/* Fill buffer with spaces */
	a = 0; b = 0x18;	/* NT flag */
	n = 0; t = 8;
	for (;;) {
		c = *(*path)++;
		if (c == '\0' || c == '/') {		/* Reached to end of str or directory separator */
    1bb4:	1affffe6 	bne	1b54 <trace_path+0x90>
			if (n == 0) break;
    1bb8:	e3510000 	cmp	r1, #0	; 0x0
    1bbc:	1a00003c 	bne	1cb4 <trace_path+0x1f0>
		if (!(dptr[DIR_Attr] & AM_DIR)) return FR_NO_PATH;	/* Cannot trace because it is a file */
		clust = ((DWORD)LD_WORD(&dptr[DIR_FstClusHI]) << 16) | LD_WORD(&dptr[DIR_FstClusLO]); /* Get cluster# of the directory */
		dj->clust = dj->sclust = clust;				/* Restart scanning at the new directory */
		dj->sect = clust2sect(fs, clust);
		dj->index = 2;
	}
    1bc0:	e3a00004 	mov	r0, #4	; 0x4
    1bc4:	e89daff8 	ldm	sp, {r3, r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
		    (c >= 0xE0 && c <= 0xFC))) {
			if (n == 0 && c == 0xE5)		/* Change heading \xE5 to \x05 */
				c = 0x05;
			a ^= 0x01; goto md_l2;
		}
		if (c == '"') break;				/* Reject " */
    1bc8:	e3540022 	cmp	r4, #34	; 0x22
    1bcc:	0afffffb 	beq	1bc0 <trace_path+0xfc>
		if (c <= ')') goto md_l1;			/* Accept ! # $ % & ' ( ) */
    1bd0:	e3540029 	cmp	r4, #41	; 0x29
    1bd4:	9a00001d 	bls	1c50 <trace_path+0x18c>
		if (c <= ',') break;				/* Reject * + , */
    1bd8:	e354002c 	cmp	r4, #44	; 0x2c
    1bdc:	9afffff7 	bls	1bc0 <trace_path+0xfc>
		if (c <= '9') goto md_l1;			/* Accept - 0-9 */
    1be0:	e3540039 	cmp	r4, #57	; 0x39
    1be4:	9a000019 	bls	1c50 <trace_path+0x18c>
		if (c <= '?') break;				/* Reject : ; < = > ? */
    1be8:	e354003f 	cmp	r4, #63	; 0x3f
    1bec:	9afffff3 	bls	1bc0 <trace_path+0xfc>
		if (!(a & 1)) {	/* These checks are not applied to S-JIS 2nd byte */
    1bf0:	e3100001 	tst	r0, #1	; 0x1
    1bf4:	1a000015 	bne	1c50 <trace_path+0x18c>
			if (c == '|') break;			/* Reject | */
    1bf8:	e354007c 	cmp	r4, #124	; 0x7c
    1bfc:	0affffef 	beq	1bc0 <trace_path+0xfc>
			if (c >= '[' && c <= ']') break;/* Reject [ \ ] */
    1c00:	e244305b 	sub	r3, r4, #91	; 0x5b
    1c04:	e20330ff 	and	r3, r3, #255	; 0xff
    1c08:	e3530002 	cmp	r3, #2	; 0x2
    1c0c:	9affffeb 	bls	1bc0 <trace_path+0xfc>
			if (_USE_NTFLAG && c >= 'A' && c <= 'Z')
    1c10:	e2443041 	sub	r3, r4, #65	; 0x41
    1c14:	e20330ff 	and	r3, r3, #255	; 0xff
    1c18:	e3530019 	cmp	r3, #25	; 0x19
    1c1c:	8a000002 	bhi	1c2c <trace_path+0x168>
				(t == 8) ? (b &= 0xF7) : (b &= 0xEF);
    1c20:	e35c0008 	cmp	ip, #8	; 0x8
    1c24:	020ee0f7 	andeq	lr, lr, #247	; 0xf7
    1c28:	120ee0ef 	andne	lr, lr, #239	; 0xef
			if (c >= 'a' && c <= 'z') {		/* Convert to upper case */
    1c2c:	e2443061 	sub	r3, r4, #97	; 0x61
    1c30:	e20330ff 	and	r3, r3, #255	; 0xff
    1c34:	e3530019 	cmp	r3, #25	; 0x19
    1c38:	8a000004 	bhi	1c50 <trace_path+0x18c>
				c -= 0x20;
				if (_USE_NTFLAG) (t == 8) ? (a |= 0x08) : (a |= 0x10);
    1c3c:	e35c0008 	cmp	ip, #8	; 0x8
			if (c == '|') break;			/* Reject | */
			if (c >= '[' && c <= ']') break;/* Reject [ \ ] */
			if (_USE_NTFLAG && c >= 'A' && c <= 'Z')
				(t == 8) ? (b &= 0xF7) : (b &= 0xEF);
			if (c >= 'a' && c <= 'z') {		/* Convert to upper case */
				c -= 0x20;
    1c40:	e2443020 	sub	r3, r4, #32	; 0x20
    1c44:	e20340ff 	and	r4, r3, #255	; 0xff
				if (_USE_NTFLAG) (t == 8) ? (a |= 0x08) : (a |= 0x10);
    1c48:	03800008 	orreq	r0, r0, #8	; 0x8
    1c4c:	13800010 	orrne	r0, r0, #16	; 0x10
			}
		}
	md_l1:
		a &= 0xFE;
    1c50:	e20000fe 	and	r0, r0, #254	; 0xfe
    1c54:	eaffffce 	b	1b94 <trace_path+0xd0>
			dirname[11] = _USE_NTFLAG ? (a & b) : 0;
			return c;
		}
		if (c <= ' ' || c == 0x7F) break;		/* Reject invisible chars */
		if (c == '.') {
			if (!(a & 1) && n >= 1 && n <= 8) {	/* Enter extension part */
    1c58:	e2203001 	eor	r3, r0, #1	; 0x1
    1c5c:	e3510000 	cmp	r1, #0	; 0x0
    1c60:	03a03000 	moveq	r3, #0	; 0x0
    1c64:	12033001 	andne	r3, r3, #1	; 0x1
    1c68:	e3530000 	cmp	r3, #0	; 0x0
    1c6c:	0affffd3 	beq	1bc0 <trace_path+0xfc>
    1c70:	e3510008 	cmp	r1, #8	; 0x8
    1c74:	8affffd1 	bhi	1bc0 <trace_path+0xfc>
)
{
	BYTE n, t, c, a, b;


	memset(dirname, ' ', 8+3);	/* Fill buffer with spaces */
    1c78:	e3a0c00b 	mov	ip, #11	; 0xb
    1c7c:	e3a01008 	mov	r1, #8	; 0x8
    1c80:	eaffffaf 	b	1b44 <trace_path+0x80>


	/* Initialize directory object */
	clust = fs->dirbase;
	if (fs->fs_type == FS_FAT32) {
		dj->clust = dj->sclust = clust;
    1c84:	e5872008 	str	r2, [r7, #8]
    1c88:	e587200c 	str	r2, [r7, #12]
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    1c8c:	e598300c 	ldr	r3, [r8, #12]
DWORD clust2sect (	/* !=0: sector number, 0: failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
    1c90:	e2420002 	sub	r0, r2, #2	; 0x2
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    1c94:	e2433002 	sub	r3, r3, #2	; 0x2
    1c98:	e1500003 	cmp	r0, r3
	return clust * fs->csize + fs->database;
    1c9c:	35d8202b 	ldrbcc	r2, [r8, #43]
    1ca0:	35983018 	ldrcc	r3, [r8, #24]
    1ca4:	30213290 	mlacc	r1, r0, r2, r3
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    1ca8:	23a01000 	movcs	r1, #0	; 0x0

	/* Initialize directory object */
	clust = fs->dirbase;
	if (fs->fs_type == FS_FAT32) {
		dj->clust = dj->sclust = clust;
		dj->sect = clust2sect(fs, clust);
    1cac:	e5871010 	str	r1, [r7, #16]
    1cb0:	eaffff94 	b	1b08 <trace_path+0x44>
	n = 0; t = 8;
	for (;;) {
		c = *(*path)++;
		if (c == '\0' || c == '/') {		/* Reached to end of str or directory separator */
			if (n == 0) break;
			dirname[11] = _USE_NTFLAG ? (a & b) : 0;
    1cb4:	e00e3000 	and	r3, lr, r0
		*dir = NULL; return FR_OK;
	}

	for (;;) {
		ds = make_dirfile(&path, fn);			/* Get a paragraph into fn[] */
		if (ds == 1) return FR_INVALID_NAME;
    1cb8:	e3540001 	cmp	r4, #1	; 0x1
	n = 0; t = 8;
	for (;;) {
		c = *(*path)++;
		if (c == '\0' || c == '/') {		/* Reached to end of str or directory separator */
			if (n == 0) break;
			dirname[11] = _USE_NTFLAG ? (a & b) : 0;
    1cbc:	e5c9300b 	strb	r3, [r9, #11]
		*dir = NULL; return FR_OK;
	}

	for (;;) {
		ds = make_dirfile(&path, fn);			/* Get a paragraph into fn[] */
		if (ds == 1) return FR_INVALID_NAME;
    1cc0:	1a000004 	bne	1cd8 <trace_path+0x214>
    1cc4:	eaffffbd 	b	1bc0 <trace_path+0xfc>
			if (dptr[DIR_Name] == 0)						/* Has it reached to end of dir? */
				return !ds ? FR_NO_FILE : FR_NO_PATH;
			if (dptr[DIR_Name] != 0xE5						/* Matched? */
				&& !(dptr[DIR_Attr] & AM_VOL)
				&& !memcmp(&dptr[DIR_Name], fn, 8+3) ) break;
			if (!next_dir_entry(dj))						/* Next directory pointer */
    1cc8:	e1a00007 	mov	r0, r7
    1ccc:	ebfffbad 	bl	b88 <next_dir_entry>
    1cd0:	e3500000 	cmp	r0, #0	; 0x0
    1cd4:	0a000031 	beq	1da0 <trace_path+0x2dc>

	for (;;) {
		ds = make_dirfile(&path, fn);			/* Get a paragraph into fn[] */
		if (ds == 1) return FR_INVALID_NAME;
		for (;;) {
			if (!move_window(fs, dj->sect)) return FR_RW_ERROR;
    1cd8:	e5971010 	ldr	r1, [r7, #16]
    1cdc:	e1a00008 	mov	r0, r8
    1ce0:	ebfffb19 	bl	94c <move_window>
    1ce4:	e3500000 	cmp	r0, #0	; 0x0
    1ce8:	0a000032 	beq	1db8 <trace_path+0x2f4>
			dptr = &fs->win[(dj->index & ((SS(fs) - 1) / 32)) * 32];	/* Pointer to the directory entry */
    1cec:	e1d730b2 	ldrh	r3, [r7, #2]
    1cf0:	e203300f 	and	r3, r3, #15	; 0xf
    1cf4:	e1a03283 	lsl	r3, r3, #5
    1cf8:	e2832030 	add	r2, r3, #48	; 0x30
			if (dptr[DIR_Name] == 0)						/* Has it reached to end of dir? */
    1cfc:	e0883003 	add	r3, r8, r3
    1d00:	e5d33030 	ldrb	r3, [r3, #48]
    1d04:	e3530000 	cmp	r3, #0	; 0x0
	for (;;) {
		ds = make_dirfile(&path, fn);			/* Get a paragraph into fn[] */
		if (ds == 1) return FR_INVALID_NAME;
		for (;;) {
			if (!move_window(fs, dj->sect)) return FR_RW_ERROR;
			dptr = &fs->win[(dj->index & ((SS(fs) - 1) / 32)) * 32];	/* Pointer to the directory entry */
    1d08:	e0885002 	add	r5, r8, r2
			if (dptr[DIR_Name] == 0)						/* Has it reached to end of dir? */
    1d0c:	0a000023 	beq	1da0 <trace_path+0x2dc>
				return !ds ? FR_NO_FILE : FR_NO_PATH;
			if (dptr[DIR_Name] != 0xE5						/* Matched? */
    1d10:	e35300e5 	cmp	r3, #229	; 0xe5
    1d14:	0affffeb 	beq	1cc8 <trace_path+0x204>
    1d18:	e5d5600b 	ldrb	r6, [r5, #11]
    1d1c:	e3160008 	tst	r6, #8	; 0x8
    1d20:	1affffe8 	bne	1cc8 <trace_path+0x204>
    1d24:	e1a01009 	mov	r1, r9
    1d28:	e3a0200b 	mov	r2, #11	; 0xb
    1d2c:	e1a00005 	mov	r0, r5
    1d30:	eb000d1f 	bl	51b4 <memcmp>
    1d34:	e250c000 	subs	ip, r0, #0	; 0x0
    1d38:	1affffe2 	bne	1cc8 <trace_path+0x204>
				&& !(dptr[DIR_Attr] & AM_VOL)
				&& !memcmp(&dptr[DIR_Name], fn, 8+3) ) break;
			if (!next_dir_entry(dj))						/* Next directory pointer */
				return !ds ? FR_NO_FILE : FR_NO_PATH;
		}
		if (!ds) { *dir = dptr; return FR_OK; }				/* Matched with end of path */
    1d3c:	e3540000 	cmp	r4, #0	; 0x0
    1d40:	0a00001e 	beq	1dc0 <trace_path+0x2fc>
		if (!(dptr[DIR_Attr] & AM_DIR)) return FR_NO_PATH;	/* Cannot trace because it is a file */
    1d44:	e3160010 	tst	r6, #16	; 0x10
    1d48:	0a000016 	beq	1da8 <trace_path+0x2e4>
		clust = ((DWORD)LD_WORD(&dptr[DIR_FstClusHI]) << 16) | LD_WORD(&dptr[DIR_FstClusLO]); /* Get cluster# of the directory */
    1d4c:	e5d50015 	ldrb	r0, [r5, #21]
    1d50:	e5d52014 	ldrb	r2, [r5, #20]
    1d54:	e5d5101b 	ldrb	r1, [r5, #27]
    1d58:	e5d5301a 	ldrb	r3, [r5, #26]
    1d5c:	e1822400 	orr	r2, r2, r0, lsl #8
    1d60:	e1833401 	orr	r3, r3, r1, lsl #8
    1d64:	e1833802 	orr	r3, r3, r2, lsl #16
		dj->clust = dj->sclust = clust;				/* Restart scanning at the new directory */
    1d68:	e5873008 	str	r3, [r7, #8]
    1d6c:	e587300c 	str	r3, [r7, #12]
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    1d70:	e598200c 	ldr	r2, [r8, #12]
DWORD clust2sect (	/* !=0: sector number, 0: failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
    1d74:	e2431002 	sub	r1, r3, #2	; 0x2
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    1d78:	e2422002 	sub	r2, r2, #2	; 0x2
    1d7c:	e1510002 	cmp	r1, r2
	return clust * fs->csize + fs->database;
    1d80:	35d8202b 	ldrbcc	r2, [r8, #43]
    1d84:	35983018 	ldrcc	r3, [r8, #24]
    1d88:	30203192 	mlacc	r0, r2, r1, r3
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    1d8c:	21a0000c 	movcs	r0, ip
		if (!ds) { *dir = dptr; return FR_OK; }				/* Matched with end of path */
		if (!(dptr[DIR_Attr] & AM_DIR)) return FR_NO_PATH;	/* Cannot trace because it is a file */
		clust = ((DWORD)LD_WORD(&dptr[DIR_FstClusHI]) << 16) | LD_WORD(&dptr[DIR_FstClusLO]); /* Get cluster# of the directory */
		dj->clust = dj->sclust = clust;				/* Restart scanning at the new directory */
		dj->sect = clust2sect(fs, clust);
		dj->index = 2;
    1d90:	e3a03002 	mov	r3, #2	; 0x2
		}
		if (!ds) { *dir = dptr; return FR_OK; }				/* Matched with end of path */
		if (!(dptr[DIR_Attr] & AM_DIR)) return FR_NO_PATH;	/* Cannot trace because it is a file */
		clust = ((DWORD)LD_WORD(&dptr[DIR_FstClusHI]) << 16) | LD_WORD(&dptr[DIR_FstClusLO]); /* Get cluster# of the directory */
		dj->clust = dj->sclust = clust;				/* Restart scanning at the new directory */
		dj->sect = clust2sect(fs, clust);
    1d94:	e5870010 	str	r0, [r7, #16]
		dj->index = 2;
    1d98:	e1c730b2 	strh	r3, [r7, #2]
    1d9c:	eaffff60 	b	1b24 <trace_path+0x60>
				return !ds ? FR_NO_FILE : FR_NO_PATH;
			if (dptr[DIR_Name] != 0xE5						/* Matched? */
				&& !(dptr[DIR_Attr] & AM_VOL)
				&& !memcmp(&dptr[DIR_Name], fn, 8+3) ) break;
			if (!next_dir_entry(dj))						/* Next directory pointer */
				return !ds ? FR_NO_FILE : FR_NO_PATH;
    1da0:	e3540000 	cmp	r4, #0	; 0x0
    1da4:	0a000001 	beq	1db0 <trace_path+0x2ec>
		if (!(dptr[DIR_Attr] & AM_DIR)) return FR_NO_PATH;	/* Cannot trace because it is a file */
		clust = ((DWORD)LD_WORD(&dptr[DIR_FstClusHI]) << 16) | LD_WORD(&dptr[DIR_FstClusLO]); /* Get cluster# of the directory */
		dj->clust = dj->sclust = clust;				/* Restart scanning at the new directory */
		dj->sect = clust2sect(fs, clust);
		dj->index = 2;
	}
    1da8:	e3a00003 	mov	r0, #3	; 0x3
    1dac:	e89daff8 	ldm	sp, {r3, r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
    1db0:	e3a00002 	mov	r0, #2	; 0x2
}
    1db4:	e89daff8 	ldm	sp, {r3, r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}

	for (;;) {
		ds = make_dirfile(&path, fn);			/* Get a paragraph into fn[] */
		if (ds == 1) return FR_INVALID_NAME;
		for (;;) {
			if (!move_window(fs, dj->sect)) return FR_RW_ERROR;
    1db8:	e2800008 	add	r0, r0, #8	; 0x8
    1dbc:	e89daff8 	ldm	sp, {r3, r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
				&& !(dptr[DIR_Attr] & AM_VOL)
				&& !memcmp(&dptr[DIR_Name], fn, 8+3) ) break;
			if (!next_dir_entry(dj))						/* Next directory pointer */
				return !ds ? FR_NO_FILE : FR_NO_PATH;
		}
		if (!ds) { *dir = dptr; return FR_OK; }				/* Matched with end of path */
    1dc0:	e51b302c 	ldr	r3, [fp, #-44]
    1dc4:	e1a00004 	mov	r0, r4
    1dc8:	e5835000 	str	r5, [r3]
    1dcc:	e89daff8 	ldm	sp, {r3, r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}

00001dd0 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const char *path		/* Pointer to the file or directory path */
)
{
    1dd0:	e1a0c00d 	mov	ip, sp
    1dd4:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
    1dd8:	e24cb004 	sub	fp, ip, #4	; 0x4
    1ddc:	e24b301c 	sub	r3, fp, #28	; 0x1c
    1de0:	e24dd028 	sub	sp, sp, #40	; 0x28
    1de4:	e5230028 	str	r0, [r3, #-40]!
	BYTE *dir, *sdir;
	DWORD dclust, dsect;
	char fn[8+3+1];

	//xprintf("pass2");
	res = auto_mount(&path, &dj.fs, 1);
    1de8:	e24b103c 	sub	r1, fp, #60	; 0x3c
    1dec:	e1a00003 	mov	r0, r3
    1df0:	e3a02001 	mov	r2, #1	; 0x1
    1df4:	ebfffe36 	bl	16d4 <auto_mount>
	if (res != FR_OK) return res;
    1df8:	e3500000 	cmp	r0, #0	; 0x0
	BYTE *dir, *sdir;
	DWORD dclust, dsect;
	char fn[8+3+1];

	//xprintf("pass2");
	res = auto_mount(&path, &dj.fs, 1);
    1dfc:	e24b4040 	sub	r4, fp, #64	; 0x40
	if (res != FR_OK) return res;
    1e00:	0a000001 	beq	1e0c <f_unlink+0x3c>
	dir[DIR_Name] = 0xE5;
	dj.fs->winflag = 1;
	if (!remove_chain(dj.fs, dclust)) return FR_RW_ERROR;	/* Remove the cluster chain */

	return sync(dj.fs);
}
    1e04:	e24bd01c 	sub	sp, fp, #28	; 0x1c
    1e08:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
	char fn[8+3+1];

	//xprintf("pass2");
	res = auto_mount(&path, &dj.fs, 1);
	if (res != FR_OK) return res;
	res = trace_path(&dj, fn, path, &dir);	/* Trace the file path */
    1e0c:	e1a00004 	mov	r0, r4
    1e10:	e24b102c 	sub	r1, fp, #44	; 0x2c
    1e14:	e51b2044 	ldr	r2, [fp, #-68]
    1e18:	e24b3020 	sub	r3, fp, #32	; 0x20
    1e1c:	ebffff28 	bl	1ac4 <trace_path>
	if (res != FR_OK) return res;			/* Trace failed */
    1e20:	e3500000 	cmp	r0, #0	; 0x0
    1e24:	1afffff6 	bne	1e04 <f_unlink+0x34>
	if (!dir) return FR_INVALID_NAME;		/* It is the root directory */
    1e28:	e51b3020 	ldr	r3, [fp, #-32]
    1e2c:	e3530000 	cmp	r3, #0	; 0x0
    1e30:	03a00004 	moveq	r0, #4	; 0x4
    1e34:	0afffff2 	beq	1e04 <f_unlink+0x34>
	if (dir[DIR_Attr] & AM_RDO) return FR_DENIED;	/* It is a R/O object */
    1e38:	e5d3e00b 	ldrb	lr, [r3, #11]
    1e3c:	e21e5001 	ands	r5, lr, #1	; 0x1
    1e40:	1a000037 	bne	1f24 <f_unlink+0x154>
	dsect = dj.fs->winsect;
	dclust = ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);
    1e44:	e5d30015 	ldrb	r0, [r3, #21]
    1e48:	e5d32014 	ldrb	r2, [r3, #20]
    1e4c:	e5d3101b 	ldrb	r1, [r3, #27]
    1e50:	e5d3301a 	ldrb	r3, [r3, #26]
	if (res != FR_OK) return res;
	res = trace_path(&dj, fn, path, &dir);	/* Trace the file path */
	if (res != FR_OK) return res;			/* Trace failed */
	if (!dir) return FR_INVALID_NAME;		/* It is the root directory */
	if (dir[DIR_Attr] & AM_RDO) return FR_DENIED;	/* It is a R/O object */
	dsect = dj.fs->winsect;
    1e54:	e51bc03c 	ldr	ip, [fp, #-60]
	dclust = ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);
    1e58:	e1822400 	orr	r2, r2, r0, lsl #8
    1e5c:	e1833401 	orr	r3, r3, r1, lsl #8
	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
    1e60:	e31e0010 	tst	lr, #16	; 0x10
	res = trace_path(&dj, fn, path, &dir);	/* Trace the file path */
	if (res != FR_OK) return res;			/* Trace failed */
	if (!dir) return FR_INVALID_NAME;		/* It is the root directory */
	if (dir[DIR_Attr] & AM_RDO) return FR_DENIED;	/* It is a R/O object */
	dsect = dj.fs->winsect;
	dclust = ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);
    1e64:	e1836802 	orr	r6, r3, r2, lsl #16
	if (res != FR_OK) return res;
	res = trace_path(&dj, fn, path, &dir);	/* Trace the file path */
	if (res != FR_OK) return res;			/* Trace failed */
	if (!dir) return FR_INVALID_NAME;		/* It is the root directory */
	if (dir[DIR_Attr] & AM_RDO) return FR_DENIED;	/* It is a R/O object */
	dsect = dj.fs->winsect;
    1e68:	e59c7004 	ldr	r7, [ip, #4]
	dclust = ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);
	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
    1e6c:	0a000025 	beq	1f08 <f_unlink+0x138>
		dj.clust = dclust;					/* Check if the sub-dir is empty or not */
    1e70:	e50b6034 	str	r6, [fp, #-52]
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    1e74:	e59c300c 	ldr	r3, [ip, #12]
DWORD clust2sect (	/* !=0: sector number, 0: failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
    1e78:	e2460002 	sub	r0, r6, #2	; 0x2
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    1e7c:	e2433002 	sub	r3, r3, #2	; 0x2
    1e80:	e1500003 	cmp	r0, r3
	return clust * fs->csize + fs->database;
    1e84:	35dc202b 	ldrbcc	r2, [ip, #43]
    1e88:	359c3018 	ldrcc	r3, [ip, #24]
    1e8c:	30213092 	mlacc	r1, r2, r0, r3
	FATFS *fs,		/* File system object */
	DWORD clust		/* Cluster# to be converted */
)
{
	clust -= 2;
	if (clust >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    1e90:	21a01005 	movcs	r1, r5
	dsect = dj.fs->winsect;
	dclust = ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);
	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
		dj.clust = dclust;					/* Check if the sub-dir is empty or not */
		dj.sect = clust2sect(dj.fs, dclust);
		dj.index = 2;
    1e94:	e3a03002 	mov	r3, #2	; 0x2
	if (dir[DIR_Attr] & AM_RDO) return FR_DENIED;	/* It is a R/O object */
	dsect = dj.fs->winsect;
	dclust = ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);
	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
		dj.clust = dclust;					/* Check if the sub-dir is empty or not */
		dj.sect = clust2sect(dj.fs, dclust);
    1e98:	e50b1030 	str	r1, [fp, #-48]
		dj.index = 2;
    1e9c:	e14b33be 	strh	r3, [fp, #-62]
    1ea0:	ea000000 	b	1ea8 <f_unlink+0xd8>
			if (!move_window(dj.fs, dj.sect)) return FR_RW_ERROR;
			sdir = &dj.fs->win[(dj.index & ((SS(dj.fs) - 1) >> 5)) * 32];
			if (sdir[DIR_Name] == 0) break;
			if (sdir[DIR_Name] != 0xE5 && !(sdir[DIR_Attr] & AM_VOL))
				return FR_DENIED;	/* The directory is not empty */
		} while (next_dir_entry(&dj));
    1ea4:	e51bc03c 	ldr	ip, [fp, #-60]
	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
		dj.clust = dclust;					/* Check if the sub-dir is empty or not */
		dj.sect = clust2sect(dj.fs, dclust);
		dj.index = 2;
		do {
			if (!move_window(dj.fs, dj.sect)) return FR_RW_ERROR;
    1ea8:	e1a0000c 	mov	r0, ip
    1eac:	e51b1030 	ldr	r1, [fp, #-48]
    1eb0:	ebfffaa5 	bl	94c <move_window>
    1eb4:	e3500000 	cmp	r0, #0	; 0x0
			sdir = &dj.fs->win[(dj.index & ((SS(dj.fs) - 1) >> 5)) * 32];
			if (sdir[DIR_Name] == 0) break;
			if (sdir[DIR_Name] != 0xE5 && !(sdir[DIR_Attr] & AM_VOL))
				return FR_DENIED;	/* The directory is not empty */
		} while (next_dir_entry(&dj));
    1eb8:	e1a00004 	mov	r0, r4
	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
		dj.clust = dclust;					/* Check if the sub-dir is empty or not */
		dj.sect = clust2sect(dj.fs, dclust);
		dj.index = 2;
		do {
			if (!move_window(dj.fs, dj.sect)) return FR_RW_ERROR;
    1ebc:	0a000016 	beq	1f1c <f_unlink+0x14c>
			sdir = &dj.fs->win[(dj.index & ((SS(dj.fs) - 1) >> 5)) * 32];
    1ec0:	e15b33be 	ldrh	r3, [fp, #-62]
    1ec4:	e51bc03c 	ldr	ip, [fp, #-60]
    1ec8:	e203300f 	and	r3, r3, #15	; 0xf
    1ecc:	e1a03283 	lsl	r3, r3, #5
			if (sdir[DIR_Name] == 0) break;
			if (sdir[DIR_Name] != 0xE5 && !(sdir[DIR_Attr] & AM_VOL))
    1ed0:	e08c2003 	add	r2, ip, r3
		dj.sect = clust2sect(dj.fs, dclust);
		dj.index = 2;
		do {
			if (!move_window(dj.fs, dj.sect)) return FR_RW_ERROR;
			sdir = &dj.fs->win[(dj.index & ((SS(dj.fs) - 1) >> 5)) * 32];
			if (sdir[DIR_Name] == 0) break;
    1ed4:	e08c3003 	add	r3, ip, r3
    1ed8:	e5d33030 	ldrb	r3, [r3, #48]
    1edc:	e3530000 	cmp	r3, #0	; 0x0
    1ee0:	0a000008 	beq	1f08 <f_unlink+0x138>
			if (sdir[DIR_Name] != 0xE5 && !(sdir[DIR_Attr] & AM_VOL))
    1ee4:	e35300e5 	cmp	r3, #229	; 0xe5
    1ee8:	0a000002 	beq	1ef8 <f_unlink+0x128>
    1eec:	e5d2303b 	ldrb	r3, [r2, #59]
    1ef0:	e3130008 	tst	r3, #8	; 0x8
    1ef4:	0a00000a 	beq	1f24 <f_unlink+0x154>
				return FR_DENIED;	/* The directory is not empty */
		} while (next_dir_entry(&dj));
    1ef8:	ebfffb22 	bl	b88 <next_dir_entry>
    1efc:	e3500000 	cmp	r0, #0	; 0x0
    1f00:	1affffe7 	bne	1ea4 <f_unlink+0xd4>
    1f04:	e51bc03c 	ldr	ip, [fp, #-60]
	}
	if (!move_window(dj.fs, dsect)) return FR_RW_ERROR;	/* Mark the directory entry 'deleted' */
    1f08:	e1a0000c 	mov	r0, ip
    1f0c:	e1a01007 	mov	r1, r7
    1f10:	ebfffa8d 	bl	94c <move_window>
    1f14:	e3500000 	cmp	r0, #0	; 0x0
    1f18:	1a000003 	bne	1f2c <f_unlink+0x15c>
	dir[DIR_Name] = 0xE5;
	dj.fs->winflag = 1;
	if (!remove_chain(dj.fs, dclust)) return FR_RW_ERROR;	/* Remove the cluster chain */

	return sync(dj.fs);
    1f1c:	e3a00008 	mov	r0, #8	; 0x8
    1f20:	eaffffb7 	b	1e04 <f_unlink+0x34>
    1f24:	e3a00006 	mov	r0, #6	; 0x6
    1f28:	eaffffb5 	b	1e04 <f_unlink+0x34>
			if (sdir[DIR_Name] != 0xE5 && !(sdir[DIR_Attr] & AM_VOL))
				return FR_DENIED;	/* The directory is not empty */
		} while (next_dir_entry(&dj));
	}
	if (!move_window(dj.fs, dsect)) return FR_RW_ERROR;	/* Mark the directory entry 'deleted' */
	dir[DIR_Name] = 0xE5;
    1f2c:	e51b3020 	ldr	r3, [fp, #-32]
    1f30:	e3e0201a 	mvn	r2, #26	; 0x1a
    1f34:	e5c32000 	strb	r2, [r3]
	dj.fs->winflag = 1;
    1f38:	e51b003c 	ldr	r0, [fp, #-60]
    1f3c:	e3a03001 	mov	r3, #1	; 0x1
    1f40:	e5c0302e 	strb	r3, [r0, #46]
	if (!remove_chain(dj.fs, dclust)) return FR_RW_ERROR;	/* Remove the cluster chain */
    1f44:	e1a01006 	mov	r1, r6
    1f48:	ebfffbe3 	bl	edc <remove_chain>
    1f4c:	e3500000 	cmp	r0, #0	; 0x0
    1f50:	0afffff1 	beq	1f1c <f_unlink+0x14c>

	return sync(dj.fs);
    1f54:	e51b003c 	ldr	r0, [fp, #-60]
    1f58:	ebfffc65 	bl	10f4 <sync>
    1f5c:	eaffffa8 	b	1e04 <f_unlink+0x34>

00001f60 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const char *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    1f60:	e1a0c00d 	mov	ip, sp
    1f64:	e92dddf0 	push	{r4, r5, r6, r7, r8, sl, fp, ip, lr, pc}
    1f68:	e24cb004 	sub	fp, ip, #4	; 0x4
    1f6c:	e24bc024 	sub	ip, fp, #36	; 0x24
    1f70:	e24dd028 	sub	sp, sp, #40	; 0x28
    1f74:	e52c1028 	str	r1, [ip, #-40]!
	DIR dj;
	BYTE *dir;
	char fn[8+3+1];


	fp->fs = NULL;		/* Clear file object */
    1f78:	e3a03000 	mov	r3, #0	; 0x0
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const char *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    1f7c:	e1a04002 	mov	r4, r2
	DIR dj;
	BYTE *dir;
	char fn[8+3+1];


	fp->fs = NULL;		/* Clear file object */
    1f80:	e5803004 	str	r3, [r0, #4]
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const char *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    1f84:	e1a06000 	mov	r6, r0


	fp->fs = NULL;		/* Clear file object */
#if !_FS_READONLY
	mode &= (FA_READ|FA_WRITE|FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW);
	res = auto_mount(&path, &dj.fs, (BYTE)(mode & (FA_WRITE|FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW)));
    1f88:	e24b1044 	sub	r1, fp, #68	; 0x44
    1f8c:	e1a0000c 	mov	r0, ip
    1f90:	e202201e 	and	r2, r2, #30	; 0x1e
    1f94:	ebfffdce 	bl	16d4 <auto_mount>
#else
	mode &= FA_READ;
	res = auto_mount(&path, &dj.fs, 0);
#endif
	if (res != FR_OK) return res;
    1f98:	e3500000 	cmp	r0, #0	; 0x0
	char fn[8+3+1];


	fp->fs = NULL;		/* Clear file object */
#if !_FS_READONLY
	mode &= (FA_READ|FA_WRITE|FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW);
    1f9c:	e204801f 	and	r8, r4, #31	; 0x1f
	res = auto_mount(&path, &dj.fs, (BYTE)(mode & (FA_WRITE|FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW)));
    1fa0:	e24b5048 	sub	r5, fp, #72	; 0x48
#else
	mode &= FA_READ;
	res = auto_mount(&path, &dj.fs, 0);
#endif
	if (res != FR_OK) return res;
    1fa4:	0a000001 	beq	1fb0 <f_open+0x50>
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
	fp->curr_sect = 0;
	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */

	return FR_OK;
}
    1fa8:	e24bd024 	sub	sp, fp, #36	; 0x24
    1fac:	e89dadf0 	ldm	sp, {r4, r5, r6, r7, r8, sl, fp, sp, pc}
#else
	mode &= FA_READ;
	res = auto_mount(&path, &dj.fs, 0);
#endif
	if (res != FR_OK) return res;
	res = trace_path(&dj, fn, path, &dir);	/* Trace the file path */
    1fb0:	e24ba034 	sub	sl, fp, #52	; 0x34
    1fb4:	e24b7028 	sub	r7, fp, #40	; 0x28
    1fb8:	e1a00005 	mov	r0, r5
    1fbc:	e1a0100a 	mov	r1, sl
    1fc0:	e51b204c 	ldr	r2, [fp, #-76]
    1fc4:	e1a03007 	mov	r3, r7
    1fc8:	ebfffebd 	bl	1ac4 <trace_path>

#if !_FS_READONLY
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW)) {
    1fcc:	e314001c 	tst	r4, #28	; 0x1c
    1fd0:	0a00004c 	beq	2108 <f_open+0x1a8>
		DWORD ps, rs;
		if (res != FR_OK) {		/* No file, create new */
    1fd4:	e3500000 	cmp	r0, #0	; 0x0
    1fd8:	1a00007b 	bne	21cc <f_open+0x26c>
			memcpy(&dir[DIR_Name], fn, 8+3);
			dir[DIR_NTres] = fn[11];
			mode |= FA_CREATE_ALWAYS;
		}
		else {					/* Any object is already existing */
			if (mode & FA_CREATE_NEW)			/* Cannot create new */
    1fdc:	e3140004 	tst	r4, #4	; 0x4
    1fe0:	13a00007 	movne	r0, #7	; 0x7
    1fe4:	1affffef 	bne	1fa8 <f_open+0x48>
				return FR_EXIST;
			if (!dir || (dir[DIR_Attr] & (AM_RDO|AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
    1fe8:	e51b5028 	ldr	r5, [fp, #-40]
    1fec:	e3550000 	cmp	r5, #0	; 0x0
    1ff0:	0a000071 	beq	21bc <f_open+0x25c>
    1ff4:	e5d5300b 	ldrb	r3, [r5, #11]
    1ff8:	e2137011 	ands	r7, r3, #17	; 0x11
    1ffc:	1a00006e 	bne	21bc <f_open+0x25c>
				return FR_DENIED;
			if (mode & FA_CREATE_ALWAYS) {		/* Resize it to zero if needed */
    2000:	e3140008 	tst	r4, #8	; 0x8
    2004:	0a00004b 	beq	2138 <f_open+0x1d8>
				rs = ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);	/* Get start cluster */
    2008:	e5d5e015 	ldrb	lr, [r5, #21]
    200c:	e5d50014 	ldrb	r0, [r5, #20]
    2010:	e5d5c01b 	ldrb	ip, [r5, #27]
    2014:	e5d5101a 	ldrb	r1, [r5, #26]
				ST_WORD(&dir[DIR_FstClusHI], 0);	/* cluster = 0 */
    2018:	e5c57014 	strb	r7, [r5, #20]
    201c:	e51b3028 	ldr	r3, [fp, #-40]
    2020:	e5c37015 	strb	r7, [r3, #21]
				ST_WORD(&dir[DIR_FstClusLO], 0);
    2024:	e51b2028 	ldr	r2, [fp, #-40]
    2028:	e5c2701a 	strb	r7, [r2, #26]
    202c:	e51b3028 	ldr	r3, [fp, #-40]
    2030:	e5c3701b 	strb	r7, [r3, #27]
				ST_DWORD(&dir[DIR_FileSize], 0);	/* size = 0 */
    2034:	e51b2028 	ldr	r2, [fp, #-40]
    2038:	e5c2701c 	strb	r7, [r2, #28]
    203c:	e51b3028 	ldr	r3, [fp, #-40]
    2040:	e5c3701d 	strb	r7, [r3, #29]
    2044:	e51b2028 	ldr	r2, [fp, #-40]
    2048:	e5c2701e 	strb	r7, [r2, #30]
    204c:	e51b3028 	ldr	r3, [fp, #-40]
    2050:	e5c3701f 	strb	r7, [r3, #31]
				dj.fs->winflag = 1;
    2054:	e51b2044 	ldr	r2, [fp, #-68]
			if (mode & FA_CREATE_NEW)			/* Cannot create new */
				return FR_EXIST;
			if (!dir || (dir[DIR_Attr] & (AM_RDO|AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
				return FR_DENIED;
			if (mode & FA_CREATE_ALWAYS) {		/* Resize it to zero if needed */
				rs = ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);	/* Get start cluster */
    2058:	e180040e 	orr	r0, r0, lr, lsl #8
    205c:	e181140c 	orr	r1, r1, ip, lsl #8
    2060:	e1815800 	orr	r5, r1, r0, lsl #16
				ST_WORD(&dir[DIR_FstClusHI], 0);	/* cluster = 0 */
				ST_WORD(&dir[DIR_FstClusLO], 0);
				ST_DWORD(&dir[DIR_FileSize], 0);	/* size = 0 */
				dj.fs->winflag = 1;
    2064:	e3a03001 	mov	r3, #1	; 0x1
    2068:	e5c2302e 	strb	r3, [r2, #46]
				ps = dj.fs->winsect;			/* Remove the cluster chain */
				if (!remove_chain(dj.fs, rs) || !move_window(dj.fs, ps))
    206c:	e1a00002 	mov	r0, r2
    2070:	e1a01005 	mov	r1, r5
				rs = ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);	/* Get start cluster */
				ST_WORD(&dir[DIR_FstClusHI], 0);	/* cluster = 0 */
				ST_WORD(&dir[DIR_FstClusLO], 0);
				ST_DWORD(&dir[DIR_FileSize], 0);	/* size = 0 */
				dj.fs->winflag = 1;
				ps = dj.fs->winsect;			/* Remove the cluster chain */
    2074:	e5924004 	ldr	r4, [r2, #4]
				if (!remove_chain(dj.fs, rs) || !move_window(dj.fs, ps))
    2078:	ebfffb97 	bl	edc <remove_chain>
    207c:	e3500000 	cmp	r0, #0	; 0x0
    2080:	0a00006b 	beq	2234 <f_open+0x2d4>
    2084:	e1a01004 	mov	r1, r4
    2088:	e51b0044 	ldr	r0, [fp, #-68]
    208c:	ebfffa2e 	bl	94c <move_window>
    2090:	e3500000 	cmp	r0, #0	; 0x0
    2094:	0a000066 	beq	2234 <f_open+0x2d4>
					return FR_RW_ERROR;
				dj.fs->last_clust = rs - 1;		/* Reuse the cluster hole */
    2098:	e51b3044 	ldr	r3, [fp, #-68]
    209c:	e2452001 	sub	r2, r5, #1	; 0x1
    20a0:	e583201c 	str	r2, [r3, #28]
			}
		}
		if (mode & FA_CREATE_ALWAYS) {
			dir[DIR_Attr] = 0;					/* Reset attribute */
    20a4:	e51b3028 	ldr	r3, [fp, #-40]
    20a8:	e3a02000 	mov	r2, #0	; 0x0
    20ac:	e5c3200b 	strb	r2, [r3, #11]
			ps = get_fattime();
    20b0:	eb000222 	bl	2940 <get_fattime>
			ST_DWORD(&dir[DIR_CrtTime], ps);	/* Created time */
    20b4:	e51b2028 	ldr	r2, [fp, #-40]
    20b8:	e20010ff 	and	r1, r0, #255	; 0xff
    20bc:	e5c2100e 	strb	r1, [r2, #14]
    20c0:	e51b1028 	ldr	r1, [fp, #-40]
    20c4:	e1a03800 	lsl	r3, r0, #16
    20c8:	e1a03c23 	lsr	r3, r3, #24
    20cc:	e5c1300f 	strb	r3, [r1, #15]
    20d0:	e51b3028 	ldr	r3, [fp, #-40]
    20d4:	e1a02820 	lsr	r2, r0, #16
    20d8:	e20220ff 	and	r2, r2, #255	; 0xff
    20dc:	e5c32010 	strb	r2, [r3, #16]
    20e0:	e51b3028 	ldr	r3, [fp, #-40]
    20e4:	e1a00c20 	lsr	r0, r0, #24
    20e8:	e5c30011 	strb	r0, [r3, #17]
			dj.fs->winflag = 1;
    20ec:	e51b2044 	ldr	r2, [fp, #-68]
    20f0:	e3a03001 	mov	r3, #1	; 0x1
    20f4:	e5c2302e 	strb	r3, [r2, #46]
			mode |= FA__WRITTEN;				/* Set file changed flag */
    20f8:	e3888020 	orr	r8, r8, #32	; 0x20
    20fc:	e51b5028 	ldr	r5, [fp, #-40]
    2100:	e51bc044 	ldr	ip, [fp, #-68]
    2104:	ea00000d 	b	2140 <f_open+0x1e0>
		}
	}
	/* Open an existing file */
	else {
#endif /* !_FS_READONLY */
		if (res != FR_OK) return res;			/* Trace failed */
    2108:	e3500000 	cmp	r0, #0	; 0x0
    210c:	1affffa5 	bne	1fa8 <f_open+0x48>
		if (!dir || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
    2110:	e51b5028 	ldr	r5, [fp, #-40]
    2114:	e3550000 	cmp	r5, #0	; 0x0
    2118:	0a000029 	beq	21c4 <f_open+0x264>
    211c:	e5d5300b 	ldrb	r3, [r5, #11]
    2120:	e3130010 	tst	r3, #16	; 0x10
    2124:	1a000026 	bne	21c4 <f_open+0x264>
			return FR_NO_FILE;
#if !_FS_READONLY
		if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    2128:	e3140002 	tst	r4, #2	; 0x2
    212c:	0a000001 	beq	2138 <f_open+0x1d8>
    2130:	e3130001 	tst	r3, #1	; 0x1
    2134:	1a000020 	bne	21bc <f_open+0x25c>
    2138:	e51bc044 	ldr	ip, [fp, #-68]
    213c:	e1a0200c 	mov	r2, ip
			return FR_DENIED;
	}
	fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
    2140:	e5923004 	ldr	r3, [r2, #4]
	fp->dir_ptr = dir;
    2144:	e5865020 	str	r5, [r6, #32]
#endif
	fp->flag = mode;					/* File access mode */
    2148:	e5c68002 	strb	r8, [r6, #2]
			return FR_NO_FILE;
#if !_FS_READONLY
		if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
			return FR_DENIED;
	}
	fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
    214c:	e586301c 	str	r3, [r6, #28]
	fp->dir_ptr = dir;
#endif
	fp->flag = mode;					/* File access mode */
	fp->org_clust =						/* File start cluster */
    2150:	e5d50015 	ldrb	r0, [r5, #21]
    2154:	e5d52014 	ldrb	r2, [r5, #20]
    2158:	e5d5101b 	ldrb	r1, [r5, #27]
    215c:	e5d5301a 	ldrb	r3, [r5, #26]
    2160:	e1822400 	orr	r2, r2, r0, lsl #8
    2164:	e1833401 	orr	r3, r3, r1, lsl #8
    2168:	e1833802 	orr	r3, r3, r2, lsl #16
    216c:	e5863010 	str	r3, [r6, #16]
		((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);
	fp->fsize = LD_DWORD(&dir[DIR_FileSize]);	/* File size */
    2170:	e5d5201f 	ldrb	r2, [r5, #31]
    2174:	e5d5301e 	ldrb	r3, [r5, #30]
    2178:	e1a03803 	lsl	r3, r3, #16
    217c:	e1833c02 	orr	r3, r3, r2, lsl #24
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
    2180:	e3e02000 	mvn	r2, #0	; 0x0
	fp->dir_ptr = dir;
#endif
	fp->flag = mode;					/* File access mode */
	fp->org_clust =						/* File start cluster */
		((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);
	fp->fsize = LD_DWORD(&dir[DIR_FileSize]);	/* File size */
    2184:	e5d5001d 	ldrb	r0, [r5, #29]
    2188:	e5d5101c 	ldrb	r1, [r5, #28]
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
    218c:	e5c62003 	strb	r2, [r6, #3]
	fp->dir_ptr = dir;
#endif
	fp->flag = mode;					/* File access mode */
	fp->org_clust =						/* File start cluster */
		((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);
	fp->fsize = LD_DWORD(&dir[DIR_FileSize]);	/* File size */
    2190:	e1833001 	orr	r3, r3, r1
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
	fp->curr_sect = 0;
	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */
    2194:	e1dc10b0 	ldrh	r1, [ip]
#endif
	fp->flag = mode;					/* File access mode */
	fp->org_clust =						/* File start cluster */
		((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);
	fp->fsize = LD_DWORD(&dir[DIR_FileSize]);	/* File size */
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
    2198:	e2822001 	add	r2, r2, #1	; 0x1
	fp->dir_ptr = dir;
#endif
	fp->flag = mode;					/* File access mode */
	fp->org_clust =						/* File start cluster */
		((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);
	fp->fsize = LD_DWORD(&dir[DIR_FileSize]);	/* File size */
    219c:	e1833400 	orr	r3, r3, r0, lsl #8
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
	fp->curr_sect = 0;
	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */
    21a0:	e1c610b0 	strh	r1, [r6]
	fp->dir_ptr = dir;
#endif
	fp->flag = mode;					/* File access mode */
	fp->org_clust =						/* File start cluster */
		((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);
	fp->fsize = LD_DWORD(&dir[DIR_FileSize]);	/* File size */
    21a4:	e586300c 	str	r3, [r6, #12]
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
    21a8:	e5862008 	str	r2, [r6, #8]
	fp->curr_sect = 0;
    21ac:	e5862018 	str	r2, [r6, #24]
	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */
    21b0:	e586c004 	str	ip, [r6, #4]
    21b4:	e1a00002 	mov	r0, r2
    21b8:	eaffff7a 	b	1fa8 <f_open+0x48>

	return FR_OK;
    21bc:	e3a00006 	mov	r0, #6	; 0x6
    21c0:	eaffff78 	b	1fa8 <f_open+0x48>
    21c4:	e3a00002 	mov	r0, #2	; 0x2
    21c8:	eaffff76 	b	1fa8 <f_open+0x48>
#if !_FS_READONLY
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW)) {
		DWORD ps, rs;
		if (res != FR_OK) {		/* No file, create new */
			if (res != FR_NO_FILE) return res;
    21cc:	e3500002 	cmp	r0, #2	; 0x2
    21d0:	1affff74 	bne	1fa8 <f_open+0x48>
			res = reserve_direntry(&dj, &dir);
    21d4:	e1a00005 	mov	r0, r5
    21d8:	e1a01007 	mov	r1, r7
    21dc:	ebfffb65 	bl	f78 <reserve_direntry>
			if (res != FR_OK) return res;
    21e0:	e3500000 	cmp	r0, #0	; 0x0
    21e4:	1affff6f 	bne	1fa8 <f_open+0x48>
			memset(dir, 0, 32);		/* Initialize the new entry with open name */
    21e8:	e1a01000 	mov	r1, r0
    21ec:	e3a02020 	mov	r2, #32	; 0x20
    21f0:	e51b0028 	ldr	r0, [fp, #-40]
    21f4:	eb000c58 	bl	535c <memset>
			memcpy(&dir[DIR_Name], fn, 8+3);
    21f8:	e1a0100a 	mov	r1, sl
    21fc:	e3a0200b 	mov	r2, #11	; 0xb
    2200:	e51b0028 	ldr	r0, [fp, #-40]
    2204:	eb000c15 	bl	5260 <memcpy>
			dir[DIR_NTres] = fn[11];
			mode |= FA_CREATE_ALWAYS;
    2208:	e3881008 	orr	r1, r8, #8	; 0x8
			if (res != FR_NO_FILE) return res;
			res = reserve_direntry(&dj, &dir);
			if (res != FR_OK) return res;
			memset(dir, 0, 32);		/* Initialize the new entry with open name */
			memcpy(&dir[DIR_Name], fn, 8+3);
			dir[DIR_NTres] = fn[11];
    220c:	e55b2029 	ldrb	r2, [fp, #-41]
    2210:	e51b3028 	ldr	r3, [fp, #-40]
				if (!remove_chain(dj.fs, rs) || !move_window(dj.fs, ps))
					return FR_RW_ERROR;
				dj.fs->last_clust = rs - 1;		/* Reuse the cluster hole */
			}
		}
		if (mode & FA_CREATE_ALWAYS) {
    2214:	e3110008 	tst	r1, #8	; 0x8
			if (res != FR_NO_FILE) return res;
			res = reserve_direntry(&dj, &dir);
			if (res != FR_OK) return res;
			memset(dir, 0, 32);		/* Initialize the new entry with open name */
			memcpy(&dir[DIR_Name], fn, 8+3);
			dir[DIR_NTres] = fn[11];
    2218:	e5c3200c 	strb	r2, [r3, #12]
			mode |= FA_CREATE_ALWAYS;
    221c:	e20180ff 	and	r8, r1, #255	; 0xff
				if (!remove_chain(dj.fs, rs) || !move_window(dj.fs, ps))
					return FR_RW_ERROR;
				dj.fs->last_clust = rs - 1;		/* Reuse the cluster hole */
			}
		}
		if (mode & FA_CREATE_ALWAYS) {
    2220:	1affff9f 	bne	20a4 <f_open+0x144>
    2224:	e51bc044 	ldr	ip, [fp, #-68]
    2228:	e51b5028 	ldr	r5, [fp, #-40]
    222c:	e1a0200c 	mov	r2, ip
    2230:	eaffffc2 	b	2140 <f_open+0x1e0>
	fp->fsize = LD_DWORD(&dir[DIR_FileSize]);	/* File size */
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
	fp->curr_sect = 0;
	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */

	return FR_OK;
    2234:	e3a00008 	mov	r0, #8	; 0x8
    2238:	eaffff5a 	b	1fa8 <f_open+0x48>

0000223c <disk_status>:
/* Return Disk Status                                                    */

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0..) */
)
{
    223c:	e1a0c00d 	mov	ip, sp
    2240:	e92dd800 	push	{fp, ip, lr, pc}
	if ( drv != 0 ) return STA_NOINIT;
    2244:	e31000ff 	tst	r0, #255	; 0xff

	return Stat;
    2248:	059f3010 	ldreq	r3, [pc, #16]	; 2260 <disk_status+0x24>
    224c:	05d32000 	ldrbeq	r2, [r3]
/* Return Disk Status                                                    */

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0..) */
)
{
    2250:	e24cb004 	sub	fp, ip, #4	; 0x4
	if ( drv != 0 ) return STA_NOINIT;
    2254:	13a00001 	movne	r0, #1	; 0x1

	return Stat;
    2258:	020200ff 	andeq	r0, r2, #255	; 0xff
}
    225c:	e89da800 	ldm	sp, {fp, sp, pc}
    2260:	40000000 	.word	0x40000000

00002264 <SELECT>:
	return ( st & ( 1<<8 ) ) ? 1 : 0;
}

// state to trans (SD Card State Diagram: V2.2 P4-7)
static void SELECT(void)
{
    2264:	e1a0c00d 	mov	ip, sp
    2268:	e92dd810 	push	{r4, fp, ip, lr, pc}
	DWORD currst, st;
	dump_status("before select");

	Timer2 = 1000;
    226c:	e59f403c 	ldr	r4, [pc, #60]	; 22b0 <SELECT+0x4c>
    2270:	e3a03ffa 	mov	r3, #1000	; 0x3e8
    2274:	e5843000 	str	r3, [r4]
	return ( st & ( 1<<8 ) ) ? 1 : 0;
}

// state to trans (SD Card State Diagram: V2.2 P4-7)
static void SELECT(void)
{
    2278:	e24cb004 	sub	fp, ip, #4	; 0x4
	dump_status("before select");

	Timer2 = 1000;
	do {
		// cmd7 until state is trans
		st = MCI_Send_Status();
    227c:	eb000534 	bl	3754 <MCI_Send_Status>
		currst = currstate_from_status(st);
		if ( currst != CURR_STATE_TRAN ) {
    2280:	e1a004a0 	lsr	r0, r0, #9
    2284:	e20000ff 	and	r0, r0, #255	; 0xff
    2288:	e3500004 	cmp	r0, #4	; 0x4
    228c:	1a000001 	bne	2298 <SELECT+0x34>
				diskio_printf("SELECT Select_Card failed - retry\n");
			}
		}
	} while ( ( currst != CURR_STATE_TRAN ) && Timer2 );

	if ( Timer2 == 0 ) {
    2290:	e5943000 	ldr	r3, [r4]
		diskio_printf("SELECT timeout changeing to trans\n");
	}
	dump_status("after select");
}
    2294:	e89da810 	ldm	sp, {r4, fp, sp, pc}
	do {
		// cmd7 until state is trans
		st = MCI_Send_Status();
		currst = currstate_from_status(st);
		if ( currst != CURR_STATE_TRAN ) {
			if ( MCI_Select_Card() == FALSE ) {
    2298:	eb0004c5 	bl	35b4 <MCI_Select_Card>
				diskio_printf("SELECT Select_Card failed - retry\n");
			}
		}
	} while ( ( currst != CURR_STATE_TRAN ) && Timer2 );
    229c:	e5943000 	ldr	r3, [r4]
    22a0:	e3530000 	cmp	r3, #0	; 0x0
    22a4:	1afffff4 	bne	227c <SELECT+0x18>

	if ( Timer2 == 0 ) {
    22a8:	e5943000 	ldr	r3, [r4]
		diskio_printf("SELECT timeout changeing to trans\n");
	}
	dump_status("after select");
}
    22ac:	e89da810 	ldm	sp, {r4, fp, sp, pc}
    22b0:	40000708 	.word	0x40000708

000022b4 <DESELECT>:

// state to stby
static void DESELECT(void)
{
    22b4:	e1a0c00d 	mov	ip, sp
    22b8:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
	DWORD cardtype_save, st, currst;

	Timer2 = 500;
    22bc:	e59f405c 	ldr	r4, [pc, #92]	; 2320 <DESELECT+0x6c>
    22c0:	e3a03f7d 	mov	r3, #500	; 0x1f4
    22c4:	e5843000 	str	r3, [r4]
	dump_status("after select");
}

// state to stby
static void DESELECT(void)
{
    22c8:	e24cb004 	sub	fp, ip, #4	; 0x4
	DWORD cardtype_save, st, currst;

	Timer2 = 500;
	do {
		st = MCI_Send_Status();
    22cc:	eb000520 	bl	3754 <MCI_Send_Status>
		
		currst = currstate_from_status(st);
    22d0:	e1a004a0 	lsr	r0, r0, #9
    22d4:	e20000ff 	and	r0, r0, #255	; 0xff
	} while ( ( currst != CURR_STATE_TRAN ) && 
	          ( currst != CURR_STATE_STBY  ) && 
	          Timer2 );
    22d8:	e2403003 	sub	r3, r0, #3	; 0x3
    22dc:	e3530001 	cmp	r3, #1	; 0x1
    22e0:	9a000002 	bls	22f0 <DESELECT+0x3c>
    22e4:	e5943000 	ldr	r3, [r4]
    22e8:	e3530000 	cmp	r3, #0	; 0x0
    22ec:	1afffff6 	bne	22cc <DESELECT+0x18>

	if ( Timer2 == 0 ) {
    22f0:	e5943000 	ldr	r3, [r4]
    22f4:	e3530000 	cmp	r3, #0	; 0x0
    22f8:	089da830 	ldmeq	sp, {r4, r5, fp, sp, pc}
		diskio_printf("DESELCT timeout waiting trans or stby\n");
	}
	else if ( currst == CURR_STATE_TRAN ) {
    22fc:	e3500004 	cmp	r0, #4	; 0x4
    2300:	189da830 	ldmne	sp, {r4, r5, fp, sp, pc}
		cardtype_save = MCI_CardType;
    2304:	e59f4018 	ldr	r4, [pc, #24]	; 2324 <DESELECT+0x70>
		// CMD7: trans to stby (RCA 0) / de-select
		MCI_CardType = 0;
    2308:	e3a03000 	mov	r3, #0	; 0x0

	if ( Timer2 == 0 ) {
		diskio_printf("DESELCT timeout waiting trans or stby\n");
	}
	else if ( currst == CURR_STATE_TRAN ) {
		cardtype_save = MCI_CardType;
    230c:	e5945000 	ldr	r5, [r4]
		// CMD7: trans to stby (RCA 0) / de-select
		MCI_CardType = 0;
    2310:	e5843000 	str	r3, [r4]
		if ( MCI_Select_Card() == FALSE ) {
    2314:	eb0004a6 	bl	35b4 <MCI_Select_Card>
			diskio_printf("DESELECT failed\n");
		}
		MCI_CardType = cardtype_save;
    2318:	e5845000 	str	r5, [r4]
    231c:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
    2320:	40000708 	.word	0x40000708
    2324:	40000050 	.word	0x40000050

00002328 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0..) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
    2328:	e1a0c00d 	mov	ip, sp
	DRESULT res;
	BYTE n; // buffered csd[16];
	DWORD csize;

	if (drv) return RES_PARERR;
    232c:	e31000ff 	tst	r0, #255	; 0xff
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0..) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
    2330:	e92dd810 	push	{r4, fp, ip, lr, pc}
    2334:	e20110ff 	and	r1, r1, #255	; 0xff
    2338:	e1a04002 	mov	r4, r2
    233c:	e24cb004 	sub	fp, ip, #4	; 0x4
	DRESULT res;
	BYTE n; // buffered csd[16];
	DWORD csize;

	if (drv) return RES_PARERR;
    2340:	13a04004 	movne	r4, #4	; 0x4
    2344:	1a000017 	bne	23a8 <disk_ioctl+0x80>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
    2348:	e59f31f0 	ldr	r3, [pc, #496]	; 2540 <disk_ioctl+0x218>
    234c:	e5d32000 	ldrb	r2, [r3]
    2350:	e3120001 	tst	r2, #1	; 0x1
    2354:	13a04003 	movne	r4, #3	; 0x3
    2358:	1a000012 	bne	23a8 <disk_ioctl+0x80>

	res = RES_ERROR;

	switch (ctrl) {
    235c:	e3510003 	cmp	r1, #3	; 0x3
    2360:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
    2364:	ea000011 	b	23b0 <disk_ioctl+0x88>
    2368:	00002378 	.word	0x00002378
    236c:	00002428 	.word	0x00002428
    2370:	00002414 	.word	0x00002414
    2374:	000023bc 	.word	0x000023bc
	BYTE res;
	DWORD st;
	// DWORD currst;

	res = 0xaa;
	Timer2 = 500;	/* Wait for ready in timeout of 500ms */
    2378:	e59f41c4 	ldr	r4, [pc, #452]	; 2544 <disk_ioctl+0x21c>
	res = RES_ERROR;

	switch (ctrl) {

		case CTRL_SYNC :	/* Flush dirty buffer if present */
			SELECT();
    237c:	ebffffb8 	bl	2264 <SELECT>
	BYTE res;
	DWORD st;
	// DWORD currst;

	res = 0xaa;
	Timer2 = 500;	/* Wait for ready in timeout of 500ms */
    2380:	e3a03f7d 	mov	r3, #500	; 0x1f4
    2384:	e5843000 	str	r3, [r4]
	do {
		st = MCI_Send_Status();
    2388:	eb0004f1 	bl	3754 <MCI_Send_Status>
		if ( st == INVALID_RESPONSE ) {
    238c:	e3700001 	cmn	r0, #1	; 0x1
    2390:	0a000040 	beq	2498 <disk_ioctl+0x170>
			diskio_printf("wait_ready: Send_Status INVALID_RESPONSE\n");
		}
		else {
			// currst = currstate_from_status(st);
			// if ( currst == 3 /* stby */ || currst == 4 /* trans */) {
			if ( status_ready_bit( st ) ) {
    2394:	e3100c01 	tst	r0, #256	; 0x100
    2398:	0a00003e 	beq	2498 <disk_ioctl+0x170>
			}
		}
	}
	while ( (res != 0xFF) && Timer2 );

	if ( Timer2 == 0 ) {
    239c:	e5943000 	ldr	r3, [r4]
    23a0:	e3a04000 	mov	r4, #0	; 0x0

// well, no SPI used here but will keep the interface compatible with
// Chan's examples
static void release_spi(void)
{
	DESELECT();
    23a4:	ebffffc2 	bl	22b4 <DESELECT>
	}

	release_spi(); 

	return res;
}
    23a8:	e1a00004 	mov	r0, r4
    23ac:	e89da810 	ldm	sp, {r4, fp, sp, pc}
	if (drv) return RES_PARERR;
	if (Stat & STA_NOINIT) return RES_NOTRDY;

	res = RES_ERROR;

	switch (ctrl) {
    23b0:	e3a04004 	mov	r4, #4	; 0x4

// well, no SPI used here but will keep the interface compatible with
// Chan's examples
static void release_spi(void)
{
	DESELECT();
    23b4:	ebffffbe 	bl	22b4 <DESELECT>
    23b8:	eafffffa 	b	23a8 <disk_ioctl+0x80>
			res = RES_OK;
			break;

		
		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sectors (DWORD) */
			if (CardType & 4) {   /* SDC ver 2.00 - use cached  Read SD status */
    23bc:	e59f3184 	ldr	r3, [pc, #388]	; 2548 <disk_ioctl+0x220>
    23c0:	e5933000 	ldr	r3, [r3]
    23c4:	e213c004 	ands	ip, r3, #4	; 0x4
    23c8:	1a00003a 	bne	24b8 <disk_ioctl+0x190>
				// TODO - untested!
				*(DWORD*)buff = 16UL << (sd_status[10] >> 4);
				res = RES_OK;
			} 
			else {   /* SDC ver 1.XX or MMC */
				if (CardType & 2) {			/* SDC ver 1.XX */
    23cc:	e213e002 	ands	lr, r3, #2	; 0x2
    23d0:	0a00004b 	beq	2504 <disk_ioctl+0x1dc>
					*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
    23d4:	e59f2170 	ldr	r2, [pc, #368]	; 254c <disk_ioctl+0x224>
    23d8:	e5d2300b 	ldrb	r3, [r2, #11]
    23dc:	e5d2100a 	ldrb	r1, [r2, #10]
    23e0:	e5d2000d 	ldrb	r0, [r2, #13]
    23e4:	e1a033a3 	lsr	r3, r3, #7
    23e8:	e201103f 	and	r1, r1, #63	; 0x3f
    23ec:	e1a01081 	lsl	r1, r1, #1
    23f0:	e2833001 	add	r3, r3, #1	; 0x1
    23f4:	e1a00320 	lsr	r0, r0, #6
    23f8:	e0833001 	add	r3, r3, r1
    23fc:	e2400001 	sub	r0, r0, #1	; 0x1
    2400:	e1a03013 	lsl	r3, r3, r0
    2404:	e5843000 	str	r3, [r4]
    2408:	e1a0400c 	mov	r4, ip

// well, no SPI used here but will keep the interface compatible with
// Chan's examples
static void release_spi(void)
{
	DESELECT();
    240c:	ebffffa8 	bl	22b4 <DESELECT>
    2410:	eaffffe4 	b	23a8 <disk_ioctl+0x80>
				res = RES_OK;
			}
			break;

		case GET_SECTOR_SIZE :	/* Get sectors on the disk (WORD) */
			*(WORD*)buff = 512;
    2414:	e3a03c02 	mov	r3, #512	; 0x200
    2418:	e1c430b0 	strh	r3, [r4]
    241c:	e3a04000 	mov	r4, #0	; 0x0

// well, no SPI used here but will keep the interface compatible with
// Chan's examples
static void release_spi(void)
{
	DESELECT();
    2420:	ebffffa3 	bl	22b4 <DESELECT>
    2424:	eaffffdf 	b	23a8 <disk_ioctl+0x80>
			*(WORD*)buff = 512;
			res = RES_OK;
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (WORD) */
			if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
    2428:	e59fc11c 	ldr	ip, [pc, #284]	; 254c <disk_ioctl+0x224>
    242c:	e5dc3000 	ldrb	r3, [ip]
    2430:	e1a03323 	lsr	r3, r3, #6
    2434:	e3530001 	cmp	r3, #1	; 0x1
    2438:	0a000027 	beq	24dc <disk_ioctl+0x1b4>
				*(DWORD*)buff = (DWORD)csize << 10;
			} 
			else {					/* MMC or SDC ver 1.XX */
				n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
				*(DWORD*)buff = (DWORD)csize << (n - 9);
    243c:	e5dc0009 	ldrb	r0, [ip, #9]
    2440:	e5dc3007 	ldrb	r3, [ip, #7]
    2444:	e5dc2005 	ldrb	r2, [ip, #5]
    2448:	e5dce008 	ldrb	lr, [ip, #8]
    244c:	e5dc1006 	ldrb	r1, [ip, #6]
    2450:	e5dcc00a 	ldrb	ip, [ip, #10]
    2454:	e1a03103 	lsl	r3, r3, #2
    2458:	e202200f 	and	r2, r2, #15	; 0xf
    245c:	e2000003 	and	r0, r0, #3	; 0x3
    2460:	e083332e 	add	r3, r3, lr, lsr #6
    2464:	e08223ac 	add	r2, r2, ip, lsr #7
    2468:	e1a00080 	lsl	r0, r0, #1
    246c:	e2011003 	and	r1, r1, #3	; 0x3
    2470:	e0822000 	add	r2, r2, r0
    2474:	e1a01501 	lsl	r1, r1, #10
    2478:	e2833001 	add	r3, r3, #1	; 0x1
    247c:	e0833001 	add	r3, r3, r1
    2480:	e2422007 	sub	r2, r2, #7	; 0x7
    2484:	e1a03213 	lsl	r3, r3, r2
    2488:	e5843000 	str	r3, [r4]
    248c:	e3a04000 	mov	r4, #0	; 0x0

// well, no SPI used here but will keep the interface compatible with
// Chan's examples
static void release_spi(void)
{
	DESELECT();
    2490:	ebffff87 	bl	22b4 <DESELECT>
    2494:	eaffffc3 	b	23a8 <disk_ioctl+0x80>
			if ( status_ready_bit( st ) ) {
				res = 0xff;
			}
		}
	}
	while ( (res != 0xFF) && Timer2 );
    2498:	e5943000 	ldr	r3, [r4]
    249c:	e3530000 	cmp	r3, #0	; 0x0
    24a0:	1affffb8 	bne	2388 <disk_ioctl+0x60>

	if ( Timer2 == 0 ) {
    24a4:	e59f3098 	ldr	r3, [pc, #152]	; 2544 <disk_ioctl+0x21c>
    24a8:	e3a04001 	mov	r4, #1	; 0x1
    24ac:	e5933000 	ldr	r3, [r3]

// well, no SPI used here but will keep the interface compatible with
// Chan's examples
static void release_spi(void)
{
	DESELECT();
    24b0:	ebffff7f 	bl	22b4 <DESELECT>
    24b4:	eaffffbb 	b	23a8 <disk_ioctl+0x80>

		
		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sectors (DWORD) */
			if (CardType & 4) {   /* SDC ver 2.00 - use cached  Read SD status */
				// TODO - untested!
				*(DWORD*)buff = 16UL << (sd_status[10] >> 4);
    24b8:	e59f3090 	ldr	r3, [pc, #144]	; 2550 <disk_ioctl+0x228>
    24bc:	e5d3200a 	ldrb	r2, [r3, #10]
    24c0:	e3a03010 	mov	r3, #16	; 0x10
    24c4:	e1a02222 	lsr	r2, r2, #4
    24c8:	e1a03213 	lsl	r3, r3, r2
    24cc:	e5843000 	str	r3, [r4]
    24d0:	e3a04000 	mov	r4, #0	; 0x0

// well, no SPI used here but will keep the interface compatible with
// Chan's examples
static void release_spi(void)
{
	DESELECT();
    24d4:	ebffff76 	bl	22b4 <DESELECT>
    24d8:	eaffffb2 	b	23a8 <disk_ioctl+0x80>
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (WORD) */
			if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
				csize = csd[9] + ((WORD)csd[8] << 8) + 1;
				*(DWORD*)buff = (DWORD)csize << 10;
    24dc:	e5dc2008 	ldrb	r2, [ip, #8]
    24e0:	e5dc3009 	ldrb	r3, [ip, #9]
    24e4:	e1a02402 	lsl	r2, r2, #8
    24e8:	e2833001 	add	r3, r3, #1	; 0x1
    24ec:	e0833002 	add	r3, r3, r2
    24f0:	e1a03503 	lsl	r3, r3, #10
    24f4:	e5843000 	str	r3, [r4]
    24f8:	e3a04000 	mov	r4, #0	; 0x0

// well, no SPI used here but will keep the interface compatible with
// Chan's examples
static void release_spi(void)
{
	DESELECT();
    24fc:	ebffff6c 	bl	22b4 <DESELECT>
    2500:	eaffffa8 	b	23a8 <disk_ioctl+0x80>
			} 
			else {   /* SDC ver 1.XX or MMC */
				if (CardType & 2) {			/* SDC ver 1.XX */
					*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
				} else {					/* MMC */
					*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
    2504:	e59f1040 	ldr	r1, [pc, #64]	; 254c <disk_ioctl+0x224>
    2508:	e5d1300b 	ldrb	r3, [r1, #11]
    250c:	e5d1000a 	ldrb	r0, [r1, #10]
    2510:	e2032003 	and	r2, r3, #3	; 0x3
    2514:	e1a032a3 	lsr	r3, r3, #5
    2518:	e1a02182 	lsl	r2, r2, #3
    251c:	e200007c 	and	r0, r0, #124	; 0x7c
    2520:	e2833001 	add	r3, r3, #1	; 0x1
    2524:	e0833002 	add	r3, r3, r2
    2528:	e1a00120 	lsr	r0, r0, #2
    252c:	e0223390 	mla	r2, r0, r3, r3
    2530:	e5842000 	str	r2, [r4]
    2534:	e1a0400e 	mov	r4, lr

// well, no SPI used here but will keep the interface compatible with
// Chan's examples
static void release_spi(void)
{
	DESELECT();
    2538:	ebffff5d 	bl	22b4 <DESELECT>
    253c:	eaffff99 	b	23a8 <disk_ioctl+0x80>
    2540:	40000000 	.word	0x40000000
    2544:	40000708 	.word	0x40000708
    2548:	4000070c 	.word	0x4000070c
    254c:	40000710 	.word	0x40000710
    2550:	40000720 	.word	0x40000720

00002554 <disk_write>:
	BYTE drv,			/* Physical drive number (0..) */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
    2554:	e1a0c00d 	mov	ip, sp
	//WORD k;

	if (drv || !count)
    2558:	e31000ff 	tst	r0, #255	; 0xff
	BYTE drv,			/* Physical drive number (0..) */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
    255c:	e92dd870 	push	{r4, r5, r6, fp, ip, lr, pc}
	//WORD k;

	if (drv || !count)
    2560:	03a00000 	moveq	r0, #0	; 0x0
    2564:	13a00001 	movne	r0, #1	; 0x1
    2568:	e21340ff 	ands	r4, r3, #255	; 0xff
    256c:	03800001 	orreq	r0, r0, #1	; 0x1
    2570:	e3500000 	cmp	r0, #0	; 0x0
	BYTE drv,			/* Physical drive number (0..) */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
    2574:	e24cb004 	sub	fp, ip, #4	; 0x4
    2578:	e1a05001 	mov	r5, r1
    257c:	e1a06002 	mov	r6, r2
	//WORD k;

	if (drv || !count)
    2580:	13a00004 	movne	r0, #4	; 0x4
    2584:	189da870 	ldmne	sp, {r4, r5, r6, fp, sp, pc}
		return RES_PARERR;
	if (Stat & STA_NOINIT)
    2588:	e59f209c 	ldr	r2, [pc, #156]	; 262c <disk_write+0xd8>
    258c:	e5d23000 	ldrb	r3, [r2]
    2590:	e3130001 	tst	r3, #1	; 0x1
    2594:	13a00003 	movne	r0, #3	; 0x3
    2598:	189da870 	ldmne	sp, {r4, r5, r6, fp, sp, pc}
		return RES_NOTRDY;
	if (Stat & STA_PROTECT)
    259c:	e5d23000 	ldrb	r3, [r2]
    25a0:	e3130004 	tst	r3, #4	; 0x4
    25a4:	13a00002 	movne	r0, #2	; 0x2
    25a8:	189da870 	ldmne	sp, {r4, r5, r6, fp, sp, pc}

	// done in mci-driver: if (!(CardType & 4)) sector *= 512;	/* Convert to byte address if needed */

	/* Select the card and wait for ready */
	/* mthomas - not sure if this is needed for SD */
	DESELECT();
    25ac:	ebffff40 	bl	22b4 <DESELECT>
	//if (wait_ready() != 0xFF) return (DRESULT)0xFF;
	SELECT();
    25b0:	ebffff2b 	bl	2264 <SELECT>

	//do {
	diskio_printfw("Write_Block %d start...\n", sector );
	if (count > 1) {
    25b4:	e3540001 	cmp	r4, #1	; 0x1
    25b8:	9a000007 	bls	25dc <disk_write+0x88>
		// Multi Block Write
		if (MCI_Write_Multiple_Block(sector, count, buff) != TRUE) {
    25bc:	e1a00006 	mov	r0, r6
    25c0:	e1a01004 	mov	r1, r4
    25c4:	e1a02005 	mov	r2, r5
    25c8:	eb0006c3 	bl	40dc <MCI_Write_Multiple_Block>
    25cc:	e3500001 	cmp	r0, #1	; 0x1
    25d0:	0a000010 	beq	2618 <disk_write+0xc4>
			return RES_ERROR;
			//break;
		} else {
			diskio_printfw("Write_Block wait...\n");
			/* When MCI_Block_End_Flag is clear, it indicates TX is done */
			while (MCI_Block_End_Flag == 1) {
    25d4:	e3a00001 	mov	r0, #1	; 0x1
    25d8:	e89da870 	ldm	sp, {r4, r5, r6, fp, sp, pc}
			diskio_printfw("Write_Block Multi end wait\n");
		}
	} else {
		// Single Block write
		// TODO: avoid copy
		memcpy(WriteBlock, buff, 512);
    25dc:	e59f304c 	ldr	r3, [pc, #76]	; 2630 <disk_write+0xdc>
    25e0:	e1a01005 	mov	r1, r5
    25e4:	e5930000 	ldr	r0, [r3]
    25e8:	e3a02c02 	mov	r2, #512	; 0x200
    25ec:	eb000b1b 	bl	5260 <memcpy>
		if (MCI_Write_Block(sector) != TRUE) {
    25f0:	e1a00006 	mov	r0, r6
    25f4:	eb00063e 	bl	3ef4 <MCI_Write_Block>
    25f8:	e3500001 	cmp	r0, #1	; 0x1
    25fc:	1afffff4 	bne	25d4 <disk_write+0x80>
    2600:	e59f202c 	ldr	r2, [pc, #44]	; 2634 <disk_write+0xe0>
			return RES_ERROR;
			//break;
		} else {
			diskio_printfw("Write_Block wait...\n");
			/* When MCI_Block_End_Flag is clear, it indicates TX is done */
			while (MCI_Block_End_Flag == 1) {
    2604:	e5923000 	ldr	r3, [r2]
    2608:	e3530001 	cmp	r3, #1	; 0x1
    260c:	0afffffc 	beq	2604 <disk_write+0xb0>
    2610:	e3a00000 	mov	r0, #0	; 0x0
	// laebi: not necessary
	//release_spi();

	//return count ? RES_ERROR : RES_OK;
	return RES_OK;
}
    2614:	e89da870 	ldm	sp, {r4, r5, r6, fp, sp, pc}
    2618:	e59f2014 	ldr	r2, [pc, #20]	; 2634 <disk_write+0xe0>
			return RES_ERROR;
			//break;
		} else {
			diskio_printfw("Write_Block Multi wait...\n");
			/* When MCI_Block_End_Flag is clear, it indicates TX is done */
			while (MCI_Block_End_Flag == 1) {
    261c:	e5923000 	ldr	r3, [r2]
    2620:	e3530001 	cmp	r3, #1	; 0x1
    2624:	0afffffc 	beq	261c <disk_write+0xc8>
    2628:	eafffff8 	b	2610 <disk_write+0xbc>
    262c:	40000000 	.word	0x40000000
    2630:	40000004 	.word	0x40000004
    2634:	40000770 	.word	0x40000770

00002638 <disk_read>:
	BYTE drv,		/* Physical drive number (0..) */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector number (LBA) */
	BYTE count		/* Sector count (1..255) */
)
{
    2638:	e1a0c00d 	mov	ip, sp
	// DRESULT res;
	//WORD k;

	if (drv || !count) return RES_PARERR;
    263c:	e31000ff 	tst	r0, #255	; 0xff
	BYTE drv,		/* Physical drive number (0..) */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector number (LBA) */
	BYTE count		/* Sector count (1..255) */
)
{
    2640:	e92dd9f0 	push	{r4, r5, r6, r7, r8, fp, ip, lr, pc}
	// DRESULT res;
	//WORD k;

	if (drv || !count) return RES_PARERR;
    2644:	03a00000 	moveq	r0, #0	; 0x0
    2648:	13a00001 	movne	r0, #1	; 0x1
    264c:	e21370ff 	ands	r7, r3, #255	; 0xff
    2650:	03800001 	orreq	r0, r0, #1	; 0x1
    2654:	e3500000 	cmp	r0, #0	; 0x0
	BYTE drv,		/* Physical drive number (0..) */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector number (LBA) */
	BYTE count		/* Sector count (1..255) */
)
{
    2658:	e24cb004 	sub	fp, ip, #4	; 0x4
    265c:	e1a05001 	mov	r5, r1
    2660:	e1a04002 	mov	r4, r2
	// DRESULT res;
	//WORD k;

	if (drv || !count) return RES_PARERR;
    2664:	13a00004 	movne	r0, #4	; 0x4
    2668:	189da9f0 	ldmne	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
	if (Stat & STA_NOINIT) return RES_NOTRDY;
    266c:	e59f306c 	ldr	r3, [pc, #108]	; 26e0 <disk_read+0xa8>
    2670:	e5d32000 	ldrb	r2, [r3]
    2674:	e3120001 	tst	r2, #1	; 0x1
    2678:	13a00003 	movne	r0, #3	; 0x3
    267c:	189da9f0 	ldmne	sp, {r4, r5, r6, r7, r8, fp, sp, pc}

	// done in MCI driver if (!(CardType & 4)) sector *= 512;	/* Convert to byte address if needed */

	/* Select the card and wait for ready */
	/* mthomas - not sure if this is needed for SD */
	DESELECT();
    2680:	ebffff0b 	bl	22b4 <DESELECT>
	//if (wait_ready() != 0xFF) return (DRESULT)(0xFF);
	SELECT();
    2684:	ebfffef6 	bl	2264 <SELECT>
    2688:	e59f6054 	ldr	r6, [pc, #84]	; 26e4 <disk_read+0xac>
			/* When MCI_Block_End_Flag is clear, it indicates RX is done */
			while ( MCI_Block_End_Flag == 1 ) { ; }
			diskio_printfr("Read_Block end wait\n");
			// laebi: memcpy is faster than the for-Loop
			// TODO: avoid copy
			memcpy(buff, ReadBlock, 512);
    268c:	e59f8054 	ldr	r8, [pc, #84]	; 26e8 <disk_read+0xb0>
	SELECT();

	// TODO: Multi-block
	do {
		diskio_printfr("Read_Block start...\n");
		if ( MCI_Read_Block( sector ) != TRUE ) {
    2690:	e1a00004 	mov	r0, r4
    2694:	eb00059d 	bl	3d10 <MCI_Read_Block>
    2698:	e3500001 	cmp	r0, #1	; 0x1
    269c:	1a00000b 	bne	26d0 <disk_read+0x98>
		}
		else {
			
			diskio_printfr("Read_Block wait...\n");
			/* When MCI_Block_End_Flag is clear, it indicates RX is done */
			while ( MCI_Block_End_Flag == 1 ) { ; }
    26a0:	e5963000 	ldr	r3, [r6]
    26a4:	e3530001 	cmp	r3, #1	; 0x1
    26a8:	0afffffc 	beq	26a0 <disk_read+0x68>
			diskio_printfr("Read_Block end wait\n");
			// laebi: memcpy is faster than the for-Loop
			// TODO: avoid copy
			memcpy(buff, ReadBlock, 512);
    26ac:	e1a00005 	mov	r0, r5
    26b0:	e5981000 	ldr	r1, [r8]
    26b4:	e3a02c02 	mov	r2, #512	; 0x200
    26b8:	eb000ae8 	bl	5260 <memcpy>
			// mziegert 20090823: Bugfix, memcpy does not increase buff pointer
			buff = &buff[512];
			sector++;
		}
	} while ( --count );
    26bc:	e2473001 	sub	r3, r7, #1	; 0x1
    26c0:	e21370ff 	ands	r7, r3, #255	; 0xff
			diskio_printfr("Read_Block end wait\n");
			// laebi: memcpy is faster than the for-Loop
			// TODO: avoid copy
			memcpy(buff, ReadBlock, 512);
			// mziegert 20090823: Bugfix, memcpy does not increase buff pointer
			buff = &buff[512];
    26c4:	12855c02 	addne	r5, r5, #512	; 0x200
			sector++;
    26c8:	12844001 	addne	r4, r4, #1	; 0x1
    26cc:	1affffef 	bne	2690 <disk_read+0x58>

// well, no SPI used here but will keep the interface compatible with
// Chan's examples
static void release_spi(void)
{
	DESELECT();
    26d0:	ebfffef7 	bl	22b4 <DESELECT>
		}
	} while ( --count );
	
	release_spi();

	return count ? RES_ERROR : RES_OK;
    26d4:	e2570000 	subs	r0, r7, #0	; 0x0
    26d8:	13a00001 	movne	r0, #1	; 0x1
}
    26dc:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
    26e0:	40000000 	.word	0x40000000
    26e4:	40000770 	.word	0x40000770
    26e8:	40000008 	.word	0x40000008

000026ec <disk_initialize>:
/* Initialize a Drive                                                    */

DSTATUS disk_initialize (
	BYTE drv				/* Physical drive nmuber (0..) */
)
{
    26ec:	e1a0c00d 	mov	ip, sp
    26f0:	e92dd870 	push	{r4, r5, r6, fp, ip, lr, pc}
    26f4:	e24cb004 	sub	fp, ip, #4	; 0x4
    26f8:	e24dd010 	sub	sp, sp, #16	; 0x10
	if ( drv != 0 ) return STA_NOINIT;
    26fc:	e21040ff 	ands	r4, r0, #255	; 0xff
    2700:	13a00001 	movne	r0, #1	; 0x1
    2704:	0a000001 	beq	2710 <disk_initialize+0x24>
			CardType = 0;
		}
	}
	
	return Stat;
}
    2708:	e24bd018 	sub	sp, fp, #24	; 0x18
    270c:	e89da870 	ldm	sp, {r4, r5, r6, fp, sp, pc}

	diskio_printf("\n");
#if MCI_DMA_ENABLED
	/* on DMA channel 0, source is memory, destination is MCI FIFO. */
	/* On DMA channel 1, source is MCI FIFO, destination is memory. */
	DMA_Init();
    2710:	eb000811 	bl	475c <DMA_Init>
	diskio_printf("MCI DMA enabled\n");
#endif

	if ( MCI_Init() != TRUE )
    2714:	eb000703 	bl	4328 <MCI_Init>
    2718:	e3500001 	cmp	r0, #1	; 0x1
    271c:	0a000019 	beq	2788 <disk_initialize+0x9c>
    2720:	e59f41f8 	ldr	r4, [pc, #504]	; 2920 <disk_initialize+0x234>
{
	if ( drv != 0 ) return STA_NOINIT;
	if ( MCI_disk_initialize() ) {
		// error occured 
		diskio_printf("mci error\n");
		Stat |= STA_NOINIT;
    2724:	e59f51f8 	ldr	r5, [pc, #504]	; 2924 <disk_initialize+0x238>
    2728:	e5d53000 	ldrb	r3, [r5]
    272c:	e3833001 	orr	r3, r3, #1	; 0x1
    2730:	e5c53000 	strb	r3, [r5]
	DESELECT();
}

static void power_off (void)
{
	SELECT();
    2734:	ebfffeca 	bl	2264 <SELECT>
	BYTE res;
	DWORD st;
	// DWORD currst;

	res = 0xaa;
	Timer2 = 500;	/* Wait for ready in timeout of 500ms */
    2738:	e3a03f7d 	mov	r3, #500	; 0x1f4
    273c:	e5843000 	str	r3, [r4]
	do {
		st = MCI_Send_Status();
    2740:	eb000403 	bl	3754 <MCI_Send_Status>
		if ( st == INVALID_RESPONSE ) {
    2744:	e3700001 	cmn	r0, #1	; 0x1
    2748:	0a00000a 	beq	2778 <disk_initialize+0x8c>
			diskio_printf("wait_ready: Send_Status INVALID_RESPONSE\n");
		}
		else {
			// currst = currstate_from_status(st);
			// if ( currst == 3 /* stby */ || currst == 4 /* trans */) {
			if ( status_ready_bit( st ) ) {
    274c:	e3100c01 	tst	r0, #256	; 0x100
    2750:	0a000008 	beq	2778 <disk_initialize+0x8c>
			}
		}
	}
	while ( (res != 0xFF) && Timer2 );

	if ( Timer2 == 0 ) {
    2754:	e5943000 	ldr	r3, [r4]

// well, no SPI used here but will keep the interface compatible with
// Chan's examples
static void release_spi(void)
{
	DESELECT();
    2758:	ebfffed5 	bl	22b4 <DESELECT>
{
	SELECT();
	wait_ready();
	release_spi();

	MCI_Power_Off();
    275c:	eb0004df 	bl	3ae0 <MCI_Power_Off>

	Stat |= STA_NOINIT;		/* Set STA_NOINIT */
    2760:	e5d53000 	ldrb	r3, [r5]
    2764:	e3833001 	orr	r3, r3, #1	; 0x1
    2768:	e5c53000 	strb	r3, [r5]
		default :
			CardType = 0;
		}
	}
	
	return Stat;
    276c:	e5d53000 	ldrb	r3, [r5]
    2770:	e20300ff 	and	r0, r3, #255	; 0xff
    2774:	eaffffe3 	b	2708 <disk_initialize+0x1c>
			if ( status_ready_bit( st ) ) {
				res = 0xff;
			}
		}
	}
	while ( (res != 0xFF) && Timer2 );
    2778:	e5943000 	ldr	r3, [r4]
    277c:	e3530000 	cmp	r3, #0	; 0x0
    2780:	1affffee 	bne	2740 <disk_initialize+0x54>
    2784:	eafffff2 	b	2754 <disk_initialize+0x68>
		err++; /* fatal error */
	}
	
	if ( !err ) 
	{
		MCI_CardType = MCI_CardInit();
    2788:	eb000244 	bl	30a0 <MCI_CardInit>
    278c:	e59f6194 	ldr	r6, [pc, #404]	; 2928 <disk_initialize+0x23c>
    2790:	e5860000 	str	r0, [r6]
		if ( MCI_CardType == CARD_UNKNOWN )
    2794:	e5963000 	ldr	r3, [r6]
    2798:	e3530000 	cmp	r3, #0	; 0x0
    279c:	0affffdf 	beq	2720 <disk_initialize+0x34>
			diskio_printf("unknown card\n");
			err++; /* fatal error */
		}
	}

	if ( err || MCI_Check_CID() == FALSE )
    27a0:	eb0002eb 	bl	3354 <MCI_Check_CID>
    27a4:	e3500000 	cmp	r0, #0	; 0x0
    27a8:	0affffdc 	beq	2720 <disk_initialize+0x34>
	{
		diskio_printf("Check_CID failed\n");
		err++; /* fatal error */
	}
	
	if ( err || MCI_Set_Address() == FALSE )
    27ac:	eb00030b 	bl	33e0 <MCI_Set_Address>
    27b0:	e3500000 	cmp	r0, #0	; 0x0
    27b4:	0affffd9 	beq	2720 <disk_initialize+0x34>
	{
		diskio_printf("Set_Address failed\n");
		err++; /* fatal error */
	}
	
	if ( err || MCI_Send_CSD( csddw ) == FALSE )
    27b8:	e24b5028 	sub	r5, fp, #40	; 0x28
    27bc:	e1a00005 	mov	r0, r5
    27c0:	eb000338 	bl	34a8 <MCI_Send_CSD>
    27c4:	e3500000 	cmp	r0, #0	; 0x0
    27c8:	159fe15c 	ldrne	lr, [pc, #348]	; 292c <disk_initialize+0x240>
    27cc:	11a00004 	movne	r0, r4
    27d0:	11a0c00e 	movne	ip, lr
    27d4:	0affffd1 	beq	2720 <disk_initialize+0x34>
	else 
	{
		diskio_printf("diskio: CSD %08x %08x %08x %08x\n",
			csddw[0], csddw[1], csddw[2], csddw[3]);
		for ( i=0; i<4; i++ ) {
			DWORD_TO_BYTES( &csd[i*4], csddw[i] );
    27d8:	e7952000 	ldr	r2, [r5, r0]
    27dc:	e1a03c22 	lsr	r3, r2, #24
    27e0:	e7ce3000 	strb	r3, [lr, r0]
    27e4:	e2800004 	add	r0, r0, #4	; 0x4
    27e8:	e1a03822 	lsr	r3, r2, #16
    27ec:	e1a01422 	lsr	r1, r2, #8
	}
	else 
	{
		diskio_printf("diskio: CSD %08x %08x %08x %08x\n",
			csddw[0], csddw[1], csddw[2], csddw[3]);
		for ( i=0; i<4; i++ ) {
    27f0:	e3500010 	cmp	r0, #16	; 0x10
			DWORD_TO_BYTES( &csd[i*4], csddw[i] );
    27f4:	e5cc3001 	strb	r3, [ip, #1]
    27f8:	e5cc1002 	strb	r1, [ip, #2]
    27fc:	e5cc2003 	strb	r2, [ip, #3]
    2800:	e28cc004 	add	ip, ip, #4	; 0x4
	}
	else 
	{
		diskio_printf("diskio: CSD %08x %08x %08x %08x\n",
			csddw[0], csddw[1], csddw[2], csddw[3]);
		for ( i=0; i<4; i++ ) {
    2804:	1afffff3 	bne	27d8 <disk_initialize+0xec>
			DWORD_TO_BYTES( &csd[i*4], csddw[i] );
		}
	}
	
	if ( err || MCI_Select_Card() == FALSE )
    2808:	eb000369 	bl	35b4 <MCI_Select_Card>
    280c:	e3500000 	cmp	r0, #0	; 0x0
    2810:	0affffc2 	beq	2720 <disk_initialize+0x34>
		err++;
	}
	
	if ( !err ) 
	{
		if ( ( MCI_CardType == SD_CARD ) || 
    2814:	e5963000 	ldr	r3, [r6]
    2818:	e3530002 	cmp	r3, #2	; 0x2
    281c:	0a00001a 	beq	288c <disk_initialize+0x1a0>
    2820:	e59f2100 	ldr	r2, [pc, #256]	; 2928 <disk_initialize+0x23c>
    2824:	e5923000 	ldr	r3, [r2]
    2828:	e3530004 	cmp	r3, #4	; 0x4
    282c:	0a000016 	beq	288c <disk_initialize+0x1a0>
				err++;
			}
		}
	}
	
	if ( !err && ( MCI_CardType == SDHC_CARD ) )
    2830:	e5963000 	ldr	r3, [r6]
    2834:	e3530004 	cmp	r3, #4	; 0x4
    2838:	0a00001a 	beq	28a8 <disk_initialize+0x1bc>
			diskio_printf("get_sd_status failed\n");
			err++;
		}
	}
	
	if ( err || MCI_Set_BlockLen( BLOCK_LENGTH ) == FALSE )
    283c:	e3a00c02 	mov	r0, #512	; 0x200
    2840:	eb0003f8 	bl	3828 <MCI_Set_BlockLen>
    2844:	e3500000 	cmp	r0, #0	; 0x0
    2848:	0affffb4 	beq	2720 <disk_initialize+0x34>
		diskio_printf("mci error\n");
		Stat |= STA_NOINIT;
		power_off();
	}
	else {
		Stat &= ~STA_NOINIT;
    284c:	e59f50d0 	ldr	r5, [pc, #208]	; 2924 <disk_initialize+0x238>
    2850:	e5d53000 	ldrb	r3, [r5]
    2854:	e20330fe 	and	r3, r3, #254	; 0xfe
    2858:	e5c53000 	strb	r3, [r5]
		// cardtype mci.h to chan cardtype - (maybe redundant)
		switch ( MCI_CardType ) {
    285c:	e5962000 	ldr	r2, [r6]
    2860:	e3520002 	cmp	r2, #2	; 0x2
    2864:	0a000003 	beq	2878 <disk_initialize+0x18c>
    2868:	e3520004 	cmp	r2, #4	; 0x4
    286c:	0a000001 	beq	2878 <disk_initialize+0x18c>
    2870:	e3520001 	cmp	r2, #1	; 0x1
			break;
		case SD_CARD :
			CardType = 2;
			break;
		default :
			CardType = 0;
    2874:	13a02000 	movne	r2, #0	; 0x0
    2878:	e59f30b0 	ldr	r3, [pc, #176]	; 2930 <disk_initialize+0x244>
    287c:	e5832000 	str	r2, [r3]
		}
	}
	
	return Stat;
    2880:	e5d53000 	ldrb	r3, [r5]
    2884:	e20300ff 	and	r0, r3, #255	; 0xff
    2888:	eaffff9e 	b	2708 <disk_initialize+0x1c>
	if ( !err ) 
	{
		if ( ( MCI_CardType == SD_CARD ) || 
		     ( MCI_CardType == SDHC_CARD ) )
		{
			MCI_Set_MCIClock( NORMAL_RATE );
    288c:	e3a00002 	mov	r0, #2	; 0x2
    2890:	eb000116 	bl	2cf0 <MCI_Set_MCIClock>
			if (SD_Set_BusWidth( SD_4_BIT ) != TRUE )
    2894:	e3a00001 	mov	r0, #1	; 0x1
    2898:	eb00043a 	bl	3988 <SD_Set_BusWidth>
    289c:	e3500001 	cmp	r0, #1	; 0x1
    28a0:	1affff9e 	bne	2720 <disk_initialize+0x34>
    28a4:	eaffffe1 	b	2830 <disk_initialize+0x144>
	DWORD i;
#ifdef DISKIO_DEBUG
	DWORD j;
#endif

	if ( MCI_Set_BlockLen( SD_BLOCK_LENGTH ) == FALSE )
    28a8:	e3a00040 	mov	r0, #64	; 0x40
    28ac:	eb0003dd 	bl	3828 <MCI_Set_BlockLen>
    28b0:	e3500000 	cmp	r0, #0	; 0x0
    28b4:	0affff99 	beq	2720 <disk_initialize+0x34>
	{
		diskio_printf("get_sd_status: Set_BlockLen SD_STATUS failed\n");
		return FALSE;
	}
	
	if ( MCI_Sd_Status() == FALSE ) {
    28b8:	eb00049b 	bl	3b2c <MCI_Sd_Status>
    28bc:	e3500000 	cmp	r0, #0	; 0x0
    28c0:	0affff96 	beq	2720 <disk_initialize+0x34>
		diskio_printf("get_sd_status: MCI_Sd_Status failed\n");
		return FALSE;
	}
	
	Timer2 = 2000;
    28c4:	e59f4054 	ldr	r4, [pc, #84]	; 2920 <disk_initialize+0x234>
    28c8:	e3a03e7d 	mov	r3, #2000	; 0x7d0
    28cc:	e5843000 	str	r3, [r4]
    28d0:	e59f205c 	ldr	r2, [pc, #92]	; 2934 <disk_initialize+0x248>
	while ( MCI_Block_End_Flag == 1 && Timer2 ) { ; }
    28d4:	e5923000 	ldr	r3, [r2]
    28d8:	e3530001 	cmp	r3, #1	; 0x1
    28dc:	1a000002 	bne	28ec <disk_initialize+0x200>
    28e0:	e5943000 	ldr	r3, [r4]
    28e4:	e3530000 	cmp	r3, #0	; 0x0
    28e8:	1afffff9 	bne	28d4 <disk_initialize+0x1e8>
	if ( Timer2 == 0 ) {
    28ec:	e5943000 	ldr	r3, [r4]
    28f0:	e3530000 	cmp	r3, #0	; 0x0
    28f4:	0affff8a 	beq	2724 <disk_initialize+0x38>
	}
	diskio_printf("\n");
#endif

	for ( i=0; i<16; i++ ) {
		sd_status[i] = ReadBlock[i];
    28f8:	e59f3038 	ldr	r3, [pc, #56]	; 2938 <disk_initialize+0x24c>
    28fc:	e59f0038 	ldr	r0, [pc, #56]	; 293c <disk_initialize+0x250>
    2900:	e5931000 	ldr	r1, [r3]
    2904:	e3a02000 	mov	r2, #0	; 0x0
    2908:	e7d13002 	ldrb	r3, [r1, r2]
    290c:	e7c03002 	strb	r3, [r0, r2]
			break;
	}
	diskio_printf("\n");
#endif

	for ( i=0; i<16; i++ ) {
    2910:	e2822001 	add	r2, r2, #1	; 0x1
    2914:	e3520010 	cmp	r2, #16	; 0x10
    2918:	1afffffa 	bne	2908 <disk_initialize+0x21c>
    291c:	eaffffc6 	b	283c <disk_initialize+0x150>
    2920:	40000708 	.word	0x40000708
    2924:	40000000 	.word	0x40000000
    2928:	40000050 	.word	0x40000050
    292c:	40000710 	.word	0x40000710
    2930:	4000070c 	.word	0x4000070c
    2934:	40000770 	.word	0x40000770
    2938:	40000008 	.word	0x40000008
    293c:	40000720 	.word	0x40000720

00002940 <get_fattime>:
#include "type.h"
#include "rtc.h"

DWORD get_fattime (void); /* avoid warning */
DWORD get_fattime (void)
{
    2940:	e1a0c00d 	mov	ip, sp
    2944:	e92dd800 	push	{fp, ip, lr, pc}
    2948:	e24cb004 	sub	fp, ip, #4	; 0x4
    294c:	e24dd020 	sub	sp, sp, #32	; 0x20
	RTCTime t;
	DWORD res;

	RTCGetTime( &t );
    2950:	e24b002c 	sub	r0, fp, #44	; 0x2c
    2954:	ebfff7bf 	bl	858 <RTCGetTime>
    2958:	e24b002c 	sub	r0, fp, #44	; 0x2c
    295c:	e8900009 	ldm	r0, {r0, r3}
    2960:	e51b2024 	ldr	r2, [fp, #-36]
    2964:	e1a000a0 	lsr	r0, r0, #1
    2968:	e1800283 	orr	r0, r0, r3, lsl #5
    296c:	e51b1020 	ldr	r1, [fp, #-32]
    2970:	e51b3018 	ldr	r3, [fp, #-24]
    2974:	e1800582 	orr	r0, r0, r2, lsl #11
    2978:	e51b201c 	ldr	r2, [fp, #-28]
    297c:	e1800801 	orr	r0, r0, r1, lsl #16
    2980:	e2433e7b 	sub	r3, r3, #1968	; 0x7b0
    2984:	e1800a82 	orr	r0, r0, r2, lsl #21
    2988:	e243300c 	sub	r3, r3, #12	; 0xc
		(( t.RTC_Mon )         << 21UL ) |
		(( t.RTC_Year-1980 )   << 25UL )
	);

	return res;
}
    298c:	e1800c83 	orr	r0, r0, r3, lsl #25
    2990:	e24bd00c 	sub	sp, fp, #12	; 0xc
    2994:	e89da800 	ldm	sp, {fp, sp, pc}

00002998 <MCI_IRQHandler>:
 ** 
 ******************************************************************************/
// mthomas - avoid warning missing prototype
void MCI_IRQHandler(void)  __attribute__((interrupt("IRQ")));
void MCI_IRQHandler(void)
{
    2998:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
    299c:	e1a0c00d 	mov	ip, sp
    29a0:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
	//myprintf("MCI_INTERRUPT_HANDLER");
	DWORD MCI_Status;

	MCI_Status = MCI_STATUS;
    29a4:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
    29a8:	e2800923 	add	r0, r0, #573440	; 0x8c000
    29ac:	e5902034 	ldr	r2, [r0, #52]

	//myprintf("calling MCI_IRQHandler\r\n");

	/* handle MCI_STATUS interrupt */
	if ( MCI_Status & DATA_ERR_INT_MASK )
    29b0:	e3c23f71 	bic	r3, r2, #452	; 0x1c4
    29b4:	e3c33001 	bic	r3, r3, #1	; 0x1
    29b8:	e1a03b03 	lsl	r3, r3, #22
    29bc:	e1a03b23 	lsr	r3, r3, #22
    29c0:	e3530000 	cmp	r3, #0	; 0x0
 ** 
 ******************************************************************************/
// mthomas - avoid warning missing prototype
void MCI_IRQHandler(void)  __attribute__((interrupt("IRQ")));
void MCI_IRQHandler(void)
{
    29c4:	e24cb004 	sub	fp, ip, #4	; 0x4
	MCI_Status = MCI_STATUS;

	//myprintf("calling MCI_IRQHandler\r\n");

	/* handle MCI_STATUS interrupt */
	if ( MCI_Status & DATA_ERR_INT_MASK )
    29c8:	0a00003b 	beq	2abc <MCI_IRQHandler+0x124>
 ******************************************************************************/
// mthomas - static
static void MCI_DataErrorProcess(void) {
	DWORD MCIStatus;

	MCIStatus = MCI_STATUS;
    29cc:	e590c034 	ldr	ip, [r0, #52]

	if (MCIStatus & MCI_DATA_CRC_FAIL) {
    29d0:	e31c0002 	tst	ip, #2	; 0x2
    29d4:	0a000005 	beq	29f0 <MCI_IRQHandler+0x58>
		DataCRCErrCount++;
    29d8:	e59f32c0 	ldr	r3, [pc, #704]	; 2ca0 <MCI_IRQHandler+0x308>
    29dc:	e5932000 	ldr	r2, [r3]
		MCI_CLEAR = MCI_DATA_CRC_FAIL;
    29e0:	e3a01002 	mov	r1, #2	; 0x2
	DWORD MCIStatus;

	MCIStatus = MCI_STATUS;

	if (MCIStatus & MCI_DATA_CRC_FAIL) {
		DataCRCErrCount++;
    29e4:	e2822001 	add	r2, r2, #1	; 0x1
    29e8:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_DATA_CRC_FAIL;
    29ec:	e5801038 	str	r1, [r0, #56]
	}
	if (MCIStatus & MCI_DATA_TIMEOUT) {
    29f0:	e31c0008 	tst	ip, #8	; 0x8
    29f4:	0a000007 	beq	2a18 <MCI_IRQHandler+0x80>
		DataTimeoutErrCount++;
    29f8:	e59f02a4 	ldr	r0, [pc, #676]	; 2ca4 <MCI_IRQHandler+0x30c>
    29fc:	e5903000 	ldr	r3, [r0]
		MCI_CLEAR = MCI_DATA_TIMEOUT;
    2a00:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
	if (MCIStatus & MCI_DATA_CRC_FAIL) {
		DataCRCErrCount++;
		MCI_CLEAR = MCI_DATA_CRC_FAIL;
	}
	if (MCIStatus & MCI_DATA_TIMEOUT) {
		DataTimeoutErrCount++;
    2a04:	e2833001 	add	r3, r3, #1	; 0x1
		MCI_CLEAR = MCI_DATA_TIMEOUT;
    2a08:	e2811923 	add	r1, r1, #573440	; 0x8c000
    2a0c:	e3a02008 	mov	r2, #8	; 0x8
	if (MCIStatus & MCI_DATA_CRC_FAIL) {
		DataCRCErrCount++;
		MCI_CLEAR = MCI_DATA_CRC_FAIL;
	}
	if (MCIStatus & MCI_DATA_TIMEOUT) {
		DataTimeoutErrCount++;
    2a10:	e5803000 	str	r3, [r0]
		MCI_CLEAR = MCI_DATA_TIMEOUT;
    2a14:	e5812038 	str	r2, [r1, #56]
	}
	/* Underrun or overrun */
	if (MCIStatus & MCI_TX_UNDERRUN) {
    2a18:	e31c0010 	tst	ip, #16	; 0x10
    2a1c:	0a000007 	beq	2a40 <MCI_IRQHandler+0xa8>
		DataTxUnderrunErrCount++;
    2a20:	e59f0280 	ldr	r0, [pc, #640]	; 2ca8 <MCI_IRQHandler+0x310>
    2a24:	e5903000 	ldr	r3, [r0]
		MCI_CLEAR = MCI_TX_UNDERRUN;
    2a28:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
		DataTimeoutErrCount++;
		MCI_CLEAR = MCI_DATA_TIMEOUT;
	}
	/* Underrun or overrun */
	if (MCIStatus & MCI_TX_UNDERRUN) {
		DataTxUnderrunErrCount++;
    2a2c:	e2833001 	add	r3, r3, #1	; 0x1
		MCI_CLEAR = MCI_TX_UNDERRUN;
    2a30:	e2811923 	add	r1, r1, #573440	; 0x8c000
    2a34:	e3a02010 	mov	r2, #16	; 0x10
		DataTimeoutErrCount++;
		MCI_CLEAR = MCI_DATA_TIMEOUT;
	}
	/* Underrun or overrun */
	if (MCIStatus & MCI_TX_UNDERRUN) {
		DataTxUnderrunErrCount++;
    2a38:	e5803000 	str	r3, [r0]
		MCI_CLEAR = MCI_TX_UNDERRUN;
    2a3c:	e5812038 	str	r2, [r1, #56]
	}
	if (MCIStatus & MCI_RX_OVERRUN) {
    2a40:	e31c0020 	tst	ip, #32	; 0x20
    2a44:	0a000007 	beq	2a68 <MCI_IRQHandler+0xd0>
		DataRxOverrunErrCount++;
    2a48:	e59f025c 	ldr	r0, [pc, #604]	; 2cac <MCI_IRQHandler+0x314>
    2a4c:	e5903000 	ldr	r3, [r0]
		MCI_CLEAR = MCI_RX_OVERRUN;
    2a50:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
	if (MCIStatus & MCI_TX_UNDERRUN) {
		DataTxUnderrunErrCount++;
		MCI_CLEAR = MCI_TX_UNDERRUN;
	}
	if (MCIStatus & MCI_RX_OVERRUN) {
		DataRxOverrunErrCount++;
    2a54:	e2833001 	add	r3, r3, #1	; 0x1
		MCI_CLEAR = MCI_RX_OVERRUN;
    2a58:	e2811923 	add	r1, r1, #573440	; 0x8c000
    2a5c:	e3a02020 	mov	r2, #32	; 0x20
	if (MCIStatus & MCI_TX_UNDERRUN) {
		DataTxUnderrunErrCount++;
		MCI_CLEAR = MCI_TX_UNDERRUN;
	}
	if (MCIStatus & MCI_RX_OVERRUN) {
		DataRxOverrunErrCount++;
    2a60:	e5803000 	str	r3, [r0]
		MCI_CLEAR = MCI_RX_OVERRUN;
    2a64:	e5812038 	str	r2, [r1, #56]
	}
	/* Start bit error on data signal */
	if (MCIStatus & MCI_START_BIT_ERR) {
    2a68:	e31c0c02 	tst	ip, #512	; 0x200
    2a6c:	0a000007 	beq	2a90 <MCI_IRQHandler+0xf8>
		DataStartbitErrCount++;
    2a70:	e59f0238 	ldr	r0, [pc, #568]	; 2cb0 <MCI_IRQHandler+0x318>
    2a74:	e5903000 	ldr	r3, [r0]
		MCI_CLEAR = MCI_START_BIT_ERR;
    2a78:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
		DataRxOverrunErrCount++;
		MCI_CLEAR = MCI_RX_OVERRUN;
	}
	/* Start bit error on data signal */
	if (MCIStatus & MCI_START_BIT_ERR) {
		DataStartbitErrCount++;
    2a7c:	e2833001 	add	r3, r3, #1	; 0x1
		MCI_CLEAR = MCI_START_BIT_ERR;
    2a80:	e2811923 	add	r1, r1, #573440	; 0x8c000
    2a84:	e3a02c02 	mov	r2, #512	; 0x200
		DataRxOverrunErrCount++;
		MCI_CLEAR = MCI_RX_OVERRUN;
	}
	/* Start bit error on data signal */
	if (MCIStatus & MCI_START_BIT_ERR) {
		DataStartbitErrCount++;
    2a88:	e5803000 	str	r3, [r0]
		MCI_CLEAR = MCI_START_BIT_ERR;
    2a8c:	e5812038 	str	r2, [r1, #56]

	/* handle MCI_STATUS interrupt */
	if ( MCI_Status & DATA_ERR_INT_MASK )
	{
		MCI_DataErrorProcess();
		MCI_DataErrorProcess_count++;
    2a90:	e59f221c 	ldr	r2, [pc, #540]	; 2cb4 <MCI_IRQHandler+0x31c>
		return;
	}
	if ( MCI_Status & DATA_END_INT_MASK )
	{
		MCI_DATA_END_InterruptService();
		MCI_DATA_END_InterruptService_count++;
    2a94:	e5923000 	ldr	r3, [r2]
    2a98:	e2833001 	add	r3, r3, #1	; 0x1
    2a9c:	e5823000 	str	r3, [r2]
		VICVectAddr = 0; /* Acknowledge Interrupt */
    2aa0:	e3a01000 	mov	r1, #0	; 0x0
    2aa4:	e3e03000 	mvn	r3, #0	; 0x0
    2aa8:	e50310ff 	str	r1, [r3, #-255]
		return;
	}

	VICVectAddr = 0; /* Acknowledge Interrupt */
	return;
}
    2aac:	e24bd01c 	sub	sp, fp, #28	; 0x1c
    2ab0:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
    2ab4:	e8bd1000 	pop	{ip}
    2ab8:	e25ef004 	subs	pc, lr, #4	; 0x4
		MCI_DataErrorProcess();
		MCI_DataErrorProcess_count++;
		VICVectAddr = 0; /* Acknowledge Interrupt */
		return;
	}
	if ( MCI_Status & DATA_END_INT_MASK )
    2abc:	e212cc05 	ands	ip, r2, #1280	; 0x500
    2ac0:	0a000016 	beq	2b20 <MCI_IRQHandler+0x188>
 ******************************************************************************/
// mthomas - static
static void MCI_DATA_END_InterruptService(void) {
	DWORD MCIStatus;

	MCIStatus = MCI_STATUS;
    2ac4:	e5901034 	ldr	r1, [r0, #52]

	if (MCIStatus & MCI_DATA_END) /* Data end, and Data block end  */
    2ac8:	e211cc01 	ands	ip, r1, #256	; 0x100
    2acc:	1a000054 	bne	2c24 <MCI_IRQHandler+0x28c>
	{
		DataEndCount++;
		MCI_CLEAR = MCI_DATA_END;
		return;
	}
	if (MCIStatus & MCI_DATA_BLK_END) {
    2ad0:	e3110b01 	tst	r1, #1024	; 0x400
    2ad4:	0a000065 	beq	2c70 <MCI_IRQHandler+0x2d8>
		DataBlockEndCount++;
    2ad8:	e59f11d8 	ldr	r1, [pc, #472]	; 2cb8 <MCI_IRQHandler+0x320>
    2adc:	e5913000 	ldr	r3, [r1]
		MCI_CLEAR = MCI_DATA_BLK_END;
    2ae0:	e3a02b01 	mov	r2, #1024	; 0x400
		DataEndCount++;
		MCI_CLEAR = MCI_DATA_END;
		return;
	}
	if (MCIStatus & MCI_DATA_BLK_END) {
		DataBlockEndCount++;
    2ae4:	e2833001 	add	r3, r3, #1	; 0x1
    2ae8:	e5813000 	str	r3, [r1]
		MCI_CLEAR = MCI_DATA_BLK_END;
    2aec:	e5802038 	str	r2, [r0, #56]
}
/*****************************************************************/

void MCI_TXDisable(void) {
#if MCI_DMA_ENABLED
	MCI_MASK0 &= ~((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
    2af0:	e590303c 	ldr	r3, [r0, #60]
    2af4:	e3c33e71 	bic	r3, r3, #1808	; 0x710
    2af8:	e3c3300a 	bic	r3, r3, #10	; 0xa
    2afc:	e580303c 	str	r3, [r0, #60]
	/* Enable TX interrupts only */
	MCI_MASK1 &= ~((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
    2b00:	e5902040 	ldr	r2, [r0, #64]
	}
	if (MCIStatus & MCI_DATA_BLK_END) {
		DataBlockEndCount++;
		MCI_CLEAR = MCI_DATA_BLK_END;
		MCI_TXDisable();
		MCI_Block_End_Flag = 0;
    2b04:	e59f31b0 	ldr	r3, [pc, #432]	; 2cbc <MCI_IRQHandler+0x324>

void MCI_TXDisable(void) {
#if MCI_DMA_ENABLED
	MCI_MASK0 &= ~((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
	/* Enable TX interrupts only */
	MCI_MASK1 &= ~((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
    2b08:	e3c22e71 	bic	r2, r2, #1808	; 0x710
    2b0c:	e3c2200a 	bic	r2, r2, #10	; 0xa
    2b10:	e5802040 	str	r2, [r0, #64]
	}
	if (MCIStatus & MCI_DATA_BLK_END) {
		DataBlockEndCount++;
		MCI_CLEAR = MCI_DATA_BLK_END;
		MCI_TXDisable();
		MCI_Block_End_Flag = 0;
    2b14:	e583c000 	str	ip, [r3]
		return;
	}
	if ( MCI_Status & DATA_END_INT_MASK )
	{
		MCI_DATA_END_InterruptService();
		MCI_DATA_END_InterruptService_count++;
    2b18:	e59f21a0 	ldr	r2, [pc, #416]	; 2cc0 <MCI_IRQHandler+0x328>
    2b1c:	eaffffdc 	b	2a94 <MCI_IRQHandler+0xfc>
		VICVectAddr = 0; /* Acknowledge Interrupt */
		return;
	}
	else if ( MCI_Status & FIFO_INT_MASK )
    2b20:	e3c234ff 	bic	r3, r2, #-16777216	; 0xff000000
    2b24:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
    2b28:	e3c33def 	bic	r3, r3, #15296	; 0x3bc0
    2b2c:	e3c3303f 	bic	r3, r3, #63	; 0x3f
    2b30:	e3530000 	cmp	r3, #0	; 0x0
    2b34:	1a000042 	bne	2c44 <MCI_IRQHandler+0x2ac>
		MCI_FIFOInterruptService();
		MCI_FIFOInterruptService_count++;
		VICVectAddr = 0; /* Acknowledge Interrupt */
		return;
	}
	else if ( MCI_Status & CMD_INT_MASK )
    2b38:	e3c22e73 	bic	r2, r2, #1840	; 0x730
    2b3c:	e3c2200a 	bic	r2, r2, #10	; 0xa
    2b40:	e1a02a02 	lsl	r2, r2, #20
    2b44:	e1a02a22 	lsr	r2, r2, #20
    2b48:	e3520000 	cmp	r2, #0	; 0x0
		MCI_CmdProcess_count++;
		VICVectAddr = 0; /* Acknowledge Interrupt */
		return;
	}

	VICVectAddr = 0; /* Acknowledge Interrupt */
    2b4c:	03e03000 	mvneq	r3, #0	; 0x0
    2b50:	050320ff 	streq	r2, [r3, #-255]
		MCI_FIFOInterruptService();
		MCI_FIFOInterruptService_count++;
		VICVectAddr = 0; /* Acknowledge Interrupt */
		return;
	}
	else if ( MCI_Status & CMD_INT_MASK )
    2b54:	0affffd4 	beq	2aac <MCI_IRQHandler+0x114>
 ******************************************************************************/
// mthomas - static
static void MCI_CmdProcess(void) {
	DWORD MCIStatus;

	MCIStatus = MCI_STATUS;
    2b58:	e590c034 	ldr	ip, [r0, #52]

	if (MCIStatus & MCI_CMD_CRC_FAIL) {
    2b5c:	e31c0001 	tst	ip, #1	; 0x1
    2b60:	0a000005 	beq	2b7c <MCI_IRQHandler+0x1e4>
		CmdCRCErrCount++;
    2b64:	e59f3158 	ldr	r3, [pc, #344]	; 2cc4 <MCI_IRQHandler+0x32c>
    2b68:	e5932000 	ldr	r2, [r3]
		MCI_CLEAR = MCI_CMD_CRC_FAIL;
    2b6c:	e3a01001 	mov	r1, #1	; 0x1
	DWORD MCIStatus;

	MCIStatus = MCI_STATUS;

	if (MCIStatus & MCI_CMD_CRC_FAIL) {
		CmdCRCErrCount++;
    2b70:	e2822001 	add	r2, r2, #1	; 0x1
    2b74:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_CMD_CRC_FAIL;
    2b78:	e5801038 	str	r1, [r0, #56]
	}
	if (MCIStatus & MCI_CMD_TIMEOUT) {
    2b7c:	e31c0004 	tst	ip, #4	; 0x4
    2b80:	0a000007 	beq	2ba4 <MCI_IRQHandler+0x20c>
		CmdTimeoutErrCount++;
    2b84:	e59f013c 	ldr	r0, [pc, #316]	; 2cc8 <MCI_IRQHandler+0x330>
    2b88:	e5903000 	ldr	r3, [r0]
		MCI_CLEAR = MCI_CMD_TIMEOUT;
    2b8c:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
	if (MCIStatus & MCI_CMD_CRC_FAIL) {
		CmdCRCErrCount++;
		MCI_CLEAR = MCI_CMD_CRC_FAIL;
	}
	if (MCIStatus & MCI_CMD_TIMEOUT) {
		CmdTimeoutErrCount++;
    2b90:	e2833001 	add	r3, r3, #1	; 0x1
		MCI_CLEAR = MCI_CMD_TIMEOUT;
    2b94:	e2811923 	add	r1, r1, #573440	; 0x8c000
    2b98:	e3a02004 	mov	r2, #4	; 0x4
	if (MCIStatus & MCI_CMD_CRC_FAIL) {
		CmdCRCErrCount++;
		MCI_CLEAR = MCI_CMD_CRC_FAIL;
	}
	if (MCIStatus & MCI_CMD_TIMEOUT) {
		CmdTimeoutErrCount++;
    2b9c:	e5803000 	str	r3, [r0]
		MCI_CLEAR = MCI_CMD_TIMEOUT;
    2ba0:	e5812038 	str	r2, [r1, #56]
	}
	/* Cmd Resp End or Cmd Sent */
	if (MCIStatus & MCI_CMD_RESP_END) {
    2ba4:	e31c0040 	tst	ip, #64	; 0x40
    2ba8:	0a000007 	beq	2bcc <MCI_IRQHandler+0x234>
		CmdRespEndCount++;
    2bac:	e59f0118 	ldr	r0, [pc, #280]	; 2ccc <MCI_IRQHandler+0x334>
    2bb0:	e5903000 	ldr	r3, [r0]
		MCI_CLEAR = MCI_CMD_RESP_END;
    2bb4:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
		CmdTimeoutErrCount++;
		MCI_CLEAR = MCI_CMD_TIMEOUT;
	}
	/* Cmd Resp End or Cmd Sent */
	if (MCIStatus & MCI_CMD_RESP_END) {
		CmdRespEndCount++;
    2bb8:	e2833001 	add	r3, r3, #1	; 0x1
		MCI_CLEAR = MCI_CMD_RESP_END;
    2bbc:	e2811923 	add	r1, r1, #573440	; 0x8c000
    2bc0:	e3a02040 	mov	r2, #64	; 0x40
		CmdTimeoutErrCount++;
		MCI_CLEAR = MCI_CMD_TIMEOUT;
	}
	/* Cmd Resp End or Cmd Sent */
	if (MCIStatus & MCI_CMD_RESP_END) {
		CmdRespEndCount++;
    2bc4:	e5803000 	str	r3, [r0]
		MCI_CLEAR = MCI_CMD_RESP_END;
    2bc8:	e5812038 	str	r2, [r1, #56]
	}
	if (MCIStatus & MCI_CMD_SENT) {
    2bcc:	e31c0080 	tst	ip, #128	; 0x80
    2bd0:	0a000007 	beq	2bf4 <MCI_IRQHandler+0x25c>
		CmdSentCount++;
    2bd4:	e59f00f4 	ldr	r0, [pc, #244]	; 2cd0 <MCI_IRQHandler+0x338>
    2bd8:	e5903000 	ldr	r3, [r0]
		MCI_CLEAR = MCI_CMD_SENT;
    2bdc:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
	if (MCIStatus & MCI_CMD_RESP_END) {
		CmdRespEndCount++;
		MCI_CLEAR = MCI_CMD_RESP_END;
	}
	if (MCIStatus & MCI_CMD_SENT) {
		CmdSentCount++;
    2be0:	e2833001 	add	r3, r3, #1	; 0x1
		MCI_CLEAR = MCI_CMD_SENT;
    2be4:	e2811923 	add	r1, r1, #573440	; 0x8c000
    2be8:	e3a02080 	mov	r2, #128	; 0x80
	if (MCIStatus & MCI_CMD_RESP_END) {
		CmdRespEndCount++;
		MCI_CLEAR = MCI_CMD_RESP_END;
	}
	if (MCIStatus & MCI_CMD_SENT) {
		CmdSentCount++;
    2bec:	e5803000 	str	r3, [r0]
		MCI_CLEAR = MCI_CMD_SENT;
    2bf0:	e5812038 	str	r2, [r1, #56]
	}
	if (MCIStatus & MCI_CMD_ACTIVE) {
    2bf4:	e31c0b02 	tst	ip, #2048	; 0x800
    2bf8:	0a000007 	beq	2c1c <MCI_IRQHandler+0x284>
		CmdActiveCount++;
    2bfc:	e59f00d0 	ldr	r0, [pc, #208]	; 2cd4 <MCI_IRQHandler+0x33c>
    2c00:	e5903000 	ldr	r3, [r0]
		MCI_CLEAR = MCI_CMD_ACTIVE;
    2c04:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
	if (MCIStatus & MCI_CMD_SENT) {
		CmdSentCount++;
		MCI_CLEAR = MCI_CMD_SENT;
	}
	if (MCIStatus & MCI_CMD_ACTIVE) {
		CmdActiveCount++;
    2c08:	e2833001 	add	r3, r3, #1	; 0x1
		MCI_CLEAR = MCI_CMD_ACTIVE;
    2c0c:	e2811923 	add	r1, r1, #573440	; 0x8c000
    2c10:	e3a02b02 	mov	r2, #2048	; 0x800
	if (MCIStatus & MCI_CMD_SENT) {
		CmdSentCount++;
		MCI_CLEAR = MCI_CMD_SENT;
	}
	if (MCIStatus & MCI_CMD_ACTIVE) {
		CmdActiveCount++;
    2c14:	e5803000 	str	r3, [r0]
		MCI_CLEAR = MCI_CMD_ACTIVE;
    2c18:	e5812038 	str	r2, [r1, #56]
		return;
	}
	else if ( MCI_Status & CMD_INT_MASK )
	{
		MCI_CmdProcess();
		MCI_CmdProcess_count++;
    2c1c:	e59f20b4 	ldr	r2, [pc, #180]	; 2cd8 <MCI_IRQHandler+0x340>
    2c20:	eaffff9b 	b	2a94 <MCI_IRQHandler+0xfc>

	MCIStatus = MCI_STATUS;

	if (MCIStatus & MCI_DATA_END) /* Data end, and Data block end  */
	{
		DataEndCount++;
    2c24:	e59f30b0 	ldr	r3, [pc, #176]	; 2cdc <MCI_IRQHandler+0x344>
    2c28:	e5932000 	ldr	r2, [r3]
		MCI_CLEAR = MCI_DATA_END;
    2c2c:	e3a01c01 	mov	r1, #256	; 0x100

	MCIStatus = MCI_STATUS;

	if (MCIStatus & MCI_DATA_END) /* Data end, and Data block end  */
	{
		DataEndCount++;
    2c30:	e2822001 	add	r2, r2, #1	; 0x1
    2c34:	e5832000 	str	r2, [r3]
		MCI_CLEAR = MCI_DATA_END;
    2c38:	e5801038 	str	r1, [r0, #56]
		return;
	}
	if ( MCI_Status & DATA_END_INT_MASK )
	{
		MCI_DATA_END_InterruptService();
		MCI_DATA_END_InterruptService_count++;
    2c3c:	e59f207c 	ldr	r2, [pc, #124]	; 2cc0 <MCI_IRQHandler+0x328>
    2c40:	eaffff93 	b	2a94 <MCI_IRQHandler+0xfc>
		}
		// mthomas end
	}
#endif

	DataFIFOCount++;
    2c44:	e59f2094 	ldr	r2, [pc, #148]	; 2ce0 <MCI_IRQHandler+0x348>
    2c48:	e5923000 	ldr	r3, [r2]
    2c4c:	e2833001 	add	r3, r3, #1	; 0x1
    2c50:	e5823000 	str	r3, [r2]
		return;
	}
	else if ( MCI_Status & FIFO_INT_MASK )
	{
		MCI_FIFOInterruptService();
		MCI_FIFOInterruptService_count++;
    2c54:	e59f1088 	ldr	r1, [pc, #136]	; 2ce4 <MCI_IRQHandler+0x34c>
    2c58:	e5913000 	ldr	r3, [r1]
		VICVectAddr = 0; /* Acknowledge Interrupt */
    2c5c:	e3e02000 	mvn	r2, #0	; 0x0
		return;
	}
	else if ( MCI_Status & FIFO_INT_MASK )
	{
		MCI_FIFOInterruptService();
		MCI_FIFOInterruptService_count++;
    2c60:	e2833001 	add	r3, r3, #1	; 0x1
    2c64:	e5813000 	str	r3, [r1]
		VICVectAddr = 0; /* Acknowledge Interrupt */
    2c68:	e502c0ff 	str	ip, [r2, #-255]
    2c6c:	eaffff8e 	b	2aac <MCI_IRQHandler+0x114>
		MCI_Block_End_Flag = 0;
		return;
	}

	/* Tx active  */
	if (MCIStatus & MCI_TX_ACTIVE) {
    2c70:	e3110a01 	tst	r1, #4096	; 0x1000
		DataTxActiveCount++;
    2c74:	159f206c 	ldrne	r2, [pc, #108]	; 2ce8 <MCI_IRQHandler+0x350>
    2c78:	15923000 	ldrne	r3, [r2]
    2c7c:	12833001 	addne	r3, r3, #1	; 0x1
    2c80:	15823000 	strne	r3, [r2]
	}
	/* Rx active  */
	if (MCIStatus & MCI_RX_ACTIVE) {
    2c84:	e3110a02 	tst	r1, #8192	; 0x2000
		DataRxActiveCount++;
    2c88:	159f205c 	ldrne	r2, [pc, #92]	; 2cec <MCI_IRQHandler+0x354>
    2c8c:	15923000 	ldrne	r3, [r2]
    2c90:	12833001 	addne	r3, r3, #1	; 0x1
    2c94:	15823000 	strne	r3, [r2]
		return;
	}
	if ( MCI_Status & DATA_END_INT_MASK )
	{
		MCI_DATA_END_InterruptService();
		MCI_DATA_END_InterruptService_count++;
    2c98:	e59f2020 	ldr	r2, [pc, #32]	; 2cc0 <MCI_IRQHandler+0x328>
    2c9c:	eaffff7c 	b	2a94 <MCI_IRQHandler+0xfc>
    2ca0:	40000754 	.word	0x40000754
    2ca4:	40000758 	.word	0x40000758
    2ca8:	4000075c 	.word	0x4000075c
    2cac:	40000760 	.word	0x40000760
    2cb0:	40000764 	.word	0x40000764
    2cb4:	40000730 	.word	0x40000730
    2cb8:	4000076c 	.word	0x4000076c
    2cbc:	40000770 	.word	0x40000770
    2cc0:	40000734 	.word	0x40000734
    2cc4:	40000740 	.word	0x40000740
    2cc8:	40000744 	.word	0x40000744
    2ccc:	40000748 	.word	0x40000748
    2cd0:	4000074c 	.word	0x4000074c
    2cd4:	40000750 	.word	0x40000750
    2cd8:	4000073c 	.word	0x4000073c
    2cdc:	40000768 	.word	0x40000768
    2ce0:	4000077c 	.word	0x4000077c
    2ce4:	40000738 	.word	0x40000738
    2ce8:	40000774 	.word	0x40000774
    2cec:	40000778 	.word	0x40000778

00002cf0 <MCI_Set_MCIClock>:
 **
 ** parameters:			Clock rate to be set
 ** Returned value:		None
 ** 
 ******************************************************************************/
void MCI_Set_MCIClock(DWORD ClockRate) {
    2cf0:	e1a0c00d 	mov	ip, sp
    2cf4:	e92dd800 	push	{fp, ip, lr, pc}
	volatile DWORD i; // mthomas volatile
	DWORD ClkValue = 0;

	if (ClockRate == SLOW_RATE) {
    2cf8:	e3500001 	cmp	r0, #1	; 0x1
 **
 ** parameters:			Clock rate to be set
 ** Returned value:		None
 ** 
 ******************************************************************************/
void MCI_Set_MCIClock(DWORD ClockRate) {
    2cfc:	e24cb004 	sub	fp, ip, #4	; 0x4
    2d00:	e24dd004 	sub	sp, sp, #4	; 0x4
	volatile DWORD i; // mthomas volatile
	DWORD ClkValue = 0;

	if (ClockRate == SLOW_RATE) {
    2d04:	0a000002 	beq	2d14 <MCI_Set_MCIClock+0x24>
		ClkValue |= MCLKDIV_SLOW; /* slow clock */
	} else if (ClockRate == NORMAL_RATE) {
    2d08:	e3500002 	cmp	r0, #2	; 0x2
    2d0c:	02400002 	subeq	r0, r0, #2	; 0x2
    2d10:	0a000000 	beq	2d18 <MCI_Set_MCIClock+0x28>
    2d14:	e3a0003d 	mov	r0, #61	; 0x3d
	} else {
		// mthomas - added default - low
		ClkValue |= MCLKDIV_SLOW;
	}

	MCI_CLOCK &= ~(0xFF);
    2d18:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
    2d1c:	e2811923 	add	r1, r1, #573440	; 0x8c000
    2d20:	e5913004 	ldr	r3, [r1, #4]
    2d24:	e3c330ff 	bic	r3, r3, #255	; 0xff
    2d28:	e5813004 	str	r3, [r1, #4]
	/* clear clock divider */
	// laebi: Disable MCI clock output when bus is idle (bit 9)
	MCI_CLOCK |= (1 << 8) | (1 << 9) | ClkValue;
    2d2c:	e5912004 	ldr	r2, [r1, #4]
    2d30:	e3822c03 	orr	r2, r2, #768	; 0x300
    2d34:	e1822000 	orr	r2, r2, r0
	for (i = 0; i < 0x100; i++)
    2d38:	e3a03000 	mov	r3, #0	; 0x0
	}

	MCI_CLOCK &= ~(0xFF);
	/* clear clock divider */
	// laebi: Disable MCI clock output when bus is idle (bit 9)
	MCI_CLOCK |= (1 << 8) | (1 << 9) | ClkValue;
    2d3c:	e5812004 	str	r2, [r1, #4]
	for (i = 0; i < 0x100; i++)
    2d40:	e50b3010 	str	r3, [fp, #-16]
    2d44:	e51b2010 	ldr	r2, [fp, #-16]
    2d48:	e35200ff 	cmp	r2, #255	; 0xff
    2d4c:	889da808 	ldmhi	sp, {r3, fp, sp, pc}
    2d50:	e51b3010 	ldr	r3, [fp, #-16]
    2d54:	e2833001 	add	r3, r3, #1	; 0x1
    2d58:	e50b3010 	str	r3, [fp, #-16]
    2d5c:	e51b2010 	ldr	r2, [fp, #-16]
    2d60:	e35200ff 	cmp	r2, #255	; 0xff
    2d64:	9afffff9 	bls	2d50 <MCI_Set_MCIClock+0x60>
    2d68:	e89da808 	ldm	sp, {r3, fp, sp, pc}

00002d6c <MCI_SendCmd>:
 ** parameters:			CmdIndex, Argument, ExpectResp Flag, AllowTimeout flag
 ** Returned value:		None
 ** 
 ******************************************************************************/
void MCI_SendCmd(DWORD CmdIndex, DWORD Argument, DWORD ExpectResp,
		DWORD AllowTimeout) {
    2d6c:	e1a0c00d 	mov	ip, sp
    2d70:	e92dd870 	push	{r4, r5, r6, fp, ip, lr, pc}
    2d74:	e24cb004 	sub	fp, ip, #4	; 0x4
    2d78:	e24dd004 	sub	sp, sp, #4	; 0x4
	DWORD CmdData = 0;
	DWORD CmdStatus;

	/* the command engine must be disabled when we modify the argument
	 or the peripheral resends */
	while ( (CmdStatus = MCI_STATUS) & MCI_CMD_ACTIVE) /* Command in progress. */
    2d7c:	e3a0420e 	mov	r4, #-536870912	; 0xe0000000
    2d80:	e2844923 	add	r4, r4, #573440	; 0x8c000
    2d84:	e594c034 	ldr	ip, [r4, #52]
    2d88:	e31c0b02 	tst	ip, #2048	; 0x800
 ** parameters:			CmdIndex, Argument, ExpectResp Flag, AllowTimeout flag
 ** Returned value:		None
 ** 
 ******************************************************************************/
void MCI_SendCmd(DWORD CmdIndex, DWORD Argument, DWORD ExpectResp,
		DWORD AllowTimeout) {
    2d8c:	e1a06001 	mov	r6, r1
    2d90:	e1a05003 	mov	r5, r3
    2d94:	e1a01002 	mov	r1, r2
	DWORD CmdData = 0;
	DWORD CmdStatus;

	/* the command engine must be disabled when we modify the argument
	 or the peripheral resends */
	while ( (CmdStatus = MCI_STATUS) & MCI_CMD_ACTIVE) /* Command in progress. */
    2d98:	0a000007 	beq	2dbc <MCI_SendCmd+0x50>
	{
		MCI_COMMAND = 0;
    2d9c:	e1a02004 	mov	r2, r4
    2da0:	e3a04000 	mov	r4, #0	; 0x0
		MCI_CLEAR = CmdStatus | MCI_CMD_ACTIVE;
    2da4:	e38c3b02 	orr	r3, ip, #2048	; 0x800

	/* the command engine must be disabled when we modify the argument
	 or the peripheral resends */
	while ( (CmdStatus = MCI_STATUS) & MCI_CMD_ACTIVE) /* Command in progress. */
	{
		MCI_COMMAND = 0;
    2da8:	e582400c 	str	r4, [r2, #12]
		MCI_CLEAR = CmdStatus | MCI_CMD_ACTIVE;
    2dac:	e5823038 	str	r3, [r2, #56]
	DWORD CmdData = 0;
	DWORD CmdStatus;

	/* the command engine must be disabled when we modify the argument
	 or the peripheral resends */
	while ( (CmdStatus = MCI_STATUS) & MCI_CMD_ACTIVE) /* Command in progress. */
    2db0:	e592c034 	ldr	ip, [r2, #52]
    2db4:	e31c0b02 	tst	ip, #2048	; 0x800
    2db8:	1afffff9 	bne	2da4 <MCI_SendCmd+0x38>
	{
		MCI_COMMAND = 0;
		MCI_CLEAR = CmdStatus | MCI_CMD_ACTIVE;
	}
	for (i = 0; i < 0x100; i++) {
    2dbc:	e3a03000 	mov	r3, #0	; 0x0
    2dc0:	e50b301c 	str	r3, [fp, #-28]
    2dc4:	e51b201c 	ldr	r2, [fp, #-28]
    2dc8:	e35200ff 	cmp	r2, #255	; 0xff
    2dcc:	8a000005 	bhi	2de8 <MCI_SendCmd+0x7c>
    2dd0:	e51b301c 	ldr	r3, [fp, #-28]
    2dd4:	e2833001 	add	r3, r3, #1	; 0x1
    2dd8:	e50b301c 	str	r3, [fp, #-28]
    2ddc:	e51b201c 	ldr	r2, [fp, #-28]
    2de0:	e35200ff 	cmp	r2, #255	; 0xff
    2de4:	9afffff9 	bls	2dd0 <MCI_SendCmd+0x64>
		;
	}

	/*set the command details, the CmdIndex should 0 through 0x3F only */
	CmdData |= (CmdIndex & 0x3F); /* bit 0 through 5 only */
	if (ExpectResp == EXPECT_NO_RESP) /* no response */
    2de8:	e3510000 	cmp	r1, #0	; 0x0
	for (i = 0; i < 0x100; i++) {
		;
	}

	/*set the command details, the CmdIndex should 0 through 0x3F only */
	CmdData |= (CmdIndex & 0x3F); /* bit 0 through 5 only */
    2dec:	e200003f 	and	r0, r0, #63	; 0x3f
	if (ExpectResp == EXPECT_NO_RESP) /* no response */
    2df0:	0a000004 	beq	2e08 <MCI_SendCmd+0x9c>
	{
		CmdData &= ~((1 << 6) | (1 << 7)); /* Clear long response bit as well */
	} else if (ExpectResp == EXPECT_SHORT_RESP) /* expect short response */
    2df4:	e3510001 	cmp	r1, #1	; 0x1
	{
		CmdData |= (1 << 6);
    2df8:	03800040 	orreq	r0, r0, #64	; 0x40
	/*set the command details, the CmdIndex should 0 through 0x3F only */
	CmdData |= (CmdIndex & 0x3F); /* bit 0 through 5 only */
	if (ExpectResp == EXPECT_NO_RESP) /* no response */
	{
		CmdData &= ~((1 << 6) | (1 << 7)); /* Clear long response bit as well */
	} else if (ExpectResp == EXPECT_SHORT_RESP) /* expect short response */
    2dfc:	0a000001 	beq	2e08 <MCI_SendCmd+0x9c>
	{
		CmdData |= (1 << 6);
	} else if (ExpectResp == EXPECT_LONG_RESP) /* expect long response */
    2e00:	e3510002 	cmp	r1, #2	; 0x2
	{
		CmdData |= (1 << 6) | (1 << 7);
    2e04:	038000c0 	orreq	r0, r0, #192	; 0xc0
	}

	if (AllowTimeout) /* allow timeout or not */
    2e08:	e3550000 	cmp	r5, #0	; 0x0
	{
		CmdData |= (1 << 8);
    2e0c:	13800c01 	orrne	r0, r0, #256	; 0x100
	} else {
		CmdData &= ~(1 << 8);
    2e10:	03c00c01 	biceq	r0, r0, #256	; 0x100
	}

	/*send the command*/
	CmdData |= (1 << 10); /* This bit needs to be set last. */
	MCI_ARGUMENT = Argument;
    2e14:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    2e18:	e2833923 	add	r3, r3, #573440	; 0x8c000
	} else {
		CmdData &= ~(1 << 8);
	}

	/*send the command*/
	CmdData |= (1 << 10); /* This bit needs to be set last. */
    2e1c:	e3802b01 	orr	r2, r0, #1024	; 0x400
	MCI_ARGUMENT = Argument;
    2e20:	e5836008 	str	r6, [r3, #8]
	/* Set the argument first, finally command */
	MCI_COMMAND = CmdData;
    2e24:	e583200c 	str	r2, [r3, #12]

	return;
}
    2e28:	e89da878 	ldm	sp, {r3, r4, r5, r6, fp, sp, pc}

00002e2c <MCI_GetCmdResp>:
 **						non-zero, no need to check the response field, just resend
 **						command or bailout. 
 ** Returned value:		Response status, 0 is valid response. 
 ** 
 ******************************************************************************/
DWORD MCI_GetCmdResp(DWORD ExpectCmdData, DWORD ExpectResp, DWORD *CmdResp) {
    2e2c:	e1a0c00d 	mov	ip, sp
    2e30:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
	DWORD CmdRespStatus = 0;
	DWORD LastCmdIndex;

	if (ExpectResp == EXPECT_NO_RESP) {
    2e34:	e2515000 	subs	r5, r1, #0	; 0x0
 **						non-zero, no need to check the response field, just resend
 **						command or bailout. 
 ** Returned value:		Response status, 0 is valid response. 
 ** 
 ******************************************************************************/
DWORD MCI_GetCmdResp(DWORD ExpectCmdData, DWORD ExpectResp, DWORD *CmdResp) {
    2e38:	e24cb004 	sub	fp, ip, #4	; 0x4
    2e3c:	e1a04002 	mov	r4, r2
    2e40:	e1a0c000 	mov	ip, r0
	DWORD CmdRespStatus = 0;
	DWORD LastCmdIndex;

	if (ExpectResp == EXPECT_NO_RESP) {
    2e44:	0a00001d 	beq	2ec0 <MCI_GetCmdResp+0x94>
		return ( 0 );
	}

	while ( 1) {
		CmdRespStatus = MCI_STATUS;
    2e48:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    2e4c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    2e50:	e5930034 	ldr	r0, [r3, #52]
    2e54:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
		if (CmdRespStatus & (MCI_CMD_TIMEOUT)) {
    2e58:	e3100004 	tst	r0, #4	; 0x4
	if (ExpectResp == EXPECT_NO_RESP) {
		return ( 0 );
	}

	while ( 1) {
		CmdRespStatus = MCI_STATUS;
    2e5c:	e2811923 	add	r1, r1, #573440	; 0x8c000
		if (CmdRespStatus & (MCI_CMD_TIMEOUT)) {
    2e60:	1a00002a 	bne	2f10 <MCI_GetCmdResp+0xe4>
			MCI_CLEAR = CmdRespStatus | MCI_CMD_TIMEOUT;
			MCI_COMMAND = 0;
			MCI_ARGUMENT = 0xFFFFFFFF;
			return (CmdRespStatus );
		}
		if (CmdRespStatus & MCI_CMD_CRC_FAIL) {
    2e64:	e3100001 	tst	r0, #1	; 0x1
    2e68:	1a00002f 	bne	2f2c <MCI_GetCmdResp+0x100>
				 or STOP_TRANSMISSION. */
			} else {
				mci_debug_printf("*** CRCfail");
				return (CmdRespStatus );
			}
		} else if (CmdRespStatus & MCI_CMD_RESP_END) {
    2e6c:	e3100040 	tst	r0, #64	; 0x40
    2e70:	0afffff6 	beq	2e50 <MCI_GetCmdResp+0x24>
			MCI_CLEAR = CmdRespStatus | MCI_CMD_RESP_END;
    2e74:	e3803040 	orr	r3, r0, #64	; 0x40
    2e78:	e5813038 	str	r3, [r1, #56]
			break; /* cmd response is received, expecting response */
		}
	}

	if ( (MCI_RESP_CMD & 0x3F) != ExpectCmdData) {
    2e7c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    2e80:	e2833923 	add	r3, r3, #573440	; 0x8c000
    2e84:	e5932010 	ldr	r2, [r3, #16]
    2e88:	e202203f 	and	r2, r2, #63	; 0x3f
    2e8c:	e152000c 	cmp	r2, ip
    2e90:	0a000006 	beq	2eb0 <MCI_GetCmdResp+0x84>
		/* If the response is not R1, in the response field, the Expected Cmd data
		 won't be the same as the CMD data in SendCmd(). Below four cmds have
		 R2 or R3 response. We don't need to check if MCI_RESP_CMD is the same
		 as the Expected or not. */
		if ( (ExpectCmdData != SEND_OP_COND) && (ExpectCmdData
    2e94:	e35c0001 	cmp	ip, #1	; 0x1
    2e98:	135c0029 	cmpne	ip, #41	; 0x29
    2e9c:	0a000003 	beq	2eb0 <MCI_GetCmdResp+0x84>
    2ea0:	e35c0002 	cmp	ip, #2	; 0x2
    2ea4:	135c0009 	cmpne	ip, #9	; 0x9
    2ea8:	13e00000 	mvnne	r0, #0	; 0x0
    2eac:	189da830 	ldmne	sp, {r4, r5, fp, sp, pc}
			CmdRespStatus = INVALID_RESPONSE; /* Reuse error status */
			return ( INVALID_RESPONSE );
		}
	}

	if (ExpectResp == EXPECT_SHORT_RESP) {
    2eb0:	e3550001 	cmp	r5, #1	; 0x1
    2eb4:	0a00000f 	beq	2ef8 <MCI_GetCmdResp+0xcc>
		*CmdResp = MCI_RESP0;
	} else if (ExpectResp == EXPECT_LONG_RESP) {
    2eb8:	e3550002 	cmp	r5, #2	; 0x2
    2ebc:	0a000001 	beq	2ec8 <MCI_GetCmdResp+0x9c>
		*CmdResp = MCI_RESP0;
		*(CmdResp+1) = MCI_RESP1;
		*(CmdResp+2) = MCI_RESP2;
		*(CmdResp+3) = MCI_RESP3;
    2ec0:	e3a00000 	mov	r0, #0	; 0x0
	}
	return ( 0 ); /* Read MCI_RESP0 register assuming it's not long response. */
}
    2ec4:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
	}

	if (ExpectResp == EXPECT_SHORT_RESP) {
		*CmdResp = MCI_RESP0;
	} else if (ExpectResp == EXPECT_LONG_RESP) {
		*CmdResp = MCI_RESP0;
    2ec8:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
    2ecc:	e2811923 	add	r1, r1, #573440	; 0x8c000
    2ed0:	e5913014 	ldr	r3, [r1, #20]
    2ed4:	e5843000 	str	r3, [r4]
		*(CmdResp+1) = MCI_RESP1;
    2ed8:	e5912018 	ldr	r2, [r1, #24]
    2edc:	e5842004 	str	r2, [r4, #4]
		*(CmdResp+2) = MCI_RESP2;
    2ee0:	e591301c 	ldr	r3, [r1, #28]
    2ee4:	e5843008 	str	r3, [r4, #8]
		*(CmdResp+3) = MCI_RESP3;
    2ee8:	e5912020 	ldr	r2, [r1, #32]
    2eec:	e3a00000 	mov	r0, #0	; 0x0
    2ef0:	e584200c 	str	r2, [r4, #12]
    2ef4:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
			return ( INVALID_RESPONSE );
		}
	}

	if (ExpectResp == EXPECT_SHORT_RESP) {
		*CmdResp = MCI_RESP0;
    2ef8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    2efc:	e2833923 	add	r3, r3, #573440	; 0x8c000
    2f00:	e5932014 	ldr	r2, [r3, #20]
    2f04:	e3a00000 	mov	r0, #0	; 0x0
    2f08:	e5842000 	str	r2, [r4]
    2f0c:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
	}

	while ( 1) {
		CmdRespStatus = MCI_STATUS;
		if (CmdRespStatus & (MCI_CMD_TIMEOUT)) {
			MCI_CLEAR = CmdRespStatus | MCI_CMD_TIMEOUT;
    2f10:	e3803004 	orr	r3, r0, #4	; 0x4
    2f14:	e5813038 	str	r3, [r1, #56]
			MCI_COMMAND = 0;
    2f18:	e3a02000 	mov	r2, #0	; 0x0
			MCI_ARGUMENT = 0xFFFFFFFF;
    2f1c:	e3e03000 	mvn	r3, #0	; 0x0

	while ( 1) {
		CmdRespStatus = MCI_STATUS;
		if (CmdRespStatus & (MCI_CMD_TIMEOUT)) {
			MCI_CLEAR = CmdRespStatus | MCI_CMD_TIMEOUT;
			MCI_COMMAND = 0;
    2f20:	e581200c 	str	r2, [r1, #12]
			MCI_ARGUMENT = 0xFFFFFFFF;
    2f24:	e5813008 	str	r3, [r1, #8]
    2f28:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
			return (CmdRespStatus );
		}
		if (CmdRespStatus & MCI_CMD_CRC_FAIL) {
			MCI_CLEAR = CmdRespStatus | MCI_CMD_CRC_FAIL;
    2f2c:	e3803001 	orr	r3, r0, #1	; 0x1
    2f30:	e5813038 	str	r3, [r1, #56]
			LastCmdIndex = MCI_COMMAND & 0x003F;
    2f34:	e591200c 	ldr	r2, [r1, #12]
    2f38:	e202203f 	and	r2, r2, #63	; 0x3f
			if ( (LastCmdIndex == SEND_OP_COND) || (LastCmdIndex
    2f3c:	e3520029 	cmp	r2, #41	; 0x29
    2f40:	13520001 	cmpne	r2, #1	; 0x1
    2f44:	1a000006 	bne	2f64 <MCI_GetCmdResp+0x138>
					== SEND_APP_OP_COND) || (LastCmdIndex == STOP_TRANSMISSION)) {
				MCI_COMMAND = 0;
    2f48:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    2f4c:	e2833923 	add	r3, r3, #573440	; 0x8c000
    2f50:	e3a02000 	mov	r2, #0	; 0x0
				MCI_ARGUMENT = 0xFFFFFFFF;
    2f54:	e3e01000 	mvn	r1, #0	; 0x0
		if (CmdRespStatus & MCI_CMD_CRC_FAIL) {
			MCI_CLEAR = CmdRespStatus | MCI_CMD_CRC_FAIL;
			LastCmdIndex = MCI_COMMAND & 0x003F;
			if ( (LastCmdIndex == SEND_OP_COND) || (LastCmdIndex
					== SEND_APP_OP_COND) || (LastCmdIndex == STOP_TRANSMISSION)) {
				MCI_COMMAND = 0;
    2f58:	e583200c 	str	r2, [r3, #12]
				MCI_ARGUMENT = 0xFFFFFFFF;
    2f5c:	e5831008 	str	r1, [r3, #8]
    2f60:	eaffffc5 	b	2e7c <MCI_GetCmdResp+0x50>
			return (CmdRespStatus );
		}
		if (CmdRespStatus & MCI_CMD_CRC_FAIL) {
			MCI_CLEAR = CmdRespStatus | MCI_CMD_CRC_FAIL;
			LastCmdIndex = MCI_COMMAND & 0x003F;
			if ( (LastCmdIndex == SEND_OP_COND) || (LastCmdIndex
    2f64:	e352000c 	cmp	r2, #12	; 0xc
    2f68:	189da830 	ldmne	sp, {r4, r5, fp, sp, pc}
    2f6c:	eafffff5 	b	2f48 <MCI_GetCmdResp+0x11c>

00002f70 <MCI_Go_Idle_State>:
 **
 ** parameters:			None
 ** Returned value:		true or false, true if card has been initialized.
 ** 
 ******************************************************************************/
DWORD MCI_Go_Idle_State(void) {
    2f70:	e1a0c00d 	mov	ip, sp
    2f74:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
    2f78:	e24cb004 	sub	fp, ip, #4	; 0x4
    2f7c:	e24dd010 	sub	sp, sp, #16	; 0x10
    2f80:	e3a04020 	mov	r4, #32	; 0x20
    2f84:	e24b5024 	sub	r5, fp, #36	; 0x24
    2f88:	ea000001 	b	2f94 <MCI_Go_Idle_State+0x24>
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
    2f8c:	e2544001 	subs	r4, r4, #1	; 0x1
    2f90:	0a00000d 	beq	2fcc <MCI_Go_Idle_State+0x5c>
		/* Send CMD0 command repeatedly until the response is back correctly */
		MCI_SendCmd( GO_IDLE_STATE, 0x00000000, EXPECT_NO_RESP, 0);
    2f94:	e3a00000 	mov	r0, #0	; 0x0
    2f98:	e1a01000 	mov	r1, r0
    2f9c:	e1a02000 	mov	r2, r0
    2fa0:	e1a03000 	mov	r3, r0
    2fa4:	ebffff70 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( GO_IDLE_STATE, EXPECT_NO_RESP, (DWORD *)respValue);
    2fa8:	e3a00000 	mov	r0, #0	; 0x0
    2fac:	e1a01000 	mov	r1, r0
    2fb0:	e1a02005 	mov	r2, r5
    2fb4:	ebffff9c 	bl	2e2c <MCI_GetCmdResp>
		if (respStatus == 0) {
    2fb8:	e3500000 	cmp	r0, #0	; 0x0
    2fbc:	1afffff2 	bne	2f8c <MCI_Go_Idle_State+0x1c>
    2fc0:	e2800001 	add	r0, r0, #1	; 0x1
	{
		mci_debug_printf("Timeout go idle\n");
		return ( FALSE );
	}
	return ( TRUE );
}
    2fc4:	e24bd014 	sub	sp, fp, #20	; 0x14
    2fc8:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
    2fcc:	e1a00004 	mov	r0, r4
    2fd0:	eafffffb 	b	2fc4 <MCI_Go_Idle_State+0x54>

00002fd4 <MCI_Send_ACMD>:
 ** Returned value:		true or false, true if card has responded before timeout.
 **						false is timeout.
 ** 
 ******************************************************************************/
// mthomas - static
static DWORD MCI_Send_ACMD(void) {
    2fd4:	e1a0c00d 	mov	ip, sp
    2fd8:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}

	// mthomas - warning: MCI_CardType may be set from
	// extern to other than UNKOWN and this
	// will fail on init (workaround: added MCI_CardType = UNKNOWN below)
	// laebi: add CardType SDHC_CARD, otherwise it wouldnt work
	if (MCI_CardType == SD_CARD || MCI_CardType == SDHC_CARD) {
    2fdc:	e59f20b4 	ldr	r2, [pc, #180]	; 3098 <MCI_Send_ACMD+0xc4>
 ** Returned value:		true or false, true if card has responded before timeout.
 **						false is timeout.
 ** 
 ******************************************************************************/
// mthomas - static
static DWORD MCI_Send_ACMD(void) {
    2fe0:	e24cb004 	sub	fp, ip, #4	; 0x4
    2fe4:	e24dd014 	sub	sp, sp, #20	; 0x14

	// mthomas - warning: MCI_CardType may be set from
	// extern to other than UNKOWN and this
	// will fail on init (workaround: added MCI_CardType = UNKNOWN below)
	// laebi: add CardType SDHC_CARD, otherwise it wouldnt work
	if (MCI_CardType == SD_CARD || MCI_CardType == SDHC_CARD) {
    2fe8:	e5923000 	ldr	r3, [r2]
    2fec:	e3530002 	cmp	r3, #2	; 0x2
    2ff0:	0a000023 	beq	3084 <MCI_Send_ACMD+0xb0>
    2ff4:	e5923000 	ldr	r3, [r2]
    2ff8:	e3530004 	cmp	r3, #4	; 0x4
    2ffc:	13a05000 	movne	r5, #0	; 0x0
    3000:	0a00001f 	beq	3084 <MCI_Send_ACMD+0xb0>
		CmdArgument = CardRCA; /* Use the address from SET_RELATIVE_ADDR cmd */
    3004:	e3a04014 	mov	r4, #20	; 0x14
    3008:	e24b6030 	sub	r6, fp, #48	; 0x30
	}

	retryCount = 20;
	while (retryCount > 0) {
		/* Send CMD55 command followed by an ACMD */
		MCI_SendCmd( APP_CMD, CmdArgument, EXPECT_SHORT_RESP, 0);
    300c:	e3a07000 	mov	r7, #0	; 0x0
    3010:	e3a00037 	mov	r0, #55	; 0x37
    3014:	e1a01005 	mov	r1, r5
    3018:	e3a02001 	mov	r2, #1	; 0x1
    301c:	e3a03000 	mov	r3, #0	; 0x0
    3020:	ebffff51 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( APP_CMD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    3024:	e3a00037 	mov	r0, #55	; 0x37
    3028:	e3a01001 	mov	r1, #1	; 0x1
    302c:	e1a02006 	mov	r2, r6
    3030:	ebffff7d 	bl	2e2c <MCI_GetCmdResp>
		if ( !respStatus && (respValue[0] & CARD_STATUS_ACMD_ENABLE)) /* Check if APP_CMD enabled */
    3034:	e3500000 	cmp	r0, #0	; 0x0
    3038:	1a000002 	bne	3048 <MCI_Send_ACMD+0x74>
    303c:	e51b3030 	ldr	r3, [fp, #-48]
    3040:	e3130020 	tst	r3, #32	; 0x20
    3044:	1a000011 	bne	3090 <MCI_Send_ACMD+0xbc>
		{
			return ( TRUE );
		}
		for (i = 0; i < 0x20; i++) {
    3048:	e50b7020 	str	r7, [fp, #-32]
    304c:	e51b3020 	ldr	r3, [fp, #-32]
    3050:	e353001f 	cmp	r3, #31	; 0x1f
    3054:	8a000005 	bhi	3070 <MCI_Send_ACMD+0x9c>
    3058:	e51b3020 	ldr	r3, [fp, #-32]
    305c:	e2833001 	add	r3, r3, #1	; 0x1
    3060:	e50b3020 	str	r3, [fp, #-32]
    3064:	e51b2020 	ldr	r2, [fp, #-32]
    3068:	e352001f 	cmp	r2, #31	; 0x1f
    306c:	9afffff9 	bls	3058 <MCI_Send_ACMD+0x84>
	{
		CmdArgument = 0x00000000;
	}

	retryCount = 20;
	while (retryCount > 0) {
    3070:	e2544001 	subs	r4, r4, #1	; 0x1
    3074:	1affffe5 	bne	3010 <MCI_Send_ACMD+0x3c>
    3078:	e1a00004 	mov	r0, r4
			;
		}
		retryCount--;
	}
	return ( FALSE );
}
    307c:	e24bd01c 	sub	sp, fp, #28	; 0x1c
    3080:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
	// mthomas - warning: MCI_CardType may be set from
	// extern to other than UNKOWN and this
	// will fail on init (workaround: added MCI_CardType = UNKNOWN below)
	// laebi: add CardType SDHC_CARD, otherwise it wouldnt work
	if (MCI_CardType == SD_CARD || MCI_CardType == SDHC_CARD) {
		CmdArgument = CardRCA; /* Use the address from SET_RELATIVE_ADDR cmd */
    3084:	e59f3010 	ldr	r3, [pc, #16]	; 309c <MCI_Send_ACMD+0xc8>
    3088:	e5935000 	ldr	r5, [r3]
    308c:	eaffffdc 	b	3004 <MCI_Send_ACMD+0x30>
	retryCount = 20;
	while (retryCount > 0) {
		/* Send CMD55 command followed by an ACMD */
		MCI_SendCmd( APP_CMD, CmdArgument, EXPECT_SHORT_RESP, 0);
		respStatus = MCI_GetCmdResp( APP_CMD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
		if ( !respStatus && (respValue[0] & CARD_STATUS_ACMD_ENABLE)) /* Check if APP_CMD enabled */
    3090:	e2800001 	add	r0, r0, #1	; 0x1
    3094:	eafffff8 	b	307c <MCI_Send_ACMD+0xa8>
    3098:	40000050 	.word	0x40000050
    309c:	4000004c 	.word	0x4000004c

000030a0 <MCI_CardInit>:
 ** 
 ** extended by Martin Thomas with information from Juri Haberland,
 ** public available Information for SDHC, Chan's fat-code and 
 ** the SanDisk SD-Card manual V2.2
 ******************************************************************************/
DWORD MCI_CardInit(void) {
    30a0:	e1a0c00d 	mov	ip, sp
    30a4:	e92ddff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
	volatile DWORD i;
	DWORD CardType= CARD_UNKNOWN;
	DWORD acmd41_arg;
	DWORD resp0;

	MCI_CardType = CARD_UNKNOWN;
    30a8:	e59f32a0 	ldr	r3, [pc, #672]	; 3350 <MCI_CardInit+0x2b0>
 ** 
 ** extended by Martin Thomas with information from Juri Haberland,
 ** public available Information for SDHC, Chan's fat-code and 
 ** the SanDisk SD-Card manual V2.2
 ******************************************************************************/
DWORD MCI_CardInit(void) {
    30ac:	e24cb004 	sub	fp, ip, #4	; 0x4
    30b0:	e24dd018 	sub	sp, sp, #24	; 0x18
	volatile DWORD i;
	DWORD CardType= CARD_UNKNOWN;
	DWORD acmd41_arg;
	DWORD resp0;

	MCI_CardType = CARD_UNKNOWN;
    30b4:	e3a05000 	mov	r5, #0	; 0x0
    30b8:	e5835000 	str	r5, [r3]

	if (MCI_Go_Idle_State() == FALSE) {
    30bc:	ebffffab 	bl	2f70 <MCI_Go_Idle_State>
    30c0:	e3500000 	cmp	r0, #0	; 0x0
    30c4:	01a09000 	moveq	r9, r0
    30c8:	0a000078 	beq	32b0 <MCI_CardInit+0x210>
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 20; /* reset retry counter */
	while (retryCount > 0) {
		MCI_POWER &= ~(1 << 6 );
    30cc:	e3a0620e 	mov	r6, #-536870912	; 0xe0000000
		/* Clear Open Drain output control for SD */
		for (i = 0; i < 0x3000; i++) {
    30d0:	e3a04dbf 	mov	r4, #12224	; 0x2fc0
    30d4:	e1a07005 	mov	r7, r5
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 20; /* reset retry counter */
	while (retryCount > 0) {
		MCI_POWER &= ~(1 << 6 );
    30d8:	e2866923 	add	r6, r6, #573440	; 0x8c000
		/* Clear Open Drain output control for SD */
		for (i = 0; i < 0x3000; i++) {
    30dc:	e284403f 	add	r4, r4, #63	; 0x3f
	DWORD acmd41_arg;
	DWORD resp0;

	MCI_CardType = CARD_UNKNOWN;

	if (MCI_Go_Idle_State() == FALSE) {
    30e0:	e3a05014 	mov	r5, #20	; 0x14
    30e4:	e24ba040 	sub	sl, fp, #64	; 0x40
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 20; /* reset retry counter */
	while (retryCount > 0) {
		MCI_POWER &= ~(1 << 6 );
    30e8:	e5963000 	ldr	r3, [r6]
    30ec:	e3c33040 	bic	r3, r3, #64	; 0x40
    30f0:	e5863000 	str	r3, [r6]
		/* Clear Open Drain output control for SD */
		for (i = 0; i < 0x3000; i++) {
    30f4:	e50b7030 	str	r7, [fp, #-48]
    30f8:	e51b3030 	ldr	r3, [fp, #-48]
    30fc:	e1530004 	cmp	r3, r4
    3100:	8a000005 	bhi	311c <MCI_CardInit+0x7c>
    3104:	e51b3030 	ldr	r3, [fp, #-48]
    3108:	e2833001 	add	r3, r3, #1	; 0x1
    310c:	e50b3030 	str	r3, [fp, #-48]
    3110:	e51b2030 	ldr	r2, [fp, #-48]
    3114:	e1520004 	cmp	r2, r4
    3118:	9afffff9 	bls	3104 <MCI_CardInit+0x64>
			;
		}

		/* Send CMD8 command repeatedly until the response is back correctly or timeout */
		MCI_SendCmd( SEND_IF_COND, SEND_IF_COND_ARG , EXPECT_SHORT_RESP, 0);
    311c:	e3a01f6a 	mov	r1, #424	; 0x1a8
    3120:	e2811002 	add	r1, r1, #2	; 0x2
    3124:	e3a00008 	mov	r0, #8	; 0x8
    3128:	e3a02001 	mov	r2, #1	; 0x1
    312c:	e3a03000 	mov	r3, #0	; 0x0
    3130:	ebffff0d 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SEND_IF_COND, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    3134:	e3a00008 	mov	r0, #8	; 0x8
    3138:	e3a01001 	mov	r1, #1	; 0x1
    313c:	e1a0200a 	mov	r2, sl
    3140:	ebffff39 	bl	2e2c <MCI_GetCmdResp>
		/* mthomas TODO: check result bits - for now just check if no timeout */
		if ( !(respStatus & MCI_CMD_TIMEOUT)) {
    3144:	e3100004 	tst	r0, #4	; 0x4
    3148:	0a000078 	beq	3330 <MCI_CardInit+0x290>
			return ( TRUE ); /* response is back and correct. */
		}
		for (i = 0; i < 0x20; i++)
    314c:	e50b7030 	str	r7, [fp, #-48]
    3150:	e51b3030 	ldr	r3, [fp, #-48]
    3154:	e353001f 	cmp	r3, #31	; 0x1f
    3158:	8a000005 	bhi	3174 <MCI_CardInit+0xd4>
    315c:	e51b3030 	ldr	r3, [fp, #-48]
    3160:	e2833001 	add	r3, r3, #1	; 0x1
    3164:	e50b3030 	str	r3, [fp, #-48]
    3168:	e51b2030 	ldr	r2, [fp, #-48]
    316c:	e352001f 	cmp	r2, #31	; 0x1f
    3170:	9afffff9 	bls	315c <MCI_CardInit+0xbc>
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 20; /* reset retry counter */
	while (retryCount > 0) {
    3174:	e2555001 	subs	r5, r5, #1	; 0x1
    3178:	1affffda 	bne	30e8 <MCI_CardInit+0x48>
    317c:	e3a088ff 	mov	r8, #16711680	; 0xff0000
    3180:	e1a09005 	mov	r9, r5
    3184:	e2888902 	add	r8, r8, #32768	; 0x8000
	/* timeout on SEND_OP_COND command on MMC, now, try SEND_APP_OP_COND 
	 command to SD */
	// mthomas - less retries retryCount = 0x200;			/* reset retry counter */
	retryCount = 0x50;
	while (retryCount > 0) {
		MCI_POWER &= ~(1 << 6 );
    3188:	e3a0620e 	mov	r6, #-536870912	; 0xe0000000
		/* Clear Open Drain output control for SD */
		for (i = 0; i < 0x3000; i++) {
    318c:	e3a04dbf 	mov	r4, #12224	; 0x2fc0
	/* timeout on SEND_OP_COND command on MMC, now, try SEND_APP_OP_COND 
	 command to SD */
	// mthomas - less retries retryCount = 0x200;			/* reset retry counter */
	retryCount = 0x50;
	while (retryCount > 0) {
		MCI_POWER &= ~(1 << 6 );
    3190:	e2866923 	add	r6, r6, #573440	; 0x8c000
		/* Clear Open Drain output control for SD */
		for (i = 0; i < 0x3000; i++) {
    3194:	e284403f 	add	r4, r4, #63	; 0x3f
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 20; /* reset retry counter */
	while (retryCount > 0) {
    3198:	e3a0504f 	mov	r5, #79	; 0x4f
	// mthomas - less retries retryCount = 0x200;			/* reset retry counter */
	retryCount = 0x50;
	while (retryCount > 0) {
		MCI_POWER &= ~(1 << 6 );
		/* Clear Open Drain output control for SD */
		for (i = 0; i < 0x3000; i++) {
    319c:	e3a07000 	mov	r7, #0	; 0x0
	/* timeout on SEND_OP_COND command on MMC, now, try SEND_APP_OP_COND 
	 command to SD */
	// mthomas - less retries retryCount = 0x200;			/* reset retry counter */
	retryCount = 0x50;
	while (retryCount > 0) {
		MCI_POWER &= ~(1 << 6 );
    31a0:	e5963000 	ldr	r3, [r6]
    31a4:	e3c33040 	bic	r3, r3, #64	; 0x40
    31a8:	e5863000 	str	r3, [r6]
		/* Clear Open Drain output control for SD */
		for (i = 0; i < 0x3000; i++) {
    31ac:	e50b7030 	str	r7, [fp, #-48]
    31b0:	e51b3030 	ldr	r3, [fp, #-48]
    31b4:	e1530004 	cmp	r3, r4
    31b8:	8a000005 	bhi	31d4 <MCI_CardInit+0x134>
    31bc:	e51b3030 	ldr	r3, [fp, #-48]
    31c0:	e2833001 	add	r3, r3, #1	; 0x1
    31c4:	e50b3030 	str	r3, [fp, #-48]
    31c8:	e51b2030 	ldr	r2, [fp, #-48]
    31cc:	e1520004 	cmp	r2, r4
    31d0:	9afffff9 	bls	31bc <MCI_CardInit+0x11c>
			;
		}

		if (MCI_Send_ACMD() == FALSE) {
    31d4:	ebffff7e 	bl	2fd4 <MCI_Send_ACMD>
    31d8:	e3500000 	cmp	r0, #0	; 0x0
    31dc:	1a000036 	bne	32bc <MCI_CardInit+0x21c>

	/* timeout on SEND_OP_COND command on MMC, now, try SEND_APP_OP_COND 
	 command to SD */
	// mthomas - less retries retryCount = 0x200;			/* reset retry counter */
	retryCount = 0x50;
	while (retryCount > 0) {
    31e0:	e2555001 	subs	r5, r5, #1	; 0x1
    31e4:	2affffed 	bcs	31a0 <MCI_CardInit+0x100>
			mci_debug_printf("SDSC detected\n");
			CardType = SDSC_CARD;
		}
	} else {
		mci_debug_printf("MCI_Send_ACMD failed -> MMC, invalid power-range or no card\n");
		MCI_POWER |= (1 << 6 );
    31e8:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    31ec:	e2822923 	add	r2, r2, #573440	; 0x8c000
    31f0:	e5923000 	ldr	r3, [r2]
		/* Set Open Drain output control for MMC */
		for (i = 0; i < 0x3000; i++) {
    31f4:	e3a01000 	mov	r1, #0	; 0x0
			mci_debug_printf("SDSC detected\n");
			CardType = SDSC_CARD;
		}
	} else {
		mci_debug_printf("MCI_Send_ACMD failed -> MMC, invalid power-range or no card\n");
		MCI_POWER |= (1 << 6 );
    31f8:	e3833040 	orr	r3, r3, #64	; 0x40
    31fc:	e5823000 	str	r3, [r2]
		/* Set Open Drain output control for MMC */
		for (i = 0; i < 0x3000; i++) {
    3200:	e50b102c 	str	r1, [fp, #-44]
    3204:	e51b302c 	ldr	r3, [fp, #-44]
    3208:	e3a02dbf 	mov	r2, #12224	; 0x2fc0
    320c:	e282203f 	add	r2, r2, #63	; 0x3f
    3210:	e1530002 	cmp	r3, r2
    3214:	8a000006 	bhi	3234 <MCI_CardInit+0x194>
    3218:	e1a01002 	mov	r1, r2
    321c:	e51b302c 	ldr	r3, [fp, #-44]
    3220:	e2833001 	add	r3, r3, #1	; 0x1
    3224:	e50b302c 	str	r3, [fp, #-44]
    3228:	e51b202c 	ldr	r2, [fp, #-44]
    322c:	e1520001 	cmp	r2, r1
    3230:	9afffff9 	bls	321c <MCI_CardInit+0x17c>
    3234:	e3a04c02 	mov	r4, #512	; 0x200
	DWORD respValue[4];

	retryCount = 0x200; /* reset retry counter */
	while (retryCount > 0) {
		/* Send CMD1 command repeatedly until the response is back correctly */
		MCI_SendCmd( SEND_OP_COND, OCR_INDEX, EXPECT_SHORT_RESP, 0);
    3238:	e3a05000 	mov	r5, #0	; 0x0
    323c:	e3a00001 	mov	r0, #1	; 0x1
    3240:	e3a018ff 	mov	r1, #16711680	; 0xff0000
    3244:	e1a02000 	mov	r2, r0
    3248:	e2811902 	add	r1, r1, #32768	; 0x8000
    324c:	e3a03000 	mov	r3, #0	; 0x0
    3250:	ebfffec5 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SEND_OP_COND, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    3254:	e3a00001 	mov	r0, #1	; 0x1
    3258:	e1a01000 	mov	r1, r0
    325c:	e1a0200a 	mov	r2, sl
    3260:	ebfffef1 	bl	2e2c <MCI_GetCmdResp>
		/* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
		if ( !(respStatus & MCI_CMD_TIMEOUT) && (respValue[0] & 0x80000000)) {
    3264:	e3100004 	tst	r0, #4	; 0x4
    3268:	1a000002 	bne	3278 <MCI_CardInit+0x1d8>
    326c:	e51b3040 	ldr	r3, [fp, #-64]
    3270:	e3530000 	cmp	r3, #0	; 0x0
    3274:	ba000029 	blt	3320 <MCI_CardInit+0x280>
			return ( TRUE ); /* response is back and correct. */
		}
		for (i = 0; i < 0x20; i++)
    3278:	e50b5030 	str	r5, [fp, #-48]
    327c:	e51b3030 	ldr	r3, [fp, #-48]
    3280:	e353001f 	cmp	r3, #31	; 0x1f
    3284:	8a000005 	bhi	32a0 <MCI_CardInit+0x200>
    3288:	e51b3030 	ldr	r3, [fp, #-48]
    328c:	e2833001 	add	r3, r3, #1	; 0x1
    3290:	e50b3030 	str	r3, [fp, #-48]
    3294:	e51b2030 	ldr	r2, [fp, #-48]
    3298:	e352001f 	cmp	r2, #31	; 0x1f
    329c:	9afffff9 	bls	3288 <MCI_CardInit+0x1e8>
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x200; /* reset retry counter */
	while (retryCount > 0) {
    32a0:	e2544001 	subs	r4, r4, #1	; 0x1
    32a4:	1affffe4 	bne	323c <MCI_CardInit+0x19c>
		if (MCI_Send_OP_Cond() == TRUE) {
			CardType = MMC_CARD;
		}
	}

	MCI_CardType = CardType;
    32a8:	e59f30a0 	ldr	r3, [pc, #160]	; 3350 <MCI_CardInit+0x2b0>
    32ac:	e5839000 	str	r9, [r3]

	return (CardType );
}
    32b0:	e1a00009 	mov	r0, r9
    32b4:	e24bd028 	sub	sp, fp, #40	; 0x28
    32b8:	e89daff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
			continue;
		}

		/* Send ACMD41 command repeatedly until the response is back correctly */
		// MCI_SendCmd( SEND_APP_OP_COND, OCR_INDEX, EXPECT_SHORT_RESP, 0 );
		MCI_SendCmd( SEND_APP_OP_COND, acmd41_arg, EXPECT_SHORT_RESP, 0);
    32bc:	e3a00029 	mov	r0, #41	; 0x29
    32c0:	e1a01008 	mov	r1, r8
    32c4:	e3a02001 	mov	r2, #1	; 0x1
    32c8:	e3a03000 	mov	r3, #0	; 0x0
    32cc:	ebfffea6 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SEND_APP_OP_COND, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    32d0:	e3a00029 	mov	r0, #41	; 0x29
    32d4:	e3a01001 	mov	r1, #1	; 0x1
    32d8:	e1a0200a 	mov	r2, sl
    32dc:	ebfffed2 	bl	2e2c <MCI_GetCmdResp>
		if ( !(respStatus & MCI_CMD_TIMEOUT) && (respValue[0] & 0x80000000)) {
    32e0:	e3100004 	tst	r0, #4	; 0x4
    32e4:	1a000002 	bne	32f4 <MCI_CardInit+0x254>
    32e8:	e51b3040 	ldr	r3, [fp, #-64]
    32ec:	e3530000 	cmp	r3, #0	; 0x0
    32f0:	ba000012 	blt	3340 <MCI_CardInit+0x2a0>
			if (resp0 != NULL) {
				*resp0 = respValue[0];
			}
			return ( TRUE ); /* response is back and correct. */
		}
		for (i = 0; i < 0x20; i++) {
    32f4:	e50b7030 	str	r7, [fp, #-48]
    32f8:	e51b3030 	ldr	r3, [fp, #-48]
    32fc:	e353001f 	cmp	r3, #31	; 0x1f
    3300:	8affffb6 	bhi	31e0 <MCI_CardInit+0x140>
    3304:	e51b3030 	ldr	r3, [fp, #-48]
    3308:	e2833001 	add	r3, r3, #1	; 0x1
    330c:	e50b3030 	str	r3, [fp, #-48]
    3310:	e51b2030 	ldr	r2, [fp, #-48]
    3314:	e352001f 	cmp	r2, #31	; 0x1f
    3318:	9afffff9 	bls	3304 <MCI_CardInit+0x264>
    331c:	eaffffaf 	b	31e0 <MCI_CardInit+0x140>
		if (MCI_Send_OP_Cond() == TRUE) {
			CardType = MMC_CARD;
		}
	}

	MCI_CardType = CardType;
    3320:	e59f3028 	ldr	r3, [pc, #40]	; 3350 <MCI_CardInit+0x2b0>
	while (retryCount > 0) {
		/* Send CMD1 command repeatedly until the response is back correctly */
		MCI_SendCmd( SEND_OP_COND, OCR_INDEX, EXPECT_SHORT_RESP, 0);
		respStatus = MCI_GetCmdResp( SEND_OP_COND, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
		/* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
		if ( !(respStatus & MCI_CMD_TIMEOUT) && (respValue[0] & 0x80000000)) {
    3324:	e3a09001 	mov	r9, #1	; 0x1
		if (MCI_Send_OP_Cond() == TRUE) {
			CardType = MMC_CARD;
		}
	}

	MCI_CardType = CardType;
    3328:	e5839000 	str	r9, [r3]
    332c:	eaffffdf 	b	32b0 <MCI_CardInit+0x210>

		/* Send CMD8 command repeatedly until the response is back correctly or timeout */
		MCI_SendCmd( SEND_IF_COND, SEND_IF_COND_ARG , EXPECT_SHORT_RESP, 0);
		respStatus = MCI_GetCmdResp( SEND_IF_COND, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
		/* mthomas TODO: check result bits - for now just check if no timeout */
		if ( !(respStatus & MCI_CMD_TIMEOUT)) {
    3330:	e3a08441 	mov	r8, #1090519040	; 0x41000000
    3334:	e2488902 	sub	r8, r8, #32768	; 0x8000
    3338:	e3a09008 	mov	r9, #8	; 0x8
    333c:	eaffff91 	b	3188 <MCI_CardInit+0xe8>
		acmd41_arg = OCR_HIGH_VOLTAGE_RANGE;
	}

	if (MCI_Send_ACMD_OP_Cond(acmd41_arg, &resp0) == TRUE) {
		mci_debug_printf("ACMD41 success -> SD-Card SC or HC\n");
		if (resp0 & OCR_CARD_HIGH_CAPACITY) {
    3340:	e3130101 	tst	r3, #1073741824	; 0x40000000
    3344:	13a09004 	movne	r9, #4	; 0x4
    3348:	03a09002 	moveq	r9, #2	; 0x2
    334c:	eaffffd5 	b	32a8 <MCI_CardInit+0x208>
    3350:	40000050 	.word	0x40000050

00003354 <MCI_Check_CID>:
 **
 ** parameters:			None
 ** Returned value:		If not timeout, return true.
 ** 
 ******************************************************************************/
DWORD MCI_Check_CID(void) {
    3354:	e1a0c00d 	mov	ip, sp
    3358:	e92dd870 	push	{r4, r5, r6, fp, ip, lr, pc}
    335c:	e24cb004 	sub	fp, ip, #4	; 0x4
    3360:	e24dd014 	sub	sp, sp, #20	; 0x14
    3364:	e3a04020 	mov	r4, #32	; 0x20
    3368:	e24b502c 	sub	r5, fp, #44	; 0x2c

	/* This command is normally after CMD1(MMC) or ACMD41(SD). */
	retryCount = 0x20; /* reset retry counter */
	while (retryCount > 0) {
		/* Send CMD2 command repeatedly until the response is back correctly */
		MCI_SendCmd( ALL_SEND_CID, 0, EXPECT_LONG_RESP, 0);
    336c:	e3a06000 	mov	r6, #0	; 0x0
    3370:	e3a00002 	mov	r0, #2	; 0x2
    3374:	e3a01000 	mov	r1, #0	; 0x0
    3378:	e1a02000 	mov	r2, r0
    337c:	e1a03001 	mov	r3, r1
    3380:	ebfffe79 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( ALL_SEND_CID, EXPECT_LONG_RESP, (DWORD *)&respValue[0]);
    3384:	e3a00002 	mov	r0, #2	; 0x2
    3388:	e1a01000 	mov	r1, r0
    338c:	e1a02005 	mov	r2, r5
    3390:	ebfffea5 	bl	2e2c <MCI_GetCmdResp>
		/* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
		if ( !(respStatus & MCI_CMD_TIMEOUT )) {
    3394:	e3100004 	tst	r0, #4	; 0x4
    3398:	0a00000d 	beq	33d4 <MCI_Check_CID+0x80>
			return ( TRUE ); /* response is back and correct. */
		}
		for (i = 0; i < 0x20; i++) {
    339c:	e50b601c 	str	r6, [fp, #-28]
    33a0:	e51b301c 	ldr	r3, [fp, #-28]
    33a4:	e353001f 	cmp	r3, #31	; 0x1f
    33a8:	8a000005 	bhi	33c4 <MCI_Check_CID+0x70>
    33ac:	e51b301c 	ldr	r3, [fp, #-28]
    33b0:	e2833001 	add	r3, r3, #1	; 0x1
    33b4:	e50b301c 	str	r3, [fp, #-28]
    33b8:	e51b201c 	ldr	r2, [fp, #-28]
    33bc:	e352001f 	cmp	r2, #31	; 0x1f
    33c0:	9afffff9 	bls	33ac <MCI_Check_CID+0x58>
	DWORD respStatus;
	DWORD respValue[4];

	/* This command is normally after CMD1(MMC) or ACMD41(SD). */
	retryCount = 0x20; /* reset retry counter */
	while (retryCount > 0) {
    33c4:	e2544001 	subs	r4, r4, #1	; 0x1
    33c8:	1affffe8 	bne	3370 <MCI_Check_CID+0x1c>
    33cc:	e1a00004 	mov	r0, r4
    33d0:	ea000000 	b	33d8 <MCI_Check_CID+0x84>
		/* Send CMD2 command repeatedly until the response is back correctly */
		MCI_SendCmd( ALL_SEND_CID, 0, EXPECT_LONG_RESP, 0);
		respStatus = MCI_GetCmdResp( ALL_SEND_CID, EXPECT_LONG_RESP, (DWORD *)&respValue[0]);
		/* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
		if ( !(respStatus & MCI_CMD_TIMEOUT )) {
    33d4:	e3a00001 	mov	r0, #1	; 0x1
			;
		}
		retryCount--;
	}
	return ( FALSE );
}
    33d8:	e24bd018 	sub	sp, fp, #24	; 0x18
    33dc:	e89da870 	ldm	sp, {r4, r5, r6, fp, sp, pc}

000033e0 <MCI_Set_Address>:
 ** parameters:			None
 ** Returned value:		TRUE if response is back before timeout.
 ** 
 ** modified by mthomas
 ******************************************************************************/
DWORD MCI_Set_Address(void) {
    33e0:	e1a0c00d 	mov	ip, sp
    33e4:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
	/* If it's a SD card, SET_RELATIVE_ADDR is to get the address
	 from the card and use this value in RCA, if it's a MMC, set default
	 RCA addr. 0x00010000. */
#if 1
	// mthomas:
	if (MCI_CardType & MMC_CARD) {
    33e8:	e59f20b0 	ldr	r2, [pc, #176]	; 34a0 <MCI_Set_Address+0xc0>
 ** parameters:			None
 ** Returned value:		TRUE if response is back before timeout.
 ** 
 ** modified by mthomas
 ******************************************************************************/
DWORD MCI_Set_Address(void) {
    33ec:	e24cb004 	sub	fp, ip, #4	; 0x4
    33f0:	e24dd014 	sub	sp, sp, #20	; 0x14
	/* If it's a SD card, SET_RELATIVE_ADDR is to get the address
	 from the card and use this value in RCA, if it's a MMC, set default
	 RCA addr. 0x00010000. */
#if 1
	// mthomas:
	if (MCI_CardType & MMC_CARD) {
    33f4:	e5923000 	ldr	r3, [r2]
    33f8:	e2133001 	ands	r3, r3, #1	; 0x1
    33fc:	01a05003 	moveq	r5, r3
    3400:	13a05801 	movne	r5, #65536	; 0x10000
    3404:	e3a04020 	mov	r4, #32	; 0x20
    3408:	e24b6030 	sub	r6, fp, #48	; 0x30
#endif

	retryCount = 0x20; /* reset retry counter */
	while (retryCount > 0) {
		/* Send CMD3 command repeatedly until the response is back correctly */
		MCI_SendCmd( SET_RELATIVE_ADDR, CmdArgument, EXPECT_SHORT_RESP, 0);
    340c:	e3a07000 	mov	r7, #0	; 0x0
    3410:	e3a00003 	mov	r0, #3	; 0x3
    3414:	e1a01005 	mov	r1, r5
    3418:	e3a02001 	mov	r2, #1	; 0x1
    341c:	e3a03000 	mov	r3, #0	; 0x0
    3420:	ebfffe51 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SET_RELATIVE_ADDR, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    3424:	e3a00003 	mov	r0, #3	; 0x3
    3428:	e3a01001 	mov	r1, #1	; 0x1
    342c:	e1a02006 	mov	r2, r6
    3430:	ebfffe7d 	bl	2e2c <MCI_GetCmdResp>
		/* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
		/* It should go to IDEN state and bit 8 should be 1 */
		if ( !(respStatus & MCI_CMD_TIMEOUT) && ((respValue[0] & (0x0F << 8))
    3434:	e3100004 	tst	r0, #4	; 0x4
    3438:	1a000003 	bne	344c <MCI_Set_Address+0x6c>
    343c:	e51b2030 	ldr	r2, [fp, #-48]
    3440:	e2023c0f 	and	r3, r2, #3840	; 0xf00
    3444:	e3530c05 	cmp	r3, #1280	; 0x500
    3448:	0a00000e 	beq	3488 <MCI_Set_Address+0xa8>
				== 0x0500)) {
			CardRCA = respValue[0] & 0xFFFF0000; /* Save the RCA value from SD card */
			return ( TRUE ); /* response is back and correct. */
		}
		for (i = 0; i < 0x20; i++) {
    344c:	e50b7020 	str	r7, [fp, #-32]
    3450:	e51b3020 	ldr	r3, [fp, #-32]
    3454:	e353001f 	cmp	r3, #31	; 0x1f
    3458:	8a000005 	bhi	3474 <MCI_Set_Address+0x94>
    345c:	e51b3020 	ldr	r3, [fp, #-32]
    3460:	e2833001 	add	r3, r3, #1	; 0x1
    3464:	e50b3020 	str	r3, [fp, #-32]
    3468:	e51b2020 	ldr	r2, [fp, #-32]
    346c:	e352001f 	cmp	r2, #31	; 0x1f
    3470:	9afffff9 	bls	345c <MCI_Set_Address+0x7c>
		CmdArgument = 0x00010000;
	}
#endif

	retryCount = 0x20; /* reset retry counter */
	while (retryCount > 0) {
    3474:	e2544001 	subs	r4, r4, #1	; 0x1
    3478:	1affffe4 	bne	3410 <MCI_Set_Address+0x30>
    347c:	e1a00004 	mov	r0, r4
			;
		}
		retryCount--;
	}
	return ( FALSE );
}
    3480:	e24bd01c 	sub	sp, fp, #28	; 0x1c
    3484:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
		respStatus = MCI_GetCmdResp( SET_RELATIVE_ADDR, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
		/* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
		/* It should go to IDEN state and bit 8 should be 1 */
		if ( !(respStatus & MCI_CMD_TIMEOUT) && ((respValue[0] & (0x0F << 8))
				== 0x0500)) {
			CardRCA = respValue[0] & 0xFFFF0000; /* Save the RCA value from SD card */
    3488:	e1a03822 	lsr	r3, r2, #16
    348c:	e59f2010 	ldr	r2, [pc, #16]	; 34a4 <MCI_Set_Address+0xc4>
    3490:	e1a03803 	lsl	r3, r3, #16
    3494:	e5823000 	str	r3, [r2]
    3498:	e3a00001 	mov	r0, #1	; 0x1
    349c:	eafffff7 	b	3480 <MCI_Set_Address+0xa0>
    34a0:	40000050 	.word	0x40000050
    34a4:	4000004c 	.word	0x4000004c

000034a8 <MCI_Send_CSD>:
 ** parameters:			None
 ** Returned value:		Response value
 ** 
 ******************************************************************************/
// DWORD MCI_Send_CSD( void )
DWORD MCI_Send_CSD(DWORD *csd) {
    34a8:	e1a0c00d 	mov	ip, sp
    34ac:	e92dddf0 	push	{r4, r5, r6, r7, r8, sl, fp, ip, lr, pc}
	DWORD respValue[4];
	DWORD CmdArgument;

#if 1
	// mthomas:
	if (MCI_CardType & MMC_CARD) {
    34b0:	e59f30f4 	ldr	r3, [pc, #244]	; 35ac <MCI_Send_CSD+0x104>
 ** parameters:			None
 ** Returned value:		Response value
 ** 
 ******************************************************************************/
// DWORD MCI_Send_CSD( void )
DWORD MCI_Send_CSD(DWORD *csd) {
    34b4:	e24cb004 	sub	fp, ip, #4	; 0x4
    34b8:	e24dd014 	sub	sp, sp, #20	; 0x14
	DWORD respValue[4];
	DWORD CmdArgument;

#if 1
	// mthomas:
	if (MCI_CardType & MMC_CARD) {
    34bc:	e5932000 	ldr	r2, [r3]
    34c0:	e3120001 	tst	r2, #1	; 0x1
		/* If it's unknown or MMC_CARD, fix the RCA address */
		CmdArgument = 0x00010000;
	} else {
		CmdArgument = CardRCA;
    34c4:	059f30e4 	ldreq	r3, [pc, #228]	; 35b0 <MCI_Send_CSD+0x108>
#endif

	retryCount = 0x20;
	while (retryCount > 0) {
		/* Send SET_BLOCK_LEN command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    34c8:	e3a0520e 	mov	r5, #-536870912	; 0xe0000000
	// mthomas:
	if (MCI_CardType & MMC_CARD) {
		/* If it's unknown or MMC_CARD, fix the RCA address */
		CmdArgument = 0x00010000;
	} else {
		CmdArgument = CardRCA;
    34cc:	05936000 	ldreq	r6, [r3]
 ** parameters:			None
 ** Returned value:		Response value
 ** 
 ******************************************************************************/
// DWORD MCI_Send_CSD( void )
DWORD MCI_Send_CSD(DWORD *csd) {
    34d0:	e1a0a000 	mov	sl, r0
	DWORD respValue[4];
	DWORD CmdArgument;

#if 1
	// mthomas:
	if (MCI_CardType & MMC_CARD) {
    34d4:	13a06801 	movne	r6, #65536	; 0x10000
#endif

	retryCount = 0x20;
	while (retryCount > 0) {
		/* Send SET_BLOCK_LEN command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    34d8:	e2855923 	add	r5, r5, #573440	; 0x8c000
	// mthomas:
	if (MCI_CardType & MMC_CARD) {
		/* If it's unknown or MMC_CARD, fix the RCA address */
		CmdArgument = 0x00010000;
	} else {
		CmdArgument = CardRCA;
    34dc:	e3a04020 	mov	r4, #32	; 0x20
    34e0:	e24b7038 	sub	r7, fp, #56	; 0x38

	retryCount = 0x20;
	while (retryCount > 0) {
		/* Send SET_BLOCK_LEN command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
		MCI_SendCmd( SEND_CSD, CmdArgument, EXPECT_LONG_RESP, 0);
    34e4:	e3a08000 	mov	r8, #0	; 0x0
#endif

	retryCount = 0x20;
	while (retryCount > 0) {
		/* Send SET_BLOCK_LEN command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    34e8:	e5953038 	ldr	r3, [r5, #56]
    34ec:	e3833045 	orr	r3, r3, #69	; 0x45
    34f0:	e5853038 	str	r3, [r5, #56]
		MCI_SendCmd( SEND_CSD, CmdArgument, EXPECT_LONG_RESP, 0);
    34f4:	e3a00009 	mov	r0, #9	; 0x9
    34f8:	e1a01006 	mov	r1, r6
    34fc:	e3a02002 	mov	r2, #2	; 0x2
    3500:	e3a03000 	mov	r3, #0	; 0x0
    3504:	ebfffe18 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SEND_CSD, EXPECT_LONG_RESP, (DWORD *)&respValue[0]);
    3508:	e3a00009 	mov	r0, #9	; 0x9
    350c:	e3a01002 	mov	r1, #2	; 0x2
    3510:	e1a02007 	mov	r2, r7
    3514:	ebfffe44 	bl	2e2c <MCI_GetCmdResp>
		if ( !respStatus) {
    3518:	e3500000 	cmp	r0, #0	; 0x0
    351c:	0a00000d 	beq	3558 <MCI_Send_CSD+0xb0>
					csd[i] = respValue[i];
				}
			}
			return ( TRUE );
		}
		for (i = 0; i < 0x20; i++) {
    3520:	e50b8028 	str	r8, [fp, #-40]
    3524:	e51b3028 	ldr	r3, [fp, #-40]
    3528:	e353001f 	cmp	r3, #31	; 0x1f
    352c:	8a000005 	bhi	3548 <MCI_Send_CSD+0xa0>
    3530:	e51b3028 	ldr	r3, [fp, #-40]
    3534:	e2833001 	add	r3, r3, #1	; 0x1
    3538:	e50b3028 	str	r3, [fp, #-40]
    353c:	e51b2028 	ldr	r2, [fp, #-40]
    3540:	e352001f 	cmp	r2, #31	; 0x1f
    3544:	9afffff9 	bls	3530 <MCI_Send_CSD+0x88>
		CmdArgument = 0x00010000;
	}
#endif

	retryCount = 0x20;
	while (retryCount > 0) {
    3548:	e2544001 	subs	r4, r4, #1	; 0x1
    354c:	1affffe5 	bne	34e8 <MCI_Send_CSD+0x40>
    3550:	e1a00004 	mov	r0, r4
    3554:	ea000012 	b	35a4 <MCI_Send_CSD+0xfc>
			mci_debug_printf("MCI_Send_CSD result: %08x %08x %08x %08x\n",
					respValue[0], respValue[1],
					respValue[2], respValue[3]
			);

			if (csd) {
    3558:	e35a0000 	cmp	sl, #0	; 0x0
    355c:	0a00000f 	beq	35a0 <MCI_Send_CSD+0xf8>
				for (i = 0; i < 4; i++) {
    3560:	e50b0028 	str	r0, [fp, #-40]
    3564:	e51b3028 	ldr	r3, [fp, #-40]
    3568:	e3530003 	cmp	r3, #3	; 0x3
    356c:	8a00000b 	bhi	35a0 <MCI_Send_CSD+0xf8>
					csd[i] = respValue[i];
    3570:	e51b0028 	ldr	r0, [fp, #-40]
    3574:	e51b1028 	ldr	r1, [fp, #-40]
					respValue[0], respValue[1],
					respValue[2], respValue[3]
			);

			if (csd) {
				for (i = 0; i < 4; i++) {
    3578:	e51b3028 	ldr	r3, [fp, #-40]
    357c:	e2833001 	add	r3, r3, #1	; 0x1
    3580:	e50b3028 	str	r3, [fp, #-40]
					csd[i] = respValue[i];
    3584:	e24b3024 	sub	r3, fp, #36	; 0x24
    3588:	e0832101 	add	r2, r3, r1, lsl #2
					respValue[0], respValue[1],
					respValue[2], respValue[3]
			);

			if (csd) {
				for (i = 0; i < 4; i++) {
    358c:	e51b3028 	ldr	r3, [fp, #-40]
					csd[i] = respValue[i];
    3590:	e5121014 	ldr	r1, [r2, #-20]
					respValue[0], respValue[1],
					respValue[2], respValue[3]
			);

			if (csd) {
				for (i = 0; i < 4; i++) {
    3594:	e3530003 	cmp	r3, #3	; 0x3
					csd[i] = respValue[i];
    3598:	e78a1100 	str	r1, [sl, r0, lsl #2]
					respValue[0], respValue[1],
					respValue[2], respValue[3]
			);

			if (csd) {
				for (i = 0; i < 4; i++) {
    359c:	9afffff3 	bls	3570 <MCI_Send_CSD+0xc8>
		CmdArgument = 0x00010000;
	}
#endif

	retryCount = 0x20;
	while (retryCount > 0) {
    35a0:	e3a00001 	mov	r0, #1	; 0x1
			;
		}
		retryCount--;
	}
	return ( FALSE );
}
    35a4:	e24bd024 	sub	sp, fp, #36	; 0x24
    35a8:	e89dadf0 	ldm	sp, {r4, r5, r6, r7, r8, sl, fp, sp, pc}
    35ac:	40000050 	.word	0x40000050
    35b0:	4000004c 	.word	0x4000004c

000035b4 <MCI_Select_Card>:
 ** parameters:			None
 ** Returned value:		return false if response times out.
 ** 
 ** modified by Martin Thomas for unselect (RCA 0)
 ******************************************************************************/
DWORD MCI_Select_Card(void) {
    35b4:	e1a0c00d 	mov	ip, sp
    35b8:	e92dd9f0 	push	{r4, r5, r6, r7, r8, fp, ip, lr, pc}
	DWORD respValue[4];
	DWORD CmdArgument;

#if 1
	// mthomas:
	if (MCI_CardType == CARD_UNKNOWN) {
    35bc:	e59f3188 	ldr	r3, [pc, #392]	; 374c <MCI_Select_Card+0x198>
 ** parameters:			None
 ** Returned value:		return false if response times out.
 ** 
 ** modified by Martin Thomas for unselect (RCA 0)
 ******************************************************************************/
DWORD MCI_Select_Card(void) {
    35c0:	e24cb004 	sub	fp, ip, #4	; 0x4
    35c4:	e24dd014 	sub	sp, sp, #20	; 0x14
	DWORD respValue[4];
	DWORD CmdArgument;

#if 1
	// mthomas:
	if (MCI_CardType == CARD_UNKNOWN) {
    35c8:	e5931000 	ldr	r1, [r3]
    35cc:	e3510000 	cmp	r1, #0	; 0x0
    35d0:	0a000038 	beq	36b8 <MCI_Select_Card+0x104>
		CmdArgument = 0; // RCA = 0 -> de-select -> trans to stby
	} else if (MCI_CardType & MMC_CARD) {
    35d4:	e5933000 	ldr	r3, [r3]
    35d8:	e2130001 	ands	r0, r3, #1	; 0x1
    35dc:	1a000045 	bne	36f8 <MCI_Select_Card+0x144>
		/* If it's unknown or MMC_CARD, fix the RCA address */
		CmdArgument = 0x00010000;
	} else {
		CmdArgument = CardRCA;
    35e0:	e59f2168 	ldr	r2, [pc, #360]	; 3750 <MCI_Select_Card+0x19c>
	retryCount = 0x20;
	while (retryCount > 0) {
#if 1
		// mthomas:
		/* Send SELECT_CARD command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    35e4:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
    35e8:	e2811923 	add	r1, r1, #573440	; 0x8c000
		CmdArgument = 0; // RCA = 0 -> de-select -> trans to stby
	} else if (MCI_CardType & MMC_CARD) {
		/* If it's unknown or MMC_CARD, fix the RCA address */
		CmdArgument = 0x00010000;
	} else {
		CmdArgument = CardRCA;
    35ec:	e5926000 	ldr	r6, [r2]
	retryCount = 0x20;
	while (retryCount > 0) {
#if 1
		// mthomas:
		/* Send SELECT_CARD command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    35f0:	e5913038 	ldr	r3, [r1, #56]
    35f4:	e3833045 	orr	r3, r3, #69	; 0x45
    35f8:	e5813038 	str	r3, [r1, #56]
		MCI_SendCmd( SELECT_CARD, CmdArgument, EXPECT_SHORT_RESP, 0);
    35fc:	e3a02001 	mov	r2, #1	; 0x1
    3600:	e1a03000 	mov	r3, r0
    3604:	e1a01006 	mov	r1, r6
    3608:	e3a00007 	mov	r0, #7	; 0x7
		respStatus = MCI_GetCmdResp( SELECT_CARD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    360c:	e24b7034 	sub	r7, fp, #52	; 0x34
	while (retryCount > 0) {
#if 1
		// mthomas:
		/* Send SELECT_CARD command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
		MCI_SendCmd( SELECT_CARD, CmdArgument, EXPECT_SHORT_RESP, 0);
    3610:	ebfffdd5 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SELECT_CARD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    3614:	e3a00007 	mov	r0, #7	; 0x7
    3618:	e3a01001 	mov	r1, #1	; 0x1
    361c:	e1a02007 	mov	r2, r7
    3620:	ebfffe01 	bl	2e2c <MCI_GetCmdResp>

		if (CmdArgument) {
    3624:	e3560000 	cmp	r6, #0	; 0x0
    3628:	0a000045 	beq	3744 <MCI_Select_Card+0x190>
	retryCount = 0x20;
	while (retryCount > 0) {
#if 1
		// mthomas:
		/* Send SELECT_CARD command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    362c:	e3a0520e 	mov	r5, #-536870912	; 0xe0000000
    3630:	e2855923 	add	r5, r5, #573440	; 0x8c000
		MCI_SendCmd( SELECT_CARD, CmdArgument, EXPECT_SHORT_RESP, 0);
		respStatus = MCI_GetCmdResp( SELECT_CARD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);

		if (CmdArgument) {
    3634:	e3a04020 	mov	r4, #32	; 0x20
		{ /* Should be in STANDBY state now and ready */
			/* mthomas: READ_FOR_DATA: ready, CURRENT_STATE=3->stby */
			return ( TRUE );
		}
#endif
		for (i = 0; i < 0x20; i++) {
    3638:	e3a08000 	mov	r8, #0	; 0x0
		MCI_SendCmd( SELECT_CARD, CmdArgument, EXPECT_SHORT_RESP, 0);
		respStatus = MCI_GetCmdResp( SELECT_CARD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);

		if (CmdArgument) {
			// select card
			if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0700 )) { /* Should be in STANDBY state now and ready */
    363c:	e3500000 	cmp	r0, #0	; 0x0
    3640:	1a000003 	bne	3654 <MCI_Select_Card+0xa0>
    3644:	e51b3034 	ldr	r3, [fp, #-52]
    3648:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    364c:	e3530c07 	cmp	r3, #1792	; 0x700
    3650:	0a00003b 	beq	3744 <MCI_Select_Card+0x190>
		{ /* Should be in STANDBY state now and ready */
			/* mthomas: READ_FOR_DATA: ready, CURRENT_STATE=3->stby */
			return ( TRUE );
		}
#endif
		for (i = 0; i < 0x20; i++) {
    3654:	e50b8024 	str	r8, [fp, #-36]
    3658:	e51b3024 	ldr	r3, [fp, #-36]
    365c:	e353001f 	cmp	r3, #31	; 0x1f
    3660:	8a000005 	bhi	367c <MCI_Select_Card+0xc8>
    3664:	e51b3024 	ldr	r3, [fp, #-36]
    3668:	e2833001 	add	r3, r3, #1	; 0x1
    366c:	e50b3024 	str	r3, [fp, #-36]
    3670:	e51b2024 	ldr	r2, [fp, #-36]
    3674:	e352001f 	cmp	r2, #31	; 0x1f
    3678:	9afffff9 	bls	3664 <MCI_Select_Card+0xb0>
		CmdArgument = 0x00010000;
	}
#endif

	retryCount = 0x20;
	while (retryCount > 0) {
    367c:	e2544001 	subs	r4, r4, #1	; 0x1
    3680:	0a00002d 	beq	373c <MCI_Select_Card+0x188>
#if 1
		// mthomas:
		/* Send SELECT_CARD command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    3684:	e5953038 	ldr	r3, [r5, #56]
    3688:	e3833045 	orr	r3, r3, #69	; 0x45
    368c:	e5853038 	str	r3, [r5, #56]
		MCI_SendCmd( SELECT_CARD, CmdArgument, EXPECT_SHORT_RESP, 0);
    3690:	e1a01006 	mov	r1, r6
    3694:	e3a00007 	mov	r0, #7	; 0x7
    3698:	e3a02001 	mov	r2, #1	; 0x1
    369c:	e3a03000 	mov	r3, #0	; 0x0
    36a0:	ebfffdb1 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SELECT_CARD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    36a4:	e3a01001 	mov	r1, #1	; 0x1
    36a8:	e1a02007 	mov	r2, r7
    36ac:	e3a00007 	mov	r0, #7	; 0x7
    36b0:	ebfffddd 	bl	2e2c <MCI_GetCmdResp>
    36b4:	eaffffe0 	b	363c <MCI_Select_Card+0x88>
	retryCount = 0x20;
	while (retryCount > 0) {
#if 1
		// mthomas:
		/* Send SELECT_CARD command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    36b8:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    36bc:	e2822923 	add	r2, r2, #573440	; 0x8c000
    36c0:	e5923038 	ldr	r3, [r2, #56]
    36c4:	e3833045 	orr	r3, r3, #69	; 0x45
    36c8:	e5823038 	str	r3, [r2, #56]
		MCI_SendCmd( SELECT_CARD, CmdArgument, EXPECT_SHORT_RESP, 0);
    36cc:	e3a00007 	mov	r0, #7	; 0x7
    36d0:	e1a03001 	mov	r3, r1
    36d4:	e3a02001 	mov	r2, #1	; 0x1
    36d8:	ebfffda3 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SELECT_CARD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    36dc:	e3a00007 	mov	r0, #7	; 0x7
    36e0:	e3a01001 	mov	r1, #1	; 0x1
    36e4:	e24b2034 	sub	r2, fp, #52	; 0x34
    36e8:	ebfffdcf 	bl	2e2c <MCI_GetCmdResp>
    36ec:	e3a00001 	mov	r0, #1	; 0x1
		}mci_debug_printf(" Select_Card: arg:%08x respStatus: %08x resp0:%08x resp1:%08x\n",
				CmdArgument, respStatus, respValue[0], respValue[1]);
		retryCount--;
	} /* while retry */
	return ( FALSE );
}
    36f0:	e24bd020 	sub	sp, fp, #32	; 0x20
    36f4:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
	retryCount = 0x20;
	while (retryCount > 0) {
#if 1
		// mthomas:
		/* Send SELECT_CARD command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    36f8:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    36fc:	e2822923 	add	r2, r2, #573440	; 0x8c000
    3700:	e5923038 	ldr	r3, [r2, #56]
    3704:	e3833045 	orr	r3, r3, #69	; 0x45
    3708:	e5823038 	str	r3, [r2, #56]
		MCI_SendCmd( SELECT_CARD, CmdArgument, EXPECT_SHORT_RESP, 0);
    370c:	e3a00007 	mov	r0, #7	; 0x7
    3710:	e3a01801 	mov	r1, #65536	; 0x10000
    3714:	e3a02001 	mov	r2, #1	; 0x1
    3718:	e3a03000 	mov	r3, #0	; 0x0
		respStatus = MCI_GetCmdResp( SELECT_CARD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    371c:	e24b7034 	sub	r7, fp, #52	; 0x34
	while (retryCount > 0) {
#if 1
		// mthomas:
		/* Send SELECT_CARD command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
		MCI_SendCmd( SELECT_CARD, CmdArgument, EXPECT_SHORT_RESP, 0);
    3720:	ebfffd91 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SELECT_CARD, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    3724:	e3a00007 	mov	r0, #7	; 0x7
    3728:	e3a01001 	mov	r1, #1	; 0x1
    372c:	e1a02007 	mov	r2, r7
    3730:	ebfffdbd 	bl	2e2c <MCI_GetCmdResp>
    3734:	e3a06801 	mov	r6, #65536	; 0x10000
    3738:	eaffffbb 	b	362c <MCI_Select_Card+0x78>
		CmdArgument = 0x00010000;
	}
#endif

	retryCount = 0x20;
	while (retryCount > 0) {
    373c:	e1a00004 	mov	r0, r4
    3740:	eaffffea 	b	36f0 <MCI_Select_Card+0x13c>
    3744:	e3a00001 	mov	r0, #1	; 0x1
    3748:	eaffffe8 	b	36f0 <MCI_Select_Card+0x13c>
    374c:	40000050 	.word	0x40000050
    3750:	4000004c 	.word	0x4000004c

00003754 <MCI_Send_Status>:
 **						is set in the card status register, if timeout, return 
 **						INVALID_RESPONSE 0xFFFFFFFF.
 ** 
 ** modified by mthomas
 ******************************************************************************/
DWORD MCI_Send_Status(void) {
    3754:	e1a0c00d 	mov	ip, sp
    3758:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
	DWORD respValue[4];
	DWORD CmdArgument;

#if 1
	// mthomas:
	if (MCI_CardType & MMC_CARD) {
    375c:	e59f3088 	ldr	r3, [pc, #136]	; 37ec <MCI_Send_Status+0x98>
 **						is set in the card status register, if timeout, return 
 **						INVALID_RESPONSE 0xFFFFFFFF.
 ** 
 ** modified by mthomas
 ******************************************************************************/
DWORD MCI_Send_Status(void) {
    3760:	e24cb004 	sub	fp, ip, #4	; 0x4
    3764:	e24dd010 	sub	sp, sp, #16	; 0x10
	DWORD respValue[4];
	DWORD CmdArgument;

#if 1
	// mthomas:
	if (MCI_CardType & MMC_CARD) {
    3768:	e5932000 	ldr	r2, [r3]
    376c:	e3120001 	tst	r2, #1	; 0x1
		/* If it's unknown or MMC_CARD, fix the RCA address */
		CmdArgument = 0x00010000;
	} else {
		CmdArgument = CardRCA;
    3770:	059f3078 	ldreq	r3, [pc, #120]	; 37f0 <MCI_Send_Status+0x9c>
	/* Note that, since it's called after the block write and read, this timeout 
	 is important based on the clock you set for the data communication. */
	retryCount = 0x2000;
	while (retryCount > 0) {
		/* Send SELECT_CARD command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    3774:	e3a0520e 	mov	r5, #-536870912	; 0xe0000000
	DWORD respValue[4];
	DWORD CmdArgument;

#if 1
	// mthomas:
	if (MCI_CardType & MMC_CARD) {
    3778:	13a06801 	movne	r6, #65536	; 0x10000
		/* If it's unknown or MMC_CARD, fix the RCA address */
		CmdArgument = 0x00010000;
	} else {
		CmdArgument = CardRCA;
    377c:	05936000 	ldreq	r6, [r3]
	/* Note that, since it's called after the block write and read, this timeout 
	 is important based on the clock you set for the data communication. */
	retryCount = 0x2000;
	while (retryCount > 0) {
		/* Send SELECT_CARD command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    3780:	e2855923 	add	r5, r5, #573440	; 0x8c000
	// mthomas:
	if (MCI_CardType & MMC_CARD) {
		/* If it's unknown or MMC_CARD, fix the RCA address */
		CmdArgument = 0x00010000;
	} else {
		CmdArgument = CardRCA;
    3784:	e3a04a02 	mov	r4, #8192	; 0x2000
    3788:	e24b702c 	sub	r7, fp, #44	; 0x2c
    378c:	ea000001 	b	3798 <MCI_Send_Status+0x44>
#endif

	/* Note that, since it's called after the block write and read, this timeout 
	 is important based on the clock you set for the data communication. */
	retryCount = 0x2000;
	while (retryCount > 0) {
    3790:	e2544001 	subs	r4, r4, #1	; 0x1
    3794:	0a000012 	beq	37e4 <MCI_Send_Status+0x90>
		/* Send SELECT_CARD command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    3798:	e5953038 	ldr	r3, [r5, #56]
    379c:	e3833045 	orr	r3, r3, #69	; 0x45
    37a0:	e5853038 	str	r3, [r5, #56]
		MCI_SendCmd( SEND_STATUS, CmdArgument, EXPECT_SHORT_RESP, 0);
    37a4:	e3a0000d 	mov	r0, #13	; 0xd
    37a8:	e1a01006 	mov	r1, r6
    37ac:	e3a02001 	mov	r2, #1	; 0x1
    37b0:	e3a03000 	mov	r3, #0	; 0x0
    37b4:	ebfffd6c 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SEND_STATUS, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    37b8:	e3a0000d 	mov	r0, #13	; 0xd
    37bc:	e3a01001 	mov	r1, #1	; 0x1
    37c0:	e1a02007 	mov	r2, r7
    37c4:	ebfffd98 	bl	2e2c <MCI_GetCmdResp>
		if ( !respStatus && (respValue[0] & (1 << 8))) { /* The ready bit should be set, it should be in either TRAN or RCV state now */
    37c8:	e3500000 	cmp	r0, #0	; 0x0
    37cc:	1affffef 	bne	3790 <MCI_Send_Status+0x3c>
    37d0:	e51b002c 	ldr	r0, [fp, #-44]
    37d4:	e3100c01 	tst	r0, #256	; 0x100
    37d8:	0affffec 	beq	3790 <MCI_Send_Status+0x3c>
			return (respValue[0] );
		}
		retryCount--;
	}
	return ( INVALID_RESPONSE );
}
    37dc:	e24bd01c 	sub	sp, fp, #28	; 0x1c
    37e0:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
#endif

	/* Note that, since it's called after the block write and read, this timeout 
	 is important based on the clock you set for the data communication. */
	retryCount = 0x2000;
	while (retryCount > 0) {
    37e4:	e3e00000 	mvn	r0, #0	; 0x0
    37e8:	eafffffb 	b	37dc <MCI_Send_Status+0x88>
    37ec:	40000050 	.word	0x40000050
    37f0:	4000004c 	.word	0x4000004c

000037f4 <MCI_CheckStatus>:
 **
 ** parameters:			None
 ** Returned value:		TRUE or FALSE
 ** 
 ******************************************************************************/
DWORD MCI_CheckStatus(void) {
    37f4:	e1a0c00d 	mov	ip, sp
    37f8:	e92dd800 	push	{fp, ip, lr, pc}
    37fc:	e24cb004 	sub	fp, ip, #4	; 0x4
	DWORD respValue;

	while ( 1) // mthomas TODO: possible deadlock
	{
		if ( (respValue = MCI_Send_Status()) == INVALID_RESPONSE) {
    3800:	ebffffd3 	bl	3754 <MCI_Send_Status>
    3804:	e3700001 	cmn	r0, #1	; 0x1
		} else {
			/* The only valid state is TRANS per MMC and SD state diagram.
			 RCV state may be seen, but, I have found that it happens
			 only when TX_ACTIVE or RX_ACTIVE occurs before the WRITE_BLOCK and 
			 READ_BLOCK cmds are being sent, which is not a valid sequence. */
			if ( (respValue & (0x0F << 8)) == 0x0900) {
    3808:	e2003c0f 	and	r3, r0, #3840	; 0xf00
DWORD MCI_CheckStatus(void) {
	DWORD respValue;

	while ( 1) // mthomas TODO: possible deadlock
	{
		if ( (respValue = MCI_Send_Status()) == INVALID_RESPONSE) {
    380c:	0a000003 	beq	3820 <MCI_CheckStatus+0x2c>
		} else {
			/* The only valid state is TRANS per MMC and SD state diagram.
			 RCV state may be seen, but, I have found that it happens
			 only when TX_ACTIVE or RX_ACTIVE occurs before the WRITE_BLOCK and 
			 READ_BLOCK cmds are being sent, which is not a valid sequence. */
			if ( (respValue & (0x0F << 8)) == 0x0900) {
    3810:	e3530c09 	cmp	r3, #2304	; 0x900
    3814:	1afffff9 	bne	3800 <MCI_CheckStatus+0xc>
    3818:	e3a00001 	mov	r0, #1	; 0x1
			}
		}
	}

	return ( FALSE );
}
    381c:	e89da800 	ldm	sp, {fp, sp, pc}
DWORD MCI_CheckStatus(void) {
	DWORD respValue;

	while ( 1) // mthomas TODO: possible deadlock
	{
		if ( (respValue = MCI_Send_Status()) == INVALID_RESPONSE) {
    3820:	e2800001 	add	r0, r0, #1	; 0x1
    3824:	e89da800 	ldm	sp, {fp, sp, pc}

00003828 <MCI_Set_BlockLen>:
 ** parameters:			The length of the data block to be written or read.
 ** Returned value:		true or false, return TRUE if ready bit is set, and it's
 **						in TRANS state.
 ** 
 ******************************************************************************/
DWORD MCI_Set_BlockLen(DWORD blockLength) {
    3828:	e1a0c00d 	mov	ip, sp
    382c:	e92dd9f0 	push	{r4, r5, r6, r7, r8, fp, ip, lr, pc}
    3830:	e24cb004 	sub	fp, ip, #4	; 0x4
    3834:	e24dd014 	sub	sp, sp, #20	; 0x14
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
		/* Send SET_BLOCK_LEN command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    3838:	e3a0520e 	mov	r5, #-536870912	; 0xe0000000
 ** parameters:			The length of the data block to be written or read.
 ** Returned value:		true or false, return TRUE if ready bit is set, and it's
 **						in TRANS state.
 ** 
 ******************************************************************************/
DWORD MCI_Set_BlockLen(DWORD blockLength) {
    383c:	e1a06000 	mov	r6, r0
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
		/* Send SET_BLOCK_LEN command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    3840:	e2855923 	add	r5, r5, #573440	; 0x8c000
 ** parameters:			The length of the data block to be written or read.
 ** Returned value:		true or false, return TRUE if ready bit is set, and it's
 **						in TRANS state.
 ** 
 ******************************************************************************/
DWORD MCI_Set_BlockLen(DWORD blockLength) {
    3844:	e3a04020 	mov	r4, #32	; 0x20
    3848:	e24b7034 	sub	r7, fp, #52	; 0x34

	retryCount = 0x20;
	while (retryCount > 0) {
		/* Send SET_BLOCK_LEN command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
		MCI_SendCmd( SET_BLOCK_LEN, blockLength, EXPECT_SHORT_RESP, 0);
    384c:	e3a08000 	mov	r8, #0	; 0x0
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
		/* Send SET_BLOCK_LEN command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
    3850:	e5953038 	ldr	r3, [r5, #56]
    3854:	e3833045 	orr	r3, r3, #69	; 0x45
    3858:	e5853038 	str	r3, [r5, #56]
		MCI_SendCmd( SET_BLOCK_LEN, blockLength, EXPECT_SHORT_RESP, 0);
    385c:	e3a00010 	mov	r0, #16	; 0x10
    3860:	e1a01006 	mov	r1, r6
    3864:	e3a02001 	mov	r2, #1	; 0x1
    3868:	e3a03000 	mov	r3, #0	; 0x0
    386c:	ebfffd3e 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SET_BLOCK_LEN, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    3870:	e3a00010 	mov	r0, #16	; 0x10
    3874:	e3a01001 	mov	r1, #1	; 0x1
    3878:	e1a02007 	mov	r2, r7
    387c:	ebfffd6a 	bl	2e2c <MCI_GetCmdResp>
		/* bit 9 through 12 should be in transfer state now. bit 8 is ready. */
		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
    3880:	e3500000 	cmp	r0, #0	; 0x0
    3884:	1a000003 	bne	3898 <MCI_Set_BlockLen+0x70>
    3888:	e51b3034 	ldr	r3, [fp, #-52]
    388c:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    3890:	e3530c09 	cmp	r3, #2304	; 0x900
    3894:	0a00000e 	beq	38d4 <MCI_Set_BlockLen+0xac>
			return ( TRUE );
		}
		for (i = 0; i < 0x20; i++) {
    3898:	e50b8024 	str	r8, [fp, #-36]
    389c:	e51b3024 	ldr	r3, [fp, #-36]
    38a0:	e353001f 	cmp	r3, #31	; 0x1f
    38a4:	8a000005 	bhi	38c0 <MCI_Set_BlockLen+0x98>
    38a8:	e51b3024 	ldr	r3, [fp, #-36]
    38ac:	e2833001 	add	r3, r3, #1	; 0x1
    38b0:	e50b3024 	str	r3, [fp, #-36]
    38b4:	e51b2024 	ldr	r2, [fp, #-36]
    38b8:	e352001f 	cmp	r2, #31	; 0x1f
    38bc:	9afffff9 	bls	38a8 <MCI_Set_BlockLen+0x80>
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
    38c0:	e2544001 	subs	r4, r4, #1	; 0x1
    38c4:	1affffe1 	bne	3850 <MCI_Set_BlockLen+0x28>
    38c8:	e1a00004 	mov	r0, r4
			;
		}
		retryCount--;
	}
	return ( FALSE );
}
    38cc:	e24bd020 	sub	sp, fp, #32	; 0x20
    38d0:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
		/* Send SET_BLOCK_LEN command before read and write */
		MCI_CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
		MCI_SendCmd( SET_BLOCK_LEN, blockLength, EXPECT_SHORT_RESP, 0);
		respStatus = MCI_GetCmdResp( SET_BLOCK_LEN, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
		/* bit 9 through 12 should be in transfer state now. bit 8 is ready. */
		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
    38d4:	e2800001 	add	r0, r0, #1	; 0x1
    38d8:	eafffffb 	b	38cc <MCI_Set_BlockLen+0xa4>

000038dc <MCI_Send_ACMD_Bus_Width>:
 ** parameters:			Bus width value, 1-bit is 0, 4-bit is 10
 ** Returned value:		true or false, true if the card is still in the 
 **						TRANS state after the cmd.
 ** 
 ******************************************************************************/
DWORD MCI_Send_ACMD_Bus_Width(DWORD buswidth) {
    38dc:	e1a0c00d 	mov	ip, sp
    38e0:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
    38e4:	e24cb004 	sub	fp, ip, #4	; 0x4
    38e8:	e24dd014 	sub	sp, sp, #20	; 0x14
    38ec:	e1a05000 	mov	r5, r0
    38f0:	e3a04020 	mov	r4, #32	; 0x20
    38f4:	e24b7030 	sub	r7, fp, #48	; 0x30
	while (retryCount > 0) {
		if (MCI_Send_ACMD() == FALSE) {
			continue;
		}
		/* Send ACMD6 command to set the bus width */
		MCI_SendCmd( SET_ACMD_BUS_WIDTH, buswidth, EXPECT_SHORT_RESP, 0);
    38f8:	e3a06000 	mov	r6, #0	; 0x0
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20; /* reset retry counter */
	while (retryCount > 0) {
		if (MCI_Send_ACMD() == FALSE) {
    38fc:	ebfffdb4 	bl	2fd4 <MCI_Send_ACMD>
    3900:	e3500000 	cmp	r0, #0	; 0x0
    3904:	0afffffc 	beq	38fc <MCI_Send_ACMD_Bus_Width+0x20>
			continue;
		}
		/* Send ACMD6 command to set the bus width */
		MCI_SendCmd( SET_ACMD_BUS_WIDTH, buswidth, EXPECT_SHORT_RESP, 0);
    3908:	e3a00006 	mov	r0, #6	; 0x6
    390c:	e1a01005 	mov	r1, r5
    3910:	e3a02001 	mov	r2, #1	; 0x1
    3914:	e3a03000 	mov	r3, #0	; 0x0
    3918:	ebfffd13 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( SET_ACMD_BUS_WIDTH, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    391c:	e3a00006 	mov	r0, #6	; 0x6
    3920:	e3a01001 	mov	r1, #1	; 0x1
    3924:	e1a02007 	mov	r2, r7
    3928:	ebfffd3f 	bl	2e2c <MCI_GetCmdResp>
		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
    392c:	e3500000 	cmp	r0, #0	; 0x0
    3930:	1a000003 	bne	3944 <MCI_Send_ACMD_Bus_Width+0x68>
    3934:	e51b3030 	ldr	r3, [fp, #-48]
    3938:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    393c:	e3530c09 	cmp	r3, #2304	; 0x900
    3940:	0a00000e 	beq	3980 <MCI_Send_ACMD_Bus_Width+0xa4>
			return ( TRUE ); /* response is back and correct. */
		}
		for (i = 0; i < 0x20; i++) {
    3944:	e50b6020 	str	r6, [fp, #-32]
    3948:	e51b3020 	ldr	r3, [fp, #-32]
    394c:	e353001f 	cmp	r3, #31	; 0x1f
    3950:	8a000005 	bhi	396c <MCI_Send_ACMD_Bus_Width+0x90>
    3954:	e51b3020 	ldr	r3, [fp, #-32]
    3958:	e2833001 	add	r3, r3, #1	; 0x1
    395c:	e50b3020 	str	r3, [fp, #-32]
    3960:	e51b2020 	ldr	r2, [fp, #-32]
    3964:	e352001f 	cmp	r2, #31	; 0x1f
    3968:	9afffff9 	bls	3954 <MCI_Send_ACMD_Bus_Width+0x78>
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20; /* reset retry counter */
	while (retryCount > 0) {
    396c:	e2544001 	subs	r4, r4, #1	; 0x1
    3970:	1affffe1 	bne	38fc <MCI_Send_ACMD_Bus_Width+0x20>
    3974:	e1a00004 	mov	r0, r4
			;
		}
		retryCount--;
	}
	return ( FALSE );
}
    3978:	e24bd01c 	sub	sp, fp, #28	; 0x1c
    397c:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
			continue;
		}
		/* Send ACMD6 command to set the bus width */
		MCI_SendCmd( SET_ACMD_BUS_WIDTH, buswidth, EXPECT_SHORT_RESP, 0);
		respStatus = MCI_GetCmdResp( SET_ACMD_BUS_WIDTH, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
    3980:	e2800001 	add	r0, r0, #1	; 0x1
    3984:	eafffffb 	b	3978 <MCI_Send_ACMD_Bus_Width+0x9c>

00003988 <SD_Set_BusWidth>:
 ** Returned value:		TRUE or FALSE
 **
 ** modified by Martin Thomas: do not set 4 bit if 
 ** parameter is SD_1_BIT
 ******************************************************************************/
DWORD SD_Set_BusWidth(DWORD width) {
    3988:	e1a0c00d 	mov	ip, sp
    398c:	e92dd800 	push	{fp, ip, lr, pc}
	volatile DWORD i; // mthomas - volatile

	for (i = 0; i < 0x10; i++)
    3990:	e3a03000 	mov	r3, #0	; 0x0
 ** Returned value:		TRUE or FALSE
 **
 ** modified by Martin Thomas: do not set 4 bit if 
 ** parameter is SD_1_BIT
 ******************************************************************************/
DWORD SD_Set_BusWidth(DWORD width) {
    3994:	e24cb004 	sub	fp, ip, #4	; 0x4
    3998:	e24dd004 	sub	sp, sp, #4	; 0x4
	volatile DWORD i; // mthomas - volatile

	for (i = 0; i < 0x10; i++)
    399c:	e50b3010 	str	r3, [fp, #-16]
    39a0:	e51b2010 	ldr	r2, [fp, #-16]
    39a4:	e352000f 	cmp	r2, #15	; 0xf
    39a8:	8a000005 	bhi	39c4 <SD_Set_BusWidth+0x3c>
    39ac:	e51b3010 	ldr	r3, [fp, #-16]
    39b0:	e2833001 	add	r3, r3, #1	; 0x1
    39b4:	e50b3010 	str	r3, [fp, #-16]
    39b8:	e51b2010 	ldr	r2, [fp, #-16]
    39bc:	e352000f 	cmp	r2, #15	; 0xf
    39c0:	9afffff9 	bls	39ac <SD_Set_BusWidth+0x24>
		; /* delay 3MCLK + 2PCLK  */

	if (width == SD_1_BIT) {
    39c4:	e3500000 	cmp	r0, #0	; 0x0
    39c8:	1a000006 	bne	39e8 <SD_Set_BusWidth+0x60>
		MCI_CLOCK &= ~(1 << 11);
    39cc:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    39d0:	e2822923 	add	r2, r2, #573440	; 0x8c000
    39d4:	e5923004 	ldr	r3, [r2, #4]
    39d8:	e3c33b02 	bic	r3, r3, #2048	; 0x800
    39dc:	e5823004 	str	r3, [r2, #4]
    39e0:	e2800001 	add	r0, r0, #1	; 0x1
    39e4:	e89da808 	ldm	sp, {r3, fp, sp, pc}
		/* 1 bit bus */
	} else if (width == SD_4_BIT) {
    39e8:	e3500001 	cmp	r0, #1	; 0x1
    39ec:	0a000006 	beq	3a0c <SD_Set_BusWidth+0x84>
			mci_debug_printf("setting 4bit width failed\n");
			return ( FALSE );
		}mci_debug_printf("setting 4bit width success\n");
	} else {
		// mthomas - added default
		MCI_CLOCK &= ~(1 << 11);
    39f0:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    39f4:	e2822923 	add	r2, r2, #573440	; 0x8c000
    39f8:	e5923004 	ldr	r3, [r2, #4]
    39fc:	e3c33b02 	bic	r3, r3, #2048	; 0x800
    3a00:	e5823004 	str	r3, [r2, #4]
    3a04:	e3a00001 	mov	r0, #1	; 0x1
		return( FALSE );
	}
#endif

	return ( TRUE );
}
    3a08:	e89da808 	ldm	sp, {r3, fp, sp, pc}

	if (width == SD_1_BIT) {
		MCI_CLOCK &= ~(1 << 11);
		/* 1 bit bus */
	} else if (width == SD_4_BIT) {
		MCI_CLOCK |= (1 << 11);
    3a0c:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    3a10:	e2822923 	add	r2, r2, #573440	; 0x8c000
    3a14:	e5923004 	ldr	r3, [r2, #4]
    3a18:	e3833b02 	orr	r3, r3, #2048	; 0x800
    3a1c:	e5823004 	str	r3, [r2, #4]
		/* 4 bit bus */
		// mthomas - moved this here from below
		if (MCI_Send_ACMD_Bus_Width( BUS_WIDTH_4BITS) == FALSE) {
    3a20:	e2800009 	add	r0, r0, #9	; 0x9
    3a24:	ebffffac 	bl	38dc <MCI_Send_ACMD_Bus_Width>
    3a28:	e2500000 	subs	r0, r0, #0	; 0x0
    3a2c:	13a00001 	movne	r0, #1	; 0x1
    3a30:	e89da808 	ldm	sp, {r3, fp, sp, pc}

00003a34 <MCI_Send_Stop>:
 ** parameters:			None
 ** Returned value:		true or false, true if, at least, the card status
 **						shows ready bit is set.
 ** 
 ******************************************************************************/
DWORD MCI_Send_Stop(void) {
    3a34:	e1a0c00d 	mov	ip, sp
    3a38:	e92dd9f0 	push	{r4, r5, r6, r7, r8, fp, ip, lr, pc}
    3a3c:	e24cb004 	sub	fp, ip, #4	; 0x4
    3a40:	e24dd014 	sub	sp, sp, #20	; 0x14
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    3a44:	e3a0620e 	mov	r6, #-536870912	; 0xe0000000
    3a48:	e3a05e7f 	mov	r5, #2032	; 0x7f0
    3a4c:	e2866923 	add	r6, r6, #573440	; 0x8c000
    3a50:	e285500f 	add	r5, r5, #15	; 0xf
 ** parameters:			None
 ** Returned value:		true or false, true if, at least, the card status
 **						shows ready bit is set.
 ** 
 ******************************************************************************/
DWORD MCI_Send_Stop(void) {
    3a54:	e3a04020 	mov	r4, #32	; 0x20
    3a58:	e24b7034 	sub	r7, fp, #52	; 0x34
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
		MCI_SendCmd( STOP_TRANSMISSION, 0x00000000, EXPECT_SHORT_RESP, 0);
    3a5c:	e3a08000 	mov	r8, #0	; 0x0
    3a60:	e3a01000 	mov	r1, #0	; 0x0
    3a64:	e1a03001 	mov	r3, r1
    3a68:	e3a0000c 	mov	r0, #12	; 0xc
    3a6c:	e3a02001 	mov	r2, #1	; 0x1
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    3a70:	e5865038 	str	r5, [r6, #56]
		MCI_SendCmd( STOP_TRANSMISSION, 0x00000000, EXPECT_SHORT_RESP, 0);
    3a74:	ebfffcbc 	bl	2d6c <MCI_SendCmd>
		respStatus = MCI_GetCmdResp( STOP_TRANSMISSION, EXPECT_SHORT_RESP, (DWORD *)respValue);
    3a78:	e3a0000c 	mov	r0, #12	; 0xc
    3a7c:	e3a01001 	mov	r1, #1	; 0x1
    3a80:	e1a02007 	mov	r2, r7
    3a84:	ebfffce8 	bl	2e2c <MCI_GetCmdResp>
		/* ready bit, bit 8, should be set in the card status register */
		if ( !respStatus && (respValue[0] & (1 << 8))) {
    3a88:	e3500000 	cmp	r0, #0	; 0x0
    3a8c:	1a000002 	bne	3a9c <MCI_Send_Stop+0x68>
    3a90:	e51b3034 	ldr	r3, [fp, #-52]
    3a94:	e3130c01 	tst	r3, #256	; 0x100
    3a98:	1a00000e 	bne	3ad8 <MCI_Send_Stop+0xa4>
			return ( TRUE );
		}
		for (i = 0; i < 0x20; i++) {
    3a9c:	e50b8024 	str	r8, [fp, #-36]
    3aa0:	e51b3024 	ldr	r3, [fp, #-36]
    3aa4:	e353001f 	cmp	r3, #31	; 0x1f
    3aa8:	8a000005 	bhi	3ac4 <MCI_Send_Stop+0x90>
    3aac:	e51b3024 	ldr	r3, [fp, #-36]
    3ab0:	e2833001 	add	r3, r3, #1	; 0x1
    3ab4:	e50b3024 	str	r3, [fp, #-36]
    3ab8:	e51b2024 	ldr	r2, [fp, #-36]
    3abc:	e352001f 	cmp	r2, #31	; 0x1f
    3ac0:	9afffff9 	bls	3aac <MCI_Send_Stop+0x78>
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
    3ac4:	e2544001 	subs	r4, r4, #1	; 0x1
    3ac8:	1affffe4 	bne	3a60 <MCI_Send_Stop+0x2c>
    3acc:	e1a00004 	mov	r0, r4
			;
		}
		retryCount--;
	}
	return ( FALSE );
}
    3ad0:	e24bd020 	sub	sp, fp, #32	; 0x20
    3ad4:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
		MCI_SendCmd( STOP_TRANSMISSION, 0x00000000, EXPECT_SHORT_RESP, 0);
		respStatus = MCI_GetCmdResp( STOP_TRANSMISSION, EXPECT_SHORT_RESP, (DWORD *)respValue);
		/* ready bit, bit 8, should be set in the card status register */
		if ( !respStatus && (respValue[0] & (1 << 8))) {
    3ad8:	e2800001 	add	r0, r0, #1	; 0x1
    3adc:	eafffffb 	b	3ad0 <MCI_Send_Stop+0x9c>

00003ae0 <MCI_Power_Off>:
 ** parameters:			none
 ** Returned value:		none
 ** 
 ** Added by Martin Thomas - but it does not work on MCB2300
 ******************************************************************************/
void MCI_Power_Off(void) {
    3ae0:	e1a0c00d 	mov	ip, sp
    3ae4:	e92dd800 	push	{fp, ip, lr, pc}
	volatile DWORD i;

	// SCS |= (1<<8);
	MCI_POWER = 0;
    3ae8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
 ** parameters:			none
 ** Returned value:		none
 ** 
 ** Added by Martin Thomas - but it does not work on MCB2300
 ******************************************************************************/
void MCI_Power_Off(void) {
    3aec:	e24cb004 	sub	fp, ip, #4	; 0x4
	volatile DWORD i;

	// SCS |= (1<<8);
	MCI_POWER = 0;
    3af0:	e2833923 	add	r3, r3, #573440	; 0x8c000
    3af4:	e3a02000 	mov	r2, #0	; 0x0
 ** parameters:			none
 ** Returned value:		none
 ** 
 ** Added by Martin Thomas - but it does not work on MCB2300
 ******************************************************************************/
void MCI_Power_Off(void) {
    3af8:	e24dd004 	sub	sp, sp, #4	; 0x4
	volatile DWORD i;

	// SCS |= (1<<8);
	MCI_POWER = 0;
    3afc:	e5832000 	str	r2, [r3]
	for (i = 0; i < 0x100; i++)
    3b00:	e50b2010 	str	r2, [fp, #-16]
    3b04:	e51b3010 	ldr	r3, [fp, #-16]
    3b08:	e35300ff 	cmp	r3, #255	; 0xff
    3b0c:	889da808 	ldmhi	sp, {r3, fp, sp, pc}
    3b10:	e51b3010 	ldr	r3, [fp, #-16]
    3b14:	e2833001 	add	r3, r3, #1	; 0x1
    3b18:	e50b3010 	str	r3, [fp, #-16]
    3b1c:	e51b2010 	ldr	r2, [fp, #-16]
    3b20:	e35200ff 	cmp	r2, #255	; 0xff
    3b24:	9afffff9 	bls	3b10 <MCI_Power_Off+0x30>
    3b28:	e89da808 	ldm	sp, {r3, fp, sp, pc}

00003b2c <MCI_Sd_Status>:
 ** parameters:			none
 ** Returned value:		true or false 
 ** 
 ** Added by Martin Thomas
 ******************************************************************************/
DWORD MCI_Sd_Status(void) {
    3b2c:	e1a0c00d 	mov	ip, sp
    3b30:	e92ddff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
	DWORD respStatus;
	DWORD respValue[4];
	DWORD stuffbits = 0x00000000;
	DWORD DataCtrl = 0;

	if ( (MCI_CardType == CARD_UNKNOWN ) || (MCI_CardType == MMC_CARD )) {
    3b34:	e59f21c8 	ldr	r2, [pc, #456]	; 3d04 <MCI_Sd_Status+0x1d8>
 ** parameters:			none
 ** Returned value:		true or false 
 ** 
 ** Added by Martin Thomas
 ******************************************************************************/
DWORD MCI_Sd_Status(void) {
    3b38:	e24cb004 	sub	fp, ip, #4	; 0x4
    3b3c:	e24dd014 	sub	sp, sp, #20	; 0x14
	DWORD respStatus;
	DWORD respValue[4];
	DWORD stuffbits = 0x00000000;
	DWORD DataCtrl = 0;

	if ( (MCI_CardType == CARD_UNKNOWN ) || (MCI_CardType == MMC_CARD )) {
    3b40:	e5923000 	ldr	r3, [r2]
    3b44:	e3530000 	cmp	r3, #0	; 0x0
    3b48:	0a000040 	beq	3c50 <MCI_Sd_Status+0x124>
    3b4c:	e5923000 	ldr	r3, [r2]
    3b50:	e3530001 	cmp	r3, #1	; 0x1
    3b54:	0a00003d 	beq	3c50 <MCI_Sd_Status+0x124>
		return ( FALSE ); // unsupported
	}

	MCI_CLEAR = 0x7FF;
    3b58:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    3b5c:	e3a03e7f 	mov	r3, #2032	; 0x7f0
    3b60:	e2822923 	add	r2, r2, #573440	; 0x8c000
    3b64:	e283300f 	add	r3, r3, #15	; 0xf
	MCI_DATA_CTRL = 0;
    3b68:	e3a01000 	mov	r1, #0	; 0x0

	if ( (MCI_CardType == CARD_UNKNOWN ) || (MCI_CardType == MMC_CARD )) {
		return ( FALSE ); // unsupported
	}

	MCI_CLEAR = 0x7FF;
    3b6c:	e5823038 	str	r3, [r2, #56]
	MCI_DATA_CTRL = 0;
    3b70:	e582102c 	str	r1, [r2, #44]
	for (i = 0; i < 0x10; i++) {
    3b74:	e50b102c 	str	r1, [fp, #-44]
    3b78:	e51b302c 	ldr	r3, [fp, #-44]
    3b7c:	e353000f 	cmp	r3, #15	; 0xf
    3b80:	8a000005 	bhi	3b9c <MCI_Sd_Status+0x70>
    3b84:	e51b302c 	ldr	r3, [fp, #-44]
    3b88:	e2833001 	add	r3, r3, #1	; 0x1
    3b8c:	e50b302c 	str	r3, [fp, #-44]
    3b90:	e51b202c 	ldr	r2, [fp, #-44]
    3b94:	e352000f 	cmp	r2, #15	; 0xf
    3b98:	9afffff9 	bls	3b84 <MCI_Sd_Status+0x58>
		;
	}

	/* Below status check is redundant, but ensure card is in TRANS state
	 before writing and reading to from the card. */
	if (MCI_CheckStatus() != TRUE) {
    3b9c:	ebffff14 	bl	37f4 <MCI_CheckStatus>
    3ba0:	e3500001 	cmp	r0, #1	; 0x1
    3ba4:	1a000053 	bne	3cf8 <MCI_Sd_Status+0x1cc>
/*****************************************************************/

void MCI_RXEnable(void) {
	//myprintf("inside MCI_RXEnable");
#if MCI_DMA_ENABLED
	MCI_MASK0 |= ((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));
    3ba8:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
    3bac:	e2811923 	add	r1, r1, #573440	; 0x8c000
    3bb0:	e591303c 	ldr	r3, [r1, #60]
    3bb4:	e3833e72 	orr	r3, r3, #1824	; 0x720
    3bb8:	e383300a 	orr	r3, r3, #10	; 0xa
    3bbc:	e581303c 	str	r3, [r1, #60]
	/* Enable RX interrupts only */
	MCI_MASK1 |= ((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));
    3bc0:	e5912040 	ldr	r2, [r1, #64]
    3bc4:	e3822e72 	orr	r2, r2, #1824	; 0x720
    3bc8:	e382200a 	orr	r2, r2, #10	; 0xa
    3bcc:	e5812040 	str	r2, [r1, #64]
		return ( FALSE );
	}

	MCI_RXEnable();

	MCI_DATA_TMR = DATA_TIMER_VALUE;
    3bd0:	e3a03802 	mov	r3, #131072	; 0x20000
	MCI_DATA_LEN = BLOCK_LENGTH;
    3bd4:	e3a02c02 	mov	r2, #512	; 0x200
		return ( FALSE );
	}

	MCI_RXEnable();

	MCI_DATA_TMR = DATA_TIMER_VALUE;
    3bd8:	e5813024 	str	r3, [r1, #36]
	MCI_DATA_LEN = BLOCK_LENGTH;
    3bdc:	e5812028 	str	r2, [r1, #40]
	// MCI_DATA_LEN = SD_BLOCK_LENGTH;
	MCI_Block_End_Flag = 1;
    3be0:	e59f3120 	ldr	r3, [pc, #288]	; 3d08 <MCI_Sd_Status+0x1dc>
	SDStatRead = 1;
    3be4:	e59f2120 	ldr	r2, [pc, #288]	; 3d0c <MCI_Sd_Status+0x1e0>
	MCI_RXEnable();

	MCI_DATA_TMR = DATA_TIMER_VALUE;
	MCI_DATA_LEN = BLOCK_LENGTH;
	// MCI_DATA_LEN = SD_BLOCK_LENGTH;
	MCI_Block_End_Flag = 1;
    3be8:	e5830000 	str	r0, [r3]
	SDStatRead = 1;

	// "MCI_Send_SD_STATUS":
	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    3bec:	e3a07e7f 	mov	r7, #2032	; 0x7f0

	MCI_DATA_TMR = DATA_TIMER_VALUE;
	MCI_DATA_LEN = BLOCK_LENGTH;
	// MCI_DATA_LEN = SD_BLOCK_LENGTH;
	MCI_Block_End_Flag = 1;
	SDStatRead = 1;
    3bf0:	e5820000 	str	r0, [r2]

	// "MCI_Send_SD_STATUS":
	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    3bf4:	e1a0a001 	mov	sl, r1
    3bf8:	e287700f 	add	r7, r7, #15	; 0xf

	MCI_DATA_TMR = DATA_TIMER_VALUE;
	MCI_DATA_LEN = BLOCK_LENGTH;
	// MCI_DATA_LEN = SD_BLOCK_LENGTH;
	MCI_Block_End_Flag = 1;
	SDStatRead = 1;
    3bfc:	e3a06020 	mov	r6, #32	; 0x20
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
		// prepare for ACMD (with CMD55)
		if (MCI_Send_ACMD() == TRUE) {
			// Send ACMD13
			MCI_SendCmd( SD_STATUS, stuffbits, EXPECT_SHORT_RESP, 0);
    3c00:	e3a08000 	mov	r8, #0	; 0x0
	SDStatRead = 1;

	// "MCI_Send_SD_STATUS":
	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    3c04:	e58a7038 	str	r7, [sl, #56]
		// prepare for ACMD (with CMD55)
		if (MCI_Send_ACMD() == TRUE) {
    3c08:	ebfffcf1 	bl	2fd4 <MCI_Send_ACMD>
	SDStatRead = 1;

	// "MCI_Send_SD_STATUS":
	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    3c0c:	e3a0520e 	mov	r5, #-536870912	; 0xe0000000
		// prepare for ACMD (with CMD55)
		if (MCI_Send_ACMD() == TRUE) {
    3c10:	e3500001 	cmp	r0, #1	; 0x1
    3c14:	e1a04000 	mov	r4, r0
	SDStatRead = 1;

	// "MCI_Send_SD_STATUS":
	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    3c18:	e2855923 	add	r5, r5, #573440	; 0x8c000
		// prepare for ACMD (with CMD55)
		if (MCI_Send_ACMD() == TRUE) {
    3c1c:	0a00000e 	beq	3c5c <MCI_Sd_Status+0x130>
			/* it should be in the transfer state, bit 9~12 is 0x0100 and bit 8 is 1 */
			if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
				break; /* ready and in TRAN state */
			}
		}
		for (i = 0; i < 0x20; i++) {
    3c20:	e50b802c 	str	r8, [fp, #-44]
    3c24:	e51b302c 	ldr	r3, [fp, #-44]
    3c28:	e353001f 	cmp	r3, #31	; 0x1f
    3c2c:	8a000005 	bhi	3c48 <MCI_Sd_Status+0x11c>
    3c30:	e51b302c 	ldr	r3, [fp, #-44]
    3c34:	e2833001 	add	r3, r3, #1	; 0x1
    3c38:	e50b302c 	str	r3, [fp, #-44]
    3c3c:	e51b202c 	ldr	r2, [fp, #-44]
    3c40:	e352001f 	cmp	r2, #31	; 0x1f
    3c44:	9afffff9 	bls	3c30 <MCI_Sd_Status+0x104>
	MCI_Block_End_Flag = 1;
	SDStatRead = 1;

	// "MCI_Send_SD_STATUS":
	retryCount = 0x20;
	while (retryCount > 0) {
    3c48:	e2566001 	subs	r6, r6, #1	; 0x1
    3c4c:	1affffec 	bne	3c04 <MCI_Sd_Status+0xd8>
	/* Read, enable, block transfer, and data length */
	DataCtrl |= ((1 << 0) | (1 << 1) | ( SD_STATUS_BLOCK_LEN << 4 ));
#endif
	MCI_DATA_CTRL = DataCtrl;
	// mci_debug_printf("MCI_SD_Status: DATA_CTRL set\n");
	for (i = 0; i < 0x10; i++) {
    3c50:	e3a00000 	mov	r0, #0	; 0x0
		;
	}

	return ( TRUE );
}
    3c54:	e24bd028 	sub	sp, fp, #40	; 0x28
    3c58:	e89daff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
		// prepare for ACMD (with CMD55)
		if (MCI_Send_ACMD() == TRUE) {
			// Send ACMD13
			MCI_SendCmd( SD_STATUS, stuffbits, EXPECT_SHORT_RESP, 0);
    3c5c:	e3a01000 	mov	r1, #0	; 0x0
    3c60:	e1a03001 	mov	r3, r1
    3c64:	e3a0000d 	mov	r0, #13	; 0xd
    3c68:	e1a02004 	mov	r2, r4
    3c6c:	ebfffc3e 	bl	2d6c <MCI_SendCmd>
			respStatus = MCI_GetCmdResp( SD_STATUS, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    3c70:	e3a0000d 	mov	r0, #13	; 0xd
    3c74:	e1a01004 	mov	r1, r4
    3c78:	e24b203c 	sub	r2, fp, #60	; 0x3c
    3c7c:	ebfffc6a 	bl	2e2c <MCI_GetCmdResp>
			/* it should be in the transfer state, bit 9~12 is 0x0100 and bit 8 is 1 */
			if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
    3c80:	e2509000 	subs	r9, r0, #0	; 0x0
    3c84:	1affffe5 	bne	3c20 <MCI_Sd_Status+0xf4>
    3c88:	e51b303c 	ldr	r3, [fp, #-60]
    3c8c:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    3c90:	e3530c09 	cmp	r3, #2304	; 0x900
    3c94:	1affffe1 	bne	3c20 <MCI_Sd_Status+0xf4>
		mci_debug_printf("Sd_Status: ACMD13 failed\n");
		return ( FALSE ); // error sending ACMD13 or state not trans
	}

#if MCI_DMA_ENABLED
	DMA_Move( 1, P2M);
    3c98:	e3a01002 	mov	r1, #2	; 0x2
    3c9c:	e1a00004 	mov	r0, r4
    3ca0:	eb000238 	bl	4588 <DMA_Move>
	GPDMA_CH1_CFG |= 0x10001 | (0x04 << 1) | (0x00 << 6) | (0x06 << 11);
    3ca4:	e3a03c4f 	mov	r3, #20224	; 0x4f00
    3ca8:	e28330ff 	add	r3, r3, #255	; 0xff
    3cac:	e1833a83 	orr	r3, r3, r3, lsl #21
    3cb0:	e5132ecf 	ldr	r2, [r3, #-3791]
    3cb4:	e3822a13 	orr	r2, r2, #77824	; 0x13000
    3cb8:	e3822009 	orr	r2, r2, #9	; 0x9
	DataCtrl |= ((1 << 0) | (1 << 1) | (1 << 3) | (SD_STATUS_BLOCK_LEN << 4));
#else
	/* Read, enable, block transfer, and data length */
	DataCtrl |= ((1 << 0) | (1 << 1) | ( SD_STATUS_BLOCK_LEN << 4 ));
#endif
	MCI_DATA_CTRL = DataCtrl;
    3cbc:	e3a0106b 	mov	r1, #107	; 0x6b
		return ( FALSE ); // error sending ACMD13 or state not trans
	}

#if MCI_DMA_ENABLED
	DMA_Move( 1, P2M);
	GPDMA_CH1_CFG |= 0x10001 | (0x04 << 1) | (0x00 << 6) | (0x06 << 11);
    3cc0:	e5032ecf 	str	r2, [r3, #-3791]
	DataCtrl |= ((1 << 0) | (1 << 1) | (1 << 3) | (SD_STATUS_BLOCK_LEN << 4));
#else
	/* Read, enable, block transfer, and data length */
	DataCtrl |= ((1 << 0) | (1 << 1) | ( SD_STATUS_BLOCK_LEN << 4 ));
#endif
	MCI_DATA_CTRL = DataCtrl;
    3cc4:	e585102c 	str	r1, [r5, #44]
	// mci_debug_printf("MCI_SD_Status: DATA_CTRL set\n");
	for (i = 0; i < 0x10; i++) {
    3cc8:	e50b902c 	str	r9, [fp, #-44]
    3ccc:	e51b302c 	ldr	r3, [fp, #-44]
    3cd0:	e353000f 	cmp	r3, #15	; 0xf
    3cd4:	8a000005 	bhi	3cf0 <MCI_Sd_Status+0x1c4>
    3cd8:	e51b302c 	ldr	r3, [fp, #-44]
    3cdc:	e2833001 	add	r3, r3, #1	; 0x1
    3ce0:	e50b302c 	str	r3, [fp, #-44]
    3ce4:	e51b202c 	ldr	r2, [fp, #-44]
    3ce8:	e352000f 	cmp	r2, #15	; 0xf
    3cec:	9afffff9 	bls	3cd8 <MCI_Sd_Status+0x1ac>
    3cf0:	e3a00001 	mov	r0, #1	; 0x1
    3cf4:	eaffffd6 	b	3c54 <MCI_Sd_Status+0x128>
	}

	/* Below status check is redundant, but ensure card is in TRANS state
	 before writing and reading to from the card. */
	if (MCI_CheckStatus() != TRUE) {
		MCI_Send_Stop();mci_debug_printf("Sd_Status: Not in trans-state\n");
    3cf8:	ebffff4d 	bl	3a34 <MCI_Send_Stop>
    3cfc:	e3a00000 	mov	r0, #0	; 0x0
    3d00:	eaffffd3 	b	3c54 <MCI_Sd_Status+0x128>
    3d04:	40000050 	.word	0x40000050
    3d08:	40000770 	.word	0x40000770
    3d0c:	40000780 	.word	0x40000780

00003d10 <MCI_Read_Block>:
 ** parameters:			block number
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 **
 ******************************************************************************/
DWORD MCI_Read_Block(DWORD blockNum) {
    3d10:	e1a0c00d 	mov	ip, sp
    3d14:	e92ddff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
	volatile DWORD i; // mthomas - volatile
	DWORD DataCtrl = 0;

	MCI_CLEAR = 0x7FF;
    3d18:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    3d1c:	e3a03e7f 	mov	r3, #2032	; 0x7f0
 ** parameters:			block number
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 **
 ******************************************************************************/
DWORD MCI_Read_Block(DWORD blockNum) {
    3d20:	e24cb004 	sub	fp, ip, #4	; 0x4
	volatile DWORD i; // mthomas - volatile
	DWORD DataCtrl = 0;

	MCI_CLEAR = 0x7FF;
    3d24:	e2822923 	add	r2, r2, #573440	; 0x8c000
    3d28:	e283300f 	add	r3, r3, #15	; 0xf
	MCI_DATA_CTRL = 0;
    3d2c:	e3a01000 	mov	r1, #0	; 0x0
 ** parameters:			block number
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 **
 ******************************************************************************/
DWORD MCI_Read_Block(DWORD blockNum) {
    3d30:	e24dd01c 	sub	sp, sp, #28	; 0x1c
	volatile DWORD i; // mthomas - volatile
	DWORD DataCtrl = 0;

	MCI_CLEAR = 0x7FF;
    3d34:	e5823038 	str	r3, [r2, #56]
	MCI_DATA_CTRL = 0;
    3d38:	e582102c 	str	r1, [r2, #44]
	for (i = 0; i < 0x10; i++) {
    3d3c:	e50b102c 	str	r1, [fp, #-44]
    3d40:	e51b302c 	ldr	r3, [fp, #-44]
    3d44:	e353000f 	cmp	r3, #15	; 0xf
 ** parameters:			block number
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 **
 ******************************************************************************/
DWORD MCI_Read_Block(DWORD blockNum) {
    3d48:	e50b0044 	str	r0, [fp, #-68]
	volatile DWORD i; // mthomas - volatile
	DWORD DataCtrl = 0;

	MCI_CLEAR = 0x7FF;
	MCI_DATA_CTRL = 0;
	for (i = 0; i < 0x10; i++) {
    3d4c:	8a000005 	bhi	3d68 <MCI_Read_Block+0x58>
    3d50:	e51b302c 	ldr	r3, [fp, #-44]
    3d54:	e2833001 	add	r3, r3, #1	; 0x1
    3d58:	e50b302c 	str	r3, [fp, #-44]
    3d5c:	e51b202c 	ldr	r2, [fp, #-44]
    3d60:	e352000f 	cmp	r2, #15	; 0xf
    3d64:	9afffff9 	bls	3d50 <MCI_Read_Block+0x40>
		;
	}

	/* Below status check is redundant, but ensure card is in TRANS state
	 before writing and reading to from the card. */
	if (MCI_CheckStatus() != TRUE) {
    3d68:	ebfffea1 	bl	37f4 <MCI_CheckStatus>
    3d6c:	e3500001 	cmp	r0, #1	; 0x1
    3d70:	1a000040 	bne	3e78 <MCI_Read_Block+0x168>
/*****************************************************************/

void MCI_RXEnable(void) {
	//myprintf("inside MCI_RXEnable");
#if MCI_DMA_ENABLED
	MCI_MASK0 |= ((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));
    3d74:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
    3d78:	e2811923 	add	r1, r1, #573440	; 0x8c000
    3d7c:	e591303c 	ldr	r3, [r1, #60]
    3d80:	e3833e72 	orr	r3, r3, #1824	; 0x720
    3d84:	e383300a 	orr	r3, r3, #10	; 0xa
    3d88:	e581303c 	str	r3, [r1, #60]
	/* Enable RX interrupts only */
	MCI_MASK1 |= ((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));
    3d8c:	e5912040 	ldr	r2, [r1, #64]
    3d90:	e3822e72 	orr	r2, r2, #1824	; 0x720
    3d94:	e382200a 	orr	r2, r2, #10	; 0xa
		MCI_Send_Stop();
		return ( FALSE );
	}
	MCI_RXEnable();

	MCI_DATA_TMR = DATA_TIMER_VALUE;
    3d98:	e3a03802 	mov	r3, #131072	; 0x20000
void MCI_RXEnable(void) {
	//myprintf("inside MCI_RXEnable");
#if MCI_DMA_ENABLED
	MCI_MASK0 |= ((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));
	/* Enable RX interrupts only */
	MCI_MASK1 |= ((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));
    3d9c:	e5812040 	str	r2, [r1, #64]
		MCI_Send_Stop();
		return ( FALSE );
	}
	MCI_RXEnable();

	MCI_DATA_TMR = DATA_TIMER_VALUE;
    3da0:	e5813024 	str	r3, [r1, #36]
	MCI_DATA_LEN = BLOCK_LENGTH;
    3da4:	e3a02c02 	mov	r2, #512	; 0x200
	MCI_Block_End_Flag = 1;
    3da8:	e59f313c 	ldr	r3, [pc, #316]	; 3eec <MCI_Read_Block+0x1dc>
		return ( FALSE );
	}
	MCI_RXEnable();

	MCI_DATA_TMR = DATA_TIMER_VALUE;
	MCI_DATA_LEN = BLOCK_LENGTH;
    3dac:	e5812028 	str	r2, [r1, #40]
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
			MCI_SendCmd( READ_SINGLE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
		} else {
			MCI_SendCmd( READ_SINGLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
    3db0:	e51b2044 	ldr	r2, [fp, #-68]
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    3db4:	e3a05e7f 	mov	r5, #2032	; 0x7f0
	}
	MCI_RXEnable();

	MCI_DATA_TMR = DATA_TIMER_VALUE;
	MCI_DATA_LEN = BLOCK_LENGTH;
	MCI_Block_End_Flag = 1;
    3db8:	e5830000 	str	r0, [r3]
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    3dbc:	e1a09001 	mov	r9, r1
    3dc0:	e285500f 	add	r5, r5, #15	; 0xf
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
			MCI_SendCmd( READ_SINGLE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
		} else {
			MCI_SendCmd( READ_SINGLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
    3dc4:	e1a07482 	lsl	r7, r2, #9
    3dc8:	e3a04020 	mov	r4, #32	; 0x20
    3dcc:	e24b8040 	sub	r8, fp, #64	; 0x40
    3dd0:	e3a0a000 	mov	sl, #0	; 0x0
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    3dd4:	e5895038 	str	r5, [r9, #56]
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
    3dd8:	e59f2110 	ldr	r2, [pc, #272]	; 3ef0 <MCI_Read_Block+0x1e0>
    3ddc:	e5923000 	ldr	r3, [r2]
    3de0:	e3530004 	cmp	r3, #4	; 0x4
    3de4:	0a00001d 	beq	3e60 <MCI_Read_Block+0x150>
			MCI_SendCmd( READ_SINGLE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
		} else {
			MCI_SendCmd( READ_SINGLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
    3de8:	e3a00011 	mov	r0, #17	; 0x11
    3dec:	e1a01007 	mov	r1, r7
    3df0:	e3a02001 	mov	r2, #1	; 0x1
    3df4:	e3a03000 	mov	r3, #0	; 0x0
    3df8:	ebfffbdb 	bl	2d6c <MCI_SendCmd>
		}
#else
		// NXP original
		MCI_SendCmd( READ_SINGLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0 );
#endif
		respStatus = MCI_GetCmdResp( READ_SINGLE_BLOCK, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    3dfc:	e3a00011 	mov	r0, #17	; 0x11
    3e00:	e3a01001 	mov	r1, #1	; 0x1
    3e04:	e1a02008 	mov	r2, r8
    3e08:	ebfffc07 	bl	2e2c <MCI_GetCmdResp>
		/* it should be in the transfer state, bit 9~12 is 0x0100 and bit 8 is 1 */
		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
    3e0c:	e2506000 	subs	r6, r0, #0	; 0x0
    3e10:	1a000003 	bne	3e24 <MCI_Read_Block+0x114>
    3e14:	e51b3040 	ldr	r3, [fp, #-64]
    3e18:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    3e1c:	e3530c09 	cmp	r3, #2304	; 0x900
    3e20:	0a000017 	beq	3e84 <MCI_Read_Block+0x174>
			return ( TRUE ); /* ready and in TRAN state */
		}
		for (i = 0; i < 0x20; i++) {
    3e24:	e50ba030 	str	sl, [fp, #-48]
    3e28:	e51b3030 	ldr	r3, [fp, #-48]
    3e2c:	e353001f 	cmp	r3, #31	; 0x1f
    3e30:	8a000005 	bhi	3e4c <MCI_Read_Block+0x13c>
    3e34:	e51b3030 	ldr	r3, [fp, #-48]
    3e38:	e2833001 	add	r3, r3, #1	; 0x1
    3e3c:	e50b3030 	str	r3, [fp, #-48]
    3e40:	e51b2030 	ldr	r2, [fp, #-48]
    3e44:	e352001f 	cmp	r2, #31	; 0x1f
    3e48:	9afffff9 	bls	3e34 <MCI_Read_Block+0x124>
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
    3e4c:	e2544001 	subs	r4, r4, #1	; 0x1
    3e50:	1affffdf 	bne	3dd4 <MCI_Read_Block+0xc4>
    3e54:	e1a00004 	mov	r0, r4
	for (i = 0; i < 0x10; i++) {
		;
	}

	return ( TRUE );
}
    3e58:	e24bd028 	sub	sp, fp, #40	; 0x28
    3e5c:	e89daff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
			MCI_SendCmd( READ_SINGLE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
    3e60:	e3a00011 	mov	r0, #17	; 0x11
    3e64:	e51b1044 	ldr	r1, [fp, #-68]
    3e68:	e3a02001 	mov	r2, #1	; 0x1
    3e6c:	e2433004 	sub	r3, r3, #4	; 0x4
    3e70:	ebfffbbd 	bl	2d6c <MCI_SendCmd>
    3e74:	eaffffe0 	b	3dfc <MCI_Read_Block+0xec>

	/* Below status check is redundant, but ensure card is in TRANS state
	 before writing and reading to from the card. */
	if (MCI_CheckStatus() != TRUE) {
		mci_debug_printf("MCI_Read_Block: not in trans\n");
		MCI_Send_Stop();
    3e78:	ebfffeed 	bl	3a34 <MCI_Send_Stop>
    3e7c:	e3a00000 	mov	r0, #0	; 0x0
    3e80:	eafffff4 	b	3e58 <MCI_Read_Block+0x148>
	if (MCI_Send_Read_Block(blockNum) == FALSE) {
		return ( FALSE );
	}

#if MCI_DMA_ENABLED
	DMA_Move( 1, P2M);
    3e84:	e3a01002 	mov	r1, #2	; 0x2
    3e88:	e3a00001 	mov	r0, #1	; 0x1
    3e8c:	eb0001bd 	bl	4588 <DMA_Move>
	GPDMA_CH1_CFG |= 0x10001 | (0x04 << 1) | (0x00 << 6) | (0x06 << 11);
    3e90:	e3a03c4f 	mov	r3, #20224	; 0x4f00
    3e94:	e28330ff 	add	r3, r3, #255	; 0xff
    3e98:	e1833a83 	orr	r3, r3, r3, lsl #21
    3e9c:	e5132ecf 	ldr	r2, [r3, #-3791]
	DataCtrl |= ((1 << 0) | (1 << 1) | (1 << 3) | (DATA_BLOCK_LEN << 4));
#else
	/* Read, enable, block transfer, and data length */
	DataCtrl |= ((1 << 0) | (1 << 1) | (DATA_BLOCK_LEN << 4));
#endif
	MCI_DATA_CTRL = DataCtrl;
    3ea0:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
		return ( FALSE );
	}

#if MCI_DMA_ENABLED
	DMA_Move( 1, P2M);
	GPDMA_CH1_CFG |= 0x10001 | (0x04 << 1) | (0x00 << 6) | (0x06 << 11);
    3ea4:	e3822a13 	orr	r2, r2, #77824	; 0x13000
    3ea8:	e3822009 	orr	r2, r2, #9	; 0x9
	DataCtrl |= ((1 << 0) | (1 << 1) | (1 << 3) | (DATA_BLOCK_LEN << 4));
#else
	/* Read, enable, block transfer, and data length */
	DataCtrl |= ((1 << 0) | (1 << 1) | (DATA_BLOCK_LEN << 4));
#endif
	MCI_DATA_CTRL = DataCtrl;
    3eac:	e2800923 	add	r0, r0, #573440	; 0x8c000
    3eb0:	e3a0109b 	mov	r1, #155	; 0x9b
		return ( FALSE );
	}

#if MCI_DMA_ENABLED
	DMA_Move( 1, P2M);
	GPDMA_CH1_CFG |= 0x10001 | (0x04 << 1) | (0x00 << 6) | (0x06 << 11);
    3eb4:	e5032ecf 	str	r2, [r3, #-3791]
	DataCtrl |= ((1 << 0) | (1 << 1) | (1 << 3) | (DATA_BLOCK_LEN << 4));
#else
	/* Read, enable, block transfer, and data length */
	DataCtrl |= ((1 << 0) | (1 << 1) | (DATA_BLOCK_LEN << 4));
#endif
	MCI_DATA_CTRL = DataCtrl;
    3eb8:	e580102c 	str	r1, [r0, #44]
	for (i = 0; i < 0x10; i++) {
    3ebc:	e50b602c 	str	r6, [fp, #-44]
    3ec0:	e51b302c 	ldr	r3, [fp, #-44]
    3ec4:	e353000f 	cmp	r3, #15	; 0xf
    3ec8:	8a000005 	bhi	3ee4 <MCI_Read_Block+0x1d4>
    3ecc:	e51b302c 	ldr	r3, [fp, #-44]
    3ed0:	e2833001 	add	r3, r3, #1	; 0x1
    3ed4:	e50b302c 	str	r3, [fp, #-44]
    3ed8:	e51b202c 	ldr	r2, [fp, #-44]
    3edc:	e352000f 	cmp	r2, #15	; 0xf
    3ee0:	9afffff9 	bls	3ecc <MCI_Read_Block+0x1bc>
    3ee4:	e3a00001 	mov	r0, #1	; 0x1
    3ee8:	eaffffda 	b	3e58 <MCI_Read_Block+0x148>
    3eec:	40000770 	.word	0x40000770
    3ef0:	40000050 	.word	0x40000050

00003ef4 <MCI_Write_Block>:
 ** parameters:			block number
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 ** 
 ******************************************************************************/
DWORD MCI_Write_Block(DWORD blockNum) {
    3ef4:	e1a0c00d 	mov	ip, sp
    3ef8:	e92ddff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
	volatile DWORD i; // mthomas - volatile
	DWORD DataCtrl = 0;

	MCI_CLEAR = 0x7FF;
    3efc:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    3f00:	e3a03e7f 	mov	r3, #2032	; 0x7f0
 ** parameters:			block number
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 ** 
 ******************************************************************************/
DWORD MCI_Write_Block(DWORD blockNum) {
    3f04:	e24cb004 	sub	fp, ip, #4	; 0x4
	volatile DWORD i; // mthomas - volatile
	DWORD DataCtrl = 0;

	MCI_CLEAR = 0x7FF;
    3f08:	e2822923 	add	r2, r2, #573440	; 0x8c000
    3f0c:	e283300f 	add	r3, r3, #15	; 0xf
	MCI_DATA_CTRL = 0;
    3f10:	e3a01000 	mov	r1, #0	; 0x0
 ** parameters:			block number
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 ** 
 ******************************************************************************/
DWORD MCI_Write_Block(DWORD blockNum) {
    3f14:	e24dd01c 	sub	sp, sp, #28	; 0x1c
	volatile DWORD i; // mthomas - volatile
	DWORD DataCtrl = 0;

	MCI_CLEAR = 0x7FF;
    3f18:	e5823038 	str	r3, [r2, #56]
	MCI_DATA_CTRL = 0;
    3f1c:	e582102c 	str	r1, [r2, #44]
	for (i = 0; i < 0x10; i++) {
    3f20:	e50b102c 	str	r1, [fp, #-44]
    3f24:	e51b302c 	ldr	r3, [fp, #-44]
    3f28:	e353000f 	cmp	r3, #15	; 0xf
 ** parameters:			block number
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 ** 
 ******************************************************************************/
DWORD MCI_Write_Block(DWORD blockNum) {
    3f2c:	e50b0044 	str	r0, [fp, #-68]
	volatile DWORD i; // mthomas - volatile
	DWORD DataCtrl = 0;

	MCI_CLEAR = 0x7FF;
	MCI_DATA_CTRL = 0;
	for (i = 0; i < 0x10; i++) {
    3f30:	8a000005 	bhi	3f4c <MCI_Write_Block+0x58>
    3f34:	e51b302c 	ldr	r3, [fp, #-44]
    3f38:	e2833001 	add	r3, r3, #1	; 0x1
    3f3c:	e50b302c 	str	r3, [fp, #-44]
    3f40:	e51b202c 	ldr	r2, [fp, #-44]
    3f44:	e352000f 	cmp	r2, #15	; 0xf
    3f48:	9afffff9 	bls	3f34 <MCI_Write_Block+0x40>
		;
	}

	/* Below status check is redundant, but ensure card is in TRANS state
	 before writing and reading to from the card. */
	if (MCI_CheckStatus() != TRUE) {
    3f4c:	ebfffe28 	bl	37f4 <MCI_CheckStatus>
    3f50:	e3500001 	cmp	r0, #1	; 0x1
    3f54:	e1a0c000 	mov	ip, r0
    3f58:	1a000040 	bne	4060 <MCI_Write_Block+0x16c>
		mci_debug_printf("MCI_Wead_Block: not in trans\n");
		MCI_Send_Stop();
		return ( FALSE );
	}

	MCI_DATA_TMR = DATA_TIMER_VALUE;
    3f5c:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
	MCI_DATA_LEN = BLOCK_LENGTH;
	MCI_Block_End_Flag = 1;
    3f60:	e59f116c 	ldr	r1, [pc, #364]	; 40d4 <MCI_Write_Block+0x1e0>
		mci_debug_printf("MCI_Wead_Block: not in trans\n");
		MCI_Send_Stop();
		return ( FALSE );
	}

	MCI_DATA_TMR = DATA_TIMER_VALUE;
    3f64:	e2800923 	add	r0, r0, #573440	; 0x8c000
    3f68:	e3a03802 	mov	r3, #131072	; 0x20000
	MCI_DATA_LEN = BLOCK_LENGTH;
    3f6c:	e3a02c02 	mov	r2, #512	; 0x200
		mci_debug_printf("MCI_Wead_Block: not in trans\n");
		MCI_Send_Stop();
		return ( FALSE );
	}

	MCI_DATA_TMR = DATA_TIMER_VALUE;
    3f70:	e5803024 	str	r3, [r0, #36]
	MCI_DATA_LEN = BLOCK_LENGTH;
    3f74:	e5802028 	str	r2, [r0, #40]
	MCI_Block_End_Flag = 1;
    3f78:	e581c000 	str	ip, [r1]
 ** Returned value:		None
 ** 
 ******************************************************************************/
void MCI_TXEnable(void) {
#if MCI_DMA_ENABLED
	MCI_MASK0 |= ((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
    3f7c:	e590303c 	ldr	r3, [r0, #60]
    3f80:	e3833e71 	orr	r3, r3, #1808	; 0x710
    3f84:	e383300a 	orr	r3, r3, #10	; 0xa
    3f88:	e580303c 	str	r3, [r0, #60]
	/* Enable TX interrupts only */
	MCI_MASK1 |= ((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
    3f8c:	e5902040 	ldr	r2, [r0, #64]
    3f90:	e3822e71 	orr	r2, r2, #1808	; 0x710
    3f94:	e382200a 	orr	r2, r2, #10	; 0xa
    3f98:	e5802040 	str	r2, [r0, #64]
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
			MCI_SendCmd( WRITE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
		} else {
			MCI_SendCmd( WRITE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
    3f9c:	e51b2044 	ldr	r2, [fp, #-68]
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    3fa0:	e3a05e7f 	mov	r5, #2032	; 0x7f0
    3fa4:	e1a09000 	mov	r9, r0
    3fa8:	e285500f 	add	r5, r5, #15	; 0xf
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
			MCI_SendCmd( WRITE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
		} else {
			MCI_SendCmd( WRITE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
    3fac:	e1a07482 	lsl	r7, r2, #9
    3fb0:	e3a04020 	mov	r4, #32	; 0x20
    3fb4:	e24b8040 	sub	r8, fp, #64	; 0x40
    3fb8:	e3a0a000 	mov	sl, #0	; 0x0
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    3fbc:	e5895038 	str	r5, [r9, #56]
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
    3fc0:	e59f2110 	ldr	r2, [pc, #272]	; 40d8 <MCI_Write_Block+0x1e4>
    3fc4:	e5923000 	ldr	r3, [r2]
    3fc8:	e3530004 	cmp	r3, #4	; 0x4
    3fcc:	0a00001d 	beq	4048 <MCI_Write_Block+0x154>
			MCI_SendCmd( WRITE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
		} else {
			MCI_SendCmd( WRITE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
    3fd0:	e3a00018 	mov	r0, #24	; 0x18
    3fd4:	e1a01007 	mov	r1, r7
    3fd8:	e3a02001 	mov	r2, #1	; 0x1
    3fdc:	e3a03000 	mov	r3, #0	; 0x0
    3fe0:	ebfffb61 	bl	2d6c <MCI_SendCmd>
		}
#else
		// NXP original
		MCI_SendCmd( WRITE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0 );
#endif
		respStatus = MCI_GetCmdResp( WRITE_BLOCK, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    3fe4:	e3a00018 	mov	r0, #24	; 0x18
    3fe8:	e3a01001 	mov	r1, #1	; 0x1
    3fec:	e1a02008 	mov	r2, r8
    3ff0:	ebfffb8d 	bl	2e2c <MCI_GetCmdResp>
		/* it should be in the transfer state, bit 9~12 is 0x0100 and bit 8 is 1 */
		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
    3ff4:	e2506000 	subs	r6, r0, #0	; 0x0
    3ff8:	1a000003 	bne	400c <MCI_Write_Block+0x118>
    3ffc:	e51b3040 	ldr	r3, [fp, #-64]
    4000:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    4004:	e3530c09 	cmp	r3, #2304	; 0x900
    4008:	0a000017 	beq	406c <MCI_Write_Block+0x178>
			return ( TRUE ); /* ready and in TRAN state */
		}

		for (i = 0; i < 0x20; i++) {
    400c:	e50ba030 	str	sl, [fp, #-48]
    4010:	e51b3030 	ldr	r3, [fp, #-48]
    4014:	e353001f 	cmp	r3, #31	; 0x1f
    4018:	8a000005 	bhi	4034 <MCI_Write_Block+0x140>
    401c:	e51b3030 	ldr	r3, [fp, #-48]
    4020:	e2833001 	add	r3, r3, #1	; 0x1
    4024:	e50b3030 	str	r3, [fp, #-48]
    4028:	e51b2030 	ldr	r2, [fp, #-48]
    402c:	e352001f 	cmp	r2, #31	; 0x1f
    4030:	9afffff9 	bls	401c <MCI_Write_Block+0x128>
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
    4034:	e2544001 	subs	r4, r4, #1	; 0x1
    4038:	1affffdf 	bne	3fbc <MCI_Write_Block+0xc8>
    403c:	e1a00004 	mov	r0, r4
	for (i = 0; i < 0x10; i++) {
		;
	}

	return ( TRUE );
}
    4040:	e24bd028 	sub	sp, fp, #40	; 0x28
    4044:	e89daff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
			MCI_SendCmd( WRITE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
    4048:	e3a00018 	mov	r0, #24	; 0x18
    404c:	e51b1044 	ldr	r1, [fp, #-68]
    4050:	e3a02001 	mov	r2, #1	; 0x1
    4054:	e2433004 	sub	r3, r3, #4	; 0x4
    4058:	ebfffb43 	bl	2d6c <MCI_SendCmd>
    405c:	eaffffe0 	b	3fe4 <MCI_Write_Block+0xf0>

	/* Below status check is redundant, but ensure card is in TRANS state
	 before writing and reading to from the card. */
	if (MCI_CheckStatus() != TRUE) {
		mci_debug_printf("MCI_Wead_Block: not in trans\n");
		MCI_Send_Stop();
    4060:	ebfffe73 	bl	3a34 <MCI_Send_Stop>
    4064:	e3a00000 	mov	r0, #0	; 0x0
    4068:	eafffff4 	b	4040 <MCI_Write_Block+0x14c>
	if (MCI_Send_Write_Block(blockNum) == FALSE) {
		return ( FALSE );
	}

#if MCI_DMA_ENABLED
	DMA_Move( 0, M2P);
    406c:	e3a01001 	mov	r1, #1	; 0x1
    4070:	eb000144 	bl	4588 <DMA_Move>
	GPDMA_CH0_CFG |= 0x10001 | (0x00 << 1) | (0x04 << 6) | (0x05 << 11);
    4074:	e3a02c4f 	mov	r2, #20224	; 0x4f00
    4078:	e28220ff 	add	r2, r2, #255	; 0xff
    407c:	e1822a82 	orr	r2, r2, r2, lsl #21
    4080:	e5123eef 	ldr	r3, [r2, #-3823]
    4084:	e3833b4a 	orr	r3, r3, #75776	; 0x12800
    4088:	e3833c01 	orr	r3, r3, #256	; 0x100
	DataCtrl |= ((1 << 0) | (1 << 3) | (DATA_BLOCK_LEN << 4));
#else
	/* Write, block transfer, and data length */
	DataCtrl |= ((1 << 0) | (DATA_BLOCK_LEN << 4));
#endif
	MCI_DATA_CTRL = DataCtrl;
    408c:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
		return ( FALSE );
	}

#if MCI_DMA_ENABLED
	DMA_Move( 0, M2P);
	GPDMA_CH0_CFG |= 0x10001 | (0x00 << 1) | (0x04 << 6) | (0x05 << 11);
    4090:	e3833001 	orr	r3, r3, #1	; 0x1
	DataCtrl |= ((1 << 0) | (1 << 3) | (DATA_BLOCK_LEN << 4));
#else
	/* Write, block transfer, and data length */
	DataCtrl |= ((1 << 0) | (DATA_BLOCK_LEN << 4));
#endif
	MCI_DATA_CTRL = DataCtrl;
    4094:	e2800923 	add	r0, r0, #573440	; 0x8c000
    4098:	e3a01099 	mov	r1, #153	; 0x99
		return ( FALSE );
	}

#if MCI_DMA_ENABLED
	DMA_Move( 0, M2P);
	GPDMA_CH0_CFG |= 0x10001 | (0x00 << 1) | (0x04 << 6) | (0x05 << 11);
    409c:	e5023eef 	str	r3, [r2, #-3823]
	DataCtrl |= ((1 << 0) | (1 << 3) | (DATA_BLOCK_LEN << 4));
#else
	/* Write, block transfer, and data length */
	DataCtrl |= ((1 << 0) | (DATA_BLOCK_LEN << 4));
#endif
	MCI_DATA_CTRL = DataCtrl;
    40a0:	e580102c 	str	r1, [r0, #44]
	//laebi - not necessary
	for (i = 0; i < 0x10; i++) {
    40a4:	e50b602c 	str	r6, [fp, #-44]
    40a8:	e51b302c 	ldr	r3, [fp, #-44]
    40ac:	e353000f 	cmp	r3, #15	; 0xf
    40b0:	8a000005 	bhi	40cc <MCI_Write_Block+0x1d8>
    40b4:	e51b302c 	ldr	r3, [fp, #-44]
    40b8:	e2833001 	add	r3, r3, #1	; 0x1
    40bc:	e50b302c 	str	r3, [fp, #-44]
    40c0:	e51b202c 	ldr	r2, [fp, #-44]
    40c4:	e352000f 	cmp	r2, #15	; 0xf
    40c8:	9afffff9 	bls	40b4 <MCI_Write_Block+0x1c0>
    40cc:	e3a00001 	mov	r0, #1	; 0x1
    40d0:	eaffffda 	b	4040 <MCI_Write_Block+0x14c>
    40d4:	40000770 	.word	0x40000770
    40d8:	40000050 	.word	0x40000050

000040dc <MCI_Write_Multiple_Block>:
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 **
 ** Added by Lorenz Aebi
 ******************************************************************************/
DWORD MCI_Write_Multiple_Block(DWORD blockNum, BYTE count, const BYTE *buff) {
    40dc:	e1a0c00d 	mov	ip, sp
    40e0:	e92ddff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
	volatile DWORD i; // mthomas - volatile
	DWORD DataCtrl = 0;

	MCI_CLEAR = 0x7FF;
    40e4:	e3a0420e 	mov	r4, #-536870912	; 0xe0000000
    40e8:	e3a05e7f 	mov	r5, #2032	; 0x7f0
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 **
 ** Added by Lorenz Aebi
 ******************************************************************************/
DWORD MCI_Write_Multiple_Block(DWORD blockNum, BYTE count, const BYTE *buff) {
    40ec:	e24cb004 	sub	fp, ip, #4	; 0x4
    40f0:	e24dd028 	sub	sp, sp, #40	; 0x28
	volatile DWORD i; // mthomas - volatile
	DWORD DataCtrl = 0;

	MCI_CLEAR = 0x7FF;
    40f4:	e2844923 	add	r4, r4, #573440	; 0x8c000
    40f8:	e285500f 	add	r5, r5, #15	; 0xf
	MCI_DATA_CTRL = 0;
    40fc:	e3a06000 	mov	r6, #0	; 0x0
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 **
 ** Added by Lorenz Aebi
 ******************************************************************************/
DWORD MCI_Write_Multiple_Block(DWORD blockNum, BYTE count, const BYTE *buff) {
    4100:	e20110ff 	and	r1, r1, #255	; 0xff
	volatile DWORD i; // mthomas - volatile
	DWORD DataCtrl = 0;

	MCI_CLEAR = 0x7FF;
    4104:	e5845038 	str	r5, [r4, #56]
	MCI_DATA_CTRL = 0;
    4108:	e584602c 	str	r6, [r4, #44]
 ** Returned value:		true or false, if cmd times out, return false and no 
 **						need to continue.
 **
 ** Added by Lorenz Aebi
 ******************************************************************************/
DWORD MCI_Write_Multiple_Block(DWORD blockNum, BYTE count, const BYTE *buff) {
    410c:	e50b0044 	str	r0, [fp, #-68]
    4110:	e1a08002 	mov	r8, r2
    4114:	e50b1048 	str	r1, [fp, #-72]
	//laebi - not necessary
	//for ( i = 0; i < 0x10; i++ ) { ; }

	/* Below status check is redundant, but ensure card is in TRANS state
	 before writing and reading to from the card. */
	if (MCI_CheckStatus() != TRUE) {
    4118:	ebfffdb5 	bl	37f4 <MCI_CheckStatus>
    411c:	e3500001 	cmp	r0, #1	; 0x1
    4120:	1a00003d 	bne	421c <MCI_Write_Multiple_Block+0x140>
		return ( FALSE );
	}

	MCI_DATA_TMR = DATA_TIMER_VALUE;
	MCI_DATA_LEN = BLOCK_LENGTH;
	MCI_Block_End_Flag = 1;
    4124:	e59f11f4 	ldr	r1, [pc, #500]	; 4320 <MCI_Write_Multiple_Block+0x244>
		mci_debug_printf("MCI_Wead_Block: not in trans\n");
		MCI_Send_Stop();
		return ( FALSE );
	}

	MCI_DATA_TMR = DATA_TIMER_VALUE;
    4128:	e3a03802 	mov	r3, #131072	; 0x20000
	MCI_DATA_LEN = BLOCK_LENGTH;
    412c:	e3a02c02 	mov	r2, #512	; 0x200
		mci_debug_printf("MCI_Wead_Block: not in trans\n");
		MCI_Send_Stop();
		return ( FALSE );
	}

	MCI_DATA_TMR = DATA_TIMER_VALUE;
    4130:	e5843024 	str	r3, [r4, #36]
	MCI_DATA_LEN = BLOCK_LENGTH;
    4134:	e5842028 	str	r2, [r4, #40]
	MCI_Block_End_Flag = 1;
    4138:	e5810000 	str	r0, [r1]
 ** Returned value:		None
 ** 
 ******************************************************************************/
void MCI_TXEnable(void) {
#if MCI_DMA_ENABLED
	MCI_MASK0 |= ((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
    413c:	e594303c 	ldr	r3, [r4, #60]
    4140:	e3833e71 	orr	r3, r3, #1808	; 0x710
    4144:	e383300a 	orr	r3, r3, #10	; 0xa
    4148:	e584303c 	str	r3, [r4, #60]
	/* Enable TX interrupts only */
	MCI_MASK1 |= ((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));
    414c:	e5942040 	ldr	r2, [r4, #64]
    4150:	e3822e71 	orr	r2, r2, #1808	; 0x710
    4154:	e382200a 	orr	r2, r2, #10	; 0xa
    4158:	e5842040 	str	r2, [r4, #64]
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
			MCI_SendCmd( WRITE_MULTIPLE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
		} else {
			MCI_SendCmd( WRITE_MULTIPLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
    415c:	e51b2044 	ldr	r2, [fp, #-68]
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    4160:	e1a07004 	mov	r7, r4
    4164:	e1a0a005 	mov	sl, r5
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
			MCI_SendCmd( WRITE_MULTIPLE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
		} else {
			MCI_SendCmd( WRITE_MULTIPLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
    4168:	e1a09006 	mov	r9, r6
    416c:	e1a05482 	lsl	r5, r2, #9
    4170:	e3a04020 	mov	r4, #32	; 0x20
    4174:	e24b6040 	sub	r6, fp, #64	; 0x40
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
    4178:	e587a038 	str	sl, [r7, #56]
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
    417c:	e59f21a0 	ldr	r2, [pc, #416]	; 4324 <MCI_Write_Multiple_Block+0x248>
    4180:	e5923000 	ldr	r3, [r2]
    4184:	e3530004 	cmp	r3, #4	; 0x4
    4188:	0a00001d 	beq	4204 <MCI_Write_Multiple_Block+0x128>
			MCI_SendCmd( WRITE_MULTIPLE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
		} else {
			MCI_SendCmd( WRITE_MULTIPLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0);
    418c:	e3a00019 	mov	r0, #25	; 0x19
    4190:	e1a01005 	mov	r1, r5
    4194:	e3a02001 	mov	r2, #1	; 0x1
    4198:	e3a03000 	mov	r3, #0	; 0x0
    419c:	ebfffaf2 	bl	2d6c <MCI_SendCmd>
		}
#else
		// NXP original
		MCI_SendCmd( WRITE_MULTIPLE_BLOCK, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, 0 );
#endif
		respStatus = MCI_GetCmdResp( WRITE_MULTIPLE_BLOCK, EXPECT_SHORT_RESP, (DWORD *)&respValue[0]);
    41a0:	e3a00019 	mov	r0, #25	; 0x19
    41a4:	e3a01001 	mov	r1, #1	; 0x1
    41a8:	e1a02006 	mov	r2, r6
    41ac:	ebfffb1e 	bl	2e2c <MCI_GetCmdResp>
		/* it should be in the transfer state, bit 9~12 is 0x0100 and bit 8 is 1 */
		if ( !respStatus && ((respValue[0] & (0x0F << 8)) == 0x0900)) {
    41b0:	e3500000 	cmp	r0, #0	; 0x0
    41b4:	1a000003 	bne	41c8 <MCI_Write_Multiple_Block+0xec>
    41b8:	e51b3040 	ldr	r3, [fp, #-64]
    41bc:	e2033c0f 	and	r3, r3, #3840	; 0xf00
    41c0:	e3530c09 	cmp	r3, #2304	; 0x900
    41c4:	0a000017 	beq	4228 <MCI_Write_Multiple_Block+0x14c>
			return ( TRUE ); /* ready and in TRAN state */
		}

		for (i = 0; i < 0x20; i++) {
    41c8:	e50b9030 	str	r9, [fp, #-48]
    41cc:	e51b3030 	ldr	r3, [fp, #-48]
    41d0:	e353001f 	cmp	r3, #31	; 0x1f
    41d4:	8a000005 	bhi	41f0 <MCI_Write_Multiple_Block+0x114>
    41d8:	e51b3030 	ldr	r3, [fp, #-48]
    41dc:	e2833001 	add	r3, r3, #1	; 0x1
    41e0:	e50b3030 	str	r3, [fp, #-48]
    41e4:	e51b2030 	ldr	r2, [fp, #-48]
    41e8:	e352001f 	cmp	r2, #31	; 0x1f
    41ec:	9afffff9 	bls	41d8 <MCI_Write_Multiple_Block+0xfc>
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
    41f0:	e2544001 	subs	r4, r4, #1	; 0x1
    41f4:	1affffdf 	bne	4178 <MCI_Write_Multiple_Block+0x9c>
    41f8:	e1a00004 	mov	r0, r4
	//for (i = 0; i < 0x10; i++) { ; }

	MCI_Send_Stop();

	return ( TRUE );
}
    41fc:	e24bd028 	sub	sp, fp, #40	; 0x28
    4200:	e89daff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
	while (retryCount > 0) {
		MCI_CLEAR = 0x7FF;
#if 1
		// mthomas
		if (MCI_CardType == SDHC_CARD) {
			MCI_SendCmd( WRITE_MULTIPLE_BLOCK, blockNum, EXPECT_SHORT_RESP, 0);
    4204:	e3a00019 	mov	r0, #25	; 0x19
    4208:	e51b1044 	ldr	r1, [fp, #-68]
    420c:	e3a02001 	mov	r2, #1	; 0x1
    4210:	e2433004 	sub	r3, r3, #4	; 0x4
    4214:	ebfffad4 	bl	2d6c <MCI_SendCmd>
    4218:	eaffffe0 	b	41a0 <MCI_Write_Multiple_Block+0xc4>

	/* Below status check is redundant, but ensure card is in TRANS state
	 before writing and reading to from the card. */
	if (MCI_CheckStatus() != TRUE) {
		mci_debug_printf("MCI_Wead_Block: not in trans\n");
		MCI_Send_Stop();
    421c:	ebfffe04 	bl	3a34 <MCI_Send_Stop>
    4220:	e1a00006 	mov	r0, r6
    4224:	eafffff4 	b	41fc <MCI_Write_Multiple_Block+0x120>
		/* Enable DMA channels, little endian */
		while ( !(GPDMA_CONFIG & 0x01))
			;
		/* The burst size is set to 8, the size is 8 bit too. */
		/* Terminal Count Int enable */
		GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    4228:	e3a03321 	mov	r3, #-2080374784	; 0x84000000
#if MCI_DMA_ENABLED
	do {
		// TODO: avoid copy
		memcpy((void *)DMA_SRC, buff, 512);
		buff += 512;
		GPDMA_INT_TCCLR = 0x01;
    422c:	e3a04c4f 	mov	r4, #20224	; 0x4f00
		/* Enable DMA channels, little endian */
		while ( !(GPDMA_CONFIG & 0x01))
			;
		/* The burst size is set to 8, the size is 8 bit too. */
		/* Terminal Count Int enable */
		GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    4230:	e2833849 	add	r3, r3, #4784128	; 0x490000
		DataCtrl |= ((1 << 0) | (1 << 3) | (DATA_BLOCK_LEN << 4));
#else
		/* Write, block transfer, and data length */
		DataCtrl |= ((1 << 0) | (DATA_BLOCK_LEN << 4));
#endif
		MCI_DATA_CTRL = DataCtrl;
    4234:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
#if MCI_DMA_ENABLED
	do {
		// TODO: avoid copy
		memcpy((void *)DMA_SRC, buff, 512);
		buff += 512;
		GPDMA_INT_TCCLR = 0x01;
    4238:	e28440ff 	add	r4, r4, #255	; 0xff
		GPDMA_INT_ERR_CLR = 0x01;
		GPDMA_CH0_SRC = DMA_SRC;
		GPDMA_CH0_DEST = DMA_MCIFIFO;
    423c:	e3a0920e 	mov	r9, #-536870912	; 0xe0000000
		/* Enable DMA channels, little endian */
		while ( !(GPDMA_CONFIG & 0x01))
			;
		/* The burst size is set to 8, the size is 8 bit too. */
		/* Terminal Count Int enable */
		GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    4240:	e2833c42 	add	r3, r3, #16896	; 0x4200
		DataCtrl |= ((1 << 0) | (1 << 3) | (DATA_BLOCK_LEN << 4));
#else
		/* Write, block transfer, and data length */
		DataCtrl |= ((1 << 0) | (DATA_BLOCK_LEN << 4));
#endif
		MCI_DATA_CTRL = DataCtrl;
    4244:	e2822923 	add	r2, r2, #573440	; 0x8c000
#if MCI_DMA_ENABLED
	do {
		// TODO: avoid copy
		memcpy((void *)DMA_SRC, buff, 512);
		buff += 512;
		GPDMA_INT_TCCLR = 0x01;
    4248:	e1844a84 	orr	r4, r4, r4, lsl #21
		GPDMA_INT_ERR_CLR = 0x01;
		GPDMA_CH0_SRC = DMA_SRC;
		GPDMA_CH0_DEST = DMA_MCIFIFO;
    424c:	e2899923 	add	r9, r9, #573440	; 0x8c000
	}

#if MCI_DMA_ENABLED
	do {
		// TODO: avoid copy
		memcpy((void *)DMA_SRC, buff, 512);
    4250:	e3a0a47f 	mov	sl, #2130706432	; 0x7f000000
		/* Enable DMA channels, little endian */
		while ( !(GPDMA_CONFIG & 0x01))
			;
		/* The burst size is set to 8, the size is 8 bit too. */
		/* Terminal Count Int enable */
		GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    4254:	e50b304c 	str	r3, [fp, #-76]
		DataCtrl |= ((1 << 0) | (1 << 3) | (DATA_BLOCK_LEN << 4));
#else
		/* Write, block transfer, and data length */
		DataCtrl |= ((1 << 0) | (DATA_BLOCK_LEN << 4));
#endif
		MCI_DATA_CTRL = DataCtrl;
    4258:	e50b2050 	str	r2, [fp, #-80]
	DWORD retryCount;
	DWORD respStatus;
	DWORD respValue[4];

	retryCount = 0x20;
	while (retryCount > 0) {
    425c:	e1a05000 	mov	r5, r0
	}

#if MCI_DMA_ENABLED
	do {
		// TODO: avoid copy
		memcpy((void *)DMA_SRC, buff, 512);
    4260:	e28aa60d 	add	sl, sl, #13631488	; 0xd00000
		buff += 512;
		GPDMA_INT_TCCLR = 0x01;
		GPDMA_INT_ERR_CLR = 0x01;
		GPDMA_CH0_SRC = DMA_SRC;
		GPDMA_CH0_DEST = DMA_MCIFIFO;
    4264:	e2899080 	add	r9, r9, #128	; 0x80
#if MCI_DMA_ENABLED
	do {
		// TODO: avoid copy
		memcpy((void *)DMA_SRC, buff, 512);
		buff += 512;
		GPDMA_INT_TCCLR = 0x01;
    4268:	e3a07001 	mov	r7, #1	; 0x1
		GPDMA_INT_ERR_CLR = 0x01;
		GPDMA_CH0_SRC = DMA_SRC;
		GPDMA_CH0_DEST = DMA_MCIFIFO;
		GPDMA_CONFIG = 0x01;
		/* Enable DMA channels, little endian */
		while ( !(GPDMA_CONFIG & 0x01))
    426c:	e1a06004 	mov	r6, r4
	}

#if MCI_DMA_ENABLED
	do {
		// TODO: avoid copy
		memcpy((void *)DMA_SRC, buff, 512);
    4270:	e3a0047f 	mov	r0, #2130706432	; 0x7f000000
    4274:	e1a01008 	mov	r1, r8
    4278:	e280060d 	add	r0, r0, #13631488	; 0xd00000
    427c:	e3a02c02 	mov	r2, #512	; 0x200
    4280:	eb0003f6 	bl	5260 <memcpy>
		buff += 512;
		GPDMA_INT_TCCLR = 0x01;
    4284:	e5047ff7 	str	r7, [r4, #-4087]
		GPDMA_INT_ERR_CLR = 0x01;
    4288:	e5047fef 	str	r7, [r4, #-4079]
		GPDMA_CH0_SRC = DMA_SRC;
    428c:	e504aeff 	str	sl, [r4, #-3839]
		GPDMA_CH0_DEST = DMA_MCIFIFO;
    4290:	e5049efb 	str	r9, [r4, #-3835]
		GPDMA_CONFIG = 0x01;
    4294:	e5047fcf 	str	r7, [r4, #-4047]

#if MCI_DMA_ENABLED
	do {
		// TODO: avoid copy
		memcpy((void *)DMA_SRC, buff, 512);
		buff += 512;
    4298:	e2888c02 	add	r8, r8, #512	; 0x200
		GPDMA_INT_ERR_CLR = 0x01;
		GPDMA_CH0_SRC = DMA_SRC;
		GPDMA_CH0_DEST = DMA_MCIFIFO;
		GPDMA_CONFIG = 0x01;
		/* Enable DMA channels, little endian */
		while ( !(GPDMA_CONFIG & 0x01))
    429c:	e5143fcf 	ldr	r3, [r4, #-4047]
    42a0:	e3130001 	tst	r3, #1	; 0x1
    42a4:	0afffffc 	beq	429c <MCI_Write_Multiple_Block+0x1c0>
			;
		/* The burst size is set to 8, the size is 8 bit too. */
		/* Terminal Count Int enable */
		GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    42a8:	e51b304c 	ldr	r3, [fp, #-76]
    42ac:	e5063ef3 	str	r3, [r6, #-3827]
		| (0x02 << 18) | (0x02 << 21) | (1 << 26) | 0x80000000;
		//DMA_Move( 0, M2P );
		GPDMA_CH0_CFG |= 0x10001 | (0x00 << 1) | (0x04 << 6) | (0x05 << 11);
    42b0:	e5163eef 	ldr	r3, [r6, #-3823]
    42b4:	e3833b4a 	orr	r3, r3, #75776	; 0x12800
    42b8:	e3833c01 	orr	r3, r3, #256	; 0x100
    42bc:	e3833001 	orr	r3, r3, #1	; 0x1
		DataCtrl |= ((1 << 0) | (1 << 3) | (DATA_BLOCK_LEN << 4));
#else
		/* Write, block transfer, and data length */
		DataCtrl |= ((1 << 0) | (DATA_BLOCK_LEN << 4));
#endif
		MCI_DATA_CTRL = DataCtrl;
    42c0:	e51b2050 	ldr	r2, [fp, #-80]
		/* The burst size is set to 8, the size is 8 bit too. */
		/* Terminal Count Int enable */
		GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
		| (0x02 << 18) | (0x02 << 21) | (1 << 26) | 0x80000000;
		//DMA_Move( 0, M2P );
		GPDMA_CH0_CFG |= 0x10001 | (0x00 << 1) | (0x04 << 6) | (0x05 << 11);
    42c4:	e5063eef 	str	r3, [r6, #-3823]
		/* Write, block transfer, DMA, and data length */
		DataCtrl |= ((1 << 0) | (1 << 3) | (DATA_BLOCK_LEN << 4));
    42c8:	e3855099 	orr	r5, r5, #153	; 0x99
#else
		/* Write, block transfer, and data length */
		DataCtrl |= ((1 << 0) | (DATA_BLOCK_LEN << 4));
#endif
		MCI_DATA_CTRL = DataCtrl;
		for (i = 0; i < 0x10; i++) {
    42cc:	e3a03000 	mov	r3, #0	; 0x0
		DataCtrl |= ((1 << 0) | (1 << 3) | (DATA_BLOCK_LEN << 4));
#else
		/* Write, block transfer, and data length */
		DataCtrl |= ((1 << 0) | (DATA_BLOCK_LEN << 4));
#endif
		MCI_DATA_CTRL = DataCtrl;
    42d0:	e582502c 	str	r5, [r2, #44]
		for (i = 0; i < 0x10; i++) {
    42d4:	e50b302c 	str	r3, [fp, #-44]
    42d8:	e51b302c 	ldr	r3, [fp, #-44]
    42dc:	e353000f 	cmp	r3, #15	; 0xf
    42e0:	8a000005 	bhi	42fc <MCI_Write_Multiple_Block+0x220>
    42e4:	e51b302c 	ldr	r3, [fp, #-44]
    42e8:	e2833001 	add	r3, r3, #1	; 0x1
    42ec:	e50b302c 	str	r3, [fp, #-44]
    42f0:	e51b202c 	ldr	r2, [fp, #-44]
    42f4:	e352000f 	cmp	r2, #15	; 0xf
    42f8:	9afffff9 	bls	42e4 <MCI_Write_Multiple_Block+0x208>
			;
		}
	} while (count--);
    42fc:	e51b2048 	ldr	r2, [fp, #-72]
    4300:	e3520000 	cmp	r2, #0	; 0x0
    4304:	12423001 	subne	r3, r2, #1	; 0x1
    4308:	120330ff 	andne	r3, r3, #255	; 0xff
    430c:	150b3048 	strne	r3, [fp, #-72]
    4310:	1affffd6 	bne	4270 <MCI_Write_Multiple_Block+0x194>

	//for (i = 0; i < 0x10; i++) { ; }

	MCI_Send_Stop();
    4314:	ebfffdc6 	bl	3a34 <MCI_Send_Stop>
    4318:	e3a00001 	mov	r0, #1	; 0x1
    431c:	eaffffb6 	b	41fc <MCI_Write_Multiple_Block+0x120>
    4320:	40000770 	.word	0x40000770
    4324:	40000050 	.word	0x40000050

00004328 <MCI_Init>:
 ** Returned value:		true or false, if VIC table is full, return false
 **
 ** modified by Martin Thomas to avoid that the
 ** hard-coded pinsel-values disable other functions
 ******************************************************************************/
DWORD MCI_Init(void) {
    4328:	e1a0c00d 	mov	ip, sp
    432c:	e92dd800 	push	{fp, ip, lr, pc}
	volatile DWORD i; // mthomas - volatile

	PCONP |= ( 1 << 28 );
    4330:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
 ** Returned value:		true or false, if VIC table is full, return false
 **
 ** modified by Martin Thomas to avoid that the
 ** hard-coded pinsel-values disable other functions
 ******************************************************************************/
DWORD MCI_Init(void) {
    4334:	e24cb004 	sub	fp, ip, #4	; 0x4
    4338:	e24dd004 	sub	sp, sp, #4	; 0x4
	volatile DWORD i; // mthomas - volatile

	PCONP |= ( 1 << 28 );
    433c:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    4340:	e59320c4 	ldr	r2, [r3, #196]
    4344:	e3822201 	orr	r2, r2, #268435456	; 0x10000000
    4348:	e58320c4 	str	r2, [r3, #196]
	/* Enable clock to the MCI block */

	if ( MCI_CLOCK & (1 << 8)) {
    434c:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    4350:	e2822923 	add	r2, r2, #573440	; 0x8c000
    4354:	e5923004 	ldr	r3, [r2, #4]
    4358:	e3130c01 	tst	r3, #256	; 0x100
		MCI_CLOCK &= ~(1 << 8);
    435c:	15923004 	ldrne	r3, [r2, #4]
    4360:	13c33c01 	bicne	r3, r3, #256	; 0x100
    4364:	15823004 	strne	r3, [r2, #4]
	}
	if ( MCI_POWER & 0x02) {
    4368:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    436c:	e2822923 	add	r2, r2, #573440	; 0x8c000
    4370:	e5923000 	ldr	r3, [r2]
    4374:	e3130002 	tst	r3, #2	; 0x2
		MCI_POWER = 0x00;
    4378:	13a03000 	movne	r3, #0	; 0x0
    437c:	15823000 	strne	r3, [r2]
	}
	for (i = 0; i < 0x1000; i++)
    4380:	e3a03000 	mov	r3, #0	; 0x0
    4384:	e50b3010 	str	r3, [fp, #-16]
    4388:	e51b2010 	ldr	r2, [fp, #-16]
    438c:	e2833eff 	add	r3, r3, #4080	; 0xff0
    4390:	e283300f 	add	r3, r3, #15	; 0xf
    4394:	e1520003 	cmp	r2, r3
    4398:	8a000006 	bhi	43b8 <MCI_Init+0x90>
    439c:	e1a01003 	mov	r1, r3
    43a0:	e51b3010 	ldr	r3, [fp, #-16]
    43a4:	e2833001 	add	r3, r3, #1	; 0x1
    43a8:	e50b3010 	str	r3, [fp, #-16]
    43ac:	e51b2010 	ldr	r2, [fp, #-16]
    43b0:	e1520001 	cmp	r2, r1
    43b4:	9afffff9 	bls	43a0 <MCI_Init+0x78>
		;

	/* Disable all interrupts for now */
	MCI_MASK0 = 0;
    43b8:	e3a0c20e 	mov	ip, #-536870912	; 0xe0000000
    43bc:	e28cc923 	add	ip, ip, #573440	; 0x8c000
    43c0:	e3a0e000 	mov	lr, #0	; 0x0
    43c4:	e58ce03c 	str	lr, [ip, #60]
	MCI_MASK1 = MCI_MASK0;
    43c8:	e59c303c 	ldr	r3, [ip, #60]
#warning EA,OMX23/Keil23
/*	PINSEL1 = ( PINSEL1 & ~( (3<<6)|(3<<8)|(3<<10)|(3<<12) ) )
	| ((2<<6)|(2<<8)|(2<<10)|(2<<12));
	PINSEL4 = ( PINSEL4 & ~((3<<22)|(3<<24)|(3<<26) ) )
	| ((2<<22)|(2<<24)|(2<<26) );*/
	  PINSEL1 &= 0xFFFFC03F;
    43cc:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
	for (i = 0; i < 0x1000; i++)
		;

	/* Disable all interrupts for now */
	MCI_MASK0 = 0;
	MCI_MASK1 = MCI_MASK0;
    43d0:	e58c3040 	str	r3, [ip, #64]
#warning EA,OMX23/Keil23
/*	PINSEL1 = ( PINSEL1 & ~( (3<<6)|(3<<8)|(3<<10)|(3<<12) ) )
	| ((2<<6)|(2<<8)|(2<<10)|(2<<12));
	PINSEL4 = ( PINSEL4 & ~((3<<22)|(3<<24)|(3<<26) ) )
	| ((2<<22)|(2<<24)|(2<<26) );*/
	  PINSEL1 &= 0xFFFFC03F;
    43d4:	e281190b 	add	r1, r1, #180224	; 0x2c000
    43d8:	e5913004 	ldr	r3, [r1, #4]
    43dc:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
    43e0:	e5813004 	str	r3, [r1, #4]
	  PINSEL1 |= 0x2A80;	/*Sets Clock, command,DAT0+ Power*/
    43e4:	e5912004 	ldr	r2, [r1, #4]
    43e8:	e3822daa 	orr	r2, r2, #10880	; 0x2a80
    43ec:	e5812004 	str	r2, [r1, #4]

	  PINSEL2 &=0xFD7F7FFF;
    43f0:	e5913008 	ldr	r3, [r1, #8]
    43f4:	e3c3350a 	bic	r3, r3, #41943040	; 0x2800000
    43f8:	e3c33902 	bic	r3, r3, #32768	; 0x8000
    43fc:	e5813008 	str	r3, [r1, #8]
	  PINSEL2 |=0x02808000;
    4400:	e5912008 	ldr	r2, [r1, #8]
    4404:	e382250a 	orr	r2, r2, #41943040	; 0x2800000
    4408:	e3822902 	orr	r2, r2, #32768	; 0x8000
    440c:	e5812008 	str	r2, [r1, #8]
	IODIR0 = 1 << 21; /* MCI_PWR as GPIO output */
	IOCLR0 = 1 << 21;
#endif
#else
	// #warning SCS MCIPWR active level low
	SCS &= ~0x08;
    4410:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
    4414:	e280097f 	add	r0, r0, #2080768	; 0x1fc000
    4418:	e59031a0 	ldr	r3, [r0, #416]
#endif

	/*set up clocking default mode, clear any registers as needed */
	MCI_COMMAND = 0;
	MCI_DATA_CTRL = 0;
	MCI_CLEAR = 0x7FF;
    441c:	e3a02e7f 	mov	r2, #2032	; 0x7f0
	IODIR0 = 1 << 21; /* MCI_PWR as GPIO output */
	IOCLR0 = 1 << 21;
#endif
#else
	// #warning SCS MCIPWR active level low
	SCS &= ~0x08;
    4420:	e3c33008 	bic	r3, r3, #8	; 0x8
    4424:	e58031a0 	str	r3, [r0, #416]
#endif

	/*set up clocking default mode, clear any registers as needed */
	MCI_COMMAND = 0;
	MCI_DATA_CTRL = 0;
	MCI_CLEAR = 0x7FF;
    4428:	e282200f 	add	r2, r2, #15	; 0xf
	/* clear all pending interrupts */

	MCI_POWER = 0x02;
    442c:	e3a03002 	mov	r3, #2	; 0x2
	PINSEL4 = 0x0A800000;
#endif
#endif

	/*set up clocking default mode, clear any registers as needed */
	MCI_COMMAND = 0;
    4430:	e58ce00c 	str	lr, [ip, #12]
	MCI_DATA_CTRL = 0;
    4434:	e58ce02c 	str	lr, [ip, #44]
	MCI_CLEAR = 0x7FF;
    4438:	e58c2038 	str	r2, [ip, #56]
	/* clear all pending interrupts */

	MCI_POWER = 0x02;
    443c:	e58c3000 	str	r3, [ip]
	/* power up */
	while ( !(MCI_POWER & 0x02)) {
    4440:	e59c3000 	ldr	r3, [ip]
    4444:	e3130002 	tst	r3, #2	; 0x2
    4448:	0afffffc 	beq	4440 <MCI_Init+0x118>
		;
	}
	for (i = 0; i < 0x100; i++) {
    444c:	e3a03000 	mov	r3, #0	; 0x0
    4450:	e50b3010 	str	r3, [fp, #-16]
    4454:	e51b2010 	ldr	r2, [fp, #-16]
    4458:	e35200ff 	cmp	r2, #255	; 0xff
    445c:	8a000005 	bhi	4478 <MCI_Init+0x150>
    4460:	e51b3010 	ldr	r3, [fp, #-16]
    4464:	e2833001 	add	r3, r3, #1	; 0x1
    4468:	e50b3010 	str	r3, [fp, #-16]
    446c:	e51b2010 	ldr	r2, [fp, #-16]
    4470:	e35200ff 	cmp	r2, #255	; 0xff
    4474:	9afffff9 	bls	4460 <MCI_Init+0x138>
	}

	/* During identification phase, the clock should be less than
	 400Khz. Once we pass this phase, the normal clock can be set up
	 to 25Mhz on SD card and 20Mhz on MMC card. */
	MCI_Set_MCIClock( SLOW_RATE);
    4478:	e3a00001 	mov	r0, #1	; 0x1
    447c:	ebfffa1b 	bl	2cf0 <MCI_Set_MCIClock>
	MCI_POWER |= 0x01;
    4480:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    4484:	e2822923 	add	r2, r2, #573440	; 0x8c000
    4488:	e5923000 	ldr	r3, [r2]
	/* bit 1 is set already, from power up to power on */

	for (i = 0; i < 0x2000; i++) {
    448c:	e3a01000 	mov	r1, #0	; 0x0

	/* During identification phase, the clock should be less than
	 400Khz. Once we pass this phase, the normal clock can be set up
	 to 25Mhz on SD card and 20Mhz on MMC card. */
	MCI_Set_MCIClock( SLOW_RATE);
	MCI_POWER |= 0x01;
    4490:	e3833001 	orr	r3, r3, #1	; 0x1
    4494:	e5823000 	str	r3, [r2]
	/* bit 1 is set already, from power up to power on */

	for (i = 0; i < 0x2000; i++) {
    4498:	e50b1010 	str	r1, [fp, #-16]
    449c:	e51b3010 	ldr	r3, [fp, #-16]
    44a0:	e3a02d7f 	mov	r2, #8128	; 0x1fc0
    44a4:	e282203f 	add	r2, r2, #63	; 0x3f
    44a8:	e1530002 	cmp	r3, r2
    44ac:	8a000006 	bhi	44cc <MCI_Init+0x1a4>
    44b0:	e1a01002 	mov	r1, r2
    44b4:	e51b3010 	ldr	r3, [fp, #-16]
    44b8:	e2833001 	add	r3, r3, #1	; 0x1
    44bc:	e50b3010 	str	r3, [fp, #-16]
    44c0:	e51b2010 	ldr	r2, [fp, #-16]
    44c4:	e1520001 	cmp	r2, r1
    44c8:	9afffff9 	bls	44b4 <MCI_Init+0x18c>
		;
	}
	if (install_irq( MCI_INT, (void *)MCI_IRQHandler, HIGHEST_PRIORITY+1) == FALSE) {
    44cc:	e59f1014 	ldr	r1, [pc, #20]	; 44e8 <MCI_Init+0x1c0>
    44d0:	e3a02002 	mov	r2, #2	; 0x2
    44d4:	e3a00018 	mov	r0, #24	; 0x18
    44d8:	ebfff0cf 	bl	81c <install_irq>
	 before WRITE_BLOCK only TX related data interrupts are enabled, and before
	 READ_BLOCK only RX related data interrupts are enabled. */

	mci_debug_printf("MCI_INIT ok\n");
	return ( TRUE );
}
    44dc:	e2500000 	subs	r0, r0, #0	; 0x0
    44e0:	13a00001 	movne	r0, #1	; 0x1
    44e4:	e89da808 	ldm	sp, {r3, fp, sp, pc}
    44e8:	00002998 	.word	0x00002998

000044ec <DMAHandler>:
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
void DMAHandler (void)
{
    44ec:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
    44f0:	e1a0c00d 	mov	ip, sp
    44f4:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
  DWORD regVal;
  static DWORD DMATCCount, DMAErrCount;

  regVal = GPDMA_INT_TCSTAT;
    44f8:	e3a00c4f 	mov	r0, #20224	; 0x4f00
    44fc:	e28000ff 	add	r0, r0, #255	; 0xff
    4500:	e1800a80 	orr	r0, r0, r0, lsl #21
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
void DMAHandler (void)
{
    4504:	e24cb004 	sub	fp, ip, #4	; 0x4
  DWORD regVal;
  static DWORD DMATCCount, DMAErrCount;

  regVal = GPDMA_INT_TCSTAT;
    4508:	e510cffb 	ldr	ip, [r0, #-4091]
  if ( regVal )
    450c:	e35c0000 	cmp	ip, #0	; 0x0
    4510:	0a000006 	beq	4530 <DMAHandler+0x44>
  {
	DMATCCount++;
    4514:	e59f3064 	ldr	r3, [pc, #100]	; 4580 <DMAHandler+0x94>
    4518:	e5932000 	ldr	r2, [r3]
    451c:	e2822001 	add	r2, r2, #1	; 0x1
    4520:	e5832000 	str	r2, [r3]
	GPDMA_INT_TCCLR |= regVal;
    4524:	e5101ff7 	ldr	r1, [r0, #-4087]
    4528:	e181100c 	orr	r1, r1, ip
    452c:	e5001ff7 	str	r1, [r0, #-4087]
  } 

  regVal = GPDMA_INT_ERR_STAT;
    4530:	e3a00c4f 	mov	r0, #20224	; 0x4f00
    4534:	e28000ff 	add	r0, r0, #255	; 0xff
    4538:	e1800a80 	orr	r0, r0, r0, lsl #21
    453c:	e510cff3 	ldr	ip, [r0, #-4083]
  if ( regVal )
    4540:	e35c0000 	cmp	ip, #0	; 0x0
    4544:	0a000006 	beq	4564 <DMAHandler+0x78>
  {
	DMAErrCount++;
    4548:	e59f3034 	ldr	r3, [pc, #52]	; 4584 <DMAHandler+0x98>
    454c:	e5932000 	ldr	r2, [r3]
    4550:	e2822001 	add	r2, r2, #1	; 0x1
    4554:	e5832000 	str	r2, [r3]
	GPDMA_INT_ERR_CLR |= regVal;
    4558:	e5101fef 	ldr	r1, [r0, #-4079]
    455c:	e181100c 	orr	r1, r1, ip
    4560:	e5001fef 	str	r1, [r0, #-4079]
  } 
  VICVectAddr = 0;		/* Acknowledge Interrupt */
    4564:	e3a02000 	mov	r2, #0	; 0x0
    4568:	e3e03000 	mvn	r3, #0	; 0x0
    456c:	e50320ff 	str	r2, [r3, #-255]
}
    4570:	e24bd01c 	sub	sp, fp, #28	; 0x1c
    4574:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
    4578:	e8bd1000 	pop	{ip}
    457c:	e25ef004 	subs	pc, lr, #4	; 0x4
    4580:	40000788 	.word	0x40000788
    4584:	40000784 	.word	0x40000784

00004588 <DMA_Move>:
** parameters:			Channel number, DMA mode			
** Returned value:		TRUE or FALSE		
** 
******************************************************************************/
DWORD DMA_Move( DWORD ChannelNum, DWORD DMAMode )
{
    4588:	e1a0c00d 	mov	ip, sp
  /* USB RAM is used for test.
  Please note, Ethernet has its own SRAM, but GPDMA can't access
  that. GPDMA can access USB SRAM and IRAM. Ethernet DMA controller can 
  access both IRAM and Ethernet SRAM. */
  if ( ChannelNum == 0 )
    458c:	e3500000 	cmp	r0, #0	; 0x0
** parameters:			Channel number, DMA mode			
** Returned value:		TRUE or FALSE		
** 
******************************************************************************/
DWORD DMA_Move( DWORD ChannelNum, DWORD DMAMode )
{
    4590:	e92dd800 	push	{fp, ip, lr, pc}
    4594:	e24cb004 	sub	fp, ip, #4	; 0x4
  /* USB RAM is used for test.
  Please note, Ethernet has its own SRAM, but GPDMA can't access
  that. GPDMA can access USB SRAM and IRAM. Ethernet DMA controller can 
  access both IRAM and Ethernet SRAM. */
  if ( ChannelNum == 0 )
    4598:	1a00001d 	bne	4614 <DMA_Move+0x8c>
  {
	GPDMA_INT_TCCLR = 0x01;   
    459c:	e3a00c4f 	mov	r0, #20224	; 0x4f00
    45a0:	e28000ff 	add	r0, r0, #255	; 0xff
    45a4:	e1800a80 	orr	r0, r0, r0, lsl #21
    45a8:	e3a03001 	mov	r3, #1	; 0x1
	GPDMA_INT_ERR_CLR = 0x01;
	if ( DMAMode == M2M )
    45ac:	e3510000 	cmp	r1, #0	; 0x0
  Please note, Ethernet has its own SRAM, but GPDMA can't access
  that. GPDMA can access USB SRAM and IRAM. Ethernet DMA controller can 
  access both IRAM and Ethernet SRAM. */
  if ( ChannelNum == 0 )
  {
	GPDMA_INT_TCCLR = 0x01;   
    45b0:	e5003ff7 	str	r3, [r0, #-4087]
	GPDMA_INT_ERR_CLR = 0x01;
    45b4:	e5003fef 	str	r3, [r0, #-4079]
	if ( DMAMode == M2M )
    45b8:	1a000019 	bne	4624 <DMA_Move+0x9c>
	{
	  /* Ch0 is set for M2M tranfer from AHB1 to AHB2 SRAM */
	  GPDMA_CH0_SRC = DMA_SRC;
	  GPDMA_CH0_DEST = DMA_DST;
    45bc:	e3a0347f 	mov	r3, #2130706432	; 0x7f000000
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x04 << 15) 
    45c0:	e2811323 	add	r1, r1, #-1946157056	; 0x8c000000
	GPDMA_INT_ERR_CLR = 0x01;
	if ( DMAMode == M2M )
	{
	  /* Ch0 is set for M2M tranfer from AHB1 to AHB2 SRAM */
	  GPDMA_CH0_SRC = DMA_SRC;
	  GPDMA_CH0_DEST = DMA_DST;
    45c4:	e283360d 	add	r3, r3, #13631488	; 0xd00000
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x04 << 15) 
    45c8:	e281184a 	add	r1, r1, #4849664	; 0x4a0000
	GPDMA_INT_TCCLR = 0x01;   
	GPDMA_INT_ERR_CLR = 0x01;
	if ( DMAMode == M2M )
	{
	  /* Ch0 is set for M2M tranfer from AHB1 to AHB2 SRAM */
	  GPDMA_CH0_SRC = DMA_SRC;
    45cc:	e3a0247f 	mov	r2, #2130706432	; 0x7f000000
    45d0:	e282260d 	add	r2, r2, #13631488	; 0xd00000
	  GPDMA_CH0_DEST = DMA_DST;
    45d4:	e2833a01 	add	r3, r3, #4096	; 0x1000
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x04 << 15) 
    45d8:	e2811c42 	add	r1, r1, #16896	; 0x4200
	GPDMA_INT_TCCLR = 0x01;   
	GPDMA_INT_ERR_CLR = 0x01;
	if ( DMAMode == M2M )
	{
	  /* Ch0 is set for M2M tranfer from AHB1 to AHB2 SRAM */
	  GPDMA_CH0_SRC = DMA_SRC;
    45dc:	e5002eff 	str	r2, [r0, #-3839]
	  GPDMA_CH0_DEST = DMA_DST;
    45e0:	e5003efb 	str	r3, [r0, #-3835]
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x04 << 15) 
    45e4:	e5001ef3 	str	r1, [r0, #-3827]
  else
  {
	return ( FALSE );
  }
	
  GPDMA_CONFIG = 0x01;	/* Enable DMA channels, little endian */
    45e8:	e3a03c4f 	mov	r3, #20224	; 0x4f00
    45ec:	e28330ff 	add	r3, r3, #255	; 0xff
    45f0:	e1833a83 	orr	r3, r3, r3, lsl #21
    45f4:	e3a02001 	mov	r2, #1	; 0x1
    45f8:	e5032fcf 	str	r2, [r3, #-4047]
  while ( !(GPDMA_CONFIG & 0x01) );    
    45fc:	e1a02003 	mov	r2, r3
    4600:	e5123fcf 	ldr	r3, [r2, #-4047]
    4604:	e3130001 	tst	r3, #1	; 0x1
    4608:	0afffffc 	beq	4600 <DMA_Move+0x78>
    460c:	e3a00001 	mov	r0, #1	; 0x1
    4610:	e89da800 	ldm	sp, {fp, sp, pc}
	else
	{
	  return ( FALSE );
	}
  }
  else if ( ChannelNum == 1 )
    4614:	e3500001 	cmp	r0, #1	; 0x1
    4618:	0a000012 	beq	4668 <DMA_Move+0xe0>
  {
	return ( FALSE );
  }
	
  GPDMA_CONFIG = 0x01;	/* Enable DMA channels, little endian */
  while ( !(GPDMA_CONFIG & 0x01) );    
    461c:	e3a00000 	mov	r0, #0	; 0x0
  return (TRUE);
}
    4620:	e89da800 	ldm	sp, {fp, sp, pc}
	  GPDMA_CH0_DEST = DMA_DST;
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x04 << 15) 
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | (1 << 27) | 0x80000000;	
	}
	else if ( DMAMode == M2P )
    4624:	e3510001 	cmp	r1, #1	; 0x1
    4628:	0a000022 	beq	46b8 <DMA_Move+0x130>
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | 0x80000000;
	}
	else if ( DMAMode == P2M )
    462c:	e3510002 	cmp	r1, #2	; 0x2
    4630:	1afffff9 	bne	461c <DMA_Move+0x94>
	{
	  /* Ch0 set for P2M transfer from MCI FIFO to memory. */
	  GPDMA_CH0_SRC = DMA_MCIFIFO;
    4634:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
	  GPDMA_CH0_DEST = DMA_DST;
    4638:	e3a0247f 	mov	r2, #2130706432	; 0x7f000000
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x02 << 12) | (0x04 << 15)
    463c:	e241139e 	sub	r1, r1, #2013265922	; 0x78000002
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | 0x80000000;
	}
	else if ( DMAMode == P2M )
	{
	  /* Ch0 set for P2M transfer from MCI FIFO to memory. */
	  GPDMA_CH0_SRC = DMA_MCIFIFO;
    4640:	e2833923 	add	r3, r3, #573440	; 0x8c000
	  GPDMA_CH0_DEST = DMA_DST;
    4644:	e282260d 	add	r2, r2, #13631488	; 0xd00000
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x02 << 12) | (0x04 << 15)
    4648:	e281184a 	add	r1, r1, #4849664	; 0x4a0000
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | 0x80000000;
	}
	else if ( DMAMode == P2M )
	{
	  /* Ch0 set for P2M transfer from MCI FIFO to memory. */
	  GPDMA_CH0_SRC = DMA_MCIFIFO;
    464c:	e2833080 	add	r3, r3, #128	; 0x80
	  GPDMA_CH0_DEST = DMA_DST;
    4650:	e2822a01 	add	r2, r2, #4096	; 0x1000
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x02 << 12) | (0x04 << 15)
    4654:	e2811c22 	add	r1, r1, #8704	; 0x2200
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | 0x80000000;
	}
	else if ( DMAMode == P2M )
	{
	  /* Ch0 set for P2M transfer from MCI FIFO to memory. */
	  GPDMA_CH0_SRC = DMA_MCIFIFO;
    4658:	e5003eff 	str	r3, [r0, #-3839]
	  GPDMA_CH0_DEST = DMA_DST;
    465c:	e5002efb 	str	r2, [r0, #-3835]
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x02 << 12) | (0x04 << 15)
    4660:	e5001ef3 	str	r1, [r0, #-3827]
    4664:	eaffffdf 	b	45e8 <DMA_Move+0x60>
	  return ( FALSE );
	}
  }
  else if ( ChannelNum == 1 )
  {   
	GPDMA_INT_TCCLR = 0x02;   
    4668:	e3a00c4f 	mov	r0, #20224	; 0x4f00
    466c:	e28000ff 	add	r0, r0, #255	; 0xff
    4670:	e1800a80 	orr	r0, r0, r0, lsl #21
    4674:	e3a03002 	mov	r3, #2	; 0x2
	GPDMA_INT_ERR_CLR = 0x02;
	if ( DMAMode == M2M )
    4678:	e3510000 	cmp	r1, #0	; 0x0
	  return ( FALSE );
	}
  }
  else if ( ChannelNum == 1 )
  {   
	GPDMA_INT_TCCLR = 0x02;   
    467c:	e5003ff7 	str	r3, [r0, #-4087]
	GPDMA_INT_ERR_CLR = 0x02;
    4680:	e5003fef 	str	r3, [r0, #-4079]
	if ( DMAMode == M2M )
    4684:	1a000017 	bne	46e8 <DMA_Move+0x160>
	{
	  /* Ch1 is set for M2M tranfer */
	  GPDMA_CH1_SRC = DMA_SRC;
	  GPDMA_CH1_DEST = DMA_DST;
    4688:	e3a0347f 	mov	r3, #2130706432	; 0x7f000000
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x04 << 15) 
    468c:	e2811323 	add	r1, r1, #-1946157056	; 0x8c000000
	GPDMA_INT_ERR_CLR = 0x02;
	if ( DMAMode == M2M )
	{
	  /* Ch1 is set for M2M tranfer */
	  GPDMA_CH1_SRC = DMA_SRC;
	  GPDMA_CH1_DEST = DMA_DST;
    4690:	e283360d 	add	r3, r3, #13631488	; 0xd00000
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x04 << 15) 
    4694:	e281184a 	add	r1, r1, #4849664	; 0x4a0000
	GPDMA_INT_TCCLR = 0x02;   
	GPDMA_INT_ERR_CLR = 0x02;
	if ( DMAMode == M2M )
	{
	  /* Ch1 is set for M2M tranfer */
	  GPDMA_CH1_SRC = DMA_SRC;
    4698:	e3a0247f 	mov	r2, #2130706432	; 0x7f000000
    469c:	e282260d 	add	r2, r2, #13631488	; 0xd00000
	  GPDMA_CH1_DEST = DMA_DST;
    46a0:	e2833a01 	add	r3, r3, #4096	; 0x1000
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x04 << 15) 
    46a4:	e2811c42 	add	r1, r1, #16896	; 0x4200
	GPDMA_INT_TCCLR = 0x02;   
	GPDMA_INT_ERR_CLR = 0x02;
	if ( DMAMode == M2M )
	{
	  /* Ch1 is set for M2M tranfer */
	  GPDMA_CH1_SRC = DMA_SRC;
    46a8:	e5002edf 	str	r2, [r0, #-3807]
	  GPDMA_CH1_DEST = DMA_DST;
    46ac:	e5003edb 	str	r3, [r0, #-3803]
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x04 << 15) 
    46b0:	e5001ed3 	str	r1, [r0, #-3795]
    46b4:	eaffffcb 	b	45e8 <DMA_Move+0x60>
	}
	else if ( DMAMode == M2P )
	{
	  /* Ch0 set for M2P transfer from mempry to MCI FIFO. */
	  GPDMA_CH0_SRC = DMA_SRC;
	  GPDMA_CH0_DEST = DMA_MCIFIFO;
    46b8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    46bc:	e241135f 	sub	r1, r1, #2080374785	; 0x7c000001
	}
	else if ( DMAMode == M2P )
	{
	  /* Ch0 set for M2P transfer from mempry to MCI FIFO. */
	  GPDMA_CH0_SRC = DMA_SRC;
	  GPDMA_CH0_DEST = DMA_MCIFIFO;
    46c0:	e2833923 	add	r3, r3, #573440	; 0x8c000
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    46c4:	e2811849 	add	r1, r1, #4784128	; 0x490000
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | (1 << 27) | 0x80000000;	
	}
	else if ( DMAMode == M2P )
	{
	  /* Ch0 set for M2P transfer from mempry to MCI FIFO. */
	  GPDMA_CH0_SRC = DMA_SRC;
    46c8:	e3a0247f 	mov	r2, #2130706432	; 0x7f000000
    46cc:	e282260d 	add	r2, r2, #13631488	; 0xd00000
	  GPDMA_CH0_DEST = DMA_MCIFIFO;
    46d0:	e2833080 	add	r3, r3, #128	; 0x80
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    46d4:	e2811c42 	add	r1, r1, #16896	; 0x4200
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | (1 << 27) | 0x80000000;	
	}
	else if ( DMAMode == M2P )
	{
	  /* Ch0 set for M2P transfer from mempry to MCI FIFO. */
	  GPDMA_CH0_SRC = DMA_SRC;
    46d8:	e5002eff 	str	r2, [r0, #-3839]
	  GPDMA_CH0_DEST = DMA_MCIFIFO;
    46dc:	e5003efb 	str	r3, [r0, #-3835]
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH0_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    46e0:	e5001ef3 	str	r1, [r0, #-3827]
    46e4:	eaffffbf 	b	45e8 <DMA_Move+0x60>
	  GPDMA_CH1_DEST = DMA_DST;
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x04 << 15) 
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | (1 << 27) | 0x80000000;	
	}
	else if ( DMAMode == M2P )
    46e8:	e3510001 	cmp	r1, #1	; 0x1
    46ec:	0a00000e 	beq	472c <DMA_Move+0x1a4>
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | 0x80000000;
	}
	else if ( DMAMode == P2M )
    46f0:	e3510002 	cmp	r1, #2	; 0x2
    46f4:	1affffc8 	bne	461c <DMA_Move+0x94>
	{
	  /* Ch1 set for P2M transfer from MCI_FIFO to memory. */
	  GPDMA_CH1_SRC = DMA_MCIFIFO;
    46f8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
	  GPDMA_CH1_DEST = DMA_DST;
    46fc:	e3a0247f 	mov	r2, #2130706432	; 0x7f000000
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x02 << 12) | (0x04 << 15)
    4700:	e241139e 	sub	r1, r1, #2013265922	; 0x78000002
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | 0x80000000;
	}
	else if ( DMAMode == P2M )
	{
	  /* Ch1 set for P2M transfer from MCI_FIFO to memory. */
	  GPDMA_CH1_SRC = DMA_MCIFIFO;
    4704:	e2833923 	add	r3, r3, #573440	; 0x8c000
	  GPDMA_CH1_DEST = DMA_DST;
    4708:	e282260d 	add	r2, r2, #13631488	; 0xd00000
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x02 << 12) | (0x04 << 15)
    470c:	e281184a 	add	r1, r1, #4849664	; 0x4a0000
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | 0x80000000;
	}
	else if ( DMAMode == P2M )
	{
	  /* Ch1 set for P2M transfer from MCI_FIFO to memory. */
	  GPDMA_CH1_SRC = DMA_MCIFIFO;
    4710:	e2833080 	add	r3, r3, #128	; 0x80
	  GPDMA_CH1_DEST = DMA_DST;
    4714:	e2822a01 	add	r2, r2, #4096	; 0x1000
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x02 << 12) | (0x04 << 15)
    4718:	e2811c22 	add	r1, r1, #8704	; 0x2200
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | 0x80000000;
	}
	else if ( DMAMode == P2M )
	{
	  /* Ch1 set for P2M transfer from MCI_FIFO to memory. */
	  GPDMA_CH1_SRC = DMA_MCIFIFO;
    471c:	e5003edf 	str	r3, [r0, #-3807]
	  GPDMA_CH1_DEST = DMA_DST;
    4720:	e5002edb 	str	r2, [r0, #-3803]
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x02 << 12) | (0x04 << 15)
    4724:	e5001ed3 	str	r1, [r0, #-3795]
    4728:	eaffffae 	b	45e8 <DMA_Move+0x60>
	}
	else if ( DMAMode == M2P )
	{
	  /* Ch1 set for M2P transfer from memory to MCI FIFO. */
	  GPDMA_CH1_SRC = DMA_SRC;
	  GPDMA_CH1_DEST = DMA_MCIFIFO;
    472c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    4730:	e241135f 	sub	r1, r1, #2080374785	; 0x7c000001
	}
	else if ( DMAMode == M2P )
	{
	  /* Ch1 set for M2P transfer from memory to MCI FIFO. */
	  GPDMA_CH1_SRC = DMA_SRC;
	  GPDMA_CH1_DEST = DMA_MCIFIFO;
    4734:	e2833923 	add	r3, r3, #573440	; 0x8c000
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    4738:	e2811849 	add	r1, r1, #4784128	; 0x490000
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | (1 << 27) | 0x80000000;	
	}
	else if ( DMAMode == M2P )
	{
	  /* Ch1 set for M2P transfer from memory to MCI FIFO. */
	  GPDMA_CH1_SRC = DMA_SRC;
    473c:	e3a0247f 	mov	r2, #2130706432	; 0x7f000000
    4740:	e282260d 	add	r2, r2, #13631488	; 0xd00000
	  GPDMA_CH1_DEST = DMA_MCIFIFO;
    4744:	e2833080 	add	r3, r3, #128	; 0x80
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    4748:	e2811c42 	add	r1, r1, #16896	; 0x4200
			| (0x02 << 18) | (0x02 << 21) | (1 << 26) | (1 << 27) | 0x80000000;	
	}
	else if ( DMAMode == M2P )
	{
	  /* Ch1 set for M2P transfer from memory to MCI FIFO. */
	  GPDMA_CH1_SRC = DMA_SRC;
    474c:	e5002edf 	str	r2, [r0, #-3807]
	  GPDMA_CH1_DEST = DMA_MCIFIFO;
    4750:	e5003edb 	str	r3, [r0, #-3803]
	  /* The burst size is set to 8, the size is 8 bit too. */
	  /* Terminal Count Int enable */
	  GPDMA_CH1_CTRL = (DMA_SIZE & 0x0FFF) | (0x04 << 12) | (0x02 << 15)
    4754:	e5001ed3 	str	r1, [r0, #-3795]
    4758:	eaffffa2 	b	45e8 <DMA_Move+0x60>

0000475c <DMA_Init>:
** Returned value:		TRUE or FALSE, FALSE if ISR can't be installed.		
** 
******************************************************************************/
DWORD DMA_Init(void)
{
  PCONP |= (1 << 29);	/* Enable GPDMA clock */
    475c:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
    4760:	e281197f 	add	r1, r1, #2080768	; 0x1fc000
    4764:	e59120c4 	ldr	r2, [r1, #196]

  /* clear all interrupts on channel 0 and 1 */
  GPDMA_INT_TCCLR = 0x03;
    4768:	e3a03c4f 	mov	r3, #20224	; 0x4f00
** Returned value:		TRUE or FALSE, FALSE if ISR can't be installed.		
** 
******************************************************************************/
DWORD DMA_Init(void)
{
  PCONP |= (1 << 29);	/* Enable GPDMA clock */
    476c:	e3822202 	orr	r2, r2, #536870912	; 0x20000000

  /* clear all interrupts on channel 0 and 1 */
  GPDMA_INT_TCCLR = 0x03;
    4770:	e28330ff 	add	r3, r3, #255	; 0xff
    4774:	e1833a83 	orr	r3, r3, r3, lsl #21
** Returned value:		TRUE or FALSE, FALSE if ISR can't be installed.		
** 
******************************************************************************/
DWORD DMA_Init(void)
{
  PCONP |= (1 << 29);	/* Enable GPDMA clock */
    4778:	e58120c4 	str	r2, [r1, #196]
** parameters:			None			
** Returned value:		TRUE or FALSE, FALSE if ISR can't be installed.		
** 
******************************************************************************/
DWORD DMA_Init(void)
{
    477c:	e1a0c00d 	mov	ip, sp
  PCONP |= (1 << 29);	/* Enable GPDMA clock */

  /* clear all interrupts on channel 0 and 1 */
  GPDMA_INT_TCCLR = 0x03;
    4780:	e3a00003 	mov	r0, #3	; 0x3
  GPDMA_INT_ERR_CLR = 0x03;

  GPDMA_CONFIG = 0x01;	/* Enable DMA channels, little endian */
    4784:	e3a02001 	mov	r2, #1	; 0x1
DWORD DMA_Init(void)
{
  PCONP |= (1 << 29);	/* Enable GPDMA clock */

  /* clear all interrupts on channel 0 and 1 */
  GPDMA_INT_TCCLR = 0x03;
    4788:	e5030ff7 	str	r0, [r3, #-4087]
** parameters:			None			
** Returned value:		TRUE or FALSE, FALSE if ISR can't be installed.		
** 
******************************************************************************/
DWORD DMA_Init(void)
{
    478c:	e92dd800 	push	{fp, ip, lr, pc}
  PCONP |= (1 << 29);	/* Enable GPDMA clock */

  /* clear all interrupts on channel 0 and 1 */
  GPDMA_INT_TCCLR = 0x03;
  GPDMA_INT_ERR_CLR = 0x03;
    4790:	e5030fef 	str	r0, [r3, #-4079]
** parameters:			None			
** Returned value:		TRUE or FALSE, FALSE if ISR can't be installed.		
** 
******************************************************************************/
DWORD DMA_Init(void)
{
    4794:	e24cb004 	sub	fp, ip, #4	; 0x4

  /* clear all interrupts on channel 0 and 1 */
  GPDMA_INT_TCCLR = 0x03;
  GPDMA_INT_ERR_CLR = 0x03;

  GPDMA_CONFIG = 0x01;	/* Enable DMA channels, little endian */
    4798:	e5032fcf 	str	r2, [r3, #-4047]
  while ( !(GPDMA_CONFIG & 0x01) );    
    479c:	e1a02003 	mov	r2, r3
    47a0:	e5123fcf 	ldr	r3, [r2, #-4047]
    47a4:	e3130001 	tst	r3, #1	; 0x1
    47a8:	0afffffc 	beq	47a0 <DMA_Init+0x44>
		
  if ( install_irq( GPDMA_INT, (void *)DMAHandler, HIGHEST_PRIORITY ) == FALSE )
    47ac:	e59f1014 	ldr	r1, [pc, #20]	; 47c8 <DMA_Init+0x6c>
    47b0:	e3a02001 	mov	r2, #1	; 0x1
    47b4:	e3a00019 	mov	r0, #25	; 0x19
    47b8:	ebfff017 	bl	81c <install_irq>
  {
	return( FALSE );
  }
  return( TRUE );
}   
    47bc:	e2500000 	subs	r0, r0, #0	; 0x0
    47c0:	13a00001 	movne	r0, #1	; 0x1
    47c4:	e89da800 	ldm	sp, {fp, sp, pc}
    47c8:	000044ec 	.word	0x000044ec

000047cc <writeToSDCard>:
	long p1=7;				/* read(1) write(2) create(4)*/
	put_rc(f_open(&file1, "size.bin", (BYTE)p1));
	put_rc(f_open(&file2, "video.bin", (BYTE)p1));
}
void writeToSDCard(int size)
{
    47cc:	e1a0c00d 	mov	ip, sp
    47d0:	e92dd810 	push	{r4, fp, ip, lr, pc}
    47d4:	e24cb004 	sub	fp, ip, #4	; 0x4
    47d8:	e24dd004 	sub	sp, sp, #4	; 0x4
    47dc:	e24b1010 	sub	r1, fp, #16	; 0x10
	//BYTE *data = (BYTE*)0x80000000;
	BYTE *data = (BYTE*)0x40004000;
	f_write(&file1, &size, sizeof(int), &s2);
    47e0:	e3a02004 	mov	r2, #4	; 0x4
	long p1=7;				/* read(1) write(2) create(4)*/
	put_rc(f_open(&file1, "size.bin", (BYTE)p1));
	put_rc(f_open(&file2, "video.bin", (BYTE)p1));
}
void writeToSDCard(int size)
{
    47e4:	e5210004 	str	r0, [r1, #-4]!
	//BYTE *data = (BYTE*)0x80000000;
	BYTE *data = (BYTE*)0x40004000;
	f_write(&file1, &size, sizeof(int), &s2);
    47e8:	e59f3060 	ldr	r3, [pc, #96]	; 4850 <writeToSDCard+0x84>
    47ec:	e59f0060 	ldr	r0, [pc, #96]	; 4854 <writeToSDCard+0x88>
    47f0:	ebfff2e5 	bl	138c <f_write>
	while (size>512)	{
    47f4:	e51b2014 	ldr	r2, [fp, #-20]
    47f8:	e3520c02 	cmp	r2, #512	; 0x200
    47fc:	d3a04101 	movle	r4, #1073741824	; 0x40000000
    4800:	d2844901 	addle	r4, r4, #16384	; 0x4000
    4804:	da00000c 	ble	483c <writeToSDCard+0x70>
    4808:	e3a04101 	mov	r4, #1073741824	; 0x40000000
    480c:	e2844901 	add	r4, r4, #16384	; 0x4000
		f_write(&file2, data, 512, &s2);
    4810:	e1a01004 	mov	r1, r4
    4814:	e3a02c02 	mov	r2, #512	; 0x200
    4818:	e59f3030 	ldr	r3, [pc, #48]	; 4850 <writeToSDCard+0x84>
    481c:	e59f0034 	ldr	r0, [pc, #52]	; 4858 <writeToSDCard+0x8c>
    4820:	ebfff2d9 	bl	138c <f_write>
		data+=512;
		size=size-512;
    4824:	e51b3014 	ldr	r3, [fp, #-20]
    4828:	e2432c02 	sub	r2, r3, #512	; 0x200
void writeToSDCard(int size)
{
	//BYTE *data = (BYTE*)0x80000000;
	BYTE *data = (BYTE*)0x40004000;
	f_write(&file1, &size, sizeof(int), &s2);
	while (size>512)	{
    482c:	e3520c02 	cmp	r2, #512	; 0x200
		f_write(&file2, data, 512, &s2);
		data+=512;
    4830:	e2844c02 	add	r4, r4, #512	; 0x200
		size=size-512;
    4834:	e50b2014 	str	r2, [fp, #-20]
void writeToSDCard(int size)
{
	//BYTE *data = (BYTE*)0x80000000;
	BYTE *data = (BYTE*)0x40004000;
	f_write(&file1, &size, sizeof(int), &s2);
	while (size>512)	{
    4838:	cafffff4 	bgt	4810 <writeToSDCard+0x44>
		f_write(&file2, data, 512, &s2);
		data+=512;
		size=size-512;
	}
	f_write(&file2, data, size, &s2);
    483c:	e1a01004 	mov	r1, r4
    4840:	e59f3008 	ldr	r3, [pc, #8]	; 4850 <writeToSDCard+0x84>
    4844:	e59f000c 	ldr	r0, [pc, #12]	; 4858 <writeToSDCard+0x8c>
    4848:	ebfff2cf 	bl	138c <f_write>

}
    484c:	e89da818 	ldm	sp, {r3, r4, fp, sp, pc}
    4850:	40000278 	.word	0x40000278
    4854:	4000027c 	.word	0x4000027c
    4858:	40000054 	.word	0x40000054

0000485c <put_rc>:
#include "FAT.h"
FATFS fatfs[_DRIVES];
FIL file1, file2;		/* File objects */
UINT s2;				/* not used */
void put_rc (FRESULT rc)
{
    485c:	e1a0c00d 	mov	ip, sp
		"OK\0" "NOT_READY\0" "NO_FILE\0" "FR_NO_PATH\0" "INVALID_NAME\0" "INVALID_DRIVE\0"
		"DENIED\0" "EXIST\0" "RW_ERROR\0" "WRITE_PROTECTED\0" "NOT_ENABLED\0"
		"NO_FILESYSTEM\0" "INVALID_OBJECT\0" "MKFS_ABORTED\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && *p; i++) {
    4860:	e3500000 	cmp	r0, #0	; 0x0
#include "FAT.h"
FATFS fatfs[_DRIVES];
FIL file1, file2;		/* File objects */
UINT s2;				/* not used */
void put_rc (FRESULT rc)
{
    4864:	e92dd800 	push	{fp, ip, lr, pc}
		"OK\0" "NOT_READY\0" "NO_FILE\0" "FR_NO_PATH\0" "INVALID_NAME\0" "INVALID_DRIVE\0"
		"DENIED\0" "EXIST\0" "RW_ERROR\0" "WRITE_PROTECTED\0" "NOT_ENABLED\0"
		"NO_FILESYSTEM\0" "INVALID_OBJECT\0" "MKFS_ABORTED\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && *p; i++) {
    4868:	059f2048 	ldreq	r2, [pc, #72]	; 48b8 <put_rc+0x5c>
#include "FAT.h"
FATFS fatfs[_DRIVES];
FIL file1, file2;		/* File objects */
UINT s2;				/* not used */
void put_rc (FRESULT rc)
{
    486c:	e24cb004 	sub	fp, ip, #4	; 0x4
		"OK\0" "NOT_READY\0" "NO_FILE\0" "FR_NO_PATH\0" "INVALID_NAME\0" "INVALID_DRIVE\0"
		"DENIED\0" "EXIST\0" "RW_ERROR\0" "WRITE_PROTECTED\0" "NOT_ENABLED\0"
		"NO_FILESYSTEM\0" "INVALID_OBJECT\0" "MKFS_ABORTED\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && *p; i++) {
    4870:	0a00000c 	beq	48a8 <put_rc+0x4c>
    4874:	e59f203c 	ldr	r2, [pc, #60]	; 48b8 <put_rc+0x5c>
    4878:	e3a0304f 	mov	r3, #79	; 0x4f
    487c:	e3a0c000 	mov	ip, #0	; 0x0
		while(*p++);
    4880:	e3530000 	cmp	r3, #0	; 0x0
    4884:	e2822001 	add	r2, r2, #1	; 0x1
    4888:	15d23000 	ldrbne	r3, [r2]
    488c:	1afffffb 	bne	4880 <put_rc+0x24>
		"OK\0" "NOT_READY\0" "NO_FILE\0" "FR_NO_PATH\0" "INVALID_NAME\0" "INVALID_DRIVE\0"
		"DENIED\0" "EXIST\0" "RW_ERROR\0" "WRITE_PROTECTED\0" "NOT_ENABLED\0"
		"NO_FILESYSTEM\0" "INVALID_OBJECT\0" "MKFS_ABORTED\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && *p; i++) {
    4890:	e28cc001 	add	ip, ip, #1	; 0x1
    4894:	e150000c 	cmp	r0, ip
    4898:	0a000002 	beq	48a8 <put_rc+0x4c>
    489c:	e5d23000 	ldrb	r3, [r2]
    48a0:	e3530000 	cmp	r3, #0	; 0x0
    48a4:	1afffff5 	bne	4880 <put_rc+0x24>
		while(*p++);
	}
	xprintf("\nrc=%u FR_%s", (UINT)rc, p);
    48a8:	e1a01000 	mov	r1, r0
    48ac:	e59f0008 	ldr	r0, [pc, #8]	; 48bc <put_rc+0x60>
}
    48b0:	e89d6800 	ldm	sp, {fp, sp, lr}
	FRESULT i;

	for (p = str, i = 0; i != rc && *p; i++) {
		while(*p++);
	}
	xprintf("\nrc=%u FR_%s", (UINT)rc, p);
    48b4:	eaffeef9 	b	4a0 <xprintf>
    48b8:	0000570c 	.word	0x0000570c
    48bc:	000056d4 	.word	0x000056d4

000048c0 <closeFile>:
	}
	f_write(&file2, data, size, &s2);

}
void closeFile()
{
    48c0:	e1a0c00d 	mov	ip, sp
    48c4:	e92dd800 	push	{fp, ip, lr, pc}
	put_rc(f_close(&file1));
    48c8:	e59f0018 	ldr	r0, [pc, #24]	; 48e8 <closeFile+0x28>
	}
	f_write(&file2, data, size, &s2);

}
void closeFile()
{
    48cc:	e24cb004 	sub	fp, ip, #4	; 0x4
	put_rc(f_close(&file1));
    48d0:	ebfff2a5 	bl	136c <f_close>
    48d4:	ebffffe0 	bl	485c <put_rc>
	put_rc(f_close(&file2));
    48d8:	e59f000c 	ldr	r0, [pc, #12]	; 48ec <closeFile+0x2c>
    48dc:	ebfff2a2 	bl	136c <f_close>
}
    48e0:	e89d6800 	ldm	sp, {fp, sp, lr}

}
void closeFile()
{
	put_rc(f_close(&file1));
	put_rc(f_close(&file2));
    48e4:	eaffffdc 	b	485c <put_rc>
    48e8:	4000027c 	.word	0x4000027c
    48ec:	40000054 	.word	0x40000054

000048f0 <SDOpenVideo>:
	put_rc(f_unlink("snapshot.jpg"));
	long p1=7;				/* read(1) write(2) create(4)*/
	put_rc(f_open(&file2, "snapshot.jpg", (BYTE)p1));
}
void SDOpenVideo()
{
    48f0:	e1a0c00d 	mov	ip, sp
    48f4:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
	put_rc(f_unlink("size.bin"));
    48f8:	e59f4048 	ldr	r4, [pc, #72]	; 4948 <SDOpenVideo+0x58>
	put_rc(f_unlink("snapshot.jpg"));
	long p1=7;				/* read(1) write(2) create(4)*/
	put_rc(f_open(&file2, "snapshot.jpg", (BYTE)p1));
}
void SDOpenVideo()
{
    48fc:	e24cb004 	sub	fp, ip, #4	; 0x4
	put_rc(f_unlink("size.bin"));
	put_rc(f_unlink("video.bin"));
    4900:	e59f5044 	ldr	r5, [pc, #68]	; 494c <SDOpenVideo+0x5c>
	long p1=7;				/* read(1) write(2) create(4)*/
	put_rc(f_open(&file2, "snapshot.jpg", (BYTE)p1));
}
void SDOpenVideo()
{
	put_rc(f_unlink("size.bin"));
    4904:	e1a00004 	mov	r0, r4
    4908:	ebfff530 	bl	1dd0 <f_unlink>
    490c:	ebffffd2 	bl	485c <put_rc>
	put_rc(f_unlink("video.bin"));
    4910:	e1a00005 	mov	r0, r5
    4914:	ebfff52d 	bl	1dd0 <f_unlink>
    4918:	ebffffcf 	bl	485c <put_rc>
	long p1=7;				/* read(1) write(2) create(4)*/
	put_rc(f_open(&file1, "size.bin", (BYTE)p1));
    491c:	e1a01004 	mov	r1, r4
    4920:	e3a02007 	mov	r2, #7	; 0x7
    4924:	e59f0024 	ldr	r0, [pc, #36]	; 4950 <SDOpenVideo+0x60>
    4928:	ebfff58c 	bl	1f60 <f_open>
    492c:	ebffffca 	bl	485c <put_rc>
	put_rc(f_open(&file2, "video.bin", (BYTE)p1));
    4930:	e1a01005 	mov	r1, r5
    4934:	e3a02007 	mov	r2, #7	; 0x7
    4938:	e59f0014 	ldr	r0, [pc, #20]	; 4954 <SDOpenVideo+0x64>
    493c:	ebfff587 	bl	1f60 <f_open>
}
    4940:	e89d6830 	ldm	sp, {r4, r5, fp, sp, lr}
{
	put_rc(f_unlink("size.bin"));
	put_rc(f_unlink("video.bin"));
	long p1=7;				/* read(1) write(2) create(4)*/
	put_rc(f_open(&file1, "size.bin", (BYTE)p1));
	put_rc(f_open(&file2, "video.bin", (BYTE)p1));
    4944:	eaffffc4 	b	485c <put_rc>
    4948:	000056e4 	.word	0x000056e4
    494c:	000056f0 	.word	0x000056f0
    4950:	4000027c 	.word	0x4000027c
    4954:	40000054 	.word	0x40000054

00004958 <SDOpenSnapshot>:
	long p1=0;
	put_rc(f_mount((BYTE)p1, &fatfs[p1]));

}
void SDOpenSnapshot()
{
    4958:	e1a0c00d 	mov	ip, sp
    495c:	e92dd810 	push	{r4, fp, ip, lr, pc}
	put_rc(f_unlink("snapshot.jpg"));
    4960:	e59f4024 	ldr	r4, [pc, #36]	; 498c <SDOpenSnapshot+0x34>
	long p1=0;
	put_rc(f_mount((BYTE)p1, &fatfs[p1]));

}
void SDOpenSnapshot()
{
    4964:	e24cb004 	sub	fp, ip, #4	; 0x4
	put_rc(f_unlink("snapshot.jpg"));
    4968:	e1a00004 	mov	r0, r4
    496c:	ebfff517 	bl	1dd0 <f_unlink>
    4970:	ebffffb9 	bl	485c <put_rc>
	long p1=7;				/* read(1) write(2) create(4)*/
	put_rc(f_open(&file2, "snapshot.jpg", (BYTE)p1));
    4974:	e1a01004 	mov	r1, r4
    4978:	e3a02007 	mov	r2, #7	; 0x7
    497c:	e59f000c 	ldr	r0, [pc, #12]	; 4990 <SDOpenSnapshot+0x38>
    4980:	ebfff576 	bl	1f60 <f_open>
}
    4984:	e89d6810 	ldm	sp, {r4, fp, sp, lr}
}
void SDOpenSnapshot()
{
	put_rc(f_unlink("snapshot.jpg"));
	long p1=7;				/* read(1) write(2) create(4)*/
	put_rc(f_open(&file2, "snapshot.jpg", (BYTE)p1));
    4988:	eaffffb3 	b	485c <put_rc>
    498c:	000056fc 	.word	0x000056fc
    4990:	40000054 	.word	0x40000054

00004994 <initSDCard>:
		while(*p++);
	}
	xprintf("\nrc=%u FR_%s", (UINT)rc, p);
}
void initSDCard()//fi 0 (force initialize 0)
{
    4994:	e1a0c00d 	mov	ip, sp
    4998:	e92dd800 	push	{fp, ip, lr, pc}
	long p1=0;
	put_rc(f_mount((BYTE)p1, &fatfs[p1]));
    499c:	e59f1010 	ldr	r1, [pc, #16]	; 49b4 <initSDCard+0x20>
		while(*p++);
	}
	xprintf("\nrc=%u FR_%s", (UINT)rc, p);
}
void initSDCard()//fi 0 (force initialize 0)
{
    49a0:	e24cb004 	sub	fp, ip, #4	; 0x4
	long p1=0;
	put_rc(f_mount((BYTE)p1, &fatfs[p1]));
    49a4:	e3a00000 	mov	r0, #0	; 0x0
    49a8:	ebffefc2 	bl	8b8 <f_mount>

}
    49ac:	e89d6800 	ldm	sp, {fp, sp, lr}
	xprintf("\nrc=%u FR_%s", (UINT)rc, p);
}
void initSDCard()//fi 0 (force initialize 0)
{
	long p1=0;
	put_rc(f_mount((BYTE)p1, &fatfs[p1]));
    49b0:	eaffffa9 	b	485c <put_rc>
    49b4:	400004a0 	.word	0x400004a0

000049b8 <SPIInit>:
**				can't be installed correctly, return false.
** 
*****************************************************************************/
DWORD SPIInit( void )
{
  TxCounter = 0;
    49b8:	e59f30b0 	ldr	r3, [pc, #176]	; 4a70 <SPIInit+0xb8>
    49bc:	e3a01000 	mov	r1, #0	; 0x0
    49c0:	e5831000 	str	r1, [r3]
  PCONP |= (1 << 8);	/* by default, it's enabled already, for safety reason */
    49c4:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
    49c8:	e280297f 	add	r2, r0, #2080768	; 0x1fc000
    49cc:	e59230c4 	ldr	r3, [r2, #196]
** Returned value:		true or false, if the interrupt handler
**				can't be installed correctly, return false.
** 
*****************************************************************************/
DWORD SPIInit( void )
{
    49d0:	e1a0c00d 	mov	ip, sp
    49d4:	e92dd800 	push	{fp, ip, lr, pc}
  TxCounter = 0;
  PCONP |= (1 << 8);	/* by default, it's enabled already, for safety reason */
    49d8:	e3833c01 	orr	r3, r3, #256	; 0x100
** Returned value:		true or false, if the interrupt handler
**				can't be installed correctly, return false.
** 
*****************************************************************************/
DWORD SPIInit( void )
{
    49dc:	e24cb004 	sub	fp, ip, #4	; 0x4
  TxCounter = 0;
  PCONP |= (1 << 8);	/* by default, it's enabled already, for safety reason */

  S0SPCR = 0x00;
    49e0:	e280c802 	add	ip, r0, #131072	; 0x20000
** 
*****************************************************************************/
DWORD SPIInit( void )
{
  TxCounter = 0;
  PCONP |= (1 << 8);	/* by default, it's enabled already, for safety reason */
    49e4:	e58230c4 	str	r3, [r2, #196]

  S0SPCR = 0x00;
    49e8:	e58c1000 	str	r1, [ip]
  /* Port 0.15 SPI SCK, port0.16 uses GPIO SPI_SEL, 
  port0.17 MISO, port0.18 MOSI */
  PCLKSEL0= PCLKSEL0+0x00010000;
    49ec:	e59231a8 	ldr	r3, [r2, #424]
    49f0:	e2833801 	add	r3, r3, #65536	; 0x10000
    49f4:	e58231a8 	str	r3, [r2, #424]
  PINSEL0 |= 0xC0000000;
    49f8:	e280190b 	add	r1, r0, #180224	; 0x2c000
    49fc:	e5913000 	ldr	r3, [r1]
    4a00:	e3833103 	orr	r3, r3, #-1073741824	; 0xc0000000
    4a04:	e5813000 	str	r3, [r1]
  PINSEL1 |= 0x0000003C;
    4a08:	e5912004 	ldr	r2, [r1, #4]
    4a0c:	e382203c 	orr	r2, r2, #60	; 0x3c
    4a10:	e5812004 	str	r2, [r1, #4]
  PINMODE0 |= 0x80000000;
    4a14:	e5913040 	ldr	r3, [r1, #64]
    4a18:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
    4a1c:	e5813040 	str	r3, [r1, #64]
  PINMODE1 |= 0x00000028;
    4a20:	e5912044 	ldr	r2, [r1, #68]
    4a24:	e3822028 	orr	r2, r2, #40	; 0x28
    4a28:	e5812044 	str	r2, [r1, #68]
  //PINSEL1 = PINSEL1&0xFFFC3FFF;
  IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    4a2c:	e280090a 	add	r0, r0, #163840	; 0x28000
    4a30:	e5903008 	ldr	r3, [r0, #8]
    4a34:	e3c33506 	bic	r3, r3, #25165824	; 0x1800000
    4a38:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    4a3c:	e5803008 	str	r3, [r0, #8]
  IOPIN0 &= ~0x1000000;
    4a40:	e5902000 	ldr	r2, [r0]
    4a44:	e3c22401 	bic	r2, r2, #16777216	; 0x1000000
    4a48:	e5802000 	str	r2, [r0]
  IOPIN0 = IOPIN0 +0x1000000;
    4a4c:	e5903000 	ldr	r3, [r0]
    4a50:	e2833401 	add	r3, r3, #16777216	; 0x1000000
    4a54:	e5803000 	str	r3, [r0]

  /* Setting SPI0 clock, for Atmel SEEPROM, SPI clock should be no more 
  than 3Mhz on 4.5V~5.5V, no more than 2.1Mhz on 2.7V~5.5V */
  S0SPCCR = 8;
    4a58:	e3a02008 	mov	r2, #8	; 0x8
//	return (FALSE);
//  }
  /* 8 bit, CPOL=CPHA=0, master mode, MSB first, interrupt enabled */
  S0SPCR = SPI0_SPIE | SPI0_MSTR;
#else
  S0SPCR = SPI0_MSTR;
    4a5c:	e3a03020 	mov	r3, #32	; 0x20
  IOPIN0 &= ~0x1000000;
  IOPIN0 = IOPIN0 +0x1000000;

  /* Setting SPI0 clock, for Atmel SEEPROM, SPI clock should be no more 
  than 3Mhz on 4.5V~5.5V, no more than 2.1Mhz on 2.7V~5.5V */
  S0SPCCR = 8;
    4a60:	e58c200c 	str	r2, [ip, #12]
  S0SPCR = SPI0_SPIE | SPI0_MSTR;
#else
  S0SPCR = SPI0_MSTR;
#endif
  return( TRUE );
}
    4a64:	e3a00001 	mov	r0, #1	; 0x1
//	return (FALSE);
//  }
  /* 8 bit, CPOL=CPHA=0, master mode, MSB first, interrupt enabled */
  S0SPCR = SPI0_SPIE | SPI0_MSTR;
#else
  S0SPCR = SPI0_MSTR;
    4a68:	e58c3000 	str	r3, [ip]
#endif
  return( TRUE );
}
    4a6c:	e89da800 	ldm	sp, {fp, sp, pc}
    4a70:	4000078c 	.word	0x4000078c

00004a74 <SPISend>:
** parameters:			buffer pointer, and the block length
** Returned value:		None
** 
*****************************************************************************/
void SPISend( BYTE *buf, DWORD Length )
{
    4a74:	e1a0c00d 	mov	ip, sp
    4a78:	e92dd9f0 	push	{r4, r5, r6, r7, r8, fp, ip, lr, pc}
    4a7c:	e24cb004 	sub	fp, ip, #4	; 0x4
  DWORD i;
  recvI=0;
  IOPIN0 = IOPIN0 & ~0x1000000;
    4a80:	e3a0c20e 	mov	ip, #-536870912	; 0xe0000000
    4a84:	e28cc90a 	add	ip, ip, #163840	; 0x28000
    4a88:	e59c2000 	ldr	r2, [ip]
** 
*****************************************************************************/
void SPISend( BYTE *buf, DWORD Length )
{
  DWORD i;
  recvI=0;
    4a8c:	e59f4088 	ldr	r4, [pc, #136]	; 4b1c <SPISend+0xa8>
  IOPIN0 = IOPIN0 & ~0x1000000;
    4a90:	e3c22401 	bic	r2, r2, #16777216	; 0x1000000
** 
*****************************************************************************/
void SPISend( BYTE *buf, DWORD Length )
{
  DWORD i;
  recvI=0;
    4a94:	e3a03000 	mov	r3, #0	; 0x0
  IOPIN0 = IOPIN0 & ~0x1000000;
  if ( Length == 0 )
    4a98:	e2516000 	subs	r6, r1, #0	; 0x0
** 
*****************************************************************************/
void SPISend( BYTE *buf, DWORD Length )
{
  DWORD i;
  recvI=0;
    4a9c:	e5843000 	str	r3, [r4]
  IOPIN0 = IOPIN0 & ~0x1000000;
    4aa0:	e58c2000 	str	r2, [ip]
** parameters:			buffer pointer, and the block length
** Returned value:		None
** 
*****************************************************************************/
void SPISend( BYTE *buf, DWORD Length )
{
    4aa4:	e1a05000 	mov	r5, r0
  DWORD i;
  recvI=0;
  IOPIN0 = IOPIN0 & ~0x1000000;
  if ( Length == 0 )
    4aa8:	089da9f0 	ldmeq	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
	return;
//if the OV529 is not ready, loop
  while((volatile int)IOPIN0 & (1<<23)) ;
    4aac:	e1a0200c 	mov	r2, ip
    4ab0:	e5923000 	ldr	r3, [r2]
    4ab4:	e2133502 	ands	r3, r3, #8388608	; 0x800000
    4ab8:	1afffffc 	bne	4ab0 <SPISend+0x3c>
  for ( i = 0; i < Length; i++ )
  {
	S0SPDR = *buf;
    4abc:	e3a0c20e 	mov	ip, #-536870912	; 0xe0000000
    4ac0:	e28cc802 	add	ip, ip, #131072	; 0x20000
    4ac4:	e59f8054 	ldr	r8, [pc, #84]	; 4b20 <SPISend+0xac>
  recvI=0;
  IOPIN0 = IOPIN0 & ~0x1000000;
  if ( Length == 0 )
	return;
//if the OV529 is not ready, loop
  while((volatile int)IOPIN0 & (1<<23)) ;
    4ac8:	e1a00003 	mov	r0, r3
	is being handled inside the ISR. Not an ideal example but show how the 
	interrupt is being set and handled. */ 
	while ( (SPI0Status & SPI0_TX_DONE) != SPI0_TX_DONE );
	SPI0Status &= ~SPI0_TX_DONE;
#else
	while ( !(S0SPSR & SPIF) );
    4acc:	e1a0700c 	mov	r7, ip
	return;
//if the OV529 is not ready, loop
  while((volatile int)IOPIN0 & (1<<23)) ;
  for ( i = 0; i < Length; i++ )
  {
	S0SPDR = *buf;
    4ad0:	e7d53000 	ldrb	r3, [r5, r0]
    4ad4:	e58c3008 	str	r3, [ip, #8]
	is being handled inside the ISR. Not an ideal example but show how the 
	interrupt is being set and handled. */ 
	while ( (SPI0Status & SPI0_TX_DONE) != SPI0_TX_DONE );
	SPI0Status &= ~SPI0_TX_DONE;
#else
	while ( !(S0SPSR & SPIF) );
    4ad8:	e59c3004 	ldr	r3, [ip, #4]
    4adc:	e3130080 	tst	r3, #128	; 0x80
    4ae0:	0afffffc 	beq	4ad8 <SPISend+0x64>
#endif
	recv[recvI++] = S0SPDR;		/* Flush the RxFIFO */
    4ae4:	e5943000 	ldr	r3, [r4]
  IOPIN0 = IOPIN0 & ~0x1000000;
  if ( Length == 0 )
	return;
//if the OV529 is not ready, loop
  while((volatile int)IOPIN0 & (1<<23)) ;
  for ( i = 0; i < Length; i++ )
    4ae8:	e2800001 	add	r0, r0, #1	; 0x1
	while ( (SPI0Status & SPI0_TX_DONE) != SPI0_TX_DONE );
	SPI0Status &= ~SPI0_TX_DONE;
#else
	while ( !(S0SPSR & SPIF) );
#endif
	recv[recvI++] = S0SPDR;		/* Flush the RxFIFO */
    4aec:	e5972008 	ldr	r2, [r7, #8]
    4af0:	e2831001 	add	r1, r3, #1	; 0x1
  IOPIN0 = IOPIN0 & ~0x1000000;
  if ( Length == 0 )
	return;
//if the OV529 is not ready, loop
  while((volatile int)IOPIN0 & (1<<23)) ;
  for ( i = 0; i < Length; i++ )
    4af4:	e1560000 	cmp	r6, r0
	while ( (SPI0Status & SPI0_TX_DONE) != SPI0_TX_DONE );
	SPI0Status &= ~SPI0_TX_DONE;
#else
	while ( !(S0SPSR & SPIF) );
#endif
	recv[recvI++] = S0SPDR;		/* Flush the RxFIFO */
    4af8:	e7c82003 	strb	r2, [r8, r3]
    4afc:	e5841000 	str	r1, [r4]
  IOPIN0 = IOPIN0 & ~0x1000000;
  if ( Length == 0 )
	return;
//if the OV529 is not ready, loop
  while((volatile int)IOPIN0 & (1<<23)) ;
  for ( i = 0; i < Length; i++ )
    4b00:	8afffff2 	bhi	4ad0 <SPISend+0x5c>
	while ( !(S0SPSR & SPIF) );
#endif
	recv[recvI++] = S0SPDR;		/* Flush the RxFIFO */
	buf++;
  }
   IOPIN0 |= 0x1000000;
    4b04:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    4b08:	e282290a 	add	r2, r2, #163840	; 0x28000
    4b0c:	e5923000 	ldr	r3, [r2]
    4b10:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    4b14:	e5823000 	str	r3, [r2]
    4b18:	e89da9f0 	ldm	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
    4b1c:	0790      	.short	0x0790
    4b1e:	4000      	.short	0x4000
    4b20:	400006d0 	.word	0x400006d0

00004b24 <SPIReceive>:
** parameters:			buffer pointer, and block length
** Returned value:		None
** 
*****************************************************************************/
void SPIReceive( BYTE *buf, DWORD Length )
{
    4b24:	e1a0c00d 	mov	ip, sp
    4b28:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
    4b2c:	e24cb004 	sub	fp, ip, #4	; 0x4
  register DWORD i;
//if the OV529 is not ready, loop
  while((volatile int)IOPIN0 & (1<<23)) ;
    4b30:	e3a0c20e 	mov	ip, #-536870912	; 0xe0000000
** parameters:			buffer pointer, and block length
** Returned value:		None
** 
*****************************************************************************/
void SPIReceive( BYTE *buf, DWORD Length )
{
    4b34:	e1a05000 	mov	r5, r0
    4b38:	e1a04001 	mov	r4, r1
  register DWORD i;
//if the OV529 is not ready, loop
  while((volatile int)IOPIN0 & (1<<23)) ;
    4b3c:	e28cc90a 	add	ip, ip, #163840	; 0x28000
    4b40:	e59c3000 	ldr	r3, [ip]
    4b44:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    4b48:	e2131502 	ands	r1, r3, #8388608	; 0x800000
    4b4c:	e282290a 	add	r2, r2, #163840	; 0x28000
    4b50:	1afffffa 	bne	4b40 <SPIReceive+0x1c>
  IOPIN0 &= ~0x1000000;
    4b54:	e5923000 	ldr	r3, [r2]
  for ( i = 0; i < Length; i++ )
    4b58:	e3540000 	cmp	r4, #0	; 0x0
void SPIReceive( BYTE *buf, DWORD Length )
{
  register DWORD i;
//if the OV529 is not ready, loop
  while((volatile int)IOPIN0 & (1<<23)) ;
  IOPIN0 &= ~0x1000000;
    4b5c:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
    4b60:	e5823000 	str	r3, [r2]
  for ( i = 0; i < Length; i++ )
    4b64:	0a00000d 	beq	4ba0 <SPIReceive+0x7c>
  {
	S0SPDR = 0xFF;
    4b68:	e242290a 	sub	r2, r2, #163840	; 0x28000
    4b6c:	e2822802 	add	r2, r2, #131072	; 0x20000
{
  register DWORD i;
//if the OV529 is not ready, loop
  while((volatile int)IOPIN0 & (1<<23)) ;
  IOPIN0 &= ~0x1000000;
  for ( i = 0; i < Length; i++ )
    4b70:	e1a0c001 	mov	ip, r1
  {
	S0SPDR = 0xFF;
    4b74:	e3a000ff 	mov	r0, #255	; 0xff
	while ( !(S0SPSR & SPIF) );
    4b78:	e1a01002 	mov	r1, r2
//if the OV529 is not ready, loop
  while((volatile int)IOPIN0 & (1<<23)) ;
  IOPIN0 &= ~0x1000000;
  for ( i = 0; i < Length; i++ )
  {
	S0SPDR = 0xFF;
    4b7c:	e5820008 	str	r0, [r2, #8]
	while ( !(S0SPSR & SPIF) );
    4b80:	e5923004 	ldr	r3, [r2, #4]
    4b84:	e3130080 	tst	r3, #128	; 0x80
    4b88:	0afffffc 	beq	4b80 <SPIReceive+0x5c>
	*buf++  = S0SPDR;
    4b8c:	e5913008 	ldr	r3, [r1, #8]
    4b90:	e7c5300c 	strb	r3, [r5, ip]
{
  register DWORD i;
//if the OV529 is not ready, loop
  while((volatile int)IOPIN0 & (1<<23)) ;
  IOPIN0 &= ~0x1000000;
  for ( i = 0; i < Length; i++ )
    4b94:	e28cc001 	add	ip, ip, #1	; 0x1
    4b98:	e154000c 	cmp	r4, ip
    4b9c:	8afffff6 	bhi	4b7c <SPIReceive+0x58>
  {
	S0SPDR = 0xFF;
	while ( !(S0SPSR & SPIF) );
	*buf++  = S0SPDR;
  }
  IOPIN0 |= 0x1000000;
    4ba0:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    4ba4:	e282290a 	add	r2, r2, #163840	; 0x28000
    4ba8:	e5923000 	ldr	r3, [r2]
    4bac:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    4bb0:	e5823000 	str	r3, [r2]
  return; 
}
    4bb4:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}

00004bb8 <isAck>:
BYTE ackimgqual[8]={0xFF, 0xFF, 0xFF, 0x0E, 0x10, 0, 0, 0};
BYTE ackreset[8]={0xFF, 0xFF, 0xFF, 0x0E, 0x08, 0, 0, 0xFF};
int global=0;

char isAck(BYTE * resp, BYTE cmd)
{
    4bb8:	e1a0c00d 	mov	ip, sp
    4bbc:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
    4bc0:	e24cb004 	sub	fp, ip, #4	; 0x4
    4bc4:	e20140ff 	and	r4, r1, #255	; 0xff
    4bc8:	e3a0c000 	mov	ip, #0	; 0x0
    4bcc:	e3a01001 	mov	r1, #1	; 0x1
		break;

		case(4): if(resp[i]!=cmd) return 0;
				 break;
		case(5): break;
		default: if(resp[i]!=ack[i]) return 0;
    4bd0:	e59f5064 	ldr	r5, [pc, #100]	; 4c3c <isAck+0x84>
    4bd4:	ea00000b 	b	4c08 <isAck+0x50>
char isAck(BYTE * resp, BYTE cmd)
{
	int i;
	for(i=0; i<8; i++)
	{
		switch(i)
    4bd8:	e35c0005 	cmp	ip, #5	; 0x5
    4bdc:	0a000005 	beq	4bf8 <isAck+0x40>
    4be0:	e35c0003 	cmp	ip, #3	; 0x3
    4be4:	0a00000e 	beq	4c24 <isAck+0x6c>
		break;

		case(4): if(resp[i]!=cmd) return 0;
				 break;
		case(5): break;
		default: if(resp[i]!=ack[i]) return 0;
    4be8:	e7d0200c 	ldrb	r2, [r0, ip]
    4bec:	e7d5300c 	ldrb	r3, [r5, ip]
    4bf0:	e1520003 	cmp	r2, r3
    4bf4:	1a000008 	bne	4c1c <isAck+0x64>
int global=0;

char isAck(BYTE * resp, BYTE cmd)
{
	int i;
	for(i=0; i<8; i++)
    4bf8:	e3510007 	cmp	r1, #7	; 0x7
    4bfc:	ca00000c 	bgt	4c34 <isAck+0x7c>
BYTE ackimgqual[8]={0xFF, 0xFF, 0xFF, 0x0E, 0x10, 0, 0, 0};
BYTE ackreset[8]={0xFF, 0xFF, 0xFF, 0x0E, 0x08, 0, 0, 0xFF};
int global=0;

char isAck(BYTE * resp, BYTE cmd)
{
    4c00:	e28cc001 	add	ip, ip, #1	; 0x1
    4c04:	e2811001 	add	r1, r1, #1	; 0x1
	int i;
	for(i=0; i<8; i++)
	{
		switch(i)
    4c08:	e35c0004 	cmp	ip, #4	; 0x4
    4c0c:	1afffff1 	bne	4bd8 <isAck+0x20>
			xprintf("\ra nak was returned!!!\n");
#endif
			return 0;}
		break;

		case(4): if(resp[i]!=cmd) return 0;
    4c10:	e5d03004 	ldrb	r3, [r0, #4]
    4c14:	e1530004 	cmp	r3, r4
    4c18:	0afffff8 	beq	4c00 <isAck+0x48>
int global=0;

char isAck(BYTE * resp, BYTE cmd)
{
	int i;
	for(i=0; i<8; i++)
    4c1c:	e3a00000 	mov	r0, #0	; 0x0
		case(5): break;
		default: if(resp[i]!=ack[i]) return 0;
		}
	}
	return 1;
}
    4c20:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
	int i;
	for(i=0; i<8; i++)
	{
		switch(i)
		{
		case(3):if(resp[i]==0x0F)
    4c24:	e5d03003 	ldrb	r3, [r0, #3]
    4c28:	e353000f 	cmp	r3, #15	; 0xf
    4c2c:	1afffff3 	bne	4c00 <isAck+0x48>
    4c30:	eafffff9 	b	4c1c <isAck+0x64>
int global=0;

char isAck(BYTE * resp, BYTE cmd)
{
	int i;
	for(i=0; i<8; i++)
    4c34:	e3a00001 	mov	r0, #1	; 0x1
    4c38:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
    4c3c:	40000014 	.word	0x40000014

00004c40 <getPic>:
    int imgsz;
    int size;
//    BYTE *imagebuf = (BYTE*)0x80000000;	// SRAM area starting address (used for image buffer)
    BYTE *imagebuf = (BYTE*)0x40004000;	// ON-CHIP SRAM area starting address (used for image buffer)

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    4c40:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    4c44:	e283390a 	add	r3, r3, #163840	; 0x28000
    4c48:	e5932008 	ldr	r2, [r3, #8]
    4c4c:	e3c22506 	bic	r2, r2, #25165824	; 0x1800000
    4c50:	e3822401 	orr	r2, r2, #16777216	; 0x1000000
    4c54:	e5832008 	str	r2, [r3, #8]
	IOPIN0 &= ~0x1000000;	// drive CS low
    4c58:	e5931000 	ldr	r1, [r3]
}
	IOPIN0 |= 0x1000000;	// drive CS high
}

int getPic()  //return image size
{
    4c5c:	e1a0c00d 	mov	ip, sp
    int size;
//    BYTE *imagebuf = (BYTE*)0x80000000;	// SRAM area starting address (used for image buffer)
    BYTE *imagebuf = (BYTE*)0x40004000;	// ON-CHIP SRAM area starting address (used for image buffer)

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
	IOPIN0 &= ~0x1000000;	// drive CS low
    4c60:	e3c11401 	bic	r1, r1, #16777216	; 0x1000000
}
	IOPIN0 |= 0x1000000;	// drive CS high
}

int getPic()  //return image size
{
    4c64:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
    int size;
//    BYTE *imagebuf = (BYTE*)0x80000000;	// SRAM area starting address (used for image buffer)
    BYTE *imagebuf = (BYTE*)0x40004000;	// ON-CHIP SRAM area starting address (used for image buffer)

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
	IOPIN0 &= ~0x1000000;	// drive CS low
    4c68:	e5831000 	str	r1, [r3]
			while((volatile int)IOPIN0 & (1<<23)) ;

			SPISend(getPicture, 8);
			//for(j=0; j<100000; j++);

			SPIReceive(SPIRDData, 8);
    4c6c:	e59f70ec 	ldr	r7, [pc, #236]	; 4d60 <getPic+0x120>
}
	IOPIN0 |= 0x1000000;	// drive CS high
}

int getPic()  //return image size
{
    4c70:	e24cb004 	sub	fp, ip, #4	; 0x4
	    {
#ifdef print
			xprintf("GET PICTURE: (try #%d) \n  ", i);
#endif
			//if the OV529 is not ready, loop
			while((volatile int)IOPIN0 & (1<<23)) ;
    4c74:	e1a06003 	mov	r6, r3
    int size;
//    BYTE *imagebuf = (BYTE*)0x80000000;	// SRAM area starting address (used for image buffer)
    BYTE *imagebuf = (BYTE*)0x40004000;	// ON-CHIP SRAM area starting address (used for image buffer)

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
	IOPIN0 &= ~0x1000000;	// drive CS low
    4c78:	e3a04001 	mov	r4, #1	; 0x1
	    {
#ifdef print
			xprintf("GET PICTURE: (try #%d) \n  ", i);
#endif
			//if the OV529 is not ready, loop
			while((volatile int)IOPIN0 & (1<<23)) ;
    4c7c:	e5963000 	ldr	r3, [r6]
    4c80:	e3130502 	tst	r3, #8388608	; 0x800000
    4c84:	1afffffc 	bne	4c7c <getPic+0x3c>

			SPISend(getPicture, 8);
			//for(j=0; j<100000; j++);

			SPIReceive(SPIRDData, 8);
    4c88:	e59f50d0 	ldr	r5, [pc, #208]	; 4d60 <getPic+0x120>
			xprintf("GET PICTURE: (try #%d) \n  ", i);
#endif
			//if the OV529 is not ready, loop
			while((volatile int)IOPIN0 & (1<<23)) ;

			SPISend(getPicture, 8);
    4c8c:	e59f00d0 	ldr	r0, [pc, #208]	; 4d64 <getPic+0x124>
    4c90:	e3a01008 	mov	r1, #8	; 0x8
    4c94:	ebffff76 	bl	4a74 <SPISend>
			//for(j=0; j<100000; j++);

			SPIReceive(SPIRDData, 8);
    4c98:	e1a00005 	mov	r0, r5
    4c9c:	e3a01008 	mov	r1, #8	; 0x8
    4ca0:	ebffff9f 	bl	4b24 <SPIReceive>
#ifdef print
			xprintf("MISO: %02x %02x %02x %02x %02x %02x %02x %02x\r\n ",
					SPIRDData[0], SPIRDData[1], SPIRDData[2], SPIRDData[3],
					SPIRDData[4], SPIRDData[5], SPIRDData[6], SPIRDData[7]);
#endif
			if(isAck(SPIRDData, 0x04))
    4ca4:	e1a00005 	mov	r0, r5
    4ca8:	e3a01004 	mov	r1, #4	; 0x4
    4cac:	ebffffc1 	bl	4bb8 <isAck>
    4cb0:	e3500000 	cmp	r0, #0	; 0x0
    4cb4:	1a000008 	bne	4cdc <getPic+0x9c>
    BYTE *imagebuf = (BYTE*)0x40004000;	// ON-CHIP SRAM area starting address (used for image buffer)

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
	IOPIN0 &= ~0x1000000;	// drive CS low

	    while(i++ != 30)
    4cb8:	e354001e 	cmp	r4, #30	; 0x1e
    4cbc:	e2844001 	add	r4, r4, #1	; 0x1
    4cc0:	1affffed 	bne	4c7c <getPic+0x3c>
						SPIReceive(imagebuf, imgsz);
						break;
					}
				}
	    }
		IOPIN0 |= 0x1000000;	// drive CS high
    4cc4:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    4cc8:	e282290a 	add	r2, r2, #163840	; 0x28000
    4ccc:	e5923000 	ldr	r3, [r2]
    4cd0:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    4cd4:	e5823000 	str	r3, [r2]
		return size;
}
    4cd8:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
			if(isAck(SPIRDData, 0x04))
				{
#ifdef print
					xprintf("ack getPic was received\n");
#endif
					SPIReceive(SPIRDData, 8);
    4cdc:	e1a00005 	mov	r0, r5
    4ce0:	e3a01008 	mov	r1, #8	; 0x8
    4ce4:	ebffff8e 	bl	4b24 <SPIReceive>
					xprintf("MISO: %02x %02x %02x %02x %02x %02x %02x %02x\r\n ",
							SPIRDData[0], SPIRDData[1], SPIRDData[2], SPIRDData[3],
							SPIRDData[4], SPIRDData[5], SPIRDData[6], SPIRDData[7]);
#endif
					for(j=0; j<4; j++) {
						if((j!=3 && SPIRDData[j] != 0xff) ||
    4ce8:	e5d73000 	ldrb	r3, [r7]
    4cec:	e35300ff 	cmp	r3, #255	; 0xff
    4cf0:	1afffff0 	bne	4cb8 <getPic+0x78>
    4cf4:	e5d73001 	ldrb	r3, [r7, #1]
    4cf8:	e35300ff 	cmp	r3, #255	; 0xff
    4cfc:	1affffed 	bne	4cb8 <getPic+0x78>
    4d00:	e5d73002 	ldrb	r3, [r7, #2]
    4d04:	e35300ff 	cmp	r3, #255	; 0xff
    4d08:	1affffea 	bne	4cb8 <getPic+0x78>
    4d0c:	e5d73003 	ldrb	r3, [r7, #3]
    4d10:	e353000a 	cmp	r3, #10	; 0xa
    4d14:	1affffe7 	bne	4cb8 <getPic+0x78>
					if(j==4) {
#ifdef print
						xprintf("Data size: %d\r\n",
								imgsz = (SPIRDData[5] + (SPIRDData[6]<<8) + (SPIRDData[7]<<16)));
#endif
						imgsz = (SPIRDData[5] + (SPIRDData[6]<<8) + (SPIRDData[7]<<16));
    4d18:	e5d54006 	ldrb	r4, [r5, #6]
    4d1c:	e5d53007 	ldrb	r3, [r5, #7]
    4d20:	e5d52005 	ldrb	r2, [r5, #5]
    4d24:	e1a03803 	lsl	r3, r3, #16
    4d28:	e1a04404 	lsl	r4, r4, #8
    4d2c:	e0844003 	add	r4, r4, r3
    4d30:	e0844002 	add	r4, r4, r2
						    imgsz -= 8;
						    index += 8;
						}*/


						SPIReceive(imagebuf, imgsz);
    4d34:	e3a00101 	mov	r0, #1073741824	; 0x40000000
    4d38:	e2800901 	add	r0, r0, #16384	; 0x4000
    4d3c:	e1a01004 	mov	r1, r4
    4d40:	ebffff77 	bl	4b24 <SPIReceive>
						break;
					}
				}
	    }
		IOPIN0 |= 0x1000000;	// drive CS high
    4d44:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    4d48:	e282290a 	add	r2, r2, #163840	; 0x28000
    4d4c:	e5923000 	ldr	r3, [r2]
    4d50:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
						    imgsz -= 8;
						    index += 8;
						}*/


						SPIReceive(imagebuf, imgsz);
    4d54:	e1a00004 	mov	r0, r4
						break;
					}
				}
	    }
		IOPIN0 |= 0x1000000;	// drive CS high
    4d58:	e5823000 	str	r3, [r2]
		return size;
}
    4d5c:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
    4d60:	400006ea 	.word	0x400006ea
    4d64:	40000034 	.word	0x40000034

00004d68 <getSnapshot>:
void getSnapshot()
	{
    int i = 0;
    int j=0;

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    4d68:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    4d6c:	e283390a 	add	r3, r3, #163840	; 0x28000
    4d70:	e5932008 	ldr	r2, [r3, #8]
    4d74:	e3c22506 	bic	r2, r2, #25165824	; 0x1800000
    4d78:	e3822401 	orr	r2, r2, #16777216	; 0x1000000
    4d7c:	e5832008 	str	r2, [r3, #8]
	IOPIN0 &= ~0x1000000;	// drive CS low
    4d80:	e5931000 	ldr	r1, [r3]
    4d84:	e3c11401 	bic	r1, r1, #16777216	; 0x1000000

	IOPIN0 |= 0x1000000;	// drive CS high
}

void getSnapshot()
	{
    4d88:	e1a0c00d 	mov	ip, sp
    int i = 0;
    int j=0;

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
	IOPIN0 &= ~0x1000000;	// drive CS low
    4d8c:	e5831000 	str	r1, [r3]

	IOPIN0 |= 0x1000000;	// drive CS high
}

void getSnapshot()
	{
    4d90:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
    4d94:	e24cb004 	sub	fp, ip, #4	; 0x4
{
#ifdef print
	xprintf("GET SNAPSHOT: (try #%d)   ", i);
#endif
	//if the OV529 is not ready, loop
	while((volatile int)IOPIN0 & (1<<23)) ;
    4d98:	e1a05003 	mov	r5, r3
	{
    int i = 0;
    int j=0;

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
	IOPIN0 &= ~0x1000000;	// drive CS low
    4d9c:	e3a04001 	mov	r4, #1	; 0x1
{
#ifdef print
	xprintf("GET SNAPSHOT: (try #%d)   ", i);
#endif
	//if the OV529 is not ready, loop
	while((volatile int)IOPIN0 & (1<<23)) ;
    4da0:	e5953000 	ldr	r3, [r5]
    4da4:	e3130502 	tst	r3, #8388608	; 0x800000
    4da8:	1afffffc 	bne	4da0 <getSnapshot+0x38>

	SPISend(snapshot, 8);
    4dac:	e59f0048 	ldr	r0, [pc, #72]	; 4dfc <getSnapshot+0x94>
    4db0:	e3a01008 	mov	r1, #8	; 0x8
    4db4:	ebffff2e 	bl	4a74 <SPISend>
	//for(j=0; j<100000; j++);

	SPIReceive(SPIRDData, 8);
    4db8:	e59f0040 	ldr	r0, [pc, #64]	; 4e00 <getSnapshot+0x98>
    4dbc:	e3a01008 	mov	r1, #8	; 0x8
    4dc0:	ebffff57 	bl	4b24 <SPIReceive>
#ifdef print
	xprintf("MISO: %02x %02x %02x %02x %02x %02x %02x %02x\r\n ",
			SPIRDData[0], SPIRDData[1], SPIRDData[2], SPIRDData[3],
			SPIRDData[4], SPIRDData[5], SPIRDData[6], SPIRDData[7]);
#endif
	if(isAck(SPIRDData, 0x05))
    4dc4:	e3a01005 	mov	r1, #5	; 0x5
    4dc8:	e59f0030 	ldr	r0, [pc, #48]	; 4e00 <getSnapshot+0x98>
    4dcc:	ebffff79 	bl	4bb8 <isAck>
    4dd0:	e3500000 	cmp	r0, #0	; 0x0
    4dd4:	1a000002 	bne	4de4 <getSnapshot+0x7c>
    int i = 0;
    int j=0;

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
	IOPIN0 &= ~0x1000000;	// drive CS low
while(i++!=15)
    4dd8:	e354000f 	cmp	r4, #15	; 0xf
    4ddc:	e2844001 	add	r4, r4, #1	; 0x1
    4de0:	1affffee 	bne	4da0 <getSnapshot+0x38>
			xprintf("ack snapshot was received\n");
#endif
			break;
		}
}
	IOPIN0 |= 0x1000000;	// drive CS high
    4de4:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    4de8:	e282290a 	add	r2, r2, #163840	; 0x28000
    4dec:	e5923000 	ldr	r3, [r2]
    4df0:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    4df4:	e5823000 	str	r3, [r2]
}
    4df8:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
    4dfc:	4000002c 	.word	0x4000002c
    4e00:	400006ea 	.word	0x400006ea

00004e04 <getImageQuality>:

void getImageQuality()
	{
    int j = 0;
    int i=0;
    IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    4e04:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    4e08:	e283390a 	add	r3, r3, #163840	; 0x28000
    4e0c:	e5932008 	ldr	r2, [r3, #8]
    4e10:	e3c22506 	bic	r2, r2, #25165824	; 0x1800000
    4e14:	e3822401 	orr	r2, r2, #16777216	; 0x1000000
    4e18:	e5832008 	str	r2, [r3, #8]
    IOPIN0 &= ~0x1000000;		// drive CS low
    4e1c:	e5931000 	ldr	r1, [r3]
    4e20:	e3c11401 	bic	r1, r1, #16777216	; 0x1000000
}
	IOPIN0 |= 0x1000000;	// drive CS high
}

void getImageQuality()
	{
    4e24:	e1a0c00d 	mov	ip, sp
    int j = 0;
    int i=0;
    IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    IOPIN0 &= ~0x1000000;		// drive CS low
    4e28:	e5831000 	str	r1, [r3]
}
	IOPIN0 |= 0x1000000;	// drive CS high
}

void getImageQuality()
	{
    4e2c:	e92dd800 	push	{fp, ip, lr, pc}
    IOPIN0 &= ~0x1000000;		// drive CS low
#ifdef print
	xprintf("IMAGE QUALITY:   ");
#endif
	//if the OV529 is not ready, loop
	while((volatile int)IOPIN0 & (1<<23)) ;
    4e30:	e1a02003 	mov	r2, r3
}
	IOPIN0 |= 0x1000000;	// drive CS high
}

void getImageQuality()
	{
    4e34:	e24cb004 	sub	fp, ip, #4	; 0x4
    IOPIN0 &= ~0x1000000;		// drive CS low
#ifdef print
	xprintf("IMAGE QUALITY:   ");
#endif
	//if the OV529 is not ready, loop
	while((volatile int)IOPIN0 & (1<<23)) ;
    4e38:	e5923000 	ldr	r3, [r2]
    4e3c:	e3130502 	tst	r3, #8388608	; 0x800000
    4e40:	1afffffc 	bne	4e38 <getImageQuality+0x34>

	SPISend(picQuality, 8);
    4e44:	e59f0044 	ldr	r0, [pc, #68]	; 4e90 <getImageQuality+0x8c>
    4e48:	e3a01008 	mov	r1, #8	; 0x8
    4e4c:	ebffff08 	bl	4a74 <SPISend>
	//for(j=0; j<100000; j++);

	SPIReceive(SPIRDData, 8);
    4e50:	e59f003c 	ldr	r0, [pc, #60]	; 4e94 <getImageQuality+0x90>
    4e54:	e3a01008 	mov	r1, #8	; 0x8
    4e58:	ebffff31 	bl	4b24 <SPIReceive>
#ifdef print
	xprintf("MISO: %02x %02x %02x %02x %02x %02x %02x %02x\r\n ",
			SPIRDData[0], SPIRDData[1], SPIRDData[2], SPIRDData[3],
			SPIRDData[4], SPIRDData[5], SPIRDData[6], SPIRDData[7]);
#endif
	if(isAck(SPIRDData, 0x10))
    4e5c:	e59f0030 	ldr	r0, [pc, #48]	; 4e94 <getImageQuality+0x90>
    4e60:	e3a01010 	mov	r1, #16	; 0x10
    4e64:	ebffff53 	bl	4bb8 <isAck>
    4e68:	e3500000 	cmp	r0, #0	; 0x0
		{
#ifdef print
			xprintf("ack image quality was received\n");
#endif
			SPISend(ackimgqual, 8);
    4e6c:	159f0024 	ldrne	r0, [pc, #36]	; 4e98 <getImageQuality+0x94>
    4e70:	13a01008 	movne	r1, #8	; 0x8
    4e74:	1bfffefe 	blne	4a74 <SPISend>

		}

	IOPIN0 |= 0x1000000;	// drive CS high
    4e78:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    4e7c:	e282290a 	add	r2, r2, #163840	; 0x28000
    4e80:	e5923000 	ldr	r3, [r2]
    4e84:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    4e88:	e5823000 	str	r3, [r2]
}
    4e8c:	e89da800 	ldm	sp, {fp, sp, pc}
    4e90:	40000024 	.word	0x40000024
    4e94:	400006ea 	.word	0x400006ea
    4e98:	40000044 	.word	0x40000044

00004e9c <getInit>:

void getInit()
	{
    int j=0;
    int i=0;
    IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    4e9c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    4ea0:	e283390a 	add	r3, r3, #163840	; 0x28000
    4ea4:	e5932008 	ldr	r2, [r3, #8]
    4ea8:	e3c22506 	bic	r2, r2, #25165824	; 0x1800000
    4eac:	e3822401 	orr	r2, r2, #16777216	; 0x1000000
    4eb0:	e5832008 	str	r2, [r3, #8]
    IOPIN0 &= ~0x1000000;		// drive CS low
    4eb4:	e5931000 	ldr	r1, [r3]
    4eb8:	e3c11401 	bic	r1, r1, #16777216	; 0x1000000
    }
	IOPIN0 |= 0x1000000;	// drive CS high
}

void getInit()
	{
    4ebc:	e1a0c00d 	mov	ip, sp
    int j=0;
    int i=0;
    IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    IOPIN0 &= ~0x1000000;		// drive CS low
    4ec0:	e5831000 	str	r1, [r3]
    }
	IOPIN0 |= 0x1000000;	// drive CS high
}

void getInit()
	{
    4ec4:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
    4ec8:	e24cb004 	sub	fp, ip, #4	; 0x4
{
#ifdef print
	xprintf("INIT:   " );
#endif
	//if the OV529 is not ready, loop
	while((volatile int)IOPIN0 & (1<<23)) ;
    4ecc:	e1a05003 	mov	r5, r3
void getInit()
	{
    int j=0;
    int i=0;
    IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    IOPIN0 &= ~0x1000000;		// drive CS low
    4ed0:	e3a04001 	mov	r4, #1	; 0x1
{
#ifdef print
	xprintf("INIT:   " );
#endif
	//if the OV529 is not ready, loop
	while((volatile int)IOPIN0 & (1<<23)) ;
    4ed4:	e5953000 	ldr	r3, [r5]
    4ed8:	e3130502 	tst	r3, #8388608	; 0x800000
    4edc:	1afffffc 	bne	4ed4 <getInit+0x38>

	SPISend(camInit, 8);
    4ee0:	e59f0048 	ldr	r0, [pc, #72]	; 4f30 <getInit+0x94>
    4ee4:	e3a01008 	mov	r1, #8	; 0x8
    4ee8:	ebfffee1 	bl	4a74 <SPISend>
	//for(j=0; j<100000; j++);
	SPIReceive(SPIRDData, 8);
    4eec:	e59f0040 	ldr	r0, [pc, #64]	; 4f34 <getInit+0x98>
    4ef0:	e3a01008 	mov	r1, #8	; 0x8
    4ef4:	ebffff0a 	bl	4b24 <SPIReceive>
#ifdef print
	xprintf("MISO: %02x %02x %02x %02x %02x %02x %02x %02x\r\n ",
			SPIRDData[0], SPIRDData[1], SPIRDData[2], SPIRDData[3],
			SPIRDData[4], SPIRDData[5], SPIRDData[6], SPIRDData[7]);
#endif
	if(isAck(SPIRDData, 0x01))
    4ef8:	e3a01001 	mov	r1, #1	; 0x1
    4efc:	e59f0030 	ldr	r0, [pc, #48]	; 4f34 <getInit+0x98>
    4f00:	ebffff2c 	bl	4bb8 <isAck>
    4f04:	e3500000 	cmp	r0, #0	; 0x0
    4f08:	1a000002 	bne	4f18 <getInit+0x7c>
    int j=0;
    int i=0;
    IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    IOPIN0 &= ~0x1000000;		// drive CS low

while(i++!=15)
    4f0c:	e354000f 	cmp	r4, #15	; 0xf
    4f10:	e2844001 	add	r4, r4, #1	; 0x1
    4f14:	1affffee 	bne	4ed4 <getInit+0x38>
			xprintf("ack camera init was received\n");
#endif
			break;
		}
}
	IOPIN0 |= 0x1000000;	// drive CS high
    4f18:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    4f1c:	e282290a 	add	r2, r2, #163840	; 0x28000
    4f20:	e5923000 	ldr	r3, [r2]
    4f24:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    4f28:	e5823000 	str	r3, [r2]
}
    4f2c:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
    4f30:	4000001c 	.word	0x4000001c
    4f34:	400006ea 	.word	0x400006ea

00004f38 <sendSync>:
void sendSync()
	{
    int i = 0;
    int j=0;

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
    4f38:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    4f3c:	e283390a 	add	r3, r3, #163840	; 0x28000
    4f40:	e5932008 	ldr	r2, [r3, #8]
    4f44:	e3c22506 	bic	r2, r2, #25165824	; 0x1800000
    4f48:	e3822401 	orr	r2, r2, #16777216	; 0x1000000
    4f4c:	e5832008 	str	r2, [r3, #8]
	IOPIN0 &= ~0x1000000;		// drive CS low
    4f50:	e5931000 	ldr	r1, [r3]
    4f54:	e3c11401 	bic	r1, r1, #16777216	; 0x1000000
	}
	}
*/

void sendSync()
	{
    4f58:	e1a0c00d 	mov	ip, sp
    int i = 0;
    int j=0;

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
	IOPIN0 &= ~0x1000000;		// drive CS low
    4f5c:	e5831000 	str	r1, [r3]
	}
	}
*/

void sendSync()
	{
    4f60:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
    4f64:	e24cb004 	sub	fp, ip, #4	; 0x4
		{
#ifdef print
			xprintf("SYNC: (try #%d)   ", i);
#endif
			//if the OV529 is not ready, loop
			while((volatile int)IOPIN0 & (1<<23)) ;
    4f68:	e1a05003 	mov	r5, r3
	{
    int i = 0;
    int j=0;

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
	IOPIN0 &= ~0x1000000;		// drive CS low
    4f6c:	e3a04001 	mov	r4, #1	; 0x1
		{
#ifdef print
			xprintf("SYNC: (try #%d)   ", i);
#endif
			//if the OV529 is not ready, loop
			while((volatile int)IOPIN0 & (1<<23)) ;
    4f70:	e5953000 	ldr	r3, [r5]
    4f74:	e3130502 	tst	r3, #8388608	; 0x800000
    4f78:	1afffffc 	bne	4f70 <sendSync+0x38>

			SPISend(sync, 8);
    4f7c:	e59f0094 	ldr	r0, [pc, #148]	; 5018 <sendSync+0xe0>
    4f80:	e3a01008 	mov	r1, #8	; 0x8
    4f84:	ebfffeba 	bl	4a74 <SPISend>

			//for(j=0; j<100000; j++);	// delay approx 25msec

			SPIReceive(SPIRDData, 8);
    4f88:	e59f008c 	ldr	r0, [pc, #140]	; 501c <sendSync+0xe4>
    4f8c:	e3a01008 	mov	r1, #8	; 0x8
    4f90:	ebfffee3 	bl	4b24 <SPIReceive>
#ifdef print
			xprintf("MISO: %02x %02x %02x %02x %02x %02x %02x %02x\r\n ",
					SPIRDData[0], SPIRDData[1], SPIRDData[2], SPIRDData[3],
					SPIRDData[4], SPIRDData[5], SPIRDData[6], SPIRDData[7]);
#endif
			if(isAck(SPIRDData, 0x0D))
    4f94:	e3a0100d 	mov	r1, #13	; 0xd
    4f98:	e59f007c 	ldr	r0, [pc, #124]	; 501c <sendSync+0xe4>
    4f9c:	ebffff05 	bl	4bb8 <isAck>
    4fa0:	e3500000 	cmp	r0, #0	; 0x0
    4fa4:	1a000008 	bne	4fcc <sendSync+0x94>

	IODIR0 = (IODIR0&~0x01800000)|0x01000000;
	IOPIN0 &= ~0x1000000;		// drive CS low

    //sync loop
	while(i++!=60)
    4fa8:	e354003c 	cmp	r4, #60	; 0x3c
    4fac:	e2844001 	add	r4, r4, #1	; 0x1
    4fb0:	1affffee 	bne	4f70 <sendSync+0x38>
					AckCounter++;
					acksync[5] = AckCounter;
					break;
				}
		}
	IOPIN0 |= 0x1000000;	// drive CS high
    4fb4:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    4fb8:	e282290a 	add	r2, r2, #163840	; 0x28000
    4fbc:	e5923000 	ldr	r3, [r2]
    4fc0:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    4fc4:	e5823000 	str	r3, [r2]
	}
    4fc8:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
						}
					}
#ifdef print
					if(j==8) xprintf("Got SYNC from camera\n");
#endif
					SPISend(acksync, 8);
    4fcc:	e59f404c 	ldr	r4, [pc, #76]	; 5020 <sendSync+0xe8>
			if(isAck(SPIRDData, 0x0D))
				{
#ifdef print
					xprintf("ack sync was received\n");
#endif
					SPIReceive(SPIRDData, 8);		// receive SYNC cmd from camera
    4fd0:	e59f0044 	ldr	r0, [pc, #68]	; 501c <sendSync+0xe4>
    4fd4:	e3a01008 	mov	r1, #8	; 0x8
    4fd8:	ebfffed1 	bl	4b24 <SPIReceive>
						}
					}
#ifdef print
					if(j==8) xprintf("Got SYNC from camera\n");
#endif
					SPISend(acksync, 8);
    4fdc:	e1a00004 	mov	r0, r4
    4fe0:	e3a01008 	mov	r1, #8	; 0x8
    4fe4:	ebfffea2 	bl	4a74 <SPISend>
					AckCounter++;
    4fe8:	e59f2034 	ldr	r2, [pc, #52]	; 5024 <sendSync+0xec>
    4fec:	e5d23000 	ldrb	r3, [r2]
    4ff0:	e2833001 	add	r3, r3, #1	; 0x1
    4ff4:	e20330ff 	and	r3, r3, #255	; 0xff
    4ff8:	e5c23000 	strb	r3, [r2]
					acksync[5] = AckCounter;
    4ffc:	e5c43005 	strb	r3, [r4, #5]
					break;
				}
		}
	IOPIN0 |= 0x1000000;	// drive CS high
    5000:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    5004:	e282290a 	add	r2, r2, #163840	; 0x28000
    5008:	e5923000 	ldr	r3, [r2]
    500c:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
    5010:	e5823000 	str	r3, [r2]
	}
    5014:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
    5018:	4000000c 	.word	0x4000000c
    501c:	400006ea 	.word	0x400006ea
    5020:	4000003c 	.word	0x4000003c
    5024:	40000794 	.word	0x40000794

00005028 <setupCamera>:

void stopRec(){
	global=1;
}
void setupCamera()
{
    5028:	e1a0c00d 	mov	ip, sp
    502c:	e92dd800 	push	{fp, ip, lr, pc}
    5030:	e24cb004 	sub	fp, ip, #4	; 0x4
	sendSync();
    5034:	ebffffbf 	bl	4f38 <sendSync>
	getInit();
    5038:	ebffff97 	bl	4e9c <getInit>
	getImageQuality();
}
    503c:	e89d6800 	ldm	sp, {fp, sp, lr}
}
void setupCamera()
{
	sendSync();
	getInit();
	getImageQuality();
    5040:	eaffff6f 	b	4e04 <getImageQuality>

00005044 <EINT3_Handler>:
** parameters:			None
** Returned value:		None
** 
*****************************************************************************/
void EINT3_Handler (void)
{
    5044:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
    5048:	e1a0c00d 	mov	ip, sp
    504c:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
	EXTINT = EINT3;		/* clear interrupt */
    5050:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    5054:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    5058:	e3a02008 	mov	r2, #8	; 0x8
    505c:	e5832140 	str	r2, [r3, #320]
	IO0_INT_CLR |= 15<<6;
    5060:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
    5064:	e281190a 	add	r1, r1, #163840	; 0x28000
    5068:	e591308c 	ldr	r3, [r1, #140]
    506c:	e3833d0f 	orr	r3, r3, #960	; 0x3c0
    5070:	e581308c 	str	r3, [r1, #140]
	int d0, d1, d2, d3;
	d0 = (IO0PIN >>6)&1;
    5074:	e5912000 	ldr	r2, [r1]
	d1 = (IO0PIN >>7)&1;
	d2 = (IO0PIN >>8)&1;
	d3 = (IO0PIN >>9)&1;
	if(!d0){
    5078:	e3120040 	tst	r2, #64	; 0x40
{
	EXTINT = EINT3;		/* clear interrupt */
	IO0_INT_CLR |= 15<<6;
	int d0, d1, d2, d3;
	d0 = (IO0PIN >>6)&1;
	d1 = (IO0PIN >>7)&1;
    507c:	e5910000 	ldr	r0, [r1]
** parameters:			None
** Returned value:		None
** 
*****************************************************************************/
void EINT3_Handler (void)
{
    5080:	e24cb004 	sub	fp, ip, #4	; 0x4
	EXTINT = EINT3;		/* clear interrupt */
	IO0_INT_CLR |= 15<<6;
	int d0, d1, d2, d3;
	d0 = (IO0PIN >>6)&1;
	d1 = (IO0PIN >>7)&1;
	d2 = (IO0PIN >>8)&1;
    5084:	e591c000 	ldr	ip, [r1]
	d3 = (IO0PIN >>9)&1;
    5088:	e5913000 	ldr	r3, [r1]
	if(!d0){
    508c:	1a000006 	bne	50ac <EINT3_Handler+0x68>
//	  	uart0Puts("d0\r\n");
	  	takeSnapshot=1;
    5090:	e59f308c 	ldr	r3, [pc, #140]	; 5124 <EINT3_Handler+0xe0>
    5094:	e3a02001 	mov	r2, #1	; 0x1
    5098:	e5832000 	str	r2, [r3]
	  	while(!d0)
	  		d0 = (IO0PIN >>6)&1;
    509c:	e1a02001 	mov	r2, r1
    50a0:	e5923000 	ldr	r3, [r2]
	d2 = (IO0PIN >>8)&1;
	d3 = (IO0PIN >>9)&1;
	if(!d0){
//	  	uart0Puts("d0\r\n");
	  	takeSnapshot=1;
	  	while(!d0)
    50a4:	e3130040 	tst	r3, #64	; 0x40
    50a8:	0afffffc 	beq	50a0 <EINT3_Handler+0x5c>
	  		d0 = (IO0PIN >>6)&1;
	  	}
	if(!d1){
    50ac:	e3100080 	tst	r0, #128	; 0x80
    50b0:	1a000007 	bne	50d4 <EINT3_Handler+0x90>
//		uart0Puts("d1\r\n");
		startRecording=1;
    50b4:	e59f306c 	ldr	r3, [pc, #108]	; 5128 <EINT3_Handler+0xe4>
    50b8:	e3a02001 	mov	r2, #1	; 0x1
    50bc:	e5832000 	str	r2, [r3]
		while(!d1)
			d1 = (IO0PIN >>7)&1;
    50c0:	e2422212 	sub	r2, r2, #536870913	; 0x20000001
    50c4:	e282290a 	add	r2, r2, #163840	; 0x28000
    50c8:	e5923000 	ldr	r3, [r2]
	  		d0 = (IO0PIN >>6)&1;
	  	}
	if(!d1){
//		uart0Puts("d1\r\n");
		startRecording=1;
		while(!d1)
    50cc:	e3130080 	tst	r3, #128	; 0x80
    50d0:	0afffffc 	beq	50c8 <EINT3_Handler+0x84>
			d1 = (IO0PIN >>7)&1;
	}
	if(!d2){
    50d4:	e31c0c01 	tst	ip, #256	; 0x100
    50d8:	1a000007 	bne	50fc <EINT3_Handler+0xb8>
		stopRecording=1;
    50dc:	e59f3048 	ldr	r3, [pc, #72]	; 512c <EINT3_Handler+0xe8>
    50e0:	e3a02001 	mov	r2, #1	; 0x1
    50e4:	e5832000 	str	r2, [r3]
//		uart0Puts("d2\r\n");
		while(!d2)
			d2 = (IO0PIN >>8)&1;
    50e8:	e2422212 	sub	r2, r2, #536870913	; 0x20000001
    50ec:	e282290a 	add	r2, r2, #163840	; 0x28000
    50f0:	e5923000 	ldr	r3, [r2]
			d1 = (IO0PIN >>7)&1;
	}
	if(!d2){
		stopRecording=1;
//		uart0Puts("d2\r\n");
		while(!d2)
    50f4:	e3130c01 	tst	r3, #256	; 0x100
    50f8:	0afffffc 	beq	50f0 <EINT3_Handler+0xac>

#ifndef __thumb
static inline uint32_t __get_CPSR(void)
{
	uint32_t temp;
	asm volatile ("mrs %0,CPSR":"=r" (temp):) ;
    50fc:	e10f3000 	mrs	r3, CPSR
	return temp;
}

static inline void __set_CPSR(uint32_t save_cpsr)
{
	asm volatile (" msr CPSR_cxsf,%0"::"r"(save_cpsr) );
    5100:	e38330c0 	orr	r3, r3, #192	; 0xc0
    5104:	e12ff003 	msr	CPSR_fsxc, r3
		uart0Puts("d3\r\n");
		while(!d3)
			d3 = (IO0PIN >>9)&1;
	}*/
    disable_interrupt();
    VICVectAddr = 0;		/* Acknowledge Interrupt */
    5108:	e3a02000 	mov	r2, #0	; 0x0
    510c:	e3e03000 	mvn	r3, #0	; 0x0
    5110:	e50320ff 	str	r2, [r3, #-255]
}
    5114:	e24bd01c 	sub	sp, fp, #28	; 0x1c
    5118:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
    511c:	e8bd1000 	pop	{ip}
    5120:	e25ef004 	subs	pc, lr, #4	; 0x4
    5124:	400006f4 	.word	0x400006f4
    5128:	400006f8 	.word	0x400006f8
    512c:	400006fc 	.word	0x400006fc

00005130 <EINTInit>:
*****************************************************************************/
#define IO0DIR (*(volatile unsigned long *)0xE0028008)
#define IO0PIN (*(volatile unsigned long *)0xE0028000)
DWORD EINTInit( void )
{
	PINSEL0 &= 0xFFF00FFF;
    5130:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
    5134:	e282290b 	add	r2, r2, #180224	; 0x2c000
    5138:	e5923000 	ldr	r3, [r2]
** 
*****************************************************************************/
#define IO0DIR (*(volatile unsigned long *)0xE0028008)
#define IO0PIN (*(volatile unsigned long *)0xE0028000)
DWORD EINTInit( void )
{
    513c:	e1a0c00d 	mov	ip, sp
	PINSEL0 &= 0xFFF00FFF;
    5140:	e3c33aff 	bic	r3, r3, #1044480	; 0xff000
    5144:	e5823000 	str	r3, [r2]
** 
*****************************************************************************/
#define IO0DIR (*(volatile unsigned long *)0xE0028008)
#define IO0PIN (*(volatile unsigned long *)0xE0028000)
DWORD EINTInit( void )
{
    5148:	e92dd810 	push	{r4, fp, ip, lr, pc}
	PINSEL0 &= 0xFFF00FFF;
    IO0DIR &= 0xFFF00FFF;				/* input */
    514c:	e3a0420e 	mov	r4, #-536870912	; 0xe0000000
    5150:	e284490a 	add	r4, r4, #163840	; 0x28000
    5154:	e5943008 	ldr	r3, [r4, #8]
    5158:	e3c33aff 	bic	r3, r3, #1044480	; 0xff000
    515c:	e5843008 	str	r3, [r4, #8]
    SCS&=~1;
    5160:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
    5164:	e281197f 	add	r1, r1, #2080768	; 0x1fc000
    5168:	e59131a0 	ldr	r3, [r1, #416]
    516c:	e3c33001 	bic	r3, r3, #1	; 0x1
    5170:	e58131a0 	str	r3, [r1, #416]
    EXTMODE = EINT3_EDGE;		/* INT1 edge trigger */
    5174:	e3a02008 	mov	r2, #8	; 0x8
    EXTPOLAR = 0;			/* INT1 is falling edge by default */
    5178:	e3a03000 	mov	r3, #0	; 0x0
DWORD EINTInit( void )
{
	PINSEL0 &= 0xFFF00FFF;
    IO0DIR &= 0xFFF00FFF;				/* input */
    SCS&=~1;
    EXTMODE = EINT3_EDGE;		/* INT1 edge trigger */
    517c:	e5812148 	str	r2, [r1, #328]
** 
*****************************************************************************/
#define IO0DIR (*(volatile unsigned long *)0xE0028008)
#define IO0PIN (*(volatile unsigned long *)0xE0028000)
DWORD EINTInit( void )
{
    5180:	e24cb004 	sub	fp, ip, #4	; 0x4
	PINSEL0 &= 0xFFF00FFF;
    IO0DIR &= 0xFFF00FFF;				/* input */
    SCS&=~1;
    EXTMODE = EINT3_EDGE;		/* INT1 edge trigger */
    EXTPOLAR = 0;			/* INT1 is falling edge by default */
    5184:	e581314c 	str	r3, [r1, #332]


    if ( install_irq( EINT3_INT, (void *)EINT3_Handler, MID_PRIORITY) == FALSE )
    5188:	e2422004 	sub	r2, r2, #4	; 0x4
    518c:	e59f101c 	ldr	r1, [pc, #28]	; 51b0 <EINTInit+0x80>
    5190:	e3a00011 	mov	r0, #17	; 0x11
    5194:	ebffeda0 	bl	81c <install_irq>
    5198:	e3500000 	cmp	r0, #0	; 0x0
    {
	return (FALSE);
    }
    IO0_INT_EN_F  |= 15<<6;		/*set falling edge*/
    519c:	15943094 	ldrne	r3, [r4, #148]
    51a0:	13833d0f 	orrne	r3, r3, #960	; 0x3c0
    51a4:	15843094 	strne	r3, [r4, #148]
    51a8:	13a00001 	movne	r0, #1	; 0x1
    return( TRUE );
}
    51ac:	e89da810 	ldm	sp, {r4, fp, sp, pc}
    51b0:	00005044 	.word	0x00005044

000051b4 <memcmp>:
    51b4:	e3520003 	cmp	r2, #3	; 0x3
    51b8:	e92d0070 	push	{r4, r5, r6}
    51bc:	e1a04002 	mov	r4, r2
    51c0:	e1a06000 	mov	r6, r0
    51c4:	e1a05001 	mov	r5, r1
    51c8:	9a00001f 	bls	524c <memcmp+0x98>
    51cc:	e1813000 	orr	r3, r1, r0
    51d0:	e3130003 	tst	r3, #3	; 0x3
    51d4:	0a000011 	beq	5220 <memcmp+0x6c>
    51d8:	e5d6c000 	ldrb	ip, [r6]
    51dc:	e5d50000 	ldrb	r0, [r5]
    51e0:	e15c0000 	cmp	ip, r0
    51e4:	02442001 	subeq	r2, r4, #1	; 0x1
    51e8:	01a03006 	moveq	r3, r6
    51ec:	01a01005 	moveq	r1, r5
    51f0:	0a000004 	beq	5208 <memcmp+0x54>
    51f4:	ea000017 	b	5258 <memcmp+0xa4>
    51f8:	e5f3c001 	ldrb	ip, [r3, #1]!
    51fc:	e5f10001 	ldrb	r0, [r1, #1]!
    5200:	e15c0000 	cmp	ip, r0
    5204:	1a000013 	bne	5258 <memcmp+0xa4>
    5208:	e3520000 	cmp	r2, #0	; 0x0
    520c:	e2422001 	sub	r2, r2, #1	; 0x1
    5210:	1afffff8 	bne	51f8 <memcmp+0x44>
    5214:	e3a00000 	mov	r0, #0	; 0x0
    5218:	e8bd0070 	pop	{r4, r5, r6}
    521c:	e12fff1e 	bx	lr
    5220:	e5902000 	ldr	r2, [r0]
    5224:	e5913000 	ldr	r3, [r1]
    5228:	e1520003 	cmp	r2, r3
    522c:	1a000004 	bne	5244 <memcmp+0x90>
    5230:	e2444004 	sub	r4, r4, #4	; 0x4
    5234:	e3540003 	cmp	r4, #3	; 0x3
    5238:	e2800004 	add	r0, r0, #4	; 0x4
    523c:	e2811004 	add	r1, r1, #4	; 0x4
    5240:	8afffff6 	bhi	5220 <memcmp+0x6c>
    5244:	e1a06000 	mov	r6, r0
    5248:	e1a05001 	mov	r5, r1
    524c:	e3540000 	cmp	r4, #0	; 0x0
    5250:	1affffe0 	bne	51d8 <memcmp+0x24>
    5254:	eaffffee 	b	5214 <memcmp+0x60>
    5258:	e060000c 	rsb	r0, r0, ip
    525c:	eaffffed 	b	5218 <memcmp+0x64>

00005260 <memcpy>:
    5260:	e92d0070 	push	{r4, r5, r6}
    5264:	e352000f 	cmp	r2, #15	; 0xf
    5268:	e1a04002 	mov	r4, r2
    526c:	e1a05001 	mov	r5, r1
    5270:	e1a02001 	mov	r2, r1
    5274:	e1a06000 	mov	r6, r0
    5278:	e1a01004 	mov	r1, r4
    527c:	9a000002 	bls	528c <memcpy+0x2c>
    5280:	e1853006 	orr	r3, r5, r6
    5284:	e3130003 	tst	r3, #3	; 0x3
    5288:	0a00000a 	beq	52b8 <memcpy+0x58>
    528c:	e3510000 	cmp	r1, #0	; 0x0
    5290:	0a000005 	beq	52ac <memcpy+0x4c>
    5294:	e3a0c000 	mov	ip, #0	; 0x0
    5298:	e7d2300c 	ldrb	r3, [r2, ip]
    529c:	e7c0300c 	strb	r3, [r0, ip]
    52a0:	e28cc001 	add	ip, ip, #1	; 0x1
    52a4:	e15c0001 	cmp	ip, r1
    52a8:	1afffffa 	bne	5298 <memcpy+0x38>
    52ac:	e1a00006 	mov	r0, r6
    52b0:	e8bd0070 	pop	{r4, r5, r6}
    52b4:	e12fff1e 	bx	lr
    52b8:	e1a01006 	mov	r1, r6
    52bc:	e1a0c005 	mov	ip, r5
    52c0:	e1a00004 	mov	r0, r4
    52c4:	e59c3000 	ldr	r3, [ip]
    52c8:	e5813000 	str	r3, [r1]
    52cc:	e59c2004 	ldr	r2, [ip, #4]
    52d0:	e5812004 	str	r2, [r1, #4]
    52d4:	e59c3008 	ldr	r3, [ip, #8]
    52d8:	e5813008 	str	r3, [r1, #8]
    52dc:	e2400010 	sub	r0, r0, #16	; 0x10
    52e0:	e59c300c 	ldr	r3, [ip, #12]
    52e4:	e350000f 	cmp	r0, #15	; 0xf
    52e8:	e581300c 	str	r3, [r1, #12]
    52ec:	e28cc010 	add	ip, ip, #16	; 0x10
    52f0:	e2811010 	add	r1, r1, #16	; 0x10
    52f4:	8afffff2 	bhi	52c4 <memcpy+0x64>
    52f8:	e2442010 	sub	r2, r4, #16	; 0x10
    52fc:	e1a03222 	lsr	r3, r2, #4
    5300:	e0421203 	sub	r1, r2, r3, lsl #4
    5304:	e2833001 	add	r3, r3, #1	; 0x1
    5308:	e1a03203 	lsl	r3, r3, #4
    530c:	e3510003 	cmp	r1, #3	; 0x3
    5310:	e0854003 	add	r4, r5, r3
    5314:	e0860003 	add	r0, r6, r3
    5318:	9a00000d 	bls	5354 <memcpy+0xf4>
    531c:	e3a0c000 	mov	ip, #0	; 0x0
    5320:	e794300c 	ldr	r3, [r4, ip]
    5324:	e780300c 	str	r3, [r0, ip]
    5328:	e28cc004 	add	ip, ip, #4	; 0x4
    532c:	e06c3001 	rsb	r3, ip, r1
    5330:	e3530003 	cmp	r3, #3	; 0x3
    5334:	8afffff9 	bhi	5320 <memcpy+0xc0>
    5338:	e2411004 	sub	r1, r1, #4	; 0x4
    533c:	e1a02121 	lsr	r2, r1, #2
    5340:	e2823001 	add	r3, r2, #1	; 0x1
    5344:	e1a03103 	lsl	r3, r3, #2
    5348:	e0800003 	add	r0, r0, r3
    534c:	e0411102 	sub	r1, r1, r2, lsl #2
    5350:	e0844003 	add	r4, r4, r3
    5354:	e1a02004 	mov	r2, r4
    5358:	eaffffcb 	b	528c <memcpy+0x2c>

0000535c <memset>:
    535c:	e3100003 	tst	r0, #3	; 0x3
    5360:	e92d0070 	push	{r4, r5, r6}
    5364:	e1a0c000 	mov	ip, r0
    5368:	e1a05000 	mov	r5, r0
    536c:	e1a06001 	mov	r6, r1
    5370:	0a00000a 	beq	53a0 <memset+0x44>
    5374:	e3520000 	cmp	r2, #0	; 0x0
    5378:	12422001 	subne	r2, r2, #1	; 0x1
    537c:	120130ff 	andne	r3, r1, #255	; 0xff
    5380:	1a000003 	bne	5394 <memset+0x38>
    5384:	ea000033 	b	5458 <memset+0xfc>
    5388:	e3520000 	cmp	r2, #0	; 0x0
    538c:	0a000031 	beq	5458 <memset+0xfc>
    5390:	e2422001 	sub	r2, r2, #1	; 0x1
    5394:	e4cc3001 	strb	r3, [ip], #1
    5398:	e31c0003 	tst	ip, #3	; 0x3
    539c:	1afffff9 	bne	5388 <memset+0x2c>
    53a0:	e3520003 	cmp	r2, #3	; 0x3
    53a4:	e1a01002 	mov	r1, r2
    53a8:	e1a0000c 	mov	r0, ip
    53ac:	9a000021 	bls	5438 <memset+0xdc>
    53b0:	e20630ff 	and	r3, r6, #255	; 0xff
    53b4:	e1833403 	orr	r3, r3, r3, lsl #8
    53b8:	e352000f 	cmp	r2, #15	; 0xf
    53bc:	e1830803 	orr	r0, r3, r3, lsl #16
    53c0:	e1a0400c 	mov	r4, ip
    53c4:	9a00000d 	bls	5400 <memset+0xa4>
    53c8:	e1a0300c 	mov	r3, ip
    53cc:	e2411010 	sub	r1, r1, #16	; 0x10
    53d0:	e351000f 	cmp	r1, #15	; 0xf
    53d4:	e5830000 	str	r0, [r3]
    53d8:	e5830004 	str	r0, [r3, #4]
    53dc:	e5830008 	str	r0, [r3, #8]
    53e0:	e583000c 	str	r0, [r3, #12]
    53e4:	e2833010 	add	r3, r3, #16	; 0x10
    53e8:	8afffff7 	bhi	53cc <memset+0x70>
    53ec:	e2422010 	sub	r2, r2, #16	; 0x10
    53f0:	e3c2300f 	bic	r3, r2, #15	; 0xf
    53f4:	e2833010 	add	r3, r3, #16	; 0x10
    53f8:	e08c4003 	add	r4, ip, r3
    53fc:	e202100f 	and	r1, r2, #15	; 0xf
    5400:	e3510003 	cmp	r1, #3	; 0x3
    5404:	9a00000a 	bls	5434 <memset+0xd8>
    5408:	e3a0c000 	mov	ip, #0	; 0x0
    540c:	e784000c 	str	r0, [r4, ip]
    5410:	e28cc004 	add	ip, ip, #4	; 0x4
    5414:	e06c3001 	rsb	r3, ip, r1
    5418:	e3530003 	cmp	r3, #3	; 0x3
    541c:	8afffffa 	bhi	540c <memset+0xb0>
    5420:	e2412004 	sub	r2, r1, #4	; 0x4
    5424:	e3c23003 	bic	r3, r2, #3	; 0x3
    5428:	e2833004 	add	r3, r3, #4	; 0x4
    542c:	e0844003 	add	r4, r4, r3
    5430:	e2021003 	and	r1, r2, #3	; 0x3
    5434:	e1a00004 	mov	r0, r4
    5438:	e3510000 	cmp	r1, #0	; 0x0
    543c:	0a000005 	beq	5458 <memset+0xfc>
    5440:	e20630ff 	and	r3, r6, #255	; 0xff
    5444:	e3a0c000 	mov	ip, #0	; 0x0
    5448:	e7c0300c 	strb	r3, [r0, ip]
    544c:	e28cc001 	add	ip, ip, #1	; 0x1
    5450:	e151000c 	cmp	r1, ip
    5454:	1afffffb 	bne	5448 <memset+0xec>
    5458:	e1a00005 	mov	r0, r5
    545c:	e8bd0070 	pop	{r4, r5, r6}
    5460:	e12fff1e 	bx	lr

00005464 <__aeabi_uidiv>:
    5464:	e2512001 	subs	r2, r1, #1	; 0x1
    5468:	012fff1e 	bxeq	lr
    546c:	3a000036 	bcc	554c <__aeabi_uidiv+0xe8>
    5470:	e1500001 	cmp	r0, r1
    5474:	9a000022 	bls	5504 <__aeabi_uidiv+0xa0>
    5478:	e1110002 	tst	r1, r2
    547c:	0a000023 	beq	5510 <__aeabi_uidiv+0xac>
    5480:	e311020e 	tst	r1, #-536870912	; 0xe0000000
    5484:	01a01181 	lsleq	r1, r1, #3
    5488:	03a03008 	moveq	r3, #8	; 0x8
    548c:	13a03001 	movne	r3, #1	; 0x1
    5490:	e3510201 	cmp	r1, #268435456	; 0x10000000
    5494:	31510000 	cmpcc	r1, r0
    5498:	31a01201 	lslcc	r1, r1, #4
    549c:	31a03203 	lslcc	r3, r3, #4
    54a0:	3afffffa 	bcc	5490 <__aeabi_uidiv+0x2c>
    54a4:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    54a8:	31510000 	cmpcc	r1, r0
    54ac:	31a01081 	lslcc	r1, r1, #1
    54b0:	31a03083 	lslcc	r3, r3, #1
    54b4:	3afffffa 	bcc	54a4 <__aeabi_uidiv+0x40>
    54b8:	e3a02000 	mov	r2, #0	; 0x0
    54bc:	e1500001 	cmp	r0, r1
    54c0:	20400001 	subcs	r0, r0, r1
    54c4:	21822003 	orrcs	r2, r2, r3
    54c8:	e15000a1 	cmp	r0, r1, lsr #1
    54cc:	204000a1 	subcs	r0, r0, r1, lsr #1
    54d0:	218220a3 	orrcs	r2, r2, r3, lsr #1
    54d4:	e1500121 	cmp	r0, r1, lsr #2
    54d8:	20400121 	subcs	r0, r0, r1, lsr #2
    54dc:	21822123 	orrcs	r2, r2, r3, lsr #2
    54e0:	e15001a1 	cmp	r0, r1, lsr #3
    54e4:	204001a1 	subcs	r0, r0, r1, lsr #3
    54e8:	218221a3 	orrcs	r2, r2, r3, lsr #3
    54ec:	e3500000 	cmp	r0, #0	; 0x0
    54f0:	11b03223 	lsrsne	r3, r3, #4
    54f4:	11a01221 	lsrne	r1, r1, #4
    54f8:	1affffef 	bne	54bc <__aeabi_uidiv+0x58>
    54fc:	e1a00002 	mov	r0, r2
    5500:	e12fff1e 	bx	lr
    5504:	03a00001 	moveq	r0, #1	; 0x1
    5508:	13a00000 	movne	r0, #0	; 0x0
    550c:	e12fff1e 	bx	lr
    5510:	e3510801 	cmp	r1, #65536	; 0x10000
    5514:	21a01821 	lsrcs	r1, r1, #16
    5518:	23a02010 	movcs	r2, #16	; 0x10
    551c:	33a02000 	movcc	r2, #0	; 0x0
    5520:	e3510c01 	cmp	r1, #256	; 0x100
    5524:	21a01421 	lsrcs	r1, r1, #8
    5528:	22822008 	addcs	r2, r2, #8	; 0x8
    552c:	e3510010 	cmp	r1, #16	; 0x10
    5530:	21a01221 	lsrcs	r1, r1, #4
    5534:	22822004 	addcs	r2, r2, #4	; 0x4
    5538:	e3510004 	cmp	r1, #4	; 0x4
    553c:	82822003 	addhi	r2, r2, #3	; 0x3
    5540:	908220a1 	addls	r2, r2, r1, lsr #1
    5544:	e1a00230 	lsr	r0, r0, r2
    5548:	e12fff1e 	bx	lr
    554c:	e52de008 	str	lr, [sp, #-8]!
    5550:	eb00003a 	bl	5640 <__aeabi_idiv0>
    5554:	e3a00000 	mov	r0, #0	; 0x0
    5558:	e49df008 	ldr	pc, [sp], #8

0000555c <__aeabi_uidivmod>:
    555c:	e92d4003 	push	{r0, r1, lr}
    5560:	ebffffbf 	bl	5464 <__aeabi_uidiv>
    5564:	e8bd4006 	pop	{r1, r2, lr}
    5568:	e0030092 	mul	r3, r2, r0
    556c:	e0411003 	sub	r1, r1, r3
    5570:	e12fff1e 	bx	lr

00005574 <__umodsi3>:
    5574:	e2512001 	subs	r2, r1, #1	; 0x1
    5578:	3a00002c 	bcc	5630 <__umodsi3+0xbc>
    557c:	11500001 	cmpne	r0, r1
    5580:	03a00000 	moveq	r0, #0	; 0x0
    5584:	81110002 	tsthi	r1, r2
    5588:	00000002 	andeq	r0, r0, r2
    558c:	912fff1e 	bxls	lr
    5590:	e3a02000 	mov	r2, #0	; 0x0
    5594:	e3510201 	cmp	r1, #268435456	; 0x10000000
    5598:	31510000 	cmpcc	r1, r0
    559c:	31a01201 	lslcc	r1, r1, #4
    55a0:	32822004 	addcc	r2, r2, #4	; 0x4
    55a4:	3afffffa 	bcc	5594 <__umodsi3+0x20>
    55a8:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    55ac:	31510000 	cmpcc	r1, r0
    55b0:	31a01081 	lslcc	r1, r1, #1
    55b4:	32822001 	addcc	r2, r2, #1	; 0x1
    55b8:	3afffffa 	bcc	55a8 <__umodsi3+0x34>
    55bc:	e2522003 	subs	r2, r2, #3	; 0x3
    55c0:	ba00000e 	blt	5600 <__umodsi3+0x8c>
    55c4:	e1500001 	cmp	r0, r1
    55c8:	20400001 	subcs	r0, r0, r1
    55cc:	e15000a1 	cmp	r0, r1, lsr #1
    55d0:	204000a1 	subcs	r0, r0, r1, lsr #1
    55d4:	e1500121 	cmp	r0, r1, lsr #2
    55d8:	20400121 	subcs	r0, r0, r1, lsr #2
    55dc:	e15001a1 	cmp	r0, r1, lsr #3
    55e0:	204001a1 	subcs	r0, r0, r1, lsr #3
    55e4:	e3500001 	cmp	r0, #1	; 0x1
    55e8:	e1a01221 	lsr	r1, r1, #4
    55ec:	a2522004 	subsge	r2, r2, #4	; 0x4
    55f0:	aafffff3 	bge	55c4 <__umodsi3+0x50>
    55f4:	e3120003 	tst	r2, #3	; 0x3
    55f8:	13300000 	teqne	r0, #0	; 0x0
    55fc:	0a00000a 	beq	562c <__umodsi3+0xb8>
    5600:	e3720002 	cmn	r2, #2	; 0x2
    5604:	ba000006 	blt	5624 <__umodsi3+0xb0>
    5608:	0a000002 	beq	5618 <__umodsi3+0xa4>
    560c:	e1500001 	cmp	r0, r1
    5610:	20400001 	subcs	r0, r0, r1
    5614:	e1a010a1 	lsr	r1, r1, #1
    5618:	e1500001 	cmp	r0, r1
    561c:	20400001 	subcs	r0, r0, r1
    5620:	e1a010a1 	lsr	r1, r1, #1
    5624:	e1500001 	cmp	r0, r1
    5628:	20400001 	subcs	r0, r0, r1
    562c:	e12fff1e 	bx	lr
    5630:	e52de008 	str	lr, [sp, #-8]!
    5634:	eb000001 	bl	5640 <__aeabi_idiv0>
    5638:	e3a00000 	mov	r0, #0	; 0x0
    563c:	e49df008 	ldr	pc, [sp], #8

00005640 <__aeabi_idiv0>:
    5640:	e12fff1e 	bx	lr
    5644:	6c6c6548 	cfstr64vs	mvdx6, [ip], #-288
    5648:	726f576f 	rsbvc	r5, pc, #29097984	; 0x1bc0000
    564c:	0a0d646c 	beq	35e804 <__ctors_end__+0x359060>
    5650:	00000000 	andeq	r0, r0, r0
    5654:	6b61740a 	blvs	1862684 <__ctors_end__+0x185cee0>
    5658:	6e732065 	cdpvs	0, 7, cr2, cr3, cr5, {3}
    565c:	68737061 	ldmdavs	r3!, {r0, r5, r6, ip, sp, lr}^
    5660:	000d746f 	andeq	r7, sp, pc, ror #8
    5664:	7a69730a 	bvc	1a62294 <__ctors_end__+0x1a5caf0>
    5668:	25203a65 	strcs	r3, [r0, #-2661]!
    566c:	00000d64 	andeq	r0, r0, r4, ror #26
    5670:	646e650a 	strbtvs	r6, [lr], #-1290
    5674:	00000a0d 	andeq	r0, r0, sp, lsl #20
    5678:	6174730a 	cmnvs	r4, sl, lsl #6
    567c:	65527472 	ldrbvs	r7, [r2, #-1138]
    5680:	64726f63 	ldrbtvs	r6, [r2], #-3939
    5684:	0d676e69 	stcleq	14, cr6, [r7, #-420]!
    5688:	00000000 	andeq	r0, r0, r0
    568c:	616d690a 	cmnvs	sp, sl, lsl #18
    5690:	20736567 	rsbscs	r6, r3, r7, ror #10
    5694:	726f7473 	rsbvc	r7, pc, #1929379840	; 0x73000000
    5698:	253d6465 	ldrcs	r6, [sp, #-1125]!
    569c:	000a0d64 	andeq	r0, sl, r4, ror #26
    56a0:	4e204f4e 	cdpmi	15, 2, cr4, cr0, cr14, {2}
    56a4:	20454d41 	subcs	r4, r5, r1, asr #26
    56a8:	46202020 	strtmi	r2, [r0], -r0, lsr #32
    56ac:	20205441 	eorcs	r5, r0, r1, asr #8
    56b0:	00202020 	eoreq	r2, r0, r0, lsr #32
    56b4:	4e204f4e 	cdpmi	15, 2, cr4, cr0, cr14, {2}
    56b8:	20454d41 	subcs	r4, r5, r1, asr #26
    56bc:	46202020 	strtmi	r2, [r0], -r0, lsr #32
    56c0:	32335441 	eorscc	r5, r3, #1090519040	; 0x41000000
    56c4:	00202020 	eoreq	r2, r0, r0, lsr #32
    56c8:	00544146 	subseq	r4, r4, r6, asr #2
    56cc:	33544146 	cmpcc	r4, #-2147483631	; 0x80000011
    56d0:	00000032 	andeq	r0, r0, r2, lsr r0
    56d4:	3d63720a 	sfmcc	f7, 2, [r3, #-40]!
    56d8:	46207525 	strtmi	r7, [r0], -r5, lsr #10
    56dc:	73255f52 	teqvc	r5, #328	; 0x148
    56e0:	00000000 	andeq	r0, r0, r0
    56e4:	657a6973 	ldrbvs	r6, [sl, #-2419]!
    56e8:	6e69622e 	cdpvs	2, 6, cr6, cr9, cr14, {1}
    56ec:	00000000 	andeq	r0, r0, r0
    56f0:	65646976 	strbvs	r6, [r4, #-2422]!
    56f4:	69622e6f 	stmdbvs	r2!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp}^
    56f8:	0000006e 	andeq	r0, r0, lr, rrx
    56fc:	70616e73 	rsbvc	r6, r1, r3, ror lr
    5700:	746f6873 	strbtvc	r6, [pc], #2163	; 5708 <__aeabi_idiv0+0xc8>
    5704:	67706a2e 	ldrbvs	r6, [r0, -lr, lsr #20]!
    5708:	00000000 	andeq	r0, r0, r0

0000570c <str.2353>:
    570c:	4e004b4f 525f544f 59444145 5f4f4e00     OK.NOT_READY.NO_
    571c:	454c4946 5f524600 505f4f4e 00485441     FILE.FR_NO_PATH.
    572c:	41564e49 5f44494c 454d414e 564e4900     INVALID_NAME.INV
    573c:	44494c41 4952445f 44004556 45494e45     ALID_DRIVE.DENIE
    574c:	58450044 00545349 455f5752 524f5252     D.EXIST.RW_ERROR
    575c:	49525700 505f4554 45544f52 44455443     .WRITE_PROTECTED
    576c:	544f4e00 414e455f 44454c42 5f4f4e00     .NOT_ENABLED.NO_
    577c:	454c4946 54535953 49004d45 4c41564e     FILESYSTEM.INVAL
    578c:	4f5f4449 43454a42 4b4d0054 415f5346     ID_OBJECT.MKFS_A
    579c:	54524f42 00004445                       BORTED..
