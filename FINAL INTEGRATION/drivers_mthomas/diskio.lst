   1              		.file	"diskio.c"
   9              	.Ltext0:
  10              		.section	.text.disk_status,"ax",%progbits
  11              		.align	2
  12              		.global	disk_status
  14              	disk_status:
  15              	.LFB18:
  16              		.file 1 "drivers_mthomas/diskio.c"
   1:drivers_mthomas/diskio.c **** /*-----------------------------------------------------------------------*/
   2:drivers_mthomas/diskio.c **** /* Low level disk I/O module                                             */
   3:drivers_mthomas/diskio.c **** /* (C) Copyright 2007,2008                                               */
   4:drivers_mthomas/diskio.c **** /* Martin Thomas, Lorenz Aebi                                            */
   5:drivers_mthomas/diskio.c **** /*-----------------------------------------------------------------------*/
   6:drivers_mthomas/diskio.c **** /* This is a LPC23xx/24xx MCI disk I/O module                            */
   7:drivers_mthomas/diskio.c **** /*-----------------------------------------------------------------------*/
   8:drivers_mthomas/diskio.c **** 
   9:drivers_mthomas/diskio.c **** // Add Multi Block Write by Lorenz Aebi 2008
  10:drivers_mthomas/diskio.c **** // Bugfix from Marco Ziegert 20090823
  11:drivers_mthomas/diskio.c **** 
  12:drivers_mthomas/diskio.c **** // #define DISKIO_DEBUG
  13:drivers_mthomas/diskio.c **** // #define DISKIO_DUMPSTAT
  14:drivers_mthomas/diskio.c **** // #define DISKIO_DEBUGR
  15:drivers_mthomas/diskio.c **** // #define DISKIO_DEBUGW
  16:drivers_mthomas/diskio.c **** 
  17:drivers_mthomas/diskio.c **** #include "LPC23xx.h"
  18:drivers_mthomas/diskio.c **** #include "type.h"
  19:drivers_mthomas/diskio.c **** #include "irq.h"
  20:drivers_mthomas/diskio.c **** #include "target.h"
  21:drivers_mthomas/diskio.c **** #include "mci.h"
  22:drivers_mthomas/diskio.c **** #include "dma.h"
  23:drivers_mthomas/diskio.c **** #include <string.h>
  24:drivers_mthomas/diskio.c **** 
  25:drivers_mthomas/diskio.c **** #include "diskio.h"
  26:drivers_mthomas/diskio.c **** #ifdef __GNUC__
  27:drivers_mthomas/diskio.c **** #include "monitor.h"
  28:drivers_mthomas/diskio.c **** #define myprintf xprintf
  29:drivers_mthomas/diskio.c **** #else
  30:drivers_mthomas/diskio.c **** #include <stdio.h>
  31:drivers_mthomas/diskio.c **** #define myprintf printf
  32:drivers_mthomas/diskio.c **** #endif
  33:drivers_mthomas/diskio.c **** 
  34:drivers_mthomas/diskio.c **** #ifdef __ARMCC_VERSION
  35:drivers_mthomas/diskio.c **** // RealView
  36:drivers_mthomas/diskio.c **** #define INLINE __inline
  37:drivers_mthomas/diskio.c **** #else
  38:drivers_mthomas/diskio.c **** // gcc
  39:drivers_mthomas/diskio.c **** #define INLINE inline
  40:drivers_mthomas/diskio.c **** #endif
  41:drivers_mthomas/diskio.c **** 
  42:drivers_mthomas/diskio.c **** #ifdef DISKIO_DEBUG
  43:drivers_mthomas/diskio.c **** #define diskio_printf myprintf
  44:drivers_mthomas/diskio.c **** #else
  45:drivers_mthomas/diskio.c **** #define diskio_printf( fmt, args... )
  46:drivers_mthomas/diskio.c **** #endif
  47:drivers_mthomas/diskio.c **** 
  48:drivers_mthomas/diskio.c **** #ifdef DISKIO_DEBUGR
  49:drivers_mthomas/diskio.c **** #define diskio_printfr myprintf
  50:drivers_mthomas/diskio.c **** #else
  51:drivers_mthomas/diskio.c **** #define diskio_printfr( fmt, args... )
  52:drivers_mthomas/diskio.c **** #endif
  53:drivers_mthomas/diskio.c **** 
  54:drivers_mthomas/diskio.c **** #ifdef DISKIO_DEBUGW
  55:drivers_mthomas/diskio.c **** #define diskio_printfw myprintf
  56:drivers_mthomas/diskio.c **** #else
  57:drivers_mthomas/diskio.c **** // #define diskio_printfw( fmt, args... )
  58:drivers_mthomas/diskio.c **** #define diskio_printfw( fmt, ... )
  59:drivers_mthomas/diskio.c **** #endif
  60:drivers_mthomas/diskio.c **** 
  61:drivers_mthomas/diskio.c **** 
  62:drivers_mthomas/diskio.c **** static volatile
  63:drivers_mthomas/diskio.c **** DWORD Timer1, Timer2;	/* 1000Hz decrement timer */
  64:drivers_mthomas/diskio.c **** 
  65:drivers_mthomas/diskio.c **** static volatile
  66:drivers_mthomas/diskio.c **** DSTATUS Stat = STA_NOINIT;	/* Disk status */
  67:drivers_mthomas/diskio.c **** 
  68:drivers_mthomas/diskio.c **** static
  69:drivers_mthomas/diskio.c **** UINT CardType;			/* b0:MMC, b1:SDC, b2:Block addressing */
  70:drivers_mthomas/diskio.c **** 
  71:drivers_mthomas/diskio.c **** static 
  72:drivers_mthomas/diskio.c **** BYTE csd[16]; /* cached csd */
  73:drivers_mthomas/diskio.c **** 
  74:drivers_mthomas/diskio.c **** static 
  75:drivers_mthomas/diskio.c **** BYTE sd_status[16]; /* cached 16 MS-Bytes from SD_STATUS (ACMD13) */
  76:drivers_mthomas/diskio.c **** 
  77:drivers_mthomas/diskio.c **** #define	DWORD_TO_BYTES(byte_ptr_,dw_val_)	\
  78:drivers_mthomas/diskio.c **** do { \
  79:drivers_mthomas/diskio.c **** 	*(BYTE*)(byte_ptr_)     = (BYTE)((DWORD)(dw_val_)>>24); \
  80:drivers_mthomas/diskio.c **** 	*(BYTE*)((byte_ptr_)+1) = (BYTE)((DWORD)(dw_val_)>>16); \
  81:drivers_mthomas/diskio.c **** 	*(BYTE*)((byte_ptr_)+2) = (BYTE)((WORD)(dw_val_)>>8);   \
  82:drivers_mthomas/diskio.c **** 	*(BYTE*)((byte_ptr_)+3) = (BYTE)(dw_val_); \
  83:drivers_mthomas/diskio.c **** } while (0)
  84:drivers_mthomas/diskio.c **** 
  85:drivers_mthomas/diskio.c **** 
  86:drivers_mthomas/diskio.c **** extern volatile DWORD MCI_CardType;
  87:drivers_mthomas/diskio.c **** extern volatile DWORD MCI_Block_End_Flag;
  88:drivers_mthomas/diskio.c **** 
  89:drivers_mthomas/diskio.c **** extern volatile BYTE *WriteBlock, *ReadBlock;
  90:drivers_mthomas/diskio.c **** 
  91:drivers_mthomas/diskio.c **** #define CURR_STATE_IDLE     0
  92:drivers_mthomas/diskio.c **** #define CURR_STATE_READY    1
  93:drivers_mthomas/diskio.c **** #define CURR_STATE_IDENT    2
  94:drivers_mthomas/diskio.c **** #define CURR_STATE_STBY     3
  95:drivers_mthomas/diskio.c **** #define CURR_STATE_TRAN     4
  96:drivers_mthomas/diskio.c **** #define CURR_STATE_DATA     5
  97:drivers_mthomas/diskio.c **** #define CURR_STATE_RCV      6
  98:drivers_mthomas/diskio.c **** #define CURR_STATE_PRG      7
  99:drivers_mthomas/diskio.c **** #define CURR_STATE_DIS      8
 100:drivers_mthomas/diskio.c **** 
 101:drivers_mthomas/diskio.c **** #ifdef DISKIO_DUMPSTAT
 102:drivers_mthomas/diskio.c **** 
 103:drivers_mthomas/diskio.c **** const char* states[] = {
 104:drivers_mthomas/diskio.c **** 	"idle", "ready", "ident", "stby", 
 105:drivers_mthomas/diskio.c **** 	"tran", "data", "rcv", "prg", "dis"
 106:drivers_mthomas/diskio.c **** };
 107:drivers_mthomas/diskio.c **** 
 108:drivers_mthomas/diskio.c **** static volatile void dump_status( const char* info )
 109:drivers_mthomas/diskio.c **** {
 110:drivers_mthomas/diskio.c **** 	DWORD st;
 111:drivers_mthomas/diskio.c **** 	DWORD currst;
 112:drivers_mthomas/diskio.c **** 
 113:drivers_mthomas/diskio.c **** 	st = MCI_Send_Status();
 114:drivers_mthomas/diskio.c **** 	if ( st == INVALID_RESPONSE ) {
 115:drivers_mthomas/diskio.c **** 		diskio_printf("dump_status: Send_Status INVALID_RESPONSE\n");
 116:drivers_mthomas/diskio.c **** 		return;
 117:drivers_mthomas/diskio.c **** 	}
 118:drivers_mthomas/diskio.c **** 
 119:drivers_mthomas/diskio.c **** 	diskio_printf("------ Status register %s\n -----", info);
 120:drivers_mthomas/diskio.c **** 	diskio_printf("AKE_SEQ_ERROR    : %s\n",  (st & (1 <<  3)) ? "error"     : "no error" );
 121:drivers_mthomas/diskio.c **** 	diskio_printf("APP_CMD          : %s\n",  (st & (1 <<  5)) ? "enabled"   : "disabled" );
 122:drivers_mthomas/diskio.c **** 	diskio_printf("READY_FOR_DATA   : %s\n",  (st & (1 <<  8)) ? "not ready" : "ready"    );
 123:drivers_mthomas/diskio.c **** 
 124:drivers_mthomas/diskio.c **** 	currst = (st >> 9) & 0x0f;
 125:drivers_mthomas/diskio.c **** 	if ( currst > 8 ) {
 126:drivers_mthomas/diskio.c **** 		diskio_printf("CURR_STATE       : reserved\n");
 127:drivers_mthomas/diskio.c **** 	}
 128:drivers_mthomas/diskio.c **** 	else {
 129:drivers_mthomas/diskio.c **** 		diskio_printf("CURR_STATE       : %s   <---\n", states[currst]);
 130:drivers_mthomas/diskio.c **** 	}
 131:drivers_mthomas/diskio.c **** 	// TODO bits 13-18
 132:drivers_mthomas/diskio.c **** 	diskio_printf("ERROR            : %s\n", (st & (1<<19)) ? "error"  : "no error" );
 133:drivers_mthomas/diskio.c **** 	diskio_printf("CC_ERROR         : %s\n", (st & (1<<20)) ? "error"  : "no error" );
 134:drivers_mthomas/diskio.c **** 	diskio_printf("CARD_ECC_FAILED  : %s\n", (st & (1<<21)) ? "failure": "success"  );
 135:drivers_mthomas/diskio.c **** 	diskio_printf("ILLEGAL_COMMAND  : %s\n", (st & (1<<22)) ? "error"  : "no error" );
 136:drivers_mthomas/diskio.c **** 	diskio_printf("COM_CRC_ERROR    : %s\n", (st & (1<<23)) ? "error"  : "no error" );
 137:drivers_mthomas/diskio.c **** 	diskio_printf("LOCK_UNLOCK_FAIL : %s\n", (st & (1<<24)) ? "error"  : "no error" );
 138:drivers_mthomas/diskio.c **** 	diskio_printf("CARD_IS_LOCKED   : %s\n", (st & (1<<25)) ? "locked" : "unlocked" );
 139:drivers_mthomas/diskio.c **** 	// TODO bits 26-28
 140:drivers_mthomas/diskio.c **** 	diskio_printf("BLOCK_LEN_ERROR  : %s\n", (st & (1<<29)) ? "error"  : "no error" );
 141:drivers_mthomas/diskio.c **** 	diskio_printf("ADDRESS_ERROR    : %s\n", (st & (1<<30)) ? "error"  : "no error" );
 142:drivers_mthomas/diskio.c **** 	diskio_printf("OUT_OF_RANGE     : %s\n", (st & (1<<31)) ? "error"  : "no error" );
 143:drivers_mthomas/diskio.c **** }
 144:drivers_mthomas/diskio.c **** #else 
 145:drivers_mthomas/diskio.c **** #define dump_status(s__)
 146:drivers_mthomas/diskio.c **** #endif
 147:drivers_mthomas/diskio.c **** 
 148:drivers_mthomas/diskio.c **** static INLINE USHORT currstate_from_status( DWORD st )
 149:drivers_mthomas/diskio.c **** {
 150:drivers_mthomas/diskio.c **** 	return ( (st >> 9 ) & 0xff );
 151:drivers_mthomas/diskio.c **** }
 152:drivers_mthomas/diskio.c **** 
 153:drivers_mthomas/diskio.c **** static INLINE BYTE status_ready_bit( DWORD st )
 154:drivers_mthomas/diskio.c **** {
 155:drivers_mthomas/diskio.c **** 	return ( st & ( 1<<8 ) ) ? 1 : 0;
 156:drivers_mthomas/diskio.c **** }
 157:drivers_mthomas/diskio.c **** 
 158:drivers_mthomas/diskio.c **** // state to trans (SD Card State Diagram: V2.2 P4-7)
 159:drivers_mthomas/diskio.c **** static void SELECT(void)
 160:drivers_mthomas/diskio.c **** {
 161:drivers_mthomas/diskio.c **** 	DWORD currst, st;
 162:drivers_mthomas/diskio.c **** 	dump_status("before select");
 163:drivers_mthomas/diskio.c **** 
 164:drivers_mthomas/diskio.c **** 	Timer2 = 1000;
 165:drivers_mthomas/diskio.c **** 	do {
 166:drivers_mthomas/diskio.c **** 		// cmd7 until state is trans
 167:drivers_mthomas/diskio.c **** 		st = MCI_Send_Status();
 168:drivers_mthomas/diskio.c **** 		currst = currstate_from_status(st);
 169:drivers_mthomas/diskio.c **** 		if ( currst != CURR_STATE_TRAN ) {
 170:drivers_mthomas/diskio.c **** 			if ( MCI_Select_Card() == FALSE ) {
 171:drivers_mthomas/diskio.c **** 				diskio_printf("SELECT Select_Card failed - retry\n");
 172:drivers_mthomas/diskio.c **** 			}
 173:drivers_mthomas/diskio.c **** 		}
 174:drivers_mthomas/diskio.c **** 	} while ( ( currst != CURR_STATE_TRAN ) && Timer2 );
 175:drivers_mthomas/diskio.c **** 
 176:drivers_mthomas/diskio.c **** 	if ( Timer2 == 0 ) {
 177:drivers_mthomas/diskio.c **** 		diskio_printf("SELECT timeout changeing to trans\n");
 178:drivers_mthomas/diskio.c **** 	}
 179:drivers_mthomas/diskio.c **** 	dump_status("after select");
 180:drivers_mthomas/diskio.c **** }
 181:drivers_mthomas/diskio.c **** 
 182:drivers_mthomas/diskio.c **** // state to stby
 183:drivers_mthomas/diskio.c **** static void DESELECT(void)
 184:drivers_mthomas/diskio.c **** {
 185:drivers_mthomas/diskio.c **** 	DWORD cardtype_save, st, currst;
 186:drivers_mthomas/diskio.c **** 
 187:drivers_mthomas/diskio.c **** 	Timer2 = 500;
 188:drivers_mthomas/diskio.c **** 	do {
 189:drivers_mthomas/diskio.c **** 		st = MCI_Send_Status();
 190:drivers_mthomas/diskio.c **** 		
 191:drivers_mthomas/diskio.c **** 		currst = currstate_from_status(st);
 192:drivers_mthomas/diskio.c **** 	} while ( ( currst != CURR_STATE_TRAN ) && 
 193:drivers_mthomas/diskio.c **** 	          ( currst != CURR_STATE_STBY  ) && 
 194:drivers_mthomas/diskio.c **** 	          Timer2 );
 195:drivers_mthomas/diskio.c **** 
 196:drivers_mthomas/diskio.c **** 	if ( Timer2 == 0 ) {
 197:drivers_mthomas/diskio.c **** 		diskio_printf("DESELCT timeout waiting trans or stby\n");
 198:drivers_mthomas/diskio.c **** 	}
 199:drivers_mthomas/diskio.c **** 	else if ( currst == CURR_STATE_TRAN ) {
 200:drivers_mthomas/diskio.c **** 		cardtype_save = MCI_CardType;
 201:drivers_mthomas/diskio.c **** 		// CMD7: trans to stby (RCA 0) / de-select
 202:drivers_mthomas/diskio.c **** 		MCI_CardType = 0;
 203:drivers_mthomas/diskio.c **** 		if ( MCI_Select_Card() == FALSE ) {
 204:drivers_mthomas/diskio.c **** 			diskio_printf("DESELECT failed\n");
 205:drivers_mthomas/diskio.c **** 		}
 206:drivers_mthomas/diskio.c **** 		MCI_CardType = cardtype_save;
 207:drivers_mthomas/diskio.c **** 	}
 208:drivers_mthomas/diskio.c **** 	else {
 209:drivers_mthomas/diskio.c **** 		//diskio_printf("DSELECT already in stby\n");
 210:drivers_mthomas/diskio.c **** 	}
 211:drivers_mthomas/diskio.c **** 	
 212:drivers_mthomas/diskio.c **** 	return;
 213:drivers_mthomas/diskio.c **** }
 214:drivers_mthomas/diskio.c **** 
 215:drivers_mthomas/diskio.c **** // wait for stby or trans with timeout
 216:drivers_mthomas/diskio.c **** static BYTE wait_ready( void ) 
 217:drivers_mthomas/diskio.c **** {
 218:drivers_mthomas/diskio.c **** 	BYTE res;
 219:drivers_mthomas/diskio.c **** 	DWORD st;
 220:drivers_mthomas/diskio.c **** 	// DWORD currst;
 221:drivers_mthomas/diskio.c **** 
 222:drivers_mthomas/diskio.c **** 	res = 0xaa;
 223:drivers_mthomas/diskio.c **** 	Timer2 = 500;	/* Wait for ready in timeout of 500ms */
 224:drivers_mthomas/diskio.c **** 	do {
 225:drivers_mthomas/diskio.c **** 		st = MCI_Send_Status();
 226:drivers_mthomas/diskio.c **** 		if ( st == INVALID_RESPONSE ) {
 227:drivers_mthomas/diskio.c **** 			diskio_printf("wait_ready: Send_Status INVALID_RESPONSE\n");
 228:drivers_mthomas/diskio.c **** 		}
 229:drivers_mthomas/diskio.c **** 		else {
 230:drivers_mthomas/diskio.c **** 			// currst = currstate_from_status(st);
 231:drivers_mthomas/diskio.c **** 			// if ( currst == 3 /* stby */ || currst == 4 /* trans */) {
 232:drivers_mthomas/diskio.c **** 			if ( status_ready_bit( st ) ) {
 233:drivers_mthomas/diskio.c **** 				res = 0xff;
 234:drivers_mthomas/diskio.c **** 			}
 235:drivers_mthomas/diskio.c **** 		}
 236:drivers_mthomas/diskio.c **** 	}
 237:drivers_mthomas/diskio.c **** 	while ( (res != 0xFF) && Timer2 );
 238:drivers_mthomas/diskio.c **** 
 239:drivers_mthomas/diskio.c **** 	if ( Timer2 == 0 ) {
 240:drivers_mthomas/diskio.c **** 		diskio_printf("wait_ready: timeout stby or trans\n");
 241:drivers_mthomas/diskio.c **** 	}
 242:drivers_mthomas/diskio.c **** 
 243:drivers_mthomas/diskio.c **** 	return res;
 244:drivers_mthomas/diskio.c **** }
 245:drivers_mthomas/diskio.c **** 
 246:drivers_mthomas/diskio.c **** // well, no SPI used here but will keep the interface compatible with
 247:drivers_mthomas/diskio.c **** // Chan's examples
 248:drivers_mthomas/diskio.c **** static void release_spi(void)
 249:drivers_mthomas/diskio.c **** {
 250:drivers_mthomas/diskio.c **** 	DESELECT();
 251:drivers_mthomas/diskio.c **** }
 252:drivers_mthomas/diskio.c **** 
 253:drivers_mthomas/diskio.c **** static void power_off (void)
 254:drivers_mthomas/diskio.c **** {
 255:drivers_mthomas/diskio.c **** 	SELECT();
 256:drivers_mthomas/diskio.c **** 	wait_ready();
 257:drivers_mthomas/diskio.c **** 	release_spi();
 258:drivers_mthomas/diskio.c **** 
 259:drivers_mthomas/diskio.c **** 	MCI_Power_Off();
 260:drivers_mthomas/diskio.c **** 
 261:drivers_mthomas/diskio.c **** 	Stat |= STA_NOINIT;		/* Set STA_NOINIT */
 262:drivers_mthomas/diskio.c **** }
 263:drivers_mthomas/diskio.c **** 
 264:drivers_mthomas/diskio.c **** 
 265:drivers_mthomas/diskio.c **** // must be in trans state - only used during init
 266:drivers_mthomas/diskio.c **** // reads the SD Status ( do not confuse with Status Register )
 267:drivers_mthomas/diskio.c **** static DWORD MCI_get_sd_status(void)
 268:drivers_mthomas/diskio.c **** {
 269:drivers_mthomas/diskio.c **** 	DWORD i;
 270:drivers_mthomas/diskio.c **** #ifdef DISKIO_DEBUG
 271:drivers_mthomas/diskio.c **** 	DWORD j;
 272:drivers_mthomas/diskio.c **** #endif
 273:drivers_mthomas/diskio.c **** 
 274:drivers_mthomas/diskio.c **** 	if ( MCI_Set_BlockLen( SD_BLOCK_LENGTH ) == FALSE )
 275:drivers_mthomas/diskio.c **** 	{
 276:drivers_mthomas/diskio.c **** 		diskio_printf("get_sd_status: Set_BlockLen SD_STATUS failed\n");
 277:drivers_mthomas/diskio.c **** 		return FALSE;
 278:drivers_mthomas/diskio.c **** 	}
 279:drivers_mthomas/diskio.c **** 	
 280:drivers_mthomas/diskio.c **** 	if ( MCI_Sd_Status() == FALSE ) {
 281:drivers_mthomas/diskio.c **** 		diskio_printf("get_sd_status: MCI_Sd_Status failed\n");
 282:drivers_mthomas/diskio.c **** 		return FALSE;
 283:drivers_mthomas/diskio.c **** 	}
 284:drivers_mthomas/diskio.c **** 	
 285:drivers_mthomas/diskio.c **** 	Timer2 = 2000;
 286:drivers_mthomas/diskio.c **** 	while ( MCI_Block_End_Flag == 1 && Timer2 ) { ; }
 287:drivers_mthomas/diskio.c **** 	if ( Timer2 == 0 ) {
 288:drivers_mthomas/diskio.c **** 		diskio_printf("get_sd_status: timeout waiting for data");
 289:drivers_mthomas/diskio.c **** 		return FALSE;
 290:drivers_mthomas/diskio.c **** 	}
 291:drivers_mthomas/diskio.c **** 
 292:drivers_mthomas/diskio.c **** #ifdef DISKIO_DEBUG
 293:drivers_mthomas/diskio.c **** 	diskio_printf("SD-Status (MS-Bytes):\n");
 294:drivers_mthomas/diskio.c **** 	j=0;
 295:drivers_mthomas/diskio.c **** 	// for ( i=0; i<64; i++ ) {
 296:drivers_mthomas/diskio.c **** 	for ( i=0; i<16; i++ ) {
 297:drivers_mthomas/diskio.c **** 		diskio_printf("%02d:%02x ", i, ReadBlock[i] );
 298:drivers_mthomas/diskio.c **** 		if ( j++ == 10 ) {
 299:drivers_mthomas/diskio.c **** 			diskio_printf("\n");
 300:drivers_mthomas/diskio.c **** 			j = 0;
 301:drivers_mthomas/diskio.c **** 		}
 302:drivers_mthomas/diskio.c **** 	}
 303:drivers_mthomas/diskio.c **** 	diskio_printf("\n");
 304:drivers_mthomas/diskio.c **** 
 305:drivers_mthomas/diskio.c **** 	diskio_printf("DAT_BUS_WIDTH : %02x = ", ReadBlock[0]>>6 );
 306:drivers_mthomas/diskio.c **** 	switch ( ReadBlock[0]>>6 ) {
 307:drivers_mthomas/diskio.c **** 		case 0:
 308:drivers_mthomas/diskio.c **** 			diskio_printf("1 (default)");
 309:drivers_mthomas/diskio.c **** 			break;
 310:drivers_mthomas/diskio.c **** 		case 1:
 311:drivers_mthomas/diskio.c **** 			diskio_printf("reserved1");
 312:drivers_mthomas/diskio.c **** 			break;
 313:drivers_mthomas/diskio.c **** 		case 2:
 314:drivers_mthomas/diskio.c **** 			diskio_printf("4-bit width");
 315:drivers_mthomas/diskio.c **** 			break;
 316:drivers_mthomas/diskio.c **** 		case 3:
 317:drivers_mthomas/diskio.c **** 			diskio_printf("reserved2");
 318:drivers_mthomas/diskio.c **** 			break;
 319:drivers_mthomas/diskio.c **** 	}
 320:drivers_mthomas/diskio.c **** 	diskio_printf("\n");
 321:drivers_mthomas/diskio.c **** #endif
 322:drivers_mthomas/diskio.c **** 
 323:drivers_mthomas/diskio.c **** 	for ( i=0; i<16; i++ ) {
 324:drivers_mthomas/diskio.c **** 		sd_status[i] = ReadBlock[i];
 325:drivers_mthomas/diskio.c **** 	}
 326:drivers_mthomas/diskio.c **** 	
 327:drivers_mthomas/diskio.c **** 	return TRUE;
 328:drivers_mthomas/diskio.c **** }
 329:drivers_mthomas/diskio.c **** 
 330:drivers_mthomas/diskio.c **** static int MCI_disk_initialize(void)
 331:drivers_mthomas/diskio.c **** {
 332:drivers_mthomas/diskio.c **** 	int err = 0, i;
 333:drivers_mthomas/diskio.c **** 	DWORD csddw[4];
 334:drivers_mthomas/diskio.c **** 
 335:drivers_mthomas/diskio.c **** 	diskio_printf("\n");
 336:drivers_mthomas/diskio.c **** #if MCI_DMA_ENABLED
 337:drivers_mthomas/diskio.c **** 	/* on DMA channel 0, source is memory, destination is MCI FIFO. */
 338:drivers_mthomas/diskio.c **** 	/* On DMA channel 1, source is MCI FIFO, destination is memory. */
 339:drivers_mthomas/diskio.c **** 	DMA_Init();
 340:drivers_mthomas/diskio.c **** 	diskio_printf("MCI DMA enabled\n");
 341:drivers_mthomas/diskio.c **** #endif
 342:drivers_mthomas/diskio.c **** 
 343:drivers_mthomas/diskio.c **** 	if ( MCI_Init() != TRUE )
 344:drivers_mthomas/diskio.c **** 	{
 345:drivers_mthomas/diskio.c **** 		diskio_printf("MCI_Init failed\n");
 346:drivers_mthomas/diskio.c **** 		err++; /* fatal error */
 347:drivers_mthomas/diskio.c **** 	}
 348:drivers_mthomas/diskio.c **** 	
 349:drivers_mthomas/diskio.c **** 	if ( !err ) 
 350:drivers_mthomas/diskio.c **** 	{
 351:drivers_mthomas/diskio.c **** 		MCI_CardType = MCI_CardInit();
 352:drivers_mthomas/diskio.c **** 		if ( MCI_CardType == CARD_UNKNOWN )
 353:drivers_mthomas/diskio.c **** 		{
 354:drivers_mthomas/diskio.c **** 			diskio_printf("unknown card\n");
 355:drivers_mthomas/diskio.c **** 			err++; /* fatal error */
 356:drivers_mthomas/diskio.c **** 		}
 357:drivers_mthomas/diskio.c **** 	}
 358:drivers_mthomas/diskio.c **** 
 359:drivers_mthomas/diskio.c **** 	if ( err || MCI_Check_CID() == FALSE )
 360:drivers_mthomas/diskio.c **** 	{
 361:drivers_mthomas/diskio.c **** 		diskio_printf("Check_CID failed\n");
 362:drivers_mthomas/diskio.c **** 		err++; /* fatal error */
 363:drivers_mthomas/diskio.c **** 	}
 364:drivers_mthomas/diskio.c **** 	
 365:drivers_mthomas/diskio.c **** 	if ( err || MCI_Set_Address() == FALSE )
 366:drivers_mthomas/diskio.c **** 	{
 367:drivers_mthomas/diskio.c **** 		diskio_printf("Set_Address failed\n");
 368:drivers_mthomas/diskio.c **** 		err++; /* fatal error */
 369:drivers_mthomas/diskio.c **** 	}
 370:drivers_mthomas/diskio.c **** 	
 371:drivers_mthomas/diskio.c **** 	if ( err || MCI_Send_CSD( csddw ) == FALSE )
 372:drivers_mthomas/diskio.c **** 	{
 373:drivers_mthomas/diskio.c **** 		diskio_printf("Send_CSD failed\n");
 374:drivers_mthomas/diskio.c **** 		err++;
 375:drivers_mthomas/diskio.c **** 	}
 376:drivers_mthomas/diskio.c **** 	else 
 377:drivers_mthomas/diskio.c **** 	{
 378:drivers_mthomas/diskio.c **** 		diskio_printf("diskio: CSD %08x %08x %08x %08x\n",
 379:drivers_mthomas/diskio.c **** 			csddw[0], csddw[1], csddw[2], csddw[3]);
 380:drivers_mthomas/diskio.c **** 		for ( i=0; i<4; i++ ) {
 381:drivers_mthomas/diskio.c **** 			DWORD_TO_BYTES( &csd[i*4], csddw[i] );
 382:drivers_mthomas/diskio.c **** 		}
 383:drivers_mthomas/diskio.c **** 	}
 384:drivers_mthomas/diskio.c **** 	
 385:drivers_mthomas/diskio.c **** 	if ( err || MCI_Select_Card() == FALSE )
 386:drivers_mthomas/diskio.c **** 	{
 387:drivers_mthomas/diskio.c **** 		diskio_printf("Select_Card failed\n");
 388:drivers_mthomas/diskio.c **** 		err++;
 389:drivers_mthomas/diskio.c **** 	}
 390:drivers_mthomas/diskio.c **** 	
 391:drivers_mthomas/diskio.c **** 	if ( !err ) 
 392:drivers_mthomas/diskio.c **** 	{
 393:drivers_mthomas/diskio.c **** 		if ( ( MCI_CardType == SD_CARD ) || 
 394:drivers_mthomas/diskio.c **** 		     ( MCI_CardType == SDHC_CARD ) )
 395:drivers_mthomas/diskio.c **** 		{
 396:drivers_mthomas/diskio.c **** 			MCI_Set_MCIClock( NORMAL_RATE );
 397:drivers_mthomas/diskio.c **** 			if (SD_Set_BusWidth( SD_4_BIT ) != TRUE )
 398:drivers_mthomas/diskio.c **** 			{
 399:drivers_mthomas/diskio.c **** 				diskio_printf("set 4 bit mode failed\n");
 400:drivers_mthomas/diskio.c **** 				err++;
 401:drivers_mthomas/diskio.c **** 			}
 402:drivers_mthomas/diskio.c **** 		}
 403:drivers_mthomas/diskio.c **** 	}
 404:drivers_mthomas/diskio.c **** 	
 405:drivers_mthomas/diskio.c **** 	if ( !err && ( MCI_CardType == SDHC_CARD ) )
 406:drivers_mthomas/diskio.c **** // 	     ( ( MCI_CardType == SDHC_CARD ) ||
 407:drivers_mthomas/diskio.c **** //	       ( MCI_CardType == SD_CARD ) ) )
 408:drivers_mthomas/diskio.c **** 	{
 409:drivers_mthomas/diskio.c **** 		if ( MCI_get_sd_status() == FALSE ) 
 410:drivers_mthomas/diskio.c **** 		{
 411:drivers_mthomas/diskio.c **** 			diskio_printf("get_sd_status failed\n");
 412:drivers_mthomas/diskio.c **** 			err++;
 413:drivers_mthomas/diskio.c **** 		}
 414:drivers_mthomas/diskio.c **** 	}
 415:drivers_mthomas/diskio.c **** 	
 416:drivers_mthomas/diskio.c **** 	if ( err || MCI_Set_BlockLen( BLOCK_LENGTH ) == FALSE )
 417:drivers_mthomas/diskio.c **** 	{
 418:drivers_mthomas/diskio.c **** 		diskio_printf("Set_BlockLen failed\n");
 419:drivers_mthomas/diskio.c **** 		err++;
 420:drivers_mthomas/diskio.c **** 	}
 421:drivers_mthomas/diskio.c **** 	diskio_printf("Set_BlockLen o.k.\n");
 422:drivers_mthomas/diskio.c **** 
 423:drivers_mthomas/diskio.c **** 	if (!err) diskio_printf("MMC_disk_initialize ok\n");
 424:drivers_mthomas/diskio.c **** 
 425:drivers_mthomas/diskio.c **** 	return err;
 426:drivers_mthomas/diskio.c **** }
 427:drivers_mthomas/diskio.c **** 
 428:drivers_mthomas/diskio.c **** 
 429:drivers_mthomas/diskio.c **** /*-----------------------------------------------------------------------*/
 430:drivers_mthomas/diskio.c **** /* Initialize a Drive                                                    */
 431:drivers_mthomas/diskio.c **** 
 432:drivers_mthomas/diskio.c **** DSTATUS disk_initialize (
 433:drivers_mthomas/diskio.c **** 	BYTE drv				/* Physical drive nmuber (0..) */
 434:drivers_mthomas/diskio.c **** )
 435:drivers_mthomas/diskio.c **** {
 436:drivers_mthomas/diskio.c **** 	if ( drv != 0 ) return STA_NOINIT;
 437:drivers_mthomas/diskio.c **** 	if ( MCI_disk_initialize() ) {
 438:drivers_mthomas/diskio.c **** 		// error occured 
 439:drivers_mthomas/diskio.c **** 		diskio_printf("mci error\n");
 440:drivers_mthomas/diskio.c **** 		Stat |= STA_NOINIT;
 441:drivers_mthomas/diskio.c **** 		power_off();
 442:drivers_mthomas/diskio.c **** 	}
 443:drivers_mthomas/diskio.c **** 	else {
 444:drivers_mthomas/diskio.c **** 		Stat &= ~STA_NOINIT;
 445:drivers_mthomas/diskio.c **** 		// cardtype mci.h to chan cardtype - (maybe redundant)
 446:drivers_mthomas/diskio.c **** 		switch ( MCI_CardType ) {
 447:drivers_mthomas/diskio.c **** 		case SDHC_CARD :
 448:drivers_mthomas/diskio.c **** 			CardType = 4;
 449:drivers_mthomas/diskio.c **** 			break;
 450:drivers_mthomas/diskio.c **** 		case MMC_CARD :
 451:drivers_mthomas/diskio.c **** 			CardType = 1;
 452:drivers_mthomas/diskio.c **** 			break;
 453:drivers_mthomas/diskio.c **** 		case SD_CARD :
 454:drivers_mthomas/diskio.c **** 			CardType = 2;
 455:drivers_mthomas/diskio.c **** 			break;
 456:drivers_mthomas/diskio.c **** 		default :
 457:drivers_mthomas/diskio.c **** 			CardType = 0;
 458:drivers_mthomas/diskio.c **** 		}
 459:drivers_mthomas/diskio.c **** 	}
 460:drivers_mthomas/diskio.c **** 	
 461:drivers_mthomas/diskio.c **** 	return Stat;
 462:drivers_mthomas/diskio.c **** }
 463:drivers_mthomas/diskio.c **** 
 464:drivers_mthomas/diskio.c **** 
 465:drivers_mthomas/diskio.c **** 
 466:drivers_mthomas/diskio.c **** /*-----------------------------------------------------------------------*/
 467:drivers_mthomas/diskio.c **** /* Return Disk Status                                                    */
 468:drivers_mthomas/diskio.c **** 
 469:drivers_mthomas/diskio.c **** DSTATUS disk_status (
 470:drivers_mthomas/diskio.c **** 	BYTE drv		/* Physical drive nmuber (0..) */
 471:drivers_mthomas/diskio.c **** )
 472:drivers_mthomas/diskio.c **** {
  17              	 args = 0, pretend = 0, frame = 0
  18              		@ frame_needed = 1, uses_anonymous_args = 0
  19              	.LVL0:
  20              		mov	ip, sp
  21 0000 0DC0A0E1 	.LCFI0:
  22              		stmfd	sp!, {fp, ip, lr, pc}
  23 0004 00D82DE9 	.LCFI1:
  24              		.loc 1 473 0
 473:drivers_mthomas/diskio.c **** 	if ( drv != 0 ) return STA_NOINIT;
  25              	 #255
  26 0008 FF0010E3 		.loc 1 475 0
 474:drivers_mthomas/diskio.c **** 
 475:drivers_mthomas/diskio.c **** 	return Stat;
  27              	dreq	r3, .L5
  28 000c 10309F05 		ldreqb	r2, [r3, #0]	@ zero_extendqisi2
  29 0010 0020D305 		.loc 1 472 0
  30              		sub	fp, ip, #4
  31 0014 04B04CE2 	.LCFI2:
  32              		.loc 1 473 0
  33              		movne	r0, #1
  34 0018 0100A013 	.LVL1:
  35              		.loc 1 475 0
  36              		andeq	r0, r2, #255
  37 001c FF000202 		.loc 1 476 0
 476:drivers_mthomas/diskio.c **** }
  38              	{fp, sp, pc}
  39 0020 00A89DE8 	.L6:
  40              		.align	2
  41              	.L5:
  42              		.word	Stat
  43 0024 00000000 	.LFE18:
  45              		.section	.text.disk_timerproc,"ax",%progbits
  46              		.align	2
  47              		.global	disk_timerproc
  49              	disk_timerproc:
  50              	.LFB22:
  51              		.loc 1 685 0
 477:drivers_mthomas/diskio.c **** 
 478:drivers_mthomas/diskio.c **** 
 479:drivers_mthomas/diskio.c **** 
 480:drivers_mthomas/diskio.c **** /*-----------------------------------------------------------------------*/
 481:drivers_mthomas/diskio.c **** /* Read Sector(s)                                                        */
 482:drivers_mthomas/diskio.c **** 
 483:drivers_mthomas/diskio.c **** DRESULT disk_read (
 484:drivers_mthomas/diskio.c **** 	BYTE drv,		/* Physical drive number (0..) */
 485:drivers_mthomas/diskio.c **** 	BYTE *buff,		/* Data buffer to store read data */
 486:drivers_mthomas/diskio.c **** 	DWORD sector,	/* Sector number (LBA) */
 487:drivers_mthomas/diskio.c **** 	BYTE count		/* Sector count (1..255) */
 488:drivers_mthomas/diskio.c **** )
 489:drivers_mthomas/diskio.c **** {
 490:drivers_mthomas/diskio.c **** 	// DRESULT res;
 491:drivers_mthomas/diskio.c **** 	//WORD k;
 492:drivers_mthomas/diskio.c **** 
 493:drivers_mthomas/diskio.c **** 	if (drv || !count) return RES_PARERR;
 494:drivers_mthomas/diskio.c **** 	if (Stat & STA_NOINIT) return RES_NOTRDY;
 495:drivers_mthomas/diskio.c **** 
 496:drivers_mthomas/diskio.c **** 	// done in MCI driver if (!(CardType & 4)) sector *= 512;	/* Convert to byte address if needed */
 497:drivers_mthomas/diskio.c **** 
 498:drivers_mthomas/diskio.c **** 	/* Select the card and wait for ready */
 499:drivers_mthomas/diskio.c **** 	/* mthomas - not sure if this is needed for SD */
 500:drivers_mthomas/diskio.c **** 	DESELECT();
 501:drivers_mthomas/diskio.c **** 	//if (wait_ready() != 0xFF) return (DRESULT)(0xFF);
 502:drivers_mthomas/diskio.c **** 	SELECT();
 503:drivers_mthomas/diskio.c **** 
 504:drivers_mthomas/diskio.c **** 	// TODO: Multi-block
 505:drivers_mthomas/diskio.c **** 	do {
 506:drivers_mthomas/diskio.c **** 		diskio_printfr("Read_Block start...\n");
 507:drivers_mthomas/diskio.c **** 		if ( MCI_Read_Block( sector ) != TRUE ) {
 508:drivers_mthomas/diskio.c **** 			diskio_printf("MCI_Read_Block failed\n");
 509:drivers_mthomas/diskio.c **** 			break;
 510:drivers_mthomas/diskio.c **** 		}
 511:drivers_mthomas/diskio.c **** 		else {
 512:drivers_mthomas/diskio.c **** 			
 513:drivers_mthomas/diskio.c **** 			diskio_printfr("Read_Block wait...\n");
 514:drivers_mthomas/diskio.c **** 			/* When MCI_Block_End_Flag is clear, it indicates RX is done */
 515:drivers_mthomas/diskio.c **** 			while ( MCI_Block_End_Flag == 1 ) { ; }
 516:drivers_mthomas/diskio.c **** 			diskio_printfr("Read_Block end wait\n");
 517:drivers_mthomas/diskio.c **** 			// laebi: memcpy is faster than the for-Loop
 518:drivers_mthomas/diskio.c **** 			// TODO: avoid copy
 519:drivers_mthomas/diskio.c **** 			memcpy(buff, ReadBlock, 512);
 520:drivers_mthomas/diskio.c **** 			// mziegert 20090823: Bugfix, memcpy does not increase buff pointer
 521:drivers_mthomas/diskio.c **** 			buff = &buff[512];
 522:drivers_mthomas/diskio.c **** 			sector++;
 523:drivers_mthomas/diskio.c **** 		}
 524:drivers_mthomas/diskio.c **** 	} while ( --count );
 525:drivers_mthomas/diskio.c **** 	
 526:drivers_mthomas/diskio.c **** 	release_spi();
 527:drivers_mthomas/diskio.c **** 
 528:drivers_mthomas/diskio.c **** 	return count ? RES_ERROR : RES_OK;
 529:drivers_mthomas/diskio.c **** }
 530:drivers_mthomas/diskio.c **** 
 531:drivers_mthomas/diskio.c **** 
 532:drivers_mthomas/diskio.c **** 
 533:drivers_mthomas/diskio.c **** /*-----------------------------------------------------------------------*/
 534:drivers_mthomas/diskio.c **** /* Write Sector(s)                                                       */
 535:drivers_mthomas/diskio.c **** 
 536:drivers_mthomas/diskio.c **** #if _READONLY == 0
 537:drivers_mthomas/diskio.c **** DRESULT disk_write (
 538:drivers_mthomas/diskio.c **** 	BYTE drv,			/* Physical drive number (0..) */
 539:drivers_mthomas/diskio.c **** 	const BYTE *buff,	/* Data to be written */
 540:drivers_mthomas/diskio.c **** 	DWORD sector,		/* Sector number (LBA) */
 541:drivers_mthomas/diskio.c **** 	BYTE count			/* Sector count (1..255) */
 542:drivers_mthomas/diskio.c **** )
 543:drivers_mthomas/diskio.c **** {
 544:drivers_mthomas/diskio.c **** 	//WORD k;
 545:drivers_mthomas/diskio.c **** 
 546:drivers_mthomas/diskio.c **** 	if (drv || !count)
 547:drivers_mthomas/diskio.c **** 		return RES_PARERR;
 548:drivers_mthomas/diskio.c **** 	if (Stat & STA_NOINIT)
 549:drivers_mthomas/diskio.c **** 		return RES_NOTRDY;
 550:drivers_mthomas/diskio.c **** 	if (Stat & STA_PROTECT)
 551:drivers_mthomas/diskio.c **** 		return RES_WRPRT;
 552:drivers_mthomas/diskio.c **** 
 553:drivers_mthomas/diskio.c **** 	// done in mci-driver: if (!(CardType & 4)) sector *= 512;	/* Convert to byte address if needed */
 554:drivers_mthomas/diskio.c **** 
 555:drivers_mthomas/diskio.c **** 	/* Select the card and wait for ready */
 556:drivers_mthomas/diskio.c **** 	/* mthomas - not sure if this is needed for SD */
 557:drivers_mthomas/diskio.c **** 	DESELECT();
 558:drivers_mthomas/diskio.c **** 	//if (wait_ready() != 0xFF) return (DRESULT)0xFF;
 559:drivers_mthomas/diskio.c **** 	SELECT();
 560:drivers_mthomas/diskio.c **** 
 561:drivers_mthomas/diskio.c **** 	//do {
 562:drivers_mthomas/diskio.c **** 	diskio_printfw("Write_Block %d start...\n", sector );
 563:drivers_mthomas/diskio.c **** 	if (count > 1) {
 564:drivers_mthomas/diskio.c **** 		// Multi Block Write
 565:drivers_mthomas/diskio.c **** 		if (MCI_Write_Multiple_Block(sector, count, buff) != TRUE) {
 566:drivers_mthomas/diskio.c **** 			diskio_printf("MCI_Write_Multiple_Block failed\n");
 567:drivers_mthomas/diskio.c **** 			return RES_ERROR;
 568:drivers_mthomas/diskio.c **** 			//break;
 569:drivers_mthomas/diskio.c **** 		} else {
 570:drivers_mthomas/diskio.c **** 			diskio_printfw("Write_Block Multi wait...\n");
 571:drivers_mthomas/diskio.c **** 			/* When MCI_Block_End_Flag is clear, it indicates TX is done */
 572:drivers_mthomas/diskio.c **** 			while (MCI_Block_End_Flag == 1) {
 573:drivers_mthomas/diskio.c **** 				;
 574:drivers_mthomas/diskio.c **** 			}
 575:drivers_mthomas/diskio.c **** 			diskio_printfw("Write_Block Multi end wait\n");
 576:drivers_mthomas/diskio.c **** 		}
 577:drivers_mthomas/diskio.c **** 	} else {
 578:drivers_mthomas/diskio.c **** 		// Single Block write
 579:drivers_mthomas/diskio.c **** 		// TODO: avoid copy
 580:drivers_mthomas/diskio.c **** 		memcpy(WriteBlock, buff, 512);
 581:drivers_mthomas/diskio.c **** 		if (MCI_Write_Block(sector) != TRUE) {
 582:drivers_mthomas/diskio.c **** 			diskio_printf("MCI_Write_Block failed\n");
 583:drivers_mthomas/diskio.c **** 			return RES_ERROR;
 584:drivers_mthomas/diskio.c **** 			//break;
 585:drivers_mthomas/diskio.c **** 		} else {
 586:drivers_mthomas/diskio.c **** 			diskio_printfw("Write_Block wait...\n");
 587:drivers_mthomas/diskio.c **** 			/* When MCI_Block_End_Flag is clear, it indicates TX is done */
 588:drivers_mthomas/diskio.c **** 			while (MCI_Block_End_Flag == 1) {
 589:drivers_mthomas/diskio.c **** 				;
 590:drivers_mthomas/diskio.c **** 			}
 591:drivers_mthomas/diskio.c **** 			diskio_printfw("Write_Block end wait\n");
 592:drivers_mthomas/diskio.c **** 		}
 593:drivers_mthomas/diskio.c **** 	}
 594:drivers_mthomas/diskio.c **** 
 595:drivers_mthomas/diskio.c **** 	// laebi: not necessary
 596:drivers_mthomas/diskio.c **** 	//release_spi();
 597:drivers_mthomas/diskio.c **** 
 598:drivers_mthomas/diskio.c **** 	//return count ? RES_ERROR : RES_OK;
 599:drivers_mthomas/diskio.c **** 	return RES_OK;
 600:drivers_mthomas/diskio.c **** }
 601:drivers_mthomas/diskio.c **** 
 602:drivers_mthomas/diskio.c **** #endif /* _READONLY */
 603:drivers_mthomas/diskio.c **** 
 604:drivers_mthomas/diskio.c **** 
 605:drivers_mthomas/diskio.c **** 
 606:drivers_mthomas/diskio.c **** /*-----------------------------------------------------------------------*/
 607:drivers_mthomas/diskio.c **** /* Miscellaneous Functions                                               */
 608:drivers_mthomas/diskio.c **** 
 609:drivers_mthomas/diskio.c **** DRESULT disk_ioctl (
 610:drivers_mthomas/diskio.c **** 	BYTE drv,		/* Physical drive nmuber (0..) */
 611:drivers_mthomas/diskio.c **** 	BYTE ctrl,		/* Control code */
 612:drivers_mthomas/diskio.c **** 	void *buff		/* Buffer to send/receive control data */
 613:drivers_mthomas/diskio.c **** )
 614:drivers_mthomas/diskio.c **** {
 615:drivers_mthomas/diskio.c **** 	DRESULT res;
 616:drivers_mthomas/diskio.c **** 	BYTE n; // buffered csd[16];
 617:drivers_mthomas/diskio.c **** 	DWORD csize;
 618:drivers_mthomas/diskio.c **** 
 619:drivers_mthomas/diskio.c **** 	if (drv) return RES_PARERR;
 620:drivers_mthomas/diskio.c **** 	if (Stat & STA_NOINIT) return RES_NOTRDY;
 621:drivers_mthomas/diskio.c **** 
 622:drivers_mthomas/diskio.c **** 	res = RES_ERROR;
 623:drivers_mthomas/diskio.c **** 
 624:drivers_mthomas/diskio.c **** 	switch (ctrl) {
 625:drivers_mthomas/diskio.c **** 
 626:drivers_mthomas/diskio.c **** 		case CTRL_SYNC :	/* Flush dirty buffer if present */
 627:drivers_mthomas/diskio.c **** 			SELECT();
 628:drivers_mthomas/diskio.c **** 			if (wait_ready() == 0xFF) {
 629:drivers_mthomas/diskio.c **** 				res = RES_OK;
 630:drivers_mthomas/diskio.c **** 			}
 631:drivers_mthomas/diskio.c **** 			break;
 632:drivers_mthomas/diskio.c **** 
 633:drivers_mthomas/diskio.c **** 		case GET_SECTOR_SIZE :	/* Get sectors on the disk (WORD) */
 634:drivers_mthomas/diskio.c **** 			*(WORD*)buff = 512;
 635:drivers_mthomas/diskio.c **** 			res = RES_OK;
 636:drivers_mthomas/diskio.c **** 			break;
 637:drivers_mthomas/diskio.c **** 
 638:drivers_mthomas/diskio.c **** 		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (WORD) */
 639:drivers_mthomas/diskio.c **** 			if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
 640:drivers_mthomas/diskio.c **** 				csize = csd[9] + ((WORD)csd[8] << 8) + 1;
 641:drivers_mthomas/diskio.c **** 				*(DWORD*)buff = (DWORD)csize << 10;
 642:drivers_mthomas/diskio.c **** 			} 
 643:drivers_mthomas/diskio.c **** 			else {					/* MMC or SDC ver 1.XX */
 644:drivers_mthomas/diskio.c **** 				n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
 645:drivers_mthomas/diskio.c **** 				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 646:drivers_mthomas/diskio.c **** 				*(DWORD*)buff = (DWORD)csize << (n - 9);
 647:drivers_mthomas/diskio.c **** 			}
 648:drivers_mthomas/diskio.c **** 			res = RES_OK;
 649:drivers_mthomas/diskio.c **** 			break;
 650:drivers_mthomas/diskio.c **** 
 651:drivers_mthomas/diskio.c **** 		
 652:drivers_mthomas/diskio.c **** 		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sectors (DWORD) */
 653:drivers_mthomas/diskio.c **** 			if (CardType & 4) {   /* SDC ver 2.00 - use cached  Read SD status */
 654:drivers_mthomas/diskio.c **** 				// TODO - untested!
 655:drivers_mthomas/diskio.c **** 				*(DWORD*)buff = 16UL << (sd_status[10] >> 4);
 656:drivers_mthomas/diskio.c **** 				res = RES_OK;
 657:drivers_mthomas/diskio.c **** 			} 
 658:drivers_mthomas/diskio.c **** 			else {   /* SDC ver 1.XX or MMC */
 659:drivers_mthomas/diskio.c **** 				if (CardType & 2) {			/* SDC ver 1.XX */
 660:drivers_mthomas/diskio.c **** 					*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) 
 661:drivers_mthomas/diskio.c **** 				} else {					/* MMC */
 662:drivers_mthomas/diskio.c **** 					*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) 
 663:drivers_mthomas/diskio.c **** 				}
 664:drivers_mthomas/diskio.c **** 				res = RES_OK;
 665:drivers_mthomas/diskio.c **** 			}
 666:drivers_mthomas/diskio.c **** 			break;
 667:drivers_mthomas/diskio.c **** 
 668:drivers_mthomas/diskio.c **** 		default:
 669:drivers_mthomas/diskio.c **** 			res = RES_PARERR;
 670:drivers_mthomas/diskio.c **** 	}
 671:drivers_mthomas/diskio.c **** 
 672:drivers_mthomas/diskio.c **** 	release_spi(); 
 673:drivers_mthomas/diskio.c **** 
 674:drivers_mthomas/diskio.c **** 	return res;
 675:drivers_mthomas/diskio.c **** }
 676:drivers_mthomas/diskio.c **** 
 677:drivers_mthomas/diskio.c **** 
 678:drivers_mthomas/diskio.c **** /*-----------------------------------------------------------------------*/
 679:drivers_mthomas/diskio.c **** /* Device Timer Interrupt Procedure  (Platform dependent)                */
 680:drivers_mthomas/diskio.c **** /*-----------------------------------------------------------------------*/
 681:drivers_mthomas/diskio.c **** /* This function must be called in period of 1ms                         */
 682:drivers_mthomas/diskio.c **** 
 683:drivers_mthomas/diskio.c **** 
 684:drivers_mthomas/diskio.c **** void disk_timerproc (void)
 685:drivers_mthomas/diskio.c **** {
  52              	retend = 0, frame = 0
  53              		@ frame_needed = 1, uses_anonymous_args = 0
  54              		.loc 1 688 0
 686:drivers_mthomas/diskio.c **** 	DWORD n;
 687:drivers_mthomas/diskio.c **** 
 688:drivers_mthomas/diskio.c **** 	n = Timer1;						/* 1000Hz decrement timer */
  55              	r	r2, .L11
  56 0000 30209FE5 		ldr	r3, [r2, #0]
  57 0004 003092E5 	.LVL2:
  58              		.loc 1 689 0
 689:drivers_mthomas/diskio.c **** 	if (n) Timer1 = --n;
  59              		r3, #0
  60 0008 000053E3 		subne	r3, r3, #1
  61 000c 01304312 	.LVL3:
  62              		strne	r3, [r2, #0]
  63 0010 00308215 		.loc 1 690 0
 690:drivers_mthomas/diskio.c **** 	n = Timer2;
  64              	r2, .L11+4
  65 0014 20209FE5 		ldr	r3, [r2, #0]
  66 0018 003092E5 	.LVL4:
  67              		.loc 1 691 0
 691:drivers_mthomas/diskio.c **** 	if (n) Timer2 = --n;
  68              		r3, #0
  69 001c 000053E3 		.loc 1 685 0
  70              		mov	ip, sp
  71 0020 0DC0A0E1 	.LCFI3:
  72              		.loc 1 691 0
  73              		subne	r3, r3, #1
  74 0024 01304312 	.LVL5:
  75              		.loc 1 685 0
  76              		stmfd	sp!, {fp, ip, lr, pc}
  77 0028 00D82DE9 	.LCFI4:
  78              		.loc 1 691 0
  79              		strne	r3, [r2, #0]
  80 002c 00308215 		.loc 1 685 0
  81              		sub	fp, ip, #4
  82 0030 04B04CE2 	.LCFI5:
  83              		ldmfd	sp, {fp, sp, pc}
  84 0034 00A89DE8 	.L12:
  85              		.align	2
  86              	.L11:
  87              		.word	Timer1
  88 0038 00000000 		.word	Timer2
  89 003c 00000000 	.LFE22:
  91              		.section	.text.SELECT,"ax",%progbits
  92              		.align	2
  94              	SELECT:
  95              	.LFB10:
  96              		.loc 1 160 0
  97              		@ args = 0, pretend = 0, frame = 0
  98              		@ frame_needed = 1, uses_anonymous_args = 0
  99              		.loc 1 160 0
 100              		mov	ip, sp
 101 0000 0DC0A0E1 	.LCFI6:
 102              		stmfd	sp!, {r4, fp, ip, lr, pc}
 103 0004 10D82DE9 	.LCFI7:
 104              		.loc 1 164 0
 105              		ldr	r4, .L20
 106 0008 3C409FE5 		mov	r3, #1000
 107 000c FA3FA0E3 		str	r3, [r4, #0]
 108 0010 003084E5 		.loc 1 160 0
 109              		sub	fp, ip, #4
 110 0014 04B04CE2 	.LCFI8:
 111              	.L15:
 112              		.loc 1 167 0
 113              		bl	MCI_Send_Status
 114 0018 FEFFFFEB 		.loc 1 169 0
 115              		mov	r0, r0, lsr #9
 116 001c A004A0E1 		and	r0, r0, #255
 117 0020 FF0000E2 		cmp	r0, #4
 118 0024 040050E3 		bne	.L19
 119 0028 0100001A 		.loc 1 176 0
 120              		ldr	r3, [r4, #0]
 121 002c 003094E5 		.loc 1 180 0
 122              		ldmfd	sp, {r4, fp, sp, pc}
 123 0030 10A89DE8 	.L19:
 124              		.loc 1 170 0
 125              		bl	MCI_Select_Card
 126 0034 FEFFFFEB 		.loc 1 174 0
 127              		ldr	r3, [r4, #0]
 128 0038 003094E5 		cmp	r3, #0
 129 003c 000053E3 		bne	.L15
 130 0040 F4FFFF1A 		.loc 1 176 0
 131              		ldr	r3, [r4, #0]
 132 0044 003094E5 		.loc 1 180 0
 133              		ldmfd	sp, {r4, fp, sp, pc}
 134 0048 10A89DE8 	.L21:
 135              		.align	2
 136              	.L20:
 137              		.word	Timer2
 138 004c 00000000 	.LFE10:
 140              		.section	.text.DESELECT,"ax",%progbits
 141              		.align	2
 143              	DESELECT:
 144              	.LFB11:
 145              		.loc 1 184 0
 146              		@ args = 0, pretend = 0, frame = 0
 147              		@ frame_needed = 1, uses_anonymous_args = 0
 148              		mov	ip, sp
 149 0000 0DC0A0E1 	.LCFI9:
 150              		stmfd	sp!, {r4, r5, fp, ip, lr, pc}
 151 0004 30D82DE9 	.LCFI10:
 152              		.loc 1 187 0
 153              		ldr	r4, .L28
 154 0008 5C409FE5 		mov	r3, #500
 155 000c 7D3FA0E3 		str	r3, [r4, #0]
 156 0010 003084E5 		.loc 1 184 0
 157              		sub	fp, ip, #4
 158 0014 04B04CE2 	.LCFI11:
 159              	.LVL6:
 160              	.L24:
 161              		.loc 1 189 0
 162              		bl	MCI_Send_Status
 163 0018 FEFFFFEB 	.LVL7:
 164              		.loc 1 191 0
 165              		mov	r0, r0, lsr #9
 166 001c A004A0E1 		and	r0, r0, #255
 167 0020 FF0000E2 	.LVL8:
 168              		.loc 1 194 0
 169              		sub	r3, r0, #3
 170 0024 033040E2 		cmp	r3, #1
 171 0028 010053E3 		bls	.L23
 172 002c 0200009A 		ldr	r3, [r4, #0]
 173 0030 003094E5 		cmp	r3, #0
 174 0034 000053E3 		bne	.L24
 175 0038 F6FFFF1A 	.L23:
 176              		.loc 1 196 0
 177              		ldr	r3, [r4, #0]
 178 003c 003094E5 		cmp	r3, #0
 179 0040 000053E3 		ldmeqfd	sp, {r4, r5, fp, sp, pc}
 180 0044 30A89D08 		.loc 1 199 0
 181              		cmp	r0, #4
 182 0048 040050E3 		ldmnefd	sp, {r4, r5, fp, sp, pc}
 183 004c 30A89D18 		.loc 1 200 0
 184              		ldr	r4, .L28+4
 185 0050 18409FE5 		.loc 1 202 0
 186              		mov	r3, #0
 187 0054 0030A0E3 		.loc 1 200 0
 188              		ldr	r5, [r4, #0]
 189 0058 005094E5 	.LVL9:
 190              		.loc 1 202 0
 191              		str	r3, [r4, #0]
 192 005c 003084E5 		.loc 1 203 0
 193              		bl	MCI_Select_Card
 194 0060 FEFFFFEB 	.LVL10:
 195              		.loc 1 206 0
 196              		str	r5, [r4, #0]
 197 0064 005084E5 		ldmfd	sp, {r4, r5, fp, sp, pc}
 198 0068 30A89DE8 	.L29:
 199              		.align	2
 200              	.L28:
 201              		.word	Timer2
 202 006c 00000000 		.word	MCI_CardType
 203 0070 00000000 	.LFE11:
 205              		.section	.text.disk_ioctl,"ax",%progbits
 206              		.align	2
 207              		.global	disk_ioctl
 209              	disk_ioctl:
 210              	.LFB21:
 211              		.loc 1 614 0
 212              		@ args = 0, pretend = 0, frame = 0
 213              		@ frame_needed = 1, uses_anonymous_args = 0
 214              	.LVL11:
 215              		mov	ip, sp
 216 0000 0DC0A0E1 	.LCFI12:
 217              		.loc 1 619 0
 218              		tst	r0, #255
 219 0004 FF0010E3 		.loc 1 614 0
 220              		stmfd	sp!, {r4, fp, ip, lr, pc}
 221 0008 10D82DE9 	.LCFI13:
 222              		and	r1, r1, #255
 223 000c FF1001E2 	.LVL12:
 224              		mov	r4, r2
 225 0010 0240A0E1 		sub	fp, ip, #4
 226 0014 04B04CE2 	.LCFI14:
 227              		.loc 1 619 0
 228              		movne	r4, #4
 229 0018 0440A013 	.LVL13:
 230              		bne	.L32
 231 001c 1700001A 		.loc 1 620 0
 232              		ldr	r3, .L51
 233 0020 F0319FE5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 234 0024 0020D3E5 	.LVL14:
 235              		tst	r2, #1
 236 0028 010012E3 		movne	r4, #3
 237 002c 0340A013 		bne	.L32
 238 0030 1200001A 		.loc 1 624 0
 239              		cmp	r1, #3
 240 0034 030051E3 		ldrls	pc, [pc, r1, asl #2]
 241 0038 01F19F97 		b	.L34
 242 003c 110000EA 	.L39:
 243              		.word	.L35
 244 0040 50000000 		.word	.L36
 245 0044 00010000 		.word	.L37
 246 0048 EC000000 		.word	.L38
 247 004c 94000000 	.L35:
 248              	.LBB32:
 249              	.LBB35:
 250              		.loc 1 223 0
 251              		ldr	r4, .L51+4
 252 0050 C4419FE5 	.LVL15:
 253              	.LBE35:
 254              	.LBE32:
 255              		.loc 1 627 0
 256              		bl	SELECT
 257 0054 FEFFFFEB 	.LVL16:
 258              	.LBB37:
 259              	.LBB34:
 260              		.loc 1 223 0
 261              		mov	r3, #500
 262 0058 7D3FA0E3 		str	r3, [r4, #0]
 263 005c 003084E5 	.LVL17:
 264              	.L43:
 265              	.LBE34:
 266              		.loc 1 225 0
 267              		bl	MCI_Send_Status
 268 0060 FEFFFFEB 	.LVL18:
 269              	.LBB33:
 270              		.loc 1 226 0
 271              		cmn	r0, #1
 272 0064 010070E3 	.LVL19:
 273              		beq	.L41
 274 0068 4000000A 		.loc 1 232 0
 275              		tst	r0, #256
 276 006c 010C10E3 		beq	.L41
 277 0070 3E00000A 		.loc 1 239 0
 278              		ldr	r3, [r4, #0]
 279 0074 003094E5 		mov	r4, #0
 280 0078 0040A0E3 	.LVL20:
 281              	.LBE33:
 282              	.LBE37:
 283              	.LBB38:
 284              	.LBB43:
 285              		.loc 1 250 0
 286              		bl	DESELECT
 287 007c FEFFFFEB 	.LVL21:
 288              	.L32:
 289              	.LBE43:
 290              	.LBE38:
 291              		.loc 1 675 0
 292              		mov	r0, r4
 293 0080 0400A0E1 	.LVL22:
 294              		ldmfd	sp, {r4, fp, sp, pc}
 295 0084 10A89DE8 	.LVL23:
 296              	.L34:
 297              		.loc 1 624 0
 298              		mov	r4, #4
 299 0088 0440A0E3 	.LBB48:
 300              	.LBB42:
 301              		.loc 1 250 0
 302              		bl	DESELECT
 303 008c FEFFFFEB 	.LVL24:
 304              		b	.L32
 305 0090 FAFFFFEA 	.LVL25:
 306              	.L38:
 307              	.LBE42:
 308              	.LBE48:
 309              		.loc 1 653 0
 310              		ldr	r3, .L51+8
 311 0094 84319FE5 		ldr	r3, [r3, #0]
 312 0098 003093E5 		ands	ip, r3, #4
 313 009c 04C013E2 		bne	.L49
 314 00a0 3A00001A 		.loc 1 659 0
 315              		ands	lr, r3, #2
 316 00a4 02E013E2 		beq	.L46
 317 00a8 4B00000A 		.loc 1 660 0
 318              		ldr	r2, .L51+12
 319 00ac 70219FE5 		ldrb	r3, [r2, #11]	@ zero_extendqisi2
 320 00b0 0B30D2E5 		ldrb	r1, [r2, #10]	@ zero_extendqisi2
 321 00b4 0A10D2E5 	.LVL26:
 322              		ldrb	r0, [r2, #13]	@ zero_extendqisi2
 323 00b8 0D00D2E5 	.LVL27:
 324              		mov	r3, r3, lsr #7
 325 00bc A333A0E1 		and	r1, r1, #63
 326 00c0 3F1001E2 		mov	r1, r1, asl #1
 327 00c4 8110A0E1 		add	r3, r3, #1
 328 00c8 013083E2 		mov	r0, r0, lsr #6
 329 00cc 2003A0E1 		add	r3, r3, r1
 330 00d0 013083E0 		sub	r0, r0, #1
 331 00d4 010040E2 		mov	r3, r3, asl r0
 332 00d8 1330A0E1 		str	r3, [r4, #0]
 333 00dc 003084E5 	.LVL28:
 334              		mov	r4, ip
 335 00e0 0C40A0E1 	.LVL29:
 336              	.LBB49:
 337              	.LBB44:
 338              		.loc 1 250 0
 339              		bl	DESELECT
 340 00e4 FEFFFFEB 		b	.L32
 341 00e8 E4FFFFEA 	.LVL30:
 342              	.L37:
 343              	.LBE44:
 344              	.LBE49:
 345              		.loc 1 634 0
 346              		mov	r3, #512	@ movhi
 347 00ec 023CA0E3 		strh	r3, [r4, #0]	@ movhi
 348 00f0 B030C4E1 	.LVL31:
 349              		mov	r4, #0
 350 00f4 0040A0E3 	.LVL32:
 351              	.LBB50:
 352              	.LBB41:
 353              		.loc 1 250 0
 354              		bl	DESELECT
 355 00f8 FEFFFFEB 	.LVL33:
 356              		b	.L32
 357 00fc DFFFFFEA 	.LVL34:
 358              	.L36:
 359              	.LBE41:
 360              	.LBE50:
 361              		.loc 1 639 0
 362              		ldr	ip, .L51+12
 363 0100 1CC19FE5 		ldrb	r3, [ip, #0]	@ zero_extendqisi2
 364 0104 0030DCE5 		mov	r3, r3, lsr #6
 365 0108 2333A0E1 		cmp	r3, #1
 366 010c 010053E3 		beq	.L50
 367 0110 2700000A 		.loc 1 646 0
 368              		ldrb	r0, [ip, #9]	@ zero_extendqisi2
 369 0114 0900DCE5 	.LVL35:
 370              		ldrb	r3, [ip, #7]	@ zero_extendqisi2
 371 0118 0730DCE5 		ldrb	r2, [ip, #5]	@ zero_extendqisi2
 372 011c 0520DCE5 		ldrb	lr, [ip, #8]	@ zero_extendqisi2
 373 0120 08E0DCE5 		ldrb	r1, [ip, #6]	@ zero_extendqisi2
 374 0124 0610DCE5 	.LVL36:
 375              		ldrb	ip, [ip, #10]	@ zero_extendqisi2
 376 0128 0AC0DCE5 		mov	r3, r3, asl #2
 377 012c 0331A0E1 		and	r2, r2, #15
 378 0130 0F2002E2 		and	r0, r0, #3
 379 0134 030000E2 		add	r3, r3, lr, lsr #6
 380 0138 2E3383E0 		add	r2, r2, ip, lsr #7
 381 013c AC2382E0 		mov	r0, r0, asl #1
 382 0140 8000A0E1 		and	r1, r1, #3
 383 0144 031001E2 		add	r2, r2, r0
 384 0148 002082E0 		mov	r1, r1, asl #10
 385 014c 0115A0E1 		add	r3, r3, #1
 386 0150 013083E2 		add	r3, r3, r1
 387 0154 013083E0 		sub	r2, r2, #7
 388 0158 072042E2 		mov	r3, r3, asl r2
 389 015c 1332A0E1 		str	r3, [r4, #0]
 390 0160 003084E5 	.LVL37:
 391              		mov	r4, #0
 392 0164 0040A0E3 	.LVL38:
 393              	.LBB51:
 394              	.LBB45:
 395              		.loc 1 250 0
 396              		bl	DESELECT
 397 0168 FEFFFFEB 		b	.L32
 398 016c C3FFFFEA 	.LVL39:
 399              	.L41:
 400              	.LBE45:
 401              	.LBE51:
 402              	.LBB52:
 403              	.LBB36:
 404              		.loc 1 237 0
 405              		ldr	r3, [r4, #0]
 406 0170 003094E5 		cmp	r3, #0
 407 0174 000053E3 		bne	.L43
 408 0178 B8FFFF1A 		.loc 1 239 0
 409              		ldr	r3, .L51+4
 410 017c 98309FE5 		mov	r4, #1
 411 0180 0140A0E3 	.LVL40:
 412              		ldr	r3, [r3, #0]
 413 0184 003093E5 	.LBE36:
 414              	.LBE52:
 415              	.LBB53:
 416              	.LBB40:
 417              		.loc 1 250 0
 418              		bl	DESELECT
 419 0188 FEFFFFEB 	.LVL41:
 420              		b	.L32
 421 018c BBFFFFEA 	.LVL42:
 422              	.L49:
 423              	.LBE40:
 424              	.LBE53:
 425              		.loc 1 655 0
 426              		ldr	r3, .L51+16
 427 0190 90309FE5 		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 428 0194 0A20D3E5 		mov	r3, #16
 429 0198 1030A0E3 		mov	r2, r2, lsr #4
 430 019c 2222A0E1 		mov	r3, r3, asl r2
 431 01a0 1332A0E1 		str	r3, [r4, #0]
 432 01a4 003084E5 	.LVL43:
 433              		mov	r4, #0
 434 01a8 0040A0E3 	.LVL44:
 435              	.LBB54:
 436              	.LBB46:
 437              		.loc 1 250 0
 438              		bl	DESELECT
 439 01ac FEFFFFEB 	.LVL45:
 440              		b	.L32
 441 01b0 B2FFFFEA 	.LVL46:
 442              	.L50:
 443              	.LBE46:
 444              	.LBE54:
 445              		.loc 1 641 0
 446              		ldrb	r2, [ip, #8]	@ zero_extendqisi2
 447 01b4 0820DCE5 		ldrb	r3, [ip, #9]	@ zero_extendqisi2
 448 01b8 0930DCE5 		mov	r2, r2, asl #8
 449 01bc 0224A0E1 		add	r3, r3, #1
 450 01c0 013083E2 		add	r3, r3, r2
 451 01c4 023083E0 		mov	r3, r3, asl #10
 452 01c8 0335A0E1 		str	r3, [r4, #0]
 453 01cc 003084E5 	.LVL47:
 454              		mov	r4, #0
 455 01d0 0040A0E3 	.LVL48:
 456              	.LBB55:
 457              	.LBB39:
 458              		.loc 1 250 0
 459              		bl	DESELECT
 460 01d4 FEFFFFEB 	.LVL49:
 461              		b	.L32
 462 01d8 A8FFFFEA 	.LVL50:
 463              	.L46:
 464              	.LBE39:
 465              	.LBE55:
 466              		.loc 1 662 0
 467              		ldr	r1, .L51+12
 468 01dc 40109FE5 	.LVL51:
 469              		ldrb	r3, [r1, #11]	@ zero_extendqisi2
 470 01e0 0B30D1E5 		ldrb	r0, [r1, #10]	@ zero_extendqisi2
 471 01e4 0A00D1E5 	.LVL52:
 472              		and	r2, r3, #3
 473 01e8 032003E2 		mov	r3, r3, lsr #5
 474 01ec A332A0E1 		mov	r2, r2, asl #3
 475 01f0 8221A0E1 		and	r0, r0, #124
 476 01f4 7C0000E2 		add	r3, r3, #1
 477 01f8 013083E2 		add	r3, r3, r2
 478 01fc 023083E0 		mov	r0, r0, lsr #2
 479 0200 2001A0E1 		mla	r2, r0, r3, r3
 480 0204 903322E0 		str	r2, [r4, #0]
 481 0208 002084E5 	.LVL53:
 482              		mov	r4, lr
 483 020c 0E40A0E1 	.LVL54:
 484              	.LBB56:
 485              	.LBB47:
 486              		.loc 1 250 0
 487              		bl	DESELECT
 488 0210 FEFFFFEB 		b	.L32
 489 0214 99FFFFEA 	.L52:
 490              		.align	2
 491              	.L51:
 492              		.word	Stat
 493 0218 00000000 		.word	Timer2
 494 021c 00000000 		.word	CardType
 495 0220 00000000 		.word	csd
 496 0224 00000000 		.word	sd_status
 497 0228 00000000 	.LBE47:
 498              	.LBE56:
 499              	.LFE21:
 501              		.section	.text.disk_write,"ax",%progbits
 502              		.align	2
 503              		.global	disk_write
 505              	disk_write:
 506              	.LFB20:
 507              		.loc 1 543 0
 508              		@ args = 0, pretend = 0, frame = 0
 509              		@ frame_needed = 1, uses_anonymous_args = 0
 510              	.LVL55:
 511              		mov	ip, sp
 512 0000 0DC0A0E1 	.LCFI15:
 513              		.loc 1 546 0
 514              		tst	r0, #255
 515 0004 FF0010E3 		.loc 1 543 0
 516              		stmfd	sp!, {r4, r5, r6, fp, ip, lr, pc}
 517 0008 70D82DE9 	.LCFI16:
 518              		.loc 1 546 0
 519              		moveq	r0, #0
 520 000c 0000A003 		movne	r0, #1
 521 0010 0100A013 	.LVL56:
 522              		ands	r4, r3, #255
 523 0014 FF4013E2 	.LVL57:
 524              		orreq	r0, r0, #1
 525 0018 01008003 		cmp	r0, #0
 526 001c 000050E3 		.loc 1 543 0
 527              		sub	fp, ip, #4
 528 0020 04B04CE2 	.LCFI17:
 529              		.loc 1 543 0
 530              		mov	r5, r1
 531 0024 0150A0E1 		mov	r6, r2
 532 0028 0260A0E1 		.loc 1 546 0
 533              		movne	r0, #4
 534 002c 0400A013 		ldmnefd	sp, {r4, r5, r6, fp, sp, pc}
 535 0030 70A89D18 	.LVL58:
 536              		.loc 1 548 0
 537              		ldr	r2, .L67
 538 0034 9C209FE5 		ldrb	r3, [r2, #0]	@ zero_extendqisi2
 539 0038 0030D2E5 		tst	r3, #1
 540 003c 010013E3 		movne	r0, #3
 541 0040 0300A013 		ldmnefd	sp, {r4, r5, r6, fp, sp, pc}
 542 0044 70A89D18 		.loc 1 550 0
 543              		ldrb	r3, [r2, #0]	@ zero_extendqisi2
 544 0048 0030D2E5 		tst	r3, #4
 545 004c 040013E3 		movne	r0, #2
 546 0050 0200A013 		ldmnefd	sp, {r4, r5, r6, fp, sp, pc}
 547 0054 70A89D18 		.loc 1 557 0
 548              		bl	DESELECT
 549 0058 FEFFFFEB 		.loc 1 559 0
 550              		bl	SELECT
 551 005c FEFFFFEB 		.loc 1 563 0
 552              		cmp	r4, #1
 553 0060 010054E3 		bls	.L58
 554 0064 0700009A 		.loc 1 565 0
 555              		mov	r0, r6
 556 0068 0600A0E1 		mov	r1, r4
 557 006c 0410A0E1 		mov	r2, r5
 558 0070 0520A0E1 		bl	MCI_Write_Multiple_Block
 559 0074 FEFFFFEB 		cmp	r0, #1
 560 0078 010050E3 		beq	.L66
 561 007c 1000000A 	.L59:
 562              		.loc 1 588 0
 563              		mov	r0, #1
 564 0080 0100A0E3 		ldmfd	sp, {r4, r5, r6, fp, sp, pc}
 565 0084 70A89DE8 	.L58:
 566              		.loc 1 580 0
 567              		ldr	r3, .L67+4
 568 0088 4C309FE5 		mov	r1, r5
 569 008c 0510A0E1 		ldr	r0, [r3, #0]
 570 0090 000093E5 		mov	r2, #512
 571 0094 022CA0E3 		bl	memcpy
 572 0098 FEFFFFEB 		.loc 1 581 0
 573              		mov	r0, r6
 574 009c 0600A0E1 		bl	MCI_Write_Block
 575 00a0 FEFFFFEB 		cmp	r0, #1
 576 00a4 010050E3 		bne	.L59
 577 00a8 F4FFFF1A 		ldr	r2, .L67+8
 578 00ac 2C209FE5 	.L62:
 579              		.loc 1 588 0
 580              		ldr	r3, [r2, #0]
 581 00b0 003092E5 		cmp	r3, #1
 582 00b4 010053E3 		beq	.L62
 583 00b8 FCFFFF0A 	.L61:
 584              		mov	r0, #0
 585 00bc 0000A0E3 		.loc 1 600 0
 586              		ldmfd	sp, {r4, r5, r6, fp, sp, pc}
 587 00c0 70A89DE8 	.L66:
 588              		ldr	r2, .L67+8
 589 00c4 14209FE5 	.L60:
 590              		.loc 1 572 0
 591              		ldr	r3, [r2, #0]
 592 00c8 003092E5 		cmp	r3, #1
 593 00cc 010053E3 		beq	.L60
 594 00d0 FCFFFF0A 		b	.L61
 595 00d4 F8FFFFEA 	.L68:
 596              		.align	2
 597              	.L67:
 598              		.word	Stat
 599 00d8 00000000 		.word	WriteBlock
 600 00dc 00000000 		.word	MCI_Block_End_Flag
 601 00e0 00000000 	.LFE20:
 603              		.section	.text.disk_read,"ax",%progbits
 604              		.align	2
 605              		.global	disk_read
 607              	disk_read:
 608              	.LFB19:
 609              		.loc 1 489 0
 610              		@ args = 0, pretend = 0, frame = 0
 611              		@ frame_needed = 1, uses_anonymous_args = 0
 612              	.LVL59:
 613              		mov	ip, sp
 614 0000 0DC0A0E1 	.LCFI18:
 615              		.loc 1 493 0
 616              		tst	r0, #255
 617 0004 FF0010E3 		.loc 1 489 0
 618              		stmfd	sp!, {r4, r5, r6, r7, r8, fp, ip, lr, pc}
 619 0008 F0D92DE9 	.LCFI19:
 620              		.loc 1 493 0
 621              		moveq	r0, #0
 622 000c 0000A003 		movne	r0, #1
 623 0010 0100A013 	.LVL60:
 624              		ands	r7, r3, #255
 625 0014 FF7013E2 	.LVL61:
 626              		orreq	r0, r0, #1
 627 0018 01008003 		cmp	r0, #0
 628 001c 000050E3 		.loc 1 489 0
 629              		sub	fp, ip, #4
 630 0020 04B04CE2 	.LCFI20:
 631              		.loc 1 489 0
 632              		mov	r5, r1
 633 0024 0150A0E1 		mov	r4, r2
 634 0028 0240A0E1 		.loc 1 493 0
 635              		movne	r0, #4
 636 002c 0400A013 		ldmnefd	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
 637 0030 F0A99D18 	.LVL62:
 638              		.loc 1 494 0
 639              		ldr	r3, .L78
 640 0034 6C309FE5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 641 0038 0020D3E5 		tst	r2, #1
 642 003c 010012E3 		movne	r0, #3
 643 0040 0300A013 		ldmnefd	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
 644 0044 F0A99D18 		.loc 1 500 0
 645              		bl	DESELECT
 646 0048 FEFFFFEB 		.loc 1 502 0
 647              		bl	SELECT
 648 004c FEFFFFEB 		ldr	r6, .L78+4
 649 0050 54609FE5 		.loc 1 519 0
 650              		ldr	r8, .L78+8
 651 0054 54809FE5 	.L75:
 652              		.loc 1 507 0
 653              		mov	r0, r4
 654 0058 0400A0E1 		bl	MCI_Read_Block
 655 005c FEFFFFEB 		cmp	r0, #1
 656 0060 010050E3 		bne	.L73
 657 0064 0B00001A 	.L74:
 658              		.loc 1 515 0
 659              		ldr	r3, [r6, #0]
 660 0068 003096E5 		cmp	r3, #1
 661 006c 010053E3 		beq	.L74
 662 0070 FCFFFF0A 		.loc 1 519 0
 663              		mov	r0, r5
 664 0074 0500A0E1 		ldr	r1, [r8, #0]
 665 0078 001098E5 		mov	r2, #512
 666 007c 022CA0E3 		bl	memcpy
 667 0080 FEFFFFEB 		.loc 1 524 0
 668              		sub	r3, r7, #1
 669 0084 013047E2 		ands	r7, r3, #255
 670 0088 FF7013E2 	.LVL63:
 671              		.loc 1 521 0
 672              		addne	r5, r5, #512
 673 008c 025C8512 		.loc 1 522 0
 674              		addne	r4, r4, #1
 675 0090 01408412 		bne	.L75
 676 0094 EFFFFF1A 	.L73:
 677              	.LBB57:
 678              	.LBB58:
 679              		.loc 1 250 0
 680              		bl	DESELECT
 681 0098 FEFFFFEB 	.LBE58:
 682              	.LBE57:
 683              		.loc 1 528 0
 684              		subs	r0, r7, #0
 685 009c 000057E2 		movne	r0, #1
 686 00a0 0100A013 		.loc 1 529 0
 687              		ldmfd	sp, {r4, r5, r6, r7, r8, fp, sp, pc}
 688 00a4 F0A99DE8 	.L79:
 689              		.align	2
 690              	.L78:
 691              		.word	Stat
 692 00a8 00000000 		.word	MCI_Block_End_Flag
 693 00ac 00000000 		.word	ReadBlock
 694 00b0 00000000 	.LFE19:
 696              		.section	.text.disk_initialize,"ax",%progbits
 697              		.align	2
 698              		.global	disk_initialize
 700              	disk_initialize:
 701              	.LFB17:
 702              		.loc 1 435 0
 703              		@ args = 0, pretend = 0, frame = 16
 704              		@ frame_needed = 1, uses_anonymous_args = 0
 705              	.LVL64:
 706              		mov	ip, sp
 707 0000 0DC0A0E1 	.LCFI21:
 708              		stmfd	sp!, {r4, r5, r6, fp, ip, lr, pc}
 709 0004 70D82DE9 	.LCFI22:
 710              		sub	fp, ip, #4
 711 0008 04B04CE2 	.LCFI23:
 712              		sub	sp, sp, #16
 713 000c 10D04DE2 	.LCFI24:
 714              		.loc 1 436 0
 715              		ands	r4, r0, #255
 716 0010 FF4010E2 	.LVL65:
 717              		.loc 1 435 0
 718              		.loc 1 436 0
 719              		movne	r0, #1
 720 0014 0100A013 		beq	.L132
 721 0018 0100000A 	.L82:
 722              		.loc 1 462 0
 723              		sub	sp, fp, #24
 724 001c 18D04BE2 		ldmfd	sp, {r4, r5, r6, fp, sp, pc}
 725 0020 70A89DE8 	.L132:
 726              	.LBB71:
 727              	.LBB78:
 728              		.loc 1 339 0
 729              		bl	DMA_Init
 730 0024 FEFFFFEB 	.LBE78:
 731              		.loc 1 343 0
 732              		bl	MCI_Init
 733 0028 FEFFFFEB 	.LBB82:
 734              		cmp	r0, #1
 735 002c 010050E3 		beq	.L118
 736 0030 1900000A 	.L130:
 737              		ldr	r4, .L133
 738 0034 F8419FE5 	.LVL66:
 739              	.L83:
 740              	.LBE82:
 741              	.LBE71:
 742              		.loc 1 440 0
 743              		ldr	r5, .L133+4
 744 0038 F8519FE5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 745 003c 0030D5E5 		orr	r3, r3, #1
 746 0040 013083E3 		strb	r3, [r5, #0]
 747 0044 0030C5E5 	.LBB85:
 748              	.LBB86:
 749              		.loc 1 255 0
 750              		bl	SELECT
 751 0048 FEFFFFEB 	.LBB89:
 752              	.LBB91:
 753              		.loc 1 223 0
 754              		mov	r3, #500
 755 004c 7D3FA0E3 		str	r3, [r4, #0]
 756 0050 003084E5 	.LVL67:
 757              	.L92:
 758              	.LBE91:
 759              		.loc 1 225 0
 760              		bl	MCI_Send_Status
 761 0054 FEFFFFEB 	.LVL68:
 762              	.LBB90:
 763              		.loc 1 226 0
 764              		cmn	r0, #1
 765 0058 010070E3 	.LVL69:
 766              		beq	.L97
 767 005c 0A00000A 		.loc 1 232 0
 768              		tst	r0, #256
 769 0060 010C10E3 		beq	.L97
 770 0064 0800000A 	.L98:
 771              		.loc 1 239 0
 772              		ldr	r3, [r4, #0]
 773 0068 003094E5 	.LBE90:
 774              	.LBE89:
 775              	.LBB87:
 776              	.LBB88:
 777              		.loc 1 250 0
 778              		bl	DESELECT
 779 006c FEFFFFEB 	.LVL70:
 780              	.LBE88:
 781              	.LBE87:
 782              		.loc 1 259 0
 783              		bl	MCI_Power_Off
 784 0070 FEFFFFEB 		.loc 1 261 0
 785              		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 786 0074 0030D5E5 		orr	r3, r3, #1
 787 0078 013083E3 		strb	r3, [r5, #0]
 788 007c 0030C5E5 	.LBE86:
 789              	.LBE85:
 790              		.loc 1 461 0
 791              		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 792 0080 0030D5E5 		and	r0, r3, #255
 793 0084 FF0003E2 		b	.L82
 794 0088 E3FFFFEA 	.LVL71:
 795              	.L97:
 796              	.LBB95:
 797              	.LBB94:
 798              	.LBB93:
 799              	.LBB92:
 800              		.loc 1 237 0
 801              		ldr	r3, [r4, #0]
 802 008c 003094E5 		cmp	r3, #0
 803 0090 000053E3 		bne	.L92
 804 0094 EEFFFF1A 		b	.L98
 805 0098 F2FFFFEA 	.LVL72:
 806              	.L118:
 807              	.LBE92:
 808              	.LBE93:
 809              	.LBE94:
 810              	.LBE95:
 811              	.LBB96:
 812              		.loc 1 351 0
 813              		bl	MCI_CardInit
 814 009c FEFFFFEB 	.LBB77:
 815              		ldr	r6, .L133+8
 816 00a0 94619FE5 		str	r0, [r6, #0]
 817 00a4 000086E5 		.loc 1 352 0
 818              		ldr	r3, [r6, #0]
 819 00a8 003096E5 		cmp	r3, #0
 820 00ac 000053E3 		beq	.L130
 821 00b0 DFFFFF0A 	.LBE77:
 822              		.loc 1 359 0
 823              		bl	MCI_Check_CID
 824 00b4 FEFFFFEB 	.LBB76:
 825              		cmp	r0, #0
 826 00b8 000050E3 		beq	.L130
 827 00bc DCFFFF0A 	.LBE76:
 828              		.loc 1 365 0
 829              		bl	MCI_Set_Address
 830 00c0 FEFFFFEB 	.LBB75:
 831              		cmp	r0, #0
 832 00c4 000050E3 		beq	.L130
 833 00c8 D9FFFF0A 	.LBE75:
 834              		.loc 1 371 0
 835              		sub	r5, fp, #40
 836 00cc 28504BE2 		mov	r0, r5
 837 00d0 0500A0E1 		bl	MCI_Send_CSD
 838 00d4 FEFFFFEB 	.LBB74:
 839              		cmp	r0, #0
 840 00d8 000050E3 		ldrne	lr, .L133+12
 841 00dc 5CE19F15 		movne	r0, r4
 842 00e0 0400A011 		movne	ip, lr
 843 00e4 0EC0A011 		beq	.L130
 844 00e8 D1FFFF0A 	.L84:
 845              		.loc 1 381 0
 846              		ldr	r2, [r5, r0]
 847 00ec 002095E7 		mov	r3, r2, lsr #24
 848 00f0 223CA0E1 		strb	r3, [lr, r0]
 849 00f4 0030CEE7 		add	r0, r0, #4
 850 00f8 040080E2 		mov	r3, r2, lsr #16
 851 00fc 2238A0E1 		mov	r1, r2, lsr #8
 852 0100 2214A0E1 		.loc 1 380 0
 853              		cmp	r0, #16
 854 0104 100050E3 		.loc 1 381 0
 855              		strb	r3, [ip, #1]
 856 0108 0130CCE5 		strb	r1, [ip, #2]
 857 010c 0210CCE5 		strb	r2, [ip, #3]
 858 0110 0320CCE5 		add	ip, ip, #4
 859 0114 04C08CE2 		.loc 1 380 0
 860              		bne	.L84
 861 0118 F3FFFF1A 	.LBE74:
 862              		.loc 1 385 0
 863              		bl	MCI_Select_Card
 864 011c FEFFFFEB 	.LBB73:
 865              		cmp	r0, #0
 866 0120 000050E3 		beq	.L130
 867 0124 C2FFFF0A 		.loc 1 393 0
 868              		ldr	r3, [r6, #0]
 869 0128 003096E5 		cmp	r3, #2
 870 012c 020053E3 		beq	.L86
 871 0130 1A00000A 		ldr	r2, .L133+8
 872 0134 00219FE5 		ldr	r3, [r2, #0]
 873 0138 003092E5 		cmp	r3, #4
 874 013c 040053E3 		beq	.L86
 875 0140 1600000A 	.L87:
 876              		.loc 1 405 0
 877              		ldr	r3, [r6, #0]
 878 0144 003096E5 		cmp	r3, #4
 879 0148 040053E3 		beq	.L101
 880 014c 1A00000A 	.LVL73:
 881              	.L91:
 882              	.LBE73:
 883              		.loc 1 416 0
 884              		mov	r0, #512
 885 0150 020CA0E3 		bl	MCI_Set_BlockLen
 886 0154 FEFFFFEB 	.LVL74:
 887              	.LBB72:
 888              		cmp	r0, #0
 889 0158 000050E3 		beq	.L130
 890 015c B4FFFF0A 	.LBE72:
 891              	.LBE96:
 892              		.loc 1 444 0
 893              		ldr	r5, .L133+4
 894 0160 D0509FE5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 895 0164 0030D5E5 		and	r3, r3, #254
 896 0168 FE3003E2 		strb	r3, [r5, #0]
 897 016c 0030C5E5 		.loc 1 446 0
 898              		ldr	r2, [r6, #0]
 899 0170 002096E5 		cmp	r2, #2
 900 0174 020052E3 		beq	.L131
 901 0178 0300000A 		cmp	r2, #4
 902 017c 040052E3 		beq	.L131
 903 0180 0100000A 		cmp	r2, #1
 904 0184 010052E3 		.loc 1 457 0
 905              		movne	r2, #0
 906 0188 0020A013 	.L131:
 907              		ldr	r3, .L133+16
 908 018c B0309FE5 		str	r2, [r3, #0]
 909 0190 002083E5 		.loc 1 461 0
 910              		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 911 0194 0030D5E5 		and	r0, r3, #255
 912 0198 FF0003E2 		b	.L82
 913 019c 9EFFFFEA 	.L86:
 914              	.LBB97:
 915              	.LBB83:
 916              		.loc 1 396 0
 917              		mov	r0, #2
 918 01a0 0200A0E3 		bl	MCI_Set_MCIClock
 919 01a4 FEFFFFEB 	.LBE83:
 920              		.loc 1 397 0
 921              		mov	r0, #1
 922 01a8 0100A0E3 		bl	SD_Set_BusWidth
 923 01ac FEFFFFEB 	.LBB84:
 924              		cmp	r0, #1
 925 01b0 010050E3 		bne	.L130
 926 01b4 9EFFFF1A 		b	.L87
 927 01b8 E1FFFFEA 	.L101:
 928              	.LBB79:
 929              		.loc 1 274 0
 930              		mov	r0, #64
 931 01bc 4000A0E3 		bl	MCI_Set_BlockLen
 932 01c0 FEFFFFEB 	.LBB80:
 933              		cmp	r0, #0
 934 01c4 000050E3 		beq	.L130
 935 01c8 99FFFF0A 	.LBE80:
 936              		.loc 1 280 0
 937              		bl	MCI_Sd_Status
 938 01cc FEFFFFEB 	.LBB81:
 939              		cmp	r0, #0
 940 01d0 000050E3 		beq	.L130
 941 01d4 96FFFF0A 		.loc 1 285 0
 942              		ldr	r4, .L133
 943 01d8 54409FE5 	.LVL75:
 944              		mov	r3, #2000
 945 01dc 7D3EA0E3 		str	r3, [r4, #0]
 946 01e0 003084E5 		ldr	r2, .L133+20
 947 01e4 5C209FE5 	.L89:
 948              		.loc 1 286 0
 949              		ldr	r3, [r2, #0]
 950 01e8 003092E5 		cmp	r3, #1
 951 01ec 010053E3 		bne	.L88
 952 01f0 0200001A 		ldr	r3, [r4, #0]
 953 01f4 003094E5 		cmp	r3, #0
 954 01f8 000053E3 		bne	.L89
 955 01fc F9FFFF1A 	.L88:
 956              		.loc 1 287 0
 957              		ldr	r3, [r4, #0]
 958 0200 003094E5 		cmp	r3, #0
 959 0204 000053E3 		beq	.L83
 960 0208 8AFFFF0A 		.loc 1 324 0
 961              		ldr	r3, .L133+24
 962 020c 38309FE5 		ldr	r0, .L133+28
 963 0210 38009FE5 		ldr	r1, [r3, #0]
 964 0214 001093E5 		mov	r2, #0
 965 0218 0020A0E3 	.LVL76:
 966              	.L90:
 967              		ldrb	r3, [r1, r2]	@ zero_extendqisi2
 968 021c 0230D1E7 		strb	r3, [r0, r2]
 969 0220 0230C0E7 		.loc 1 323 0
 970              		add	r2, r2, #1
 971 0224 012082E2 		cmp	r2, #16
 972 0228 100052E3 		bne	.L90
 973 022c FAFFFF1A 		b	.L91
 974 0230 C6FFFFEA 	.L134:
 975              		.align	2
 976              	.L133:
 977              		.word	Timer2
 978 0234 00000000 		.word	Stat
 979 0238 00000000 		.word	MCI_CardType
 980 023c 00000000 		.word	csd
 981 0240 00000000 		.word	CardType
 982 0244 00000000 		.word	MCI_Block_End_Flag
 983 0248 00000000 		.word	ReadBlock
 984 024c 00000000 		.word	sd_status
 985 0250 00000000 	.LBE81:
 986              	.LBE79:
 987              	.LBE84:
 988              	.LBE97:
 989              	.LFE17:
 991              		.section	.data.Stat,"aw",%progbits
 994              	Stat:
 995              		.byte	1
 996 0000 01       		.section	.bss.Timer1,"aw",%nobits
 997              		.align	2
 1000              	Timer1:
 1001              		.space	4
 1002 0000 00000000 		.section	.bss.Timer2,"aw",%nobits
 1003              		.align	2
 1006              	Timer2:
 1007              		.space	4
 1008 0000 00000000 		.section	.bss.CardType,"aw",%nobits
 1009              		.align	2
 1012              	CardType:
 1013              		.space	4
 1014 0000 00000000 		.section	.bss.csd,"aw",%nobits
 1017              	csd:
 1018              		.space	16
 1019 0000 00000000 		.section	.bss.sd_status,"aw",%nobits
 1019      00000000 
 1019      00000000 
 1019      00000000 
 1022              	sd_status:
 1023              		.space	16
 1024 0000 00000000 		.section	.debug_frame,"",%progbits
 1024      00000000 
 1024      00000000 
 1024      00000000 
 1271              		.section	.debug_loc,"",%progbits
DEFINED SYMBOLS
                            *ABS*:00000000 diskio.c
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:14     .text.disk_status:00000000 disk_status
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:21     .text.disk_status:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:43     .text.disk_status:00000024 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:995    .data.Stat:00000000 Stat
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:50     .text.disk_timerproc:00000000 disk_timerproc
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:56     .text.disk_timerproc:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:88     .text.disk_timerproc:00000038 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:1001   .bss.Timer1:00000000 Timer1
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:1007   .bss.Timer2:00000000 Timer2
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:95     .text.SELECT:00000000 SELECT
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:101    .text.SELECT:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:138    .text.SELECT:0000004c $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:144    .text.DESELECT:00000000 DESELECT
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:149    .text.DESELECT:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:202    .text.DESELECT:0000006c $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:210    .text.disk_ioctl:00000000 disk_ioctl
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:216    .text.disk_ioctl:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:244    .text.disk_ioctl:00000040 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:252    .text.disk_ioctl:00000050 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:493    .text.disk_ioctl:00000218 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:1013   .bss.CardType:00000000 CardType
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:1018   .bss.csd:00000000 csd
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:1023   .bss.sd_status:00000000 sd_status
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:506    .text.disk_write:00000000 disk_write
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:512    .text.disk_write:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:599    .text.disk_write:000000d8 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:608    .text.disk_read:00000000 disk_read
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:614    .text.disk_read:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:692    .text.disk_read:000000a8 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:701    .text.disk_initialize:00000000 disk_initialize
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:707    .text.disk_initialize:00000000 $a
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:978    .text.disk_initialize:00000234 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:996    .data.Stat:00000000 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:1027   .debug_frame:00000000 $d
C:\DOCUME~1\pyang\LOCALS~1\Temp/ccfpn9xe.s:1275   .debug_loc:00000000 $d

UNDEFINED SYMBOLS
MCI_Send_Status
MCI_Select_Card
MCI_CardType
MCI_Write_Multiple_Block
memcpy
MCI_Write_Block
WriteBlock
MCI_Block_End_Flag
MCI_Read_Block
ReadBlock
DMA_Init
MCI_Init
MCI_Power_Off
MCI_CardInit
MCI_Check_CID
MCI_Set_Address
MCI_Send_CSD
MCI_Set_BlockLen
MCI_Set_MCIClock
SD_Set_BusWidth
MCI_Sd_Status
